"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@xyflow";
exports.ids = ["vendor-chunks/@xyflow"];
exports.modules = {

/***/ "(ssr)/./node_modules/@xyflow/react/dist/esm/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@xyflow/react/dist/esm/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Background: () => (/* binding */ Background),\n/* harmony export */   BackgroundVariant: () => (/* binding */ BackgroundVariant),\n/* harmony export */   BaseEdge: () => (/* binding */ BaseEdge),\n/* harmony export */   BezierEdge: () => (/* binding */ BezierEdge),\n/* harmony export */   ConnectionLineType: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType),\n/* harmony export */   ConnectionMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionMode),\n/* harmony export */   ControlButton: () => (/* binding */ ControlButton),\n/* harmony export */   Controls: () => (/* binding */ Controls),\n/* harmony export */   EdgeLabelRenderer: () => (/* binding */ EdgeLabelRenderer),\n/* harmony export */   EdgeText: () => (/* binding */ EdgeText),\n/* harmony export */   EdgeToolbar: () => (/* binding */ EdgeToolbar),\n/* harmony export */   Handle: () => (/* binding */ Handle),\n/* harmony export */   MarkerType: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.MarkerType),\n/* harmony export */   MiniMap: () => (/* binding */ MiniMap),\n/* harmony export */   MiniMapNode: () => (/* binding */ MiniMapNode),\n/* harmony export */   NodeResizeControl: () => (/* binding */ NodeResizeControl),\n/* harmony export */   NodeResizer: () => (/* binding */ NodeResizer),\n/* harmony export */   NodeToolbar: () => (/* binding */ NodeToolbar),\n/* harmony export */   PanOnScrollMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.PanOnScrollMode),\n/* harmony export */   Panel: () => (/* binding */ Panel),\n/* harmony export */   Position: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position),\n/* harmony export */   ReactFlow: () => (/* binding */ index),\n/* harmony export */   ReactFlowProvider: () => (/* binding */ ReactFlowProvider),\n/* harmony export */   ResizeControlVariant: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant),\n/* harmony export */   SelectionMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode),\n/* harmony export */   SimpleBezierEdge: () => (/* binding */ SimpleBezierEdge),\n/* harmony export */   SmoothStepEdge: () => (/* binding */ SmoothStepEdge),\n/* harmony export */   StepEdge: () => (/* binding */ StepEdge),\n/* harmony export */   StraightEdge: () => (/* binding */ StraightEdge),\n/* harmony export */   ViewportPortal: () => (/* binding */ ViewportPortal),\n/* harmony export */   addEdge: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.addEdge),\n/* harmony export */   applyEdgeChanges: () => (/* binding */ applyEdgeChanges),\n/* harmony export */   applyNodeChanges: () => (/* binding */ applyNodeChanges),\n/* harmony export */   getBezierEdgeCenter: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierEdgeCenter),\n/* harmony export */   getBezierPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierPath),\n/* harmony export */   getConnectedEdges: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getConnectedEdges),\n/* harmony export */   getEdgeCenter: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEdgeCenter),\n/* harmony export */   getIncomers: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getIncomers),\n/* harmony export */   getNodesBounds: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesBounds),\n/* harmony export */   getOutgoers: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getOutgoers),\n/* harmony export */   getSimpleBezierPath: () => (/* binding */ getSimpleBezierPath),\n/* harmony export */   getSmoothStepPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath),\n/* harmony export */   getStraightPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getStraightPath),\n/* harmony export */   getViewportForBounds: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getViewportForBounds),\n/* harmony export */   isEdge: () => (/* binding */ isEdge),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   reconnectEdge: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.reconnectEdge),\n/* harmony export */   useConnection: () => (/* binding */ useConnection),\n/* harmony export */   useEdges: () => (/* binding */ useEdges),\n/* harmony export */   useEdgesState: () => (/* binding */ useEdgesState),\n/* harmony export */   useHandleConnections: () => (/* binding */ useHandleConnections),\n/* harmony export */   useInternalNode: () => (/* binding */ useInternalNode),\n/* harmony export */   useKeyPress: () => (/* binding */ useKeyPress),\n/* harmony export */   useNodeConnections: () => (/* binding */ useNodeConnections),\n/* harmony export */   useNodeId: () => (/* binding */ useNodeId),\n/* harmony export */   useNodes: () => (/* binding */ useNodes),\n/* harmony export */   useNodesData: () => (/* binding */ useNodesData),\n/* harmony export */   useNodesInitialized: () => (/* binding */ useNodesInitialized),\n/* harmony export */   useNodesState: () => (/* binding */ useNodesState),\n/* harmony export */   useOnSelectionChange: () => (/* binding */ useOnSelectionChange),\n/* harmony export */   useOnViewportChange: () => (/* binding */ useOnViewportChange),\n/* harmony export */   useReactFlow: () => (/* binding */ useReactFlow),\n/* harmony export */   useStore: () => (/* binding */ useStore),\n/* harmony export */   useStoreApi: () => (/* binding */ useStoreApi),\n/* harmony export */   useUpdateNodeInternals: () => (/* binding */ useUpdateNodeInternals),\n/* harmony export */   useViewport: () => (/* binding */ useViewport)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var classcat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! classcat */ \"(ssr)/./node_modules/classcat/index.js\");\n/* harmony import */ var _xyflow_system__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @xyflow/system */ \"(ssr)/./node_modules/@xyflow/system/dist/esm/index.js\");\n/* harmony import */ var zustand_traditional__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zustand/traditional */ \"(ssr)/./node_modules/zustand/esm/traditional.mjs\");\n/* harmony import */ var zustand_shallow__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zustand/shallow */ \"(ssr)/./node_modules/zustand/esm/shallow.mjs\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_4__);\n/* __next_internal_client_entry_do_not_use__ ConnectionLineType,ConnectionMode,MarkerType,PanOnScrollMode,Position,ResizeControlVariant,SelectionMode,addEdge,getBezierEdgeCenter,getBezierPath,getConnectedEdges,getEdgeCenter,getIncomers,getNodesBounds,getOutgoers,getSmoothStepPath,getStraightPath,getViewportForBounds,reconnectEdge,Background,BackgroundVariant,BaseEdge,BezierEdge,ControlButton,Controls,EdgeLabelRenderer,EdgeText,EdgeToolbar,Handle,MiniMap,MiniMapNode,NodeResizeControl,NodeResizer,NodeToolbar,Panel,ReactFlow,ReactFlowProvider,SimpleBezierEdge,SmoothStepEdge,StepEdge,StraightEdge,ViewportPortal,applyEdgeChanges,applyNodeChanges,getSimpleBezierPath,isEdge,isNode,useConnection,useEdges,useEdgesState,useHandleConnections,useInternalNode,useKeyPress,useNodeConnections,useNodeId,useNodes,useNodesData,useNodesInitialized,useNodesState,useOnSelectionChange,useOnViewportChange,useReactFlow,useStore,useStoreApi,useUpdateNodeInternals,useViewport auto */ \n\n\n\n\n\n\n\nconst StoreContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst Provider$1 = StoreContext.Provider;\nconst zustandErrorMessage = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error001\"]();\n/**\n * This hook can be used to subscribe to internal state changes of the React Flow\n * component. The `useStore` hook is re-exported from the [Zustand](https://github.com/pmndrs/zustand)\n * state management library, so you should check out their docs for more details.\n *\n * @public\n * @param selector - A selector function that returns a slice of the flow's internal state.\n * Extracting or transforming just the state you need is a good practice to avoid unnecessary\n * re-renders.\n * @param equalityFn - A function to compare the previous and next value. This is incredibly useful\n * for preventing unnecessary re-renders. Good sensible defaults are using `Object.is` or importing\n * `zustand/shallow`, but you can be as granular as you like.\n * @returns The selected state slice.\n *\n * @example\n * ```ts\n * const nodes = useStore((state) => state.nodes);\n * ```\n *\n * @remarks This hook should only be used if there is no other way to access the internal\n * state. For many of the common use cases, there are dedicated hooks available\n * such as {@link useReactFlow}, {@link useViewport}, etc.\n */ function useStore(selector, equalityFn) {\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StoreContext);\n    if (store === null) {\n        throw new Error(zustandErrorMessage);\n    }\n    return (0,zustand_traditional__WEBPACK_IMPORTED_MODULE_5__.useStoreWithEqualityFn)(store, selector, equalityFn);\n}\n/**\n * In some cases, you might need to access the store directly. This hook returns the store object which can be used on demand to access the state or dispatch actions.\n *\n * @returns The store object.\n * @example\n * ```ts\n * const store = useStoreApi();\n * ```\n *\n * @remarks This hook should only be used if there is no other way to access the internal\n * state. For many of the common use cases, there are dedicated hooks available\n * such as {@link useReactFlow}, {@link useViewport}, etc.\n */ function useStoreApi() {\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StoreContext);\n    if (store === null) {\n        throw new Error(zustandErrorMessage);\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>({\n            getState: store.getState,\n            setState: store.setState,\n            subscribe: store.subscribe\n        }), [\n        store\n    ]);\n}\nconst style = {\n    display: \"none\"\n};\nconst ariaLiveStyle = {\n    position: \"absolute\",\n    width: 1,\n    height: 1,\n    margin: -1,\n    border: 0,\n    padding: 0,\n    overflow: \"hidden\",\n    clip: \"rect(0px, 0px, 0px, 0px)\",\n    clipPath: \"inset(100%)\"\n};\nconst ARIA_NODE_DESC_KEY = \"react-flow__node-desc\";\nconst ARIA_EDGE_DESC_KEY = \"react-flow__edge-desc\";\nconst ARIA_LIVE_MESSAGE = \"react-flow__aria-live\";\nconst ariaLiveSelector = (s)=>s.ariaLiveMessage;\nconst ariaLabelConfigSelector = (s)=>s.ariaLabelConfig;\nfunction AriaLiveMessage({ rfId }) {\n    const ariaLiveMessage = useStore(ariaLiveSelector);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        id: `${ARIA_LIVE_MESSAGE}-${rfId}`,\n        \"aria-live\": \"assertive\",\n        \"aria-atomic\": \"true\",\n        style: ariaLiveStyle,\n        children: ariaLiveMessage\n    });\n}\nfunction A11yDescriptions({ rfId, disableKeyboardA11y }) {\n    const ariaLabelConfig = useStore(ariaLabelConfigSelector);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                id: `${ARIA_NODE_DESC_KEY}-${rfId}`,\n                style: style,\n                children: disableKeyboardA11y ? ariaLabelConfig[\"node.a11yDescription.default\"] : ariaLabelConfig[\"node.a11yDescription.keyboardDisabled\"]\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                id: `${ARIA_EDGE_DESC_KEY}-${rfId}`,\n                style: style,\n                children: ariaLabelConfig[\"edge.a11yDescription.default\"]\n            }),\n            !disableKeyboardA11y && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(AriaLiveMessage, {\n                rfId: rfId\n            })\n        ]\n    });\n}\n/**\n * The `<Panel />` component helps you position content above the viewport.\n * It is used internally by the [`<MiniMap />`](/api-reference/components/minimap)\n * and [`<Controls />`](/api-reference/components/controls) components.\n *\n * @public\n *\n * @example\n * ```jsx\n *import { ReactFlow, Background, Panel } from '@xyflow/react';\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[]} fitView>\n *      <Panel position=\"top-left\">top-left</Panel>\n *      <Panel position=\"top-center\">top-center</Panel>\n *      <Panel position=\"top-right\">top-right</Panel>\n *      <Panel position=\"bottom-left\">bottom-left</Panel>\n *      <Panel position=\"bottom-center\">bottom-center</Panel>\n *      <Panel position=\"bottom-right\">bottom-right</Panel>\n *    </ReactFlow>\n *  );\n *}\n *```\n */ const Panel = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(({ position = \"top-left\", children, className, style, ...rest }, ref)=>{\n    const positionClasses = `${position}`.split(\"-\");\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__panel\",\n            className,\n            ...positionClasses\n        ]),\n        style: style,\n        ref: ref,\n        ...rest,\n        children: children\n    });\n});\nPanel.displayName = \"Panel\";\nfunction Attribution({ proOptions, position = \"bottom-right\" }) {\n    if (proOptions?.hideAttribution) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Panel, {\n        position: position,\n        className: \"react-flow__attribution\",\n        \"data-message\": \"Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n            href: \"https://reactflow.dev\",\n            target: \"_blank\",\n            rel: \"noopener noreferrer\",\n            \"aria-label\": \"React Flow attribution\",\n            children: \"React Flow\"\n        })\n    });\n}\nconst selector$m = (s)=>{\n    const selectedNodes = [];\n    const selectedEdges = [];\n    for (const [, node] of s.nodeLookup){\n        if (node.selected) {\n            selectedNodes.push(node.internals.userNode);\n        }\n    }\n    for (const [, edge] of s.edgeLookup){\n        if (edge.selected) {\n            selectedEdges.push(edge);\n        }\n    }\n    return {\n        selectedNodes,\n        selectedEdges\n    };\n};\nconst selectId = (obj)=>obj.id;\nfunction areEqual(a, b) {\n    return (0,zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow)(a.selectedNodes.map(selectId), b.selectedNodes.map(selectId)) && (0,zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow)(a.selectedEdges.map(selectId), b.selectedEdges.map(selectId));\n}\nfunction SelectionListenerInner({ onSelectionChange }) {\n    const store = useStoreApi();\n    const { selectedNodes, selectedEdges } = useStore(selector$m, areEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const params = {\n            nodes: selectedNodes,\n            edges: selectedEdges\n        };\n        onSelectionChange?.(params);\n        store.getState().onSelectionChangeHandlers.forEach((fn)=>fn(params));\n    }, [\n        selectedNodes,\n        selectedEdges,\n        onSelectionChange\n    ]);\n    return null;\n}\nconst changeSelector = (s)=>!!s.onSelectionChangeHandlers;\nfunction SelectionListener({ onSelectionChange }) {\n    const storeHasSelectionChangeHandlers = useStore(changeSelector);\n    if (onSelectionChange || storeHasSelectionChangeHandlers) {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectionListenerInner, {\n            onSelectionChange: onSelectionChange\n        });\n    }\n    return null;\n}\nconst defaultNodeOrigin = [\n    0,\n    0\n];\nconst defaultViewport = {\n    x: 0,\n    y: 0,\n    zoom: 1\n};\n/*\n * This component helps us to update the store with the values coming from the user.\n * We distinguish between values we can update directly with `useDirectStoreUpdater` (like `snapGrid`)\n * and values that have a dedicated setter function in the store (like `setNodes`).\n */ // These fields exist in the global store, and we need to keep them up to date\nconst reactFlowFieldsToTrack = [\n    \"nodes\",\n    \"edges\",\n    \"defaultNodes\",\n    \"defaultEdges\",\n    \"onConnect\",\n    \"onConnectStart\",\n    \"onConnectEnd\",\n    \"onClickConnectStart\",\n    \"onClickConnectEnd\",\n    \"nodesDraggable\",\n    \"autoPanOnNodeFocus\",\n    \"nodesConnectable\",\n    \"nodesFocusable\",\n    \"edgesFocusable\",\n    \"edgesReconnectable\",\n    \"elevateNodesOnSelect\",\n    \"elevateEdgesOnSelect\",\n    \"minZoom\",\n    \"maxZoom\",\n    \"nodeExtent\",\n    \"onNodesChange\",\n    \"onEdgesChange\",\n    \"elementsSelectable\",\n    \"connectionMode\",\n    \"snapGrid\",\n    \"snapToGrid\",\n    \"translateExtent\",\n    \"connectOnClick\",\n    \"defaultEdgeOptions\",\n    \"fitView\",\n    \"fitViewOptions\",\n    \"onNodesDelete\",\n    \"onEdgesDelete\",\n    \"onDelete\",\n    \"onNodeDrag\",\n    \"onNodeDragStart\",\n    \"onNodeDragStop\",\n    \"onSelectionDrag\",\n    \"onSelectionDragStart\",\n    \"onSelectionDragStop\",\n    \"onMoveStart\",\n    \"onMove\",\n    \"onMoveEnd\",\n    \"noPanClassName\",\n    \"nodeOrigin\",\n    \"autoPanOnConnect\",\n    \"autoPanOnNodeDrag\",\n    \"onError\",\n    \"connectionRadius\",\n    \"isValidConnection\",\n    \"selectNodesOnDrag\",\n    \"nodeDragThreshold\",\n    \"connectionDragThreshold\",\n    \"onBeforeDelete\",\n    \"debug\",\n    \"autoPanSpeed\",\n    \"paneClickDistance\",\n    \"ariaLabelConfig\"\n];\n// rfId doesn't exist in ReactFlowProps, but it's one of the fields we want to update\nconst fieldsToTrack = [\n    ...reactFlowFieldsToTrack,\n    \"rfId\"\n];\nconst selector$l = (s)=>({\n        setNodes: s.setNodes,\n        setEdges: s.setEdges,\n        setMinZoom: s.setMinZoom,\n        setMaxZoom: s.setMaxZoom,\n        setTranslateExtent: s.setTranslateExtent,\n        setNodeExtent: s.setNodeExtent,\n        reset: s.reset,\n        setDefaultNodesAndEdges: s.setDefaultNodesAndEdges,\n        setPaneClickDistance: s.setPaneClickDistance\n    });\nconst initPrevValues = {\n    /*\n     * these are values that are also passed directly to other components\n     * than the StoreUpdater. We can reduce the number of setStore calls\n     * by setting the same values here as prev fields.\n     */ translateExtent: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent,\n    nodeOrigin: defaultNodeOrigin,\n    minZoom: 0.5,\n    maxZoom: 2,\n    elementsSelectable: true,\n    noPanClassName: \"nopan\",\n    rfId: \"1\",\n    paneClickDistance: 0\n};\nfunction StoreUpdater(props) {\n    const { setNodes, setEdges, setMinZoom, setMaxZoom, setTranslateExtent, setNodeExtent, reset, setDefaultNodesAndEdges, setPaneClickDistance } = useStore(selector$l, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setDefaultNodesAndEdges(props.defaultNodes, props.defaultEdges);\n        return ()=>{\n            // when we reset the store we also need to reset the previous fields\n            previousFields.current = initPrevValues;\n            reset();\n        };\n    }, []);\n    const previousFields = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(initPrevValues);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        for (const fieldName of fieldsToTrack){\n            const fieldValue = props[fieldName];\n            const previousFieldValue = previousFields.current[fieldName];\n            if (fieldValue === previousFieldValue) continue;\n            if (typeof props[fieldName] === \"undefined\") continue;\n            // Custom handling with dedicated setters for some fields\n            if (fieldName === \"nodes\") setNodes(fieldValue);\n            else if (fieldName === \"edges\") setEdges(fieldValue);\n            else if (fieldName === \"minZoom\") setMinZoom(fieldValue);\n            else if (fieldName === \"maxZoom\") setMaxZoom(fieldValue);\n            else if (fieldName === \"translateExtent\") setTranslateExtent(fieldValue);\n            else if (fieldName === \"nodeExtent\") setNodeExtent(fieldValue);\n            else if (fieldName === \"paneClickDistance\") setPaneClickDistance(fieldValue);\n            else if (fieldName === \"ariaLabelConfig\") store.setState({\n                ariaLabelConfig: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.mergeAriaLabelConfig)(fieldValue)\n            });\n            else if (fieldName === \"fitView\") store.setState({\n                fitViewQueued: fieldValue\n            });\n            else if (fieldName === \"fitViewOptions\") store.setState({\n                fitViewOptions: fieldValue\n            });\n            else store.setState({\n                [fieldName]: fieldValue\n            });\n        }\n        previousFields.current = props;\n    }, // Only re-run the effect if one of the fields we track changes\n    fieldsToTrack.map((fieldName)=>props[fieldName]));\n    return null;\n}\nfunction getMediaQuery() {\n    if (true) {\n        return null;\n    }\n    return window.matchMedia(\"(prefers-color-scheme: dark)\");\n}\n/**\n * Hook for receiving the current color mode class 'dark' or 'light'.\n *\n * @internal\n * @param colorMode - The color mode to use ('dark', 'light' or 'system')\n */ function useColorModeClass(colorMode) {\n    const [colorModeClass, setColorModeClass] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(colorMode === \"system\" ? null : colorMode);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (colorMode !== \"system\") {\n            setColorModeClass(colorMode);\n            return;\n        }\n        const mediaQuery = getMediaQuery();\n        const updateColorModeClass = ()=>setColorModeClass(mediaQuery?.matches ? \"dark\" : \"light\");\n        updateColorModeClass();\n        mediaQuery?.addEventListener(\"change\", updateColorModeClass);\n        return ()=>{\n            mediaQuery?.removeEventListener(\"change\", updateColorModeClass);\n        };\n    }, [\n        colorMode\n    ]);\n    return colorModeClass !== null ? colorModeClass : getMediaQuery()?.matches ? \"dark\" : \"light\";\n}\nconst defaultDoc = typeof document !== \"undefined\" ? document : null;\n/**\n * This hook lets you listen for specific key codes and tells you whether they are\n * currently pressed or not.\n *\n * @public\n * @param options - Options\n *\n * @example\n * ```tsx\n *import { useKeyPress } from '@xyflow/react';\n *\n *export default function () {\n *  const spacePressed = useKeyPress('Space');\n *  const cmdAndSPressed = useKeyPress(['Meta+s', 'Strg+s']);\n *\n *  return (\n *    <div>\n *     {spacePressed && <p>Space pressed!</p>}\n *     {cmdAndSPressed && <p>Cmd + S pressed!</p>}\n *    </div>\n *  );\n *}\n *```\n */ function useKeyPress(/**\n * The key code (string or array of strings) specifies which key(s) should trigger\n * an action.\n *\n * A **string** can represent:\n * - A **single key**, e.g. `'a'`\n * - A **key combination**, using `'+'` to separate keys, e.g. `'a+d'`\n *\n * An  **array of strings** represents **multiple possible key inputs**. For example, `['a', 'd+s']`\n * means the user can press either the single key `'a'` or the combination of `'d'` and `'s'`.\n * @default null\n */ keyCode = null, options = {\n    target: defaultDoc,\n    actInsideInputWithModifier: true\n}) {\n    const [keyPressed, setKeyPressed] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // we need to remember if a modifier key is pressed in order to track it\n    const modifierPressed = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    // we need to remember the pressed keys in order to support combinations\n    const pressedKeys = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set([]));\n    /*\n     * keyCodes = array with single keys [['a']] or key combinations [['a', 's']]\n     * keysToWatch = array with all keys flattened ['a', 'd', 'ShiftLeft']\n     * used to check if we store event.code or event.key. When the code is in the list of keysToWatch\n     * we use the code otherwise the key. Explainer: When you press the left \"command\" key, the code is \"MetaLeft\"\n     * and the key is \"Meta\". We want users to be able to pass keys and codes so we assume that the key is meant when\n     * we can't find it in the list of keysToWatch.\n     */ const [keyCodes, keysToWatch] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (keyCode !== null) {\n            const keyCodeArr = Array.isArray(keyCode) ? keyCode : [\n                keyCode\n            ];\n            const keys = keyCodeArr.filter((kc)=>typeof kc === \"string\")/*\n                 * we first replace all '+' with '\\n'  which we will use to split the keys on\n                 * then we replace '\\n\\n' with '\\n+', this way we can also support the combination 'key++'\n                 * in the end we simply split on '\\n' to get the key array\n                 */ .map((kc)=>kc.replace(\"+\", \"\\n\").replace(\"\\n\\n\", \"\\n+\").split(\"\\n\"));\n            const keysFlat = keys.reduce((res, item)=>res.concat(...item), []);\n            return [\n                keys,\n                keysFlat\n            ];\n        }\n        return [\n            [],\n            []\n        ];\n    }, [\n        keyCode\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const target = options?.target ?? defaultDoc;\n        const actInsideInputWithModifier = options?.actInsideInputWithModifier ?? true;\n        if (keyCode !== null) {\n            const downHandler = (event)=>{\n                modifierPressed.current = event.ctrlKey || event.metaKey || event.shiftKey || event.altKey;\n                const preventAction = (!modifierPressed.current || modifierPressed.current && !actInsideInputWithModifier) && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isInputDOMNode)(event);\n                if (preventAction) {\n                    return false;\n                }\n                const keyOrCode = useKeyOrCode(event.code, keysToWatch);\n                pressedKeys.current.add(event[keyOrCode]);\n                if (isMatchingKey(keyCodes, pressedKeys.current, false)) {\n                    const target = event.composedPath?.()?.[0] || event.target;\n                    const isInteractiveElement = target?.nodeName === \"BUTTON\" || target?.nodeName === \"A\";\n                    if (options.preventDefault !== false && (modifierPressed.current || !isInteractiveElement)) {\n                        event.preventDefault();\n                    }\n                    setKeyPressed(true);\n                }\n            };\n            const upHandler = (event)=>{\n                const keyOrCode = useKeyOrCode(event.code, keysToWatch);\n                if (isMatchingKey(keyCodes, pressedKeys.current, true)) {\n                    setKeyPressed(false);\n                    pressedKeys.current.clear();\n                } else {\n                    pressedKeys.current.delete(event[keyOrCode]);\n                }\n                // fix for Mac: when cmd key is pressed, keyup is not triggered for any other key, see: https://stackoverflow.com/questions/27380018/when-cmd-key-is-kept-pressed-keyup-is-not-triggered-for-any-other-key\n                if (event.key === \"Meta\") {\n                    pressedKeys.current.clear();\n                }\n                modifierPressed.current = false;\n            };\n            const resetHandler = ()=>{\n                pressedKeys.current.clear();\n                setKeyPressed(false);\n            };\n            target?.addEventListener(\"keydown\", downHandler);\n            target?.addEventListener(\"keyup\", upHandler);\n            window.addEventListener(\"blur\", resetHandler);\n            window.addEventListener(\"contextmenu\", resetHandler);\n            return ()=>{\n                target?.removeEventListener(\"keydown\", downHandler);\n                target?.removeEventListener(\"keyup\", upHandler);\n                window.removeEventListener(\"blur\", resetHandler);\n                window.removeEventListener(\"contextmenu\", resetHandler);\n            };\n        }\n    }, [\n        keyCode,\n        setKeyPressed\n    ]);\n    return keyPressed;\n}\n// utils\nfunction isMatchingKey(keyCodes, pressedKeys, isUp) {\n    return keyCodes/*\n         * we only want to compare same sizes of keyCode definitions\n         * and pressed keys. When the user specified 'Meta' as a key somewhere\n         * this would also be truthy without this filter when user presses 'Meta' + 'r'\n         */ .filter((keys)=>isUp || keys.length === pressedKeys.size)/*\n         * since we want to support multiple possibilities only one of the\n         * combinations need to be part of the pressed keys\n         */ .some((keys)=>keys.every((k)=>pressedKeys.has(k)));\n}\nfunction useKeyOrCode(eventCode, keysToWatch) {\n    return keysToWatch.includes(eventCode) ? \"code\" : \"key\";\n}\n/**\n * Hook for getting viewport helper functions.\n *\n * @internal\n * @returns viewport helper functions\n */ const useViewportHelper = ()=>{\n    const store = useStoreApi();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        return {\n            zoomIn: (options)=>{\n                const { panZoom } = store.getState();\n                return panZoom ? panZoom.scaleBy(1.2, {\n                    duration: options?.duration\n                }) : Promise.resolve(false);\n            },\n            zoomOut: (options)=>{\n                const { panZoom } = store.getState();\n                return panZoom ? panZoom.scaleBy(1 / 1.2, {\n                    duration: options?.duration\n                }) : Promise.resolve(false);\n            },\n            zoomTo: (zoomLevel, options)=>{\n                const { panZoom } = store.getState();\n                return panZoom ? panZoom.scaleTo(zoomLevel, {\n                    duration: options?.duration\n                }) : Promise.resolve(false);\n            },\n            getZoom: ()=>store.getState().transform[2],\n            setViewport: async (viewport, options)=>{\n                const { transform: [tX, tY, tZoom], panZoom } = store.getState();\n                if (!panZoom) {\n                    return Promise.resolve(false);\n                }\n                await panZoom.setViewport({\n                    x: viewport.x ?? tX,\n                    y: viewport.y ?? tY,\n                    zoom: viewport.zoom ?? tZoom\n                }, options);\n                return Promise.resolve(true);\n            },\n            getViewport: ()=>{\n                const [x, y, zoom] = store.getState().transform;\n                return {\n                    x,\n                    y,\n                    zoom\n                };\n            },\n            setCenter: async (x, y, options)=>{\n                return store.getState().setCenter(x, y, options);\n            },\n            fitBounds: async (bounds, options)=>{\n                const { width, height, minZoom, maxZoom, panZoom } = store.getState();\n                const viewport = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getViewportForBounds)(bounds, width, height, minZoom, maxZoom, options?.padding ?? 0.1);\n                if (!panZoom) {\n                    return Promise.resolve(false);\n                }\n                await panZoom.setViewport(viewport, {\n                    duration: options?.duration,\n                    ease: options?.ease,\n                    interpolate: options?.interpolate\n                });\n                return Promise.resolve(true);\n            },\n            screenToFlowPosition: (clientPosition, options = {})=>{\n                const { transform, snapGrid, snapToGrid, domNode } = store.getState();\n                if (!domNode) {\n                    return clientPosition;\n                }\n                const { x: domX, y: domY } = domNode.getBoundingClientRect();\n                const correctedPosition = {\n                    x: clientPosition.x - domX,\n                    y: clientPosition.y - domY\n                };\n                const _snapGrid = options.snapGrid ?? snapGrid;\n                const _snapToGrid = options.snapToGrid ?? snapToGrid;\n                return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.pointToRendererPoint)(correctedPosition, transform, _snapToGrid, _snapGrid);\n            },\n            flowToScreenPosition: (flowPosition)=>{\n                const { transform, domNode } = store.getState();\n                if (!domNode) {\n                    return flowPosition;\n                }\n                const { x: domX, y: domY } = domNode.getBoundingClientRect();\n                const rendererPosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.rendererPointToPoint)(flowPosition, transform);\n                return {\n                    x: rendererPosition.x + domX,\n                    y: rendererPosition.y + domY\n                };\n            }\n        };\n    }, []);\n};\n/*\n * This function applies changes to nodes or edges that are triggered by React Flow internally.\n * When you drag a node for example, React Flow will send a position change update.\n * This function then applies the changes and returns the updated elements.\n */ function applyChanges(changes, elements) {\n    const updatedElements = [];\n    /*\n     * By storing a map of changes for each element, we can a quick lookup as we\n     * iterate over the elements array!\n     */ const changesMap = new Map();\n    const addItemChanges = [];\n    for (const change of changes){\n        if (change.type === \"add\") {\n            addItemChanges.push(change);\n            continue;\n        } else if (change.type === \"remove\" || change.type === \"replace\") {\n            /*\n             * For a 'remove' change we can safely ignore any other changes queued for\n             * the same element, it's going to be removed anyway!\n             */ changesMap.set(change.id, [\n                change\n            ]);\n        } else {\n            const elementChanges = changesMap.get(change.id);\n            if (elementChanges) {\n                /*\n                 * If we have some changes queued already, we can do a mutable update of\n                 * that array and save ourselves some copying.\n                 */ elementChanges.push(change);\n            } else {\n                changesMap.set(change.id, [\n                    change\n                ]);\n            }\n        }\n    }\n    for (const element of elements){\n        const changes = changesMap.get(element.id);\n        /*\n         * When there are no changes for an element we can just push it unmodified,\n         * no need to copy it.\n         */ if (!changes) {\n            updatedElements.push(element);\n            continue;\n        }\n        // If we have a 'remove' change queued, it'll be the only change in the array\n        if (changes[0].type === \"remove\") {\n            continue;\n        }\n        if (changes[0].type === \"replace\") {\n            updatedElements.push({\n                ...changes[0].item\n            });\n            continue;\n        }\n        /**\n         * For other types of changes, we want to start with a shallow copy of the\n         * object so React knows this element has changed. Sequential changes will\n         * each _mutate_ this object, so there's only ever one copy.\n         */ const updatedElement = {\n            ...element\n        };\n        for (const change of changes){\n            applyChange(change, updatedElement);\n        }\n        updatedElements.push(updatedElement);\n    }\n    /*\n     * we need to wait for all changes to be applied before adding new items\n     * to be able to add them at the correct index\n     */ if (addItemChanges.length) {\n        addItemChanges.forEach((change)=>{\n            if (change.index !== undefined) {\n                updatedElements.splice(change.index, 0, {\n                    ...change.item\n                });\n            } else {\n                updatedElements.push({\n                    ...change.item\n                });\n            }\n        });\n    }\n    return updatedElements;\n}\n// Applies a single change to an element. This is a *mutable* update.\nfunction applyChange(change, element) {\n    switch(change.type){\n        case \"select\":\n            {\n                element.selected = change.selected;\n                break;\n            }\n        case \"position\":\n            {\n                if (typeof change.position !== \"undefined\") {\n                    element.position = change.position;\n                }\n                if (typeof change.dragging !== \"undefined\") {\n                    element.dragging = change.dragging;\n                }\n                break;\n            }\n        case \"dimensions\":\n            {\n                if (typeof change.dimensions !== \"undefined\") {\n                    element.measured ??= {};\n                    element.measured.width = change.dimensions.width;\n                    element.measured.height = change.dimensions.height;\n                    if (change.setAttributes) {\n                        if (change.setAttributes === true || change.setAttributes === \"width\") {\n                            element.width = change.dimensions.width;\n                        }\n                        if (change.setAttributes === true || change.setAttributes === \"height\") {\n                            element.height = change.dimensions.height;\n                        }\n                    }\n                }\n                if (typeof change.resizing === \"boolean\") {\n                    element.resizing = change.resizing;\n                }\n                break;\n            }\n    }\n}\n/**\n * Drop in function that applies node changes to an array of nodes.\n * @public\n * @param changes - Array of changes to apply.\n * @param nodes - Array of nodes to apply the changes to.\n * @returns Array of updated nodes.\n * @example\n *```tsx\n *import { useState, useCallback } from 'react';\n *import { ReactFlow, applyNodeChanges, type Node, type Edge, type OnNodesChange } from '@xyflow/react';\n *\n *export default function Flow() {\n *  const [nodes, setNodes] = useState<Node[]>([]);\n *  const [edges, setEdges] = useState<Edge[]>([]);\n *  const onNodesChange: OnNodesChange = useCallback(\n *    (changes) => {\n *      setNodes((oldNodes) => applyNodeChanges(changes, oldNodes));\n *    },\n *    [setNodes],\n *  );\n *\n *  return (\n *    <ReactFlow nodes={nodes} edges={edges} onNodesChange={onNodesChange} />\n *  );\n *}\n *```\n * @remarks Various events on the <ReactFlow /> component can produce an {@link NodeChange}\n * that describes how to update the edges of your flow in some way.\n * If you don't need any custom behaviour, this util can be used to take an array\n * of these changes and apply them to your edges.\n */ function applyNodeChanges(changes, nodes) {\n    return applyChanges(changes, nodes);\n}\n/**\n * Drop in function that applies edge changes to an array of edges.\n * @public\n * @param changes - Array of changes to apply.\n * @param edges - Array of edge to apply the changes to.\n * @returns Array of updated edges.\n * @example\n * ```tsx\n *import { useState, useCallback } from 'react';\n *import { ReactFlow, applyEdgeChanges } from '@xyflow/react';\n *\n *export default function Flow() {\n *  const [nodes, setNodes] = useState([]);\n *  const [edges, setEdges] = useState([]);\n *  const onEdgesChange = useCallback(\n *    (changes) => {\n *      setEdges((oldEdges) => applyEdgeChanges(changes, oldEdges));\n *    },\n *    [setEdges],\n *  );\n *\n *  return (\n *    <ReactFlow nodes={nodes} edges={edges} onEdgesChange={onEdgesChange} />\n *  );\n *}\n *```\n * @remarks Various events on the <ReactFlow /> component can produce an {@link EdgeChange}\n * that describes how to update the edges of your flow in some way.\n * If you don't need any custom behaviour, this util can be used to take an array\n * of these changes and apply them to your edges.\n */ function applyEdgeChanges(changes, edges) {\n    return applyChanges(changes, edges);\n}\nfunction createSelectionChange(id, selected) {\n    return {\n        id,\n        type: \"select\",\n        selected\n    };\n}\nfunction getSelectionChanges(items, selectedIds = new Set(), mutateItem = false) {\n    const changes = [];\n    for (const [id, item] of items){\n        const willBeSelected = selectedIds.has(id);\n        // we don't want to set all items to selected=false on the first selection\n        if (!(item.selected === undefined && !willBeSelected) && item.selected !== willBeSelected) {\n            if (mutateItem) {\n                /*\n                 * this hack is needed for nodes. When the user dragged a node, it's selected.\n                 * When another node gets dragged, we need to deselect the previous one,\n                 * in order to have only one selected node at a time - the onNodesChange callback comes too late here :/\n                 */ item.selected = willBeSelected;\n            }\n            changes.push(createSelectionChange(item.id, willBeSelected));\n        }\n    }\n    return changes;\n}\nfunction getElementsDiffChanges({ items = [], lookup }) {\n    const changes = [];\n    const itemsLookup = new Map(items.map((item)=>[\n            item.id,\n            item\n        ]));\n    for (const [index, item] of items.entries()){\n        const lookupItem = lookup.get(item.id);\n        const storeItem = lookupItem?.internals?.userNode ?? lookupItem;\n        if (storeItem !== undefined && storeItem !== item) {\n            changes.push({\n                id: item.id,\n                item: item,\n                type: \"replace\"\n            });\n        }\n        if (storeItem === undefined) {\n            changes.push({\n                item: item,\n                type: \"add\",\n                index\n            });\n        }\n    }\n    for (const [id] of lookup){\n        const nextNode = itemsLookup.get(id);\n        if (nextNode === undefined) {\n            changes.push({\n                id,\n                type: \"remove\"\n            });\n        }\n    }\n    return changes;\n}\nfunction elementToRemoveChange(item) {\n    return {\n        id: item.id,\n        type: \"remove\"\n    };\n}\n/**\n * Test whether an object is usable as an [`Node`](/api-reference/types/node).\n * In TypeScript this is a type guard that will narrow the type of whatever you pass in to\n * [`Node`](/api-reference/types/node) if it returns `true`.\n *\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Node if it returns true\n * @param element - The element to test.\n * @returns Tests whether the provided value can be used as a `Node`. If you're using TypeScript,\n * this function acts as a type guard and will narrow the type of the value to `Node` if it returns\n * `true`.\n *\n * @example\n * ```js\n *import { isNode } from '@xyflow/react';\n *\n *if (isNode(node)) {\n * // ...\n *}\n *```\n */ const isNode = (element)=>(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNodeBase)(element);\n/**\n * Test whether an object is usable as an [`Edge`](/api-reference/types/edge).\n * In TypeScript this is a type guard that will narrow the type of whatever you pass in to\n * [`Edge`](/api-reference/types/edge) if it returns `true`.\n *\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Edge if it returns true\n * @param element - The element to test\n * @returns Tests whether the provided value can be used as an `Edge`. If you're using TypeScript,\n * this function acts as a type guard and will narrow the type of the value to `Edge` if it returns\n * `true`.\n *\n * @example\n * ```js\n *import { isEdge } from '@xyflow/react';\n *\n *if (isEdge(edge)) {\n * // ...\n *}\n *```\n */ const isEdge = (element)=>(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isEdgeBase)(element);\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nfunction fixedForwardRef(render) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(render);\n}\n// we need this hook to prevent a warning when using react-flow in SSR\nconst useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_1__.useEffect;\n/**\n * This hook returns a queue that can be used to batch updates.\n *\n * @param runQueue - a function that gets called when the queue is flushed\n * @internal\n *\n * @returns a Queue object\n */ function useQueue(runQueue) {\n    /*\n     * Because we're using a ref above, we need some way to let React know when to\n     * actually process the queue. We increment this number any time we mutate the\n     * queue, creating a new state to trigger the layout effect below.\n     * Using a boolean dirty flag here instead would lead to issues related to\n     * automatic batching. (https://github.com/xyflow/xyflow/issues/4779)\n     */ const [serial, setSerial] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(BigInt(0));\n    /*\n     * A reference of all the batched updates to process before the next render. We\n     * want a reference here so multiple synchronous calls to `setNodes` etc can be\n     * batched together.\n     */ const [queue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>createQueue(()=>setSerial((n)=>n + BigInt(1))));\n    /*\n     * Layout effects are guaranteed to run before the next render which means we\n     * shouldn't run into any issues with stale state or weird issues that come from\n     * rendering things one frame later than expected (we used to use `setTimeout`).\n     */ useIsomorphicLayoutEffect(()=>{\n        const queueItems = queue.get();\n        if (queueItems.length) {\n            runQueue(queueItems);\n            queue.reset();\n        }\n    }, [\n        serial\n    ]);\n    return queue;\n}\nfunction createQueue(cb) {\n    let queue = [];\n    return {\n        get: ()=>queue,\n        reset: ()=>{\n            queue = [];\n        },\n        push: (item)=>{\n            queue.push(item);\n            cb();\n        }\n    };\n}\nconst BatchContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\n/**\n * This is a context provider that holds and processes the node and edge update queues\n * that are needed to handle setNodes, addNodes, setEdges and addEdges.\n *\n * @internal\n */ function BatchProvider({ children }) {\n    const store = useStoreApi();\n    const nodeQueueHandler = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((queueItems)=>{\n        const { nodes = [], setNodes, hasDefaultNodes, onNodesChange, nodeLookup, fitViewQueued } = store.getState();\n        /*\n         * This is essentially an `Array.reduce` in imperative clothing. Processing\n         * this queue is a relatively hot path so we'd like to avoid the overhead of\n         * array methods where we can.\n         */ let next = nodes;\n        for (const payload of queueItems){\n            next = typeof payload === \"function\" ? payload(next) : payload;\n        }\n        const changes = getElementsDiffChanges({\n            items: next,\n            lookup: nodeLookup\n        });\n        if (hasDefaultNodes) {\n            setNodes(next);\n        }\n        // We only want to fire onNodesChange if there are changes to the nodes\n        if (changes.length > 0) {\n            onNodesChange?.(changes);\n        } else if (fitViewQueued) {\n            // If there are no changes to the nodes, we still need to call setNodes\n            // to trigger a re-render and fitView.\n            window.requestAnimationFrame(()=>{\n                const { fitViewQueued, nodes, setNodes } = store.getState();\n                if (fitViewQueued) {\n                    setNodes(nodes);\n                }\n            });\n        }\n    }, []);\n    const nodeQueue = useQueue(nodeQueueHandler);\n    const edgeQueueHandler = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((queueItems)=>{\n        const { edges = [], setEdges, hasDefaultEdges, onEdgesChange, edgeLookup } = store.getState();\n        let next = edges;\n        for (const payload of queueItems){\n            next = typeof payload === \"function\" ? payload(next) : payload;\n        }\n        if (hasDefaultEdges) {\n            setEdges(next);\n        } else if (onEdgesChange) {\n            onEdgesChange(getElementsDiffChanges({\n                items: next,\n                lookup: edgeLookup\n            }));\n        }\n    }, []);\n    const edgeQueue = useQueue(edgeQueueHandler);\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>({\n            nodeQueue,\n            edgeQueue\n        }), []);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BatchContext.Provider, {\n        value: value,\n        children: children\n    });\n}\nfunction useBatchContext() {\n    const batchContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(BatchContext);\n    if (!batchContext) {\n        throw new Error(\"useBatchContext must be used within a BatchProvider\");\n    }\n    return batchContext;\n}\nconst selector$k = (s)=>!!s.panZoom;\n/**\n * This hook returns a ReactFlowInstance that can be used to update nodes and edges, manipulate the viewport, or query the current state of the flow.\n *\n * @public\n * @example\n * ```jsx\n *import { useCallback, useState } from 'react';\n *import { useReactFlow } from '@xyflow/react';\n *\n *export function NodeCounter() {\n *  const reactFlow = useReactFlow();\n *  const [count, setCount] = useState(0);\n *  const countNodes = useCallback(() => {\n *    setCount(reactFlow.getNodes().length);\n *    // you need to pass it as a dependency if you are using it with useEffect or useCallback\n *    // because at the first render, it's not initialized yet and some functions might not work.\n *  }, [reactFlow]);\n *\n *  return (\n *    <div>\n *      <button onClick={countNodes}>Update count</button>\n *      <p>There are {count} nodes in the flow.</p>\n *    </div>\n *  );\n *}\n *```\n */ function useReactFlow() {\n    const viewportHelper = useViewportHelper();\n    const store = useStoreApi();\n    const batchContext = useBatchContext();\n    const viewportInitialized = useStore(selector$k);\n    const generalHelper = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const getInternalNode = (id)=>store.getState().nodeLookup.get(id);\n        const setNodes = (payload)=>{\n            batchContext.nodeQueue.push(payload);\n        };\n        const setEdges = (payload)=>{\n            batchContext.edgeQueue.push(payload);\n        };\n        const getNodeRect = (node)=>{\n            const { nodeLookup, nodeOrigin } = store.getState();\n            const nodeToUse = isNode(node) ? node : nodeLookup.get(node.id);\n            const position = nodeToUse.parentId ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.evaluateAbsolutePosition)(nodeToUse.position, nodeToUse.measured, nodeToUse.parentId, nodeLookup, nodeOrigin) : nodeToUse.position;\n            const nodeWithPosition = {\n                ...nodeToUse,\n                position,\n                width: nodeToUse.measured?.width ?? nodeToUse.width,\n                height: nodeToUse.measured?.height ?? nodeToUse.height\n            };\n            return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeToRect)(nodeWithPosition);\n        };\n        const updateNode = (id, nodeUpdate, options = {\n            replace: false\n        })=>{\n            setNodes((prevNodes)=>prevNodes.map((node)=>{\n                    if (node.id === id) {\n                        const nextNode = typeof nodeUpdate === \"function\" ? nodeUpdate(node) : nodeUpdate;\n                        return options.replace && isNode(nextNode) ? nextNode : {\n                            ...node,\n                            ...nextNode\n                        };\n                    }\n                    return node;\n                }));\n        };\n        const updateEdge = (id, edgeUpdate, options = {\n            replace: false\n        })=>{\n            setEdges((prevEdges)=>prevEdges.map((edge)=>{\n                    if (edge.id === id) {\n                        const nextEdge = typeof edgeUpdate === \"function\" ? edgeUpdate(edge) : edgeUpdate;\n                        return options.replace && isEdge(nextEdge) ? nextEdge : {\n                            ...edge,\n                            ...nextEdge\n                        };\n                    }\n                    return edge;\n                }));\n        };\n        return {\n            getNodes: ()=>store.getState().nodes.map((n)=>({\n                        ...n\n                    })),\n            getNode: (id)=>getInternalNode(id)?.internals.userNode,\n            getInternalNode,\n            getEdges: ()=>{\n                const { edges = [] } = store.getState();\n                return edges.map((e)=>({\n                        ...e\n                    }));\n            },\n            getEdge: (id)=>store.getState().edgeLookup.get(id),\n            setNodes,\n            setEdges,\n            addNodes: (payload)=>{\n                const newNodes = Array.isArray(payload) ? payload : [\n                    payload\n                ];\n                batchContext.nodeQueue.push((nodes)=>[\n                        ...nodes,\n                        ...newNodes\n                    ]);\n            },\n            addEdges: (payload)=>{\n                const newEdges = Array.isArray(payload) ? payload : [\n                    payload\n                ];\n                batchContext.edgeQueue.push((edges)=>[\n                        ...edges,\n                        ...newEdges\n                    ]);\n            },\n            toObject: ()=>{\n                const { nodes = [], edges = [], transform } = store.getState();\n                const [x, y, zoom] = transform;\n                return {\n                    nodes: nodes.map((n)=>({\n                            ...n\n                        })),\n                    edges: edges.map((e)=>({\n                            ...e\n                        })),\n                    viewport: {\n                        x,\n                        y,\n                        zoom\n                    }\n                };\n            },\n            deleteElements: async ({ nodes: nodesToRemove = [], edges: edgesToRemove = [] })=>{\n                const { nodes, edges, onNodesDelete, onEdgesDelete, triggerNodeChanges, triggerEdgeChanges, onDelete, onBeforeDelete } = store.getState();\n                const { nodes: matchingNodes, edges: matchingEdges } = await (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getElementsToRemove)({\n                    nodesToRemove,\n                    edgesToRemove,\n                    nodes,\n                    edges,\n                    onBeforeDelete\n                });\n                const hasMatchingEdges = matchingEdges.length > 0;\n                const hasMatchingNodes = matchingNodes.length > 0;\n                if (hasMatchingEdges) {\n                    const edgeChanges = matchingEdges.map(elementToRemoveChange);\n                    onEdgesDelete?.(matchingEdges);\n                    triggerEdgeChanges(edgeChanges);\n                }\n                if (hasMatchingNodes) {\n                    const nodeChanges = matchingNodes.map(elementToRemoveChange);\n                    onNodesDelete?.(matchingNodes);\n                    triggerNodeChanges(nodeChanges);\n                }\n                if (hasMatchingNodes || hasMatchingEdges) {\n                    onDelete?.({\n                        nodes: matchingNodes,\n                        edges: matchingEdges\n                    });\n                }\n                return {\n                    deletedNodes: matchingNodes,\n                    deletedEdges: matchingEdges\n                };\n            },\n            /**\n             * Partial is defined as \"the 2 nodes/areas are intersecting partially\".\n             * If a is contained in b or b is contained in a, they are both\n             * considered fully intersecting.\n             */ getIntersectingNodes: (nodeOrRect, partially = true, nodes)=>{\n                const isRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isRectObject)(nodeOrRect);\n                const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);\n                const hasNodesOption = nodes !== undefined;\n                if (!nodeRect) {\n                    return [];\n                }\n                return (nodes || store.getState().nodes).filter((n)=>{\n                    const internalNode = store.getState().nodeLookup.get(n.id);\n                    if (internalNode && !isRect && (n.id === nodeOrRect.id || !internalNode.internals.positionAbsolute)) {\n                        return false;\n                    }\n                    const currNodeRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeToRect)(hasNodesOption ? n : internalNode);\n                    const overlappingArea = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getOverlappingArea)(currNodeRect, nodeRect);\n                    const partiallyVisible = partially && overlappingArea > 0;\n                    return partiallyVisible || overlappingArea >= currNodeRect.width * currNodeRect.height || overlappingArea >= nodeRect.width * nodeRect.height;\n                });\n            },\n            isNodeIntersecting: (nodeOrRect, area, partially = true)=>{\n                const isRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isRectObject)(nodeOrRect);\n                const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);\n                if (!nodeRect) {\n                    return false;\n                }\n                const overlappingArea = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getOverlappingArea)(nodeRect, area);\n                const partiallyVisible = partially && overlappingArea > 0;\n                return partiallyVisible || overlappingArea >= area.width * area.height || overlappingArea >= nodeRect.width * nodeRect.height;\n            },\n            updateNode,\n            updateNodeData: (id, dataUpdate, options = {\n                replace: false\n            })=>{\n                updateNode(id, (node)=>{\n                    const nextData = typeof dataUpdate === \"function\" ? dataUpdate(node) : dataUpdate;\n                    return options.replace ? {\n                        ...node,\n                        data: nextData\n                    } : {\n                        ...node,\n                        data: {\n                            ...node.data,\n                            ...nextData\n                        }\n                    };\n                }, options);\n            },\n            updateEdge,\n            updateEdgeData: (id, dataUpdate, options = {\n                replace: false\n            })=>{\n                updateEdge(id, (edge)=>{\n                    const nextData = typeof dataUpdate === \"function\" ? dataUpdate(edge) : dataUpdate;\n                    return options.replace ? {\n                        ...edge,\n                        data: nextData\n                    } : {\n                        ...edge,\n                        data: {\n                            ...edge.data,\n                            ...nextData\n                        }\n                    };\n                }, options);\n            },\n            getNodesBounds: (nodes)=>{\n                const { nodeLookup, nodeOrigin } = store.getState();\n                return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesBounds)(nodes, {\n                    nodeLookup,\n                    nodeOrigin\n                });\n            },\n            getHandleConnections: ({ type, id, nodeId })=>Array.from(store.getState().connectionLookup.get(`${nodeId}-${type}${id ? `-${id}` : \"\"}`)?.values() ?? []),\n            getNodeConnections: ({ type, handleId, nodeId })=>Array.from(store.getState().connectionLookup.get(`${nodeId}${type ? handleId ? `-${type}-${handleId}` : `-${type}` : \"\"}`)?.values() ?? []),\n            fitView: async (options)=>{\n                // We either create a new Promise or reuse the existing one\n                // Even if fitView is called multiple times in a row, we only end up with a single Promise\n                const fitViewResolver = store.getState().fitViewResolver ?? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.withResolvers)();\n                // We schedule a fitView by setting fitViewQueued and triggering a setNodes\n                store.setState({\n                    fitViewQueued: true,\n                    fitViewOptions: options,\n                    fitViewResolver\n                });\n                batchContext.nodeQueue.push((nodes)=>[\n                        ...nodes\n                    ]);\n                return fitViewResolver.promise;\n            }\n        };\n    }, []);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        return {\n            ...generalHelper,\n            ...viewportHelper,\n            viewportInitialized\n        };\n    }, [\n        viewportInitialized\n    ]);\n}\nconst selected = (item)=>item.selected;\nconst win$1 =  false ? 0 : undefined;\n/**\n * Hook for handling global key events.\n *\n * @internal\n */ function useGlobalKeyHandler({ deleteKeyCode, multiSelectionKeyCode }) {\n    const store = useStoreApi();\n    const { deleteElements } = useReactFlow();\n    const deleteKeyPressed = useKeyPress(deleteKeyCode, {\n        actInsideInputWithModifier: false\n    });\n    const multiSelectionKeyPressed = useKeyPress(multiSelectionKeyCode, {\n        target: win$1\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (deleteKeyPressed) {\n            const { edges, nodes } = store.getState();\n            deleteElements({\n                nodes: nodes.filter(selected),\n                edges: edges.filter(selected)\n            });\n            store.setState({\n                nodesSelectionActive: false\n            });\n        }\n    }, [\n        deleteKeyPressed\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        store.setState({\n            multiSelectionActive: multiSelectionKeyPressed\n        });\n    }, [\n        multiSelectionKeyPressed\n    ]);\n}\n/**\n * Hook for handling resize events.\n *\n * @internal\n */ function useResizeHandler(domNode) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const updateDimensions = ()=>{\n            if (!domNode.current || !(domNode.current.checkVisibility?.() ?? true)) {\n                return false;\n            }\n            const size = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getDimensions)(domNode.current);\n            if (size.height === 0 || size.width === 0) {\n                store.getState().onError?.(\"004\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error004\"]());\n            }\n            store.setState({\n                width: size.width || 500,\n                height: size.height || 500\n            });\n        };\n        if (domNode.current) {\n            updateDimensions();\n            window.addEventListener(\"resize\", updateDimensions);\n            const resizeObserver = new ResizeObserver(()=>updateDimensions());\n            resizeObserver.observe(domNode.current);\n            return ()=>{\n                window.removeEventListener(\"resize\", updateDimensions);\n                if (resizeObserver && domNode.current) {\n                    resizeObserver.unobserve(domNode.current);\n                }\n            };\n        }\n    }, []);\n}\nconst containerStyle = {\n    position: \"absolute\",\n    width: \"100%\",\n    height: \"100%\",\n    top: 0,\n    left: 0\n};\nconst selector$j = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        lib: s.lib,\n        connectionInProgress: s.connection.inProgress\n    });\nfunction ZoomPane({ onPaneContextMenu, zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.PanOnScrollMode.Free, zoomOnDoubleClick = true, panOnDrag = true, defaultViewport, translateExtent, minZoom, maxZoom, zoomActivationKeyCode, preventScrolling = true, children, noWheelClassName, noPanClassName, onViewportChange, isControlledViewport, paneClickDistance }) {\n    const store = useStoreApi();\n    const zoomPane = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { userSelectionActive, lib, connectionInProgress } = useStore(selector$j, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const zoomActivationKeyPressed = useKeyPress(zoomActivationKeyCode);\n    const panZoom = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    useResizeHandler(zoomPane);\n    const onTransformChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((transform)=>{\n        onViewportChange?.({\n            x: transform[0],\n            y: transform[1],\n            zoom: transform[2]\n        });\n        if (!isControlledViewport) {\n            store.setState({\n                transform\n            });\n        }\n    }, [\n        onViewportChange,\n        isControlledViewport\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (zoomPane.current) {\n            panZoom.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYPanZoom)({\n                domNode: zoomPane.current,\n                minZoom,\n                maxZoom,\n                translateExtent,\n                viewport: defaultViewport,\n                paneClickDistance,\n                onDraggingChange: (paneDragging)=>store.setState({\n                        paneDragging\n                    }),\n                onPanZoomStart: (event, vp)=>{\n                    const { onViewportChangeStart, onMoveStart } = store.getState();\n                    onMoveStart?.(event, vp);\n                    onViewportChangeStart?.(vp);\n                },\n                onPanZoom: (event, vp)=>{\n                    const { onViewportChange, onMove } = store.getState();\n                    onMove?.(event, vp);\n                    onViewportChange?.(vp);\n                },\n                onPanZoomEnd: (event, vp)=>{\n                    const { onViewportChangeEnd, onMoveEnd } = store.getState();\n                    onMoveEnd?.(event, vp);\n                    onViewportChangeEnd?.(vp);\n                }\n            });\n            const { x, y, zoom } = panZoom.current.getViewport();\n            store.setState({\n                panZoom: panZoom.current,\n                transform: [\n                    x,\n                    y,\n                    zoom\n                ],\n                domNode: zoomPane.current.closest(\".react-flow\")\n            });\n            return ()=>{\n                panZoom.current?.destroy();\n            };\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        panZoom.current?.update({\n            onPaneContextMenu,\n            zoomOnScroll,\n            zoomOnPinch,\n            panOnScroll,\n            panOnScrollSpeed,\n            panOnScrollMode,\n            zoomOnDoubleClick,\n            panOnDrag,\n            zoomActivationKeyPressed,\n            preventScrolling,\n            noPanClassName,\n            userSelectionActive,\n            noWheelClassName,\n            lib,\n            onTransformChange,\n            connectionInProgress\n        });\n    }, [\n        onPaneContextMenu,\n        zoomOnScroll,\n        zoomOnPinch,\n        panOnScroll,\n        panOnScrollSpeed,\n        panOnScrollMode,\n        zoomOnDoubleClick,\n        panOnDrag,\n        zoomActivationKeyPressed,\n        preventScrolling,\n        noPanClassName,\n        userSelectionActive,\n        noWheelClassName,\n        lib,\n        onTransformChange,\n        connectionInProgress\n    ]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__renderer\",\n        ref: zoomPane,\n        style: containerStyle,\n        children: children\n    });\n}\nconst selector$i = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        userSelectionRect: s.userSelectionRect\n    });\nfunction UserSelection() {\n    const { userSelectionActive, userSelectionRect } = useStore(selector$i, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const isActive = userSelectionActive && userSelectionRect;\n    if (!isActive) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__selection react-flow__container\",\n        style: {\n            width: userSelectionRect.width,\n            height: userSelectionRect.height,\n            transform: `translate(${userSelectionRect.x}px, ${userSelectionRect.y}px)`\n        }\n    });\n}\nconst wrapHandler = (handler, containerRef)=>{\n    return (event)=>{\n        if (event.target !== containerRef.current) {\n            return;\n        }\n        handler?.(event);\n    };\n};\nconst selector$h = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        elementsSelectable: s.elementsSelectable,\n        connectionInProgress: s.connection.inProgress,\n        dragging: s.paneDragging\n    });\nfunction Pane({ isSelecting, selectionKeyPressed, selectionMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode.Full, panOnDrag, selectionOnDrag, onSelectionStart, onSelectionEnd, onPaneClick, onPaneContextMenu, onPaneScroll, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, children }) {\n    const store = useStoreApi();\n    const { userSelectionActive, elementsSelectable, dragging, connectionInProgress } = useStore(selector$h, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const hasActiveSelection = elementsSelectable && (isSelecting || userSelectionActive);\n    const container = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const containerBounds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const selectedNodeIds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set());\n    const selectedEdgeIds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set());\n    // Used to prevent click events when the user lets go of the selectionKey during a selection\n    const selectionInProgress = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const selectionStarted = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const onClick = (event)=>{\n        // We prevent click events when the user let go of the selectionKey during a selection\n        // We also prevent click events when a connection is in progress\n        if (selectionInProgress.current || connectionInProgress) {\n            selectionInProgress.current = false;\n            return;\n        }\n        onPaneClick?.(event);\n        store.getState().resetSelectedElements();\n        store.setState({\n            nodesSelectionActive: false\n        });\n    };\n    const onContextMenu = (event)=>{\n        if (Array.isArray(panOnDrag) && panOnDrag?.includes(2)) {\n            event.preventDefault();\n            return;\n        }\n        onPaneContextMenu?.(event);\n    };\n    const onWheel = onPaneScroll ? (event)=>onPaneScroll(event) : undefined;\n    const onClickCapture = (event)=>{\n        const isSelectionOnDragActive = selectionOnDrag && container.current === event.target || !selectionOnDrag || selectionKeyPressed;\n        if (!isSelectionOnDragActive) {\n            return;\n        }\n        event.stopPropagation();\n    };\n    // We are using capture here in order to prevent other pointer events\n    // to be able to create a selection above a node or an edge\n    const onPointerDownCapture = (event)=>{\n        const { resetSelectedElements, domNode } = store.getState();\n        containerBounds.current = domNode?.getBoundingClientRect();\n        const isNoKeyEvent = event.target !== container.current && !!event.target.closest(\".nokey\");\n        const isSelectionActive = selectionOnDrag && container.current === event.target || !selectionOnDrag || selectionKeyPressed;\n        if (!elementsSelectable || !isSelecting || event.button !== 0 || !containerBounds.current || isNoKeyEvent || !isSelectionActive || !event.isPrimary) {\n            return;\n        }\n        event.stopPropagation();\n        event.preventDefault();\n        event.target?.setPointerCapture?.(event.pointerId);\n        selectionStarted.current = true;\n        selectionInProgress.current = false;\n        const { x, y } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEventPosition)(event.nativeEvent, containerBounds.current);\n        resetSelectedElements();\n        store.setState({\n            userSelectionRect: {\n                width: 0,\n                height: 0,\n                startX: x,\n                startY: y,\n                x,\n                y\n            }\n        });\n        onSelectionStart?.(event);\n    };\n    const onPointerMove = (event)=>{\n        const { userSelectionRect, transform, nodeLookup, edgeLookup, connectionLookup, triggerNodeChanges, triggerEdgeChanges, defaultEdgeOptions } = store.getState();\n        if (!containerBounds.current || !userSelectionRect) {\n            return;\n        }\n        selectionInProgress.current = true;\n        const { x: mouseX, y: mouseY } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEventPosition)(event.nativeEvent, containerBounds.current);\n        const { startX, startY } = userSelectionRect;\n        const nextUserSelectRect = {\n            startX,\n            startY,\n            x: mouseX < startX ? mouseX : startX,\n            y: mouseY < startY ? mouseY : startY,\n            width: Math.abs(mouseX - startX),\n            height: Math.abs(mouseY - startY)\n        };\n        const prevSelectedNodeIds = selectedNodeIds.current;\n        const prevSelectedEdgeIds = selectedEdgeIds.current;\n        selectedNodeIds.current = new Set((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesInside)(nodeLookup, nextUserSelectRect, transform, selectionMode === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode.Partial, true).map((node)=>node.id));\n        selectedEdgeIds.current = new Set();\n        const edgesSelectable = defaultEdgeOptions?.selectable ?? true;\n        // We look for all edges connected to the selected nodes\n        for (const nodeId of selectedNodeIds.current){\n            const connections = connectionLookup.get(nodeId);\n            if (!connections) continue;\n            for (const { edgeId } of connections.values()){\n                const edge = edgeLookup.get(edgeId);\n                if (edge && (edge.selectable ?? edgesSelectable)) {\n                    selectedEdgeIds.current.add(edgeId);\n                }\n            }\n        }\n        if (!(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areSetsEqual)(prevSelectedNodeIds, selectedNodeIds.current)) {\n            const changes = getSelectionChanges(nodeLookup, selectedNodeIds.current, true);\n            triggerNodeChanges(changes);\n        }\n        if (!(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areSetsEqual)(prevSelectedEdgeIds, selectedEdgeIds.current)) {\n            const changes = getSelectionChanges(edgeLookup, selectedEdgeIds.current);\n            triggerEdgeChanges(changes);\n        }\n        store.setState({\n            userSelectionRect: nextUserSelectRect,\n            userSelectionActive: true,\n            nodesSelectionActive: false\n        });\n    };\n    const onPointerUp = (event)=>{\n        if (event.button !== 0 || !selectionStarted.current) {\n            return;\n        }\n        event.target?.releasePointerCapture?.(event.pointerId);\n        const { userSelectionRect } = store.getState();\n        /*\n         * We only want to trigger click functions when in selection mode if\n         * the user did not move the mouse.\n         */ if (!userSelectionActive && userSelectionRect && event.target === container.current) {\n            onClick?.(event);\n        }\n        store.setState({\n            userSelectionActive: false,\n            userSelectionRect: null,\n            nodesSelectionActive: selectedNodeIds.current.size > 0\n        });\n        onSelectionEnd?.(event);\n        /*\n         * If the user kept holding the selectionKey during the selection,\n         * we need to reset the selectionInProgress, so the next click event is not prevented\n         */ if (selectionKeyPressed || selectionOnDrag) {\n            selectionInProgress.current = false;\n        }\n        selectionStarted.current = false;\n    };\n    const draggable = panOnDrag === true || Array.isArray(panOnDrag) && panOnDrag.includes(0);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__pane\",\n            {\n                draggable,\n                dragging,\n                selection: isSelecting\n            }\n        ]),\n        onClick: hasActiveSelection ? undefined : wrapHandler(onClick, container),\n        onContextMenu: wrapHandler(onContextMenu, container),\n        onWheel: wrapHandler(onWheel, container),\n        onPointerEnter: hasActiveSelection ? undefined : onPaneMouseEnter,\n        onPointerMove: hasActiveSelection ? onPointerMove : onPaneMouseMove,\n        onPointerUp: hasActiveSelection ? onPointerUp : undefined,\n        onPointerDownCapture: hasActiveSelection ? onPointerDownCapture : undefined,\n        onClickCapture: hasActiveSelection ? onClickCapture : undefined,\n        onPointerLeave: onPaneMouseLeave,\n        ref: container,\n        style: containerStyle,\n        children: [\n            children,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UserSelection, {})\n        ]\n    });\n}\n/*\n * this handler is called by\n * 1. the click handler when node is not draggable or selectNodesOnDrag = false\n * or\n * 2. the on drag start handler when node is draggable and selectNodesOnDrag = true\n */ function handleNodeClick({ id, store, unselect = false, nodeRef }) {\n    const { addSelectedNodes, unselectNodesAndEdges, multiSelectionActive, nodeLookup, onError } = store.getState();\n    const node = nodeLookup.get(id);\n    if (!node) {\n        onError?.(\"012\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error012\"](id));\n        return;\n    }\n    store.setState({\n        nodesSelectionActive: false\n    });\n    if (!node.selected) {\n        addSelectedNodes([\n            id\n        ]);\n    } else if (unselect || node.selected && multiSelectionActive) {\n        unselectNodesAndEdges({\n            nodes: [\n                node\n            ],\n            edges: []\n        });\n        requestAnimationFrame(()=>nodeRef?.current?.blur());\n    }\n}\n/**\n * Hook for calling XYDrag helper from @xyflow/system.\n *\n * @internal\n */ function useDrag({ nodeRef, disabled = false, noDragClassName, handleSelector, nodeId, isSelectable, nodeClickDistance }) {\n    const store = useStoreApi();\n    const [dragging, setDragging] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const xyDrag = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        xyDrag.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYDrag)({\n            getStoreItems: ()=>store.getState(),\n            onNodeMouseDown: (id)=>{\n                handleNodeClick({\n                    id,\n                    store,\n                    nodeRef\n                });\n            },\n            onDragStart: ()=>{\n                setDragging(true);\n            },\n            onDragStop: ()=>{\n                setDragging(false);\n            }\n        });\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (disabled) {\n            xyDrag.current?.destroy();\n        } else if (nodeRef.current) {\n            xyDrag.current?.update({\n                noDragClassName,\n                handleSelector,\n                domNode: nodeRef.current,\n                isSelectable,\n                nodeId,\n                nodeClickDistance\n            });\n            return ()=>{\n                xyDrag.current?.destroy();\n            };\n        }\n    }, [\n        noDragClassName,\n        handleSelector,\n        disabled,\n        isSelectable,\n        nodeRef,\n        nodeId\n    ]);\n    return dragging;\n}\nconst selectedAndDraggable = (nodesDraggable)=>(n)=>n.selected && (n.draggable || nodesDraggable && typeof n.draggable === \"undefined\");\n/**\n * Hook for updating node positions by passing a direction and factor\n *\n * @internal\n * @returns function for updating node positions\n */ function useMoveSelectedNodes() {\n    const store = useStoreApi();\n    const moveSelectedNodes = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((params)=>{\n        const { nodeExtent, snapToGrid, snapGrid, nodesDraggable, onError, updateNodePositions, nodeLookup, nodeOrigin } = store.getState();\n        const nodeUpdates = new Map();\n        const isSelected = selectedAndDraggable(nodesDraggable);\n        /*\n         * by default a node moves 5px on each key press\n         * if snap grid is enabled, we use that for the velocity\n         */ const xVelo = snapToGrid ? snapGrid[0] : 5;\n        const yVelo = snapToGrid ? snapGrid[1] : 5;\n        const xDiff = params.direction.x * xVelo * params.factor;\n        const yDiff = params.direction.y * yVelo * params.factor;\n        for (const [, node] of nodeLookup){\n            if (!isSelected(node)) {\n                continue;\n            }\n            let nextPosition = {\n                x: node.internals.positionAbsolute.x + xDiff,\n                y: node.internals.positionAbsolute.y + yDiff\n            };\n            if (snapToGrid) {\n                nextPosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.snapPosition)(nextPosition, snapGrid);\n            }\n            const { position, positionAbsolute } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.calculateNodePosition)({\n                nodeId: node.id,\n                nextPosition,\n                nodeLookup,\n                nodeExtent,\n                nodeOrigin,\n                onError\n            });\n            node.position = position;\n            node.internals.positionAbsolute = positionAbsolute;\n            nodeUpdates.set(node.id, node);\n        }\n        updateNodePositions(nodeUpdates);\n    }, []);\n    return moveSelectedNodes;\n}\nconst NodeIdContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst Provider = NodeIdContext.Provider;\nNodeIdContext.Consumer;\n/**\n * You can use this hook to get the id of the node it is used inside. It is useful\n * if you need the node's id deeper in the render tree but don't want to manually\n * drill down the id as a prop.\n *\n * @public\n * @returns The id for a node in the flow.\n *\n * @example\n *```jsx\n *import { useNodeId } from '@xyflow/react';\n *\n *export default function CustomNode() {\n *  return (\n *    <div>\n *      <span>This node has an id of </span>\n *      <NodeIdDisplay />\n *    </div>\n *  );\n *}\n *\n *function NodeIdDisplay() {\n *  const nodeId = useNodeId();\n *\n *  return <span>{nodeId}</span>;\n *}\n *```\n */ const useNodeId = ()=>{\n    const nodeId = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(NodeIdContext);\n    return nodeId;\n};\nconst selector$g = (s)=>({\n        connectOnClick: s.connectOnClick,\n        noPanClassName: s.noPanClassName,\n        rfId: s.rfId\n    });\nconst connectingSelector = (nodeId, handleId, type)=>(state)=>{\n        const { connectionClickStartHandle: clickHandle, connectionMode, connection } = state;\n        const { fromHandle, toHandle, isValid } = connection;\n        const connectingTo = toHandle?.nodeId === nodeId && toHandle?.id === handleId && toHandle?.type === type;\n        return {\n            connectingFrom: fromHandle?.nodeId === nodeId && fromHandle?.id === handleId && fromHandle?.type === type,\n            connectingTo,\n            clickConnecting: clickHandle?.nodeId === nodeId && clickHandle?.id === handleId && clickHandle?.type === type,\n            isPossibleEndHandle: connectionMode === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionMode.Strict ? fromHandle?.type !== type : nodeId !== fromHandle?.nodeId || handleId !== fromHandle?.id,\n            connectionInProcess: !!fromHandle,\n            clickConnectionInProcess: !!clickHandle,\n            valid: connectingTo && isValid\n        };\n    };\nfunction HandleComponent({ type = \"source\", position = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, isValidConnection, isConnectable = true, isConnectableStart = true, isConnectableEnd = true, id, onConnect, children, className, onMouseDown, onTouchStart, ...rest }, ref) {\n    const handleId = id || null;\n    const isTarget = type === \"target\";\n    const store = useStoreApi();\n    const nodeId = useNodeId();\n    const { connectOnClick, noPanClassName, rfId } = useStore(selector$g, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const { connectingFrom, connectingTo, clickConnecting, isPossibleEndHandle, connectionInProcess, clickConnectionInProcess, valid } = useStore(connectingSelector(nodeId, handleId, type), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    if (!nodeId) {\n        store.getState().onError?.(\"010\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error010\"]());\n    }\n    const onConnectExtended = (params)=>{\n        const { defaultEdgeOptions, onConnect: onConnectAction, hasDefaultEdges } = store.getState();\n        const edgeParams = {\n            ...defaultEdgeOptions,\n            ...params\n        };\n        if (hasDefaultEdges) {\n            const { edges, setEdges } = store.getState();\n            setEdges((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.addEdge)(edgeParams, edges));\n        }\n        onConnectAction?.(edgeParams);\n        onConnect?.(edgeParams);\n    };\n    const onPointerDown = (event)=>{\n        if (!nodeId) {\n            return;\n        }\n        const isMouseTriggered = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isMouseEvent)(event.nativeEvent);\n        if (isConnectableStart && (isMouseTriggered && event.button === 0 || !isMouseTriggered)) {\n            const currentStore = store.getState();\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYHandle.onPointerDown(event.nativeEvent, {\n                handleDomNode: event.currentTarget,\n                autoPanOnConnect: currentStore.autoPanOnConnect,\n                connectionMode: currentStore.connectionMode,\n                connectionRadius: currentStore.connectionRadius,\n                domNode: currentStore.domNode,\n                nodeLookup: currentStore.nodeLookup,\n                lib: currentStore.lib,\n                isTarget,\n                handleId,\n                nodeId,\n                flowId: currentStore.rfId,\n                panBy: currentStore.panBy,\n                cancelConnection: currentStore.cancelConnection,\n                onConnectStart: currentStore.onConnectStart,\n                onConnectEnd: currentStore.onConnectEnd,\n                updateConnection: currentStore.updateConnection,\n                onConnect: onConnectExtended,\n                isValidConnection: isValidConnection || currentStore.isValidConnection,\n                getTransform: ()=>store.getState().transform,\n                getFromHandle: ()=>store.getState().connection.fromHandle,\n                autoPanSpeed: currentStore.autoPanSpeed,\n                dragThreshold: currentStore.connectionDragThreshold\n            });\n        }\n        if (isMouseTriggered) {\n            onMouseDown?.(event);\n        } else {\n            onTouchStart?.(event);\n        }\n    };\n    const onClick = (event)=>{\n        const { onClickConnectStart, onClickConnectEnd, connectionClickStartHandle, connectionMode, isValidConnection: isValidConnectionStore, lib, rfId: flowId, nodeLookup, connection: connectionState } = store.getState();\n        if (!nodeId || !connectionClickStartHandle && !isConnectableStart) {\n            return;\n        }\n        if (!connectionClickStartHandle) {\n            onClickConnectStart?.(event.nativeEvent, {\n                nodeId,\n                handleId,\n                handleType: type\n            });\n            store.setState({\n                connectionClickStartHandle: {\n                    nodeId,\n                    type,\n                    id: handleId\n                }\n            });\n            return;\n        }\n        const doc = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getHostForElement)(event.target);\n        const isValidConnectionHandler = isValidConnection || isValidConnectionStore;\n        const { connection, isValid } = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYHandle.isValid(event.nativeEvent, {\n            handle: {\n                nodeId,\n                id: handleId,\n                type\n            },\n            connectionMode,\n            fromNodeId: connectionClickStartHandle.nodeId,\n            fromHandleId: connectionClickStartHandle.id || null,\n            fromType: connectionClickStartHandle.type,\n            isValidConnection: isValidConnectionHandler,\n            flowId,\n            doc,\n            lib,\n            nodeLookup\n        });\n        if (isValid && connection) {\n            onConnectExtended(connection);\n        }\n        const connectionClone = structuredClone(connectionState);\n        delete connectionClone.inProgress;\n        connectionClone.toPosition = connectionClone.toHandle ? connectionClone.toHandle.position : null;\n        onClickConnectEnd?.(event, connectionClone);\n        store.setState({\n            connectionClickStartHandle: null\n        });\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        \"data-handleid\": handleId,\n        \"data-nodeid\": nodeId,\n        \"data-handlepos\": position,\n        \"data-id\": `${rfId}-${nodeId}-${handleId}-${type}`,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__handle\",\n            `react-flow__handle-${position}`,\n            \"nodrag\",\n            noPanClassName,\n            className,\n            {\n                source: !isTarget,\n                target: isTarget,\n                connectable: isConnectable,\n                connectablestart: isConnectableStart,\n                connectableend: isConnectableEnd,\n                clickconnecting: clickConnecting,\n                connectingfrom: connectingFrom,\n                connectingto: connectingTo,\n                valid,\n                /*\n                 * shows where you can start a connection from\n                 * and where you can end it while connecting\n                 */ connectionindicator: isConnectable && (!connectionInProcess || isPossibleEndHandle) && (connectionInProcess || clickConnectionInProcess ? isConnectableEnd : isConnectableStart)\n            }\n        ]),\n        onMouseDown: onPointerDown,\n        onTouchStart: onPointerDown,\n        onClick: connectOnClick ? onClick : undefined,\n        ref: ref,\n        ...rest,\n        children: children\n    });\n}\n/**\n * The `<Handle />` component is used in your [custom nodes](/learn/customization/custom-nodes)\n * to define connection points.\n *\n *@public\n *\n *@example\n *\n *```jsx\n *import { Handle, Position } from '@xyflow/react';\n *\n *export function CustomNode({ data }) {\n *  return (\n *    <>\n *      <div style={{ padding: '10px 20px' }}>\n *        {data.label}\n *      </div>\n *\n *      <Handle type=\"target\" position={Position.Left} />\n *      <Handle type=\"source\" position={Position.Right} />\n *    </>\n *  );\n *};\n *```\n */ const Handle = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(fixedForwardRef(HandleComponent));\nfunction InputNode({ data, isConnectable, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            data?.label,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"source\",\n                position: sourcePosition,\n                isConnectable: isConnectable\n            })\n        ]\n    });\n}\nfunction DefaultNode({ data, isConnectable, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"target\",\n                position: targetPosition,\n                isConnectable: isConnectable\n            }),\n            data?.label,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"source\",\n                position: sourcePosition,\n                isConnectable: isConnectable\n            })\n        ]\n    });\n}\nfunction GroupNode() {\n    return null;\n}\nfunction OutputNode({ data, isConnectable, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"target\",\n                position: targetPosition,\n                isConnectable: isConnectable\n            }),\n            data?.label\n        ]\n    });\n}\nconst arrowKeyDiffs = {\n    ArrowUp: {\n        x: 0,\n        y: -1\n    },\n    ArrowDown: {\n        x: 0,\n        y: 1\n    },\n    ArrowLeft: {\n        x: -1,\n        y: 0\n    },\n    ArrowRight: {\n        x: 1,\n        y: 0\n    }\n};\nconst builtinNodeTypes = {\n    input: InputNode,\n    default: DefaultNode,\n    output: OutputNode,\n    group: GroupNode\n};\nfunction getNodeInlineStyleDimensions(node) {\n    if (node.internals.handleBounds === undefined) {\n        return {\n            width: node.width ?? node.initialWidth ?? node.style?.width,\n            height: node.height ?? node.initialHeight ?? node.style?.height\n        };\n    }\n    return {\n        width: node.width ?? node.style?.width,\n        height: node.height ?? node.style?.height\n    };\n}\nconst selector$f = (s)=>{\n    const { width, height, x, y } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(s.nodeLookup, {\n        filter: (node)=>!!node.selected\n    });\n    return {\n        width: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(width) ? width : null,\n        height: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(height) ? height : null,\n        userSelectionActive: s.userSelectionActive,\n        transformString: `translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]}) translate(${x}px,${y}px)`\n    };\n};\nfunction NodesSelection({ onSelectionContextMenu, noPanClassName, disableKeyboardA11y }) {\n    const store = useStoreApi();\n    const { width, height, transformString, userSelectionActive } = useStore(selector$f, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const moveSelectedNodes = useMoveSelectedNodes();\n    const nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!disableKeyboardA11y) {\n            nodeRef.current?.focus({\n                preventScroll: true\n            });\n        }\n    }, [\n        disableKeyboardA11y\n    ]);\n    useDrag({\n        nodeRef\n    });\n    if (userSelectionActive || !width || !height) {\n        return null;\n    }\n    const onContextMenu = onSelectionContextMenu ? (event)=>{\n        const selectedNodes = store.getState().nodes.filter((n)=>n.selected);\n        onSelectionContextMenu(event, selectedNodes);\n    } : undefined;\n    const onKeyDown = (event)=>{\n        if (Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {\n            event.preventDefault();\n            moveSelectedNodes({\n                direction: arrowKeyDiffs[event.key],\n                factor: event.shiftKey ? 4 : 1\n            });\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__nodesselection\",\n            \"react-flow__container\",\n            noPanClassName\n        ]),\n        style: {\n            transform: transformString\n        },\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n            ref: nodeRef,\n            className: \"react-flow__nodesselection-rect\",\n            onContextMenu: onContextMenu,\n            tabIndex: disableKeyboardA11y ? undefined : -1,\n            onKeyDown: disableKeyboardA11y ? undefined : onKeyDown,\n            style: {\n                width,\n                height\n            }\n        })\n    });\n}\nconst win =  false ? 0 : undefined;\nconst selector$e = (s)=>{\n    return {\n        nodesSelectionActive: s.nodesSelectionActive,\n        userSelectionActive: s.userSelectionActive\n    };\n};\nfunction FlowRendererComponent({ children, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, paneClickDistance, deleteKeyCode, selectionKeyCode, selectionOnDrag, selectionMode, onSelectionStart, onSelectionEnd, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, elementsSelectable, zoomOnScroll, zoomOnPinch, panOnScroll: _panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag: _panOnDrag, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, onSelectionContextMenu, noWheelClassName, noPanClassName, disableKeyboardA11y, onViewportChange, isControlledViewport }) {\n    const { nodesSelectionActive, userSelectionActive } = useStore(selector$e);\n    const selectionKeyPressed = useKeyPress(selectionKeyCode, {\n        target: win\n    });\n    const panActivationKeyPressed = useKeyPress(panActivationKeyCode, {\n        target: win\n    });\n    const panOnDrag = panActivationKeyPressed || _panOnDrag;\n    const panOnScroll = panActivationKeyPressed || _panOnScroll;\n    const _selectionOnDrag = selectionOnDrag && panOnDrag !== true;\n    const isSelecting = selectionKeyPressed || userSelectionActive || _selectionOnDrag;\n    useGlobalKeyHandler({\n        deleteKeyCode,\n        multiSelectionKeyCode\n    });\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ZoomPane, {\n        onPaneContextMenu: onPaneContextMenu,\n        elementsSelectable: elementsSelectable,\n        zoomOnScroll: zoomOnScroll,\n        zoomOnPinch: zoomOnPinch,\n        panOnScroll: panOnScroll,\n        panOnScrollSpeed: panOnScrollSpeed,\n        panOnScrollMode: panOnScrollMode,\n        zoomOnDoubleClick: zoomOnDoubleClick,\n        panOnDrag: !selectionKeyPressed && panOnDrag,\n        defaultViewport: defaultViewport,\n        translateExtent: translateExtent,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        zoomActivationKeyCode: zoomActivationKeyCode,\n        preventScrolling: preventScrolling,\n        noWheelClassName: noWheelClassName,\n        noPanClassName: noPanClassName,\n        onViewportChange: onViewportChange,\n        isControlledViewport: isControlledViewport,\n        paneClickDistance: paneClickDistance,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Pane, {\n            onSelectionStart: onSelectionStart,\n            onSelectionEnd: onSelectionEnd,\n            onPaneClick: onPaneClick,\n            onPaneMouseEnter: onPaneMouseEnter,\n            onPaneMouseMove: onPaneMouseMove,\n            onPaneMouseLeave: onPaneMouseLeave,\n            onPaneContextMenu: onPaneContextMenu,\n            onPaneScroll: onPaneScroll,\n            panOnDrag: panOnDrag,\n            isSelecting: !!isSelecting,\n            selectionMode: selectionMode,\n            selectionKeyPressed: selectionKeyPressed,\n            selectionOnDrag: _selectionOnDrag,\n            children: [\n                children,\n                nodesSelectionActive && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodesSelection, {\n                    onSelectionContextMenu: onSelectionContextMenu,\n                    noPanClassName: noPanClassName,\n                    disableKeyboardA11y: disableKeyboardA11y\n                })\n            ]\n        })\n    });\n}\nFlowRendererComponent.displayName = \"FlowRenderer\";\nconst FlowRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(FlowRendererComponent);\nconst selector$d = (onlyRenderVisible)=>(s)=>{\n        return onlyRenderVisible ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesInside)(s.nodeLookup, {\n            x: 0,\n            y: 0,\n            width: s.width,\n            height: s.height\n        }, s.transform, true).map((node)=>node.id) : Array.from(s.nodeLookup.keys());\n    };\n/**\n * Hook for getting the visible node ids from the store.\n *\n * @internal\n * @param onlyRenderVisible\n * @returns array with visible node ids\n */ function useVisibleNodeIds(onlyRenderVisible) {\n    const nodeIds = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(selector$d(onlyRenderVisible), [\n        onlyRenderVisible\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return nodeIds;\n}\nconst selector$c = (s)=>s.updateNodeInternals;\nfunction useResizeObserver() {\n    const updateNodeInternals = useStore(selector$c);\n    const [resizeObserver] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>{\n        if (typeof ResizeObserver === \"undefined\") {\n            return null;\n        }\n        return new ResizeObserver((entries)=>{\n            const updates = new Map();\n            entries.forEach((entry)=>{\n                const id = entry.target.getAttribute(\"data-id\");\n                updates.set(id, {\n                    id,\n                    nodeElement: entry.target,\n                    force: true\n                });\n            });\n            updateNodeInternals(updates);\n        });\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        return ()=>{\n            resizeObserver?.disconnect();\n        };\n    }, [\n        resizeObserver\n    ]);\n    return resizeObserver;\n}\n/**\n * Hook to handle the resize observation + internal updates for the passed node.\n *\n * @internal\n * @returns nodeRef - reference to the node element\n */ function useNodeObserver({ node, nodeType, hasDimensions, resizeObserver }) {\n    const store = useStoreApi();\n    const nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const observedNode = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const prevSourcePosition = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(node.sourcePosition);\n    const prevTargetPosition = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(node.targetPosition);\n    const prevType = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(nodeType);\n    const isInitialized = hasDimensions && !!node.internals.handleBounds;\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (nodeRef.current && !node.hidden && (!isInitialized || observedNode.current !== nodeRef.current)) {\n            if (observedNode.current) {\n                resizeObserver?.unobserve(observedNode.current);\n            }\n            resizeObserver?.observe(nodeRef.current);\n            observedNode.current = nodeRef.current;\n        }\n    }, [\n        isInitialized,\n        node.hidden\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        return ()=>{\n            if (observedNode.current) {\n                resizeObserver?.unobserve(observedNode.current);\n                observedNode.current = null;\n            }\n        };\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (nodeRef.current) {\n            /*\n             * when the user programmatically changes the source or handle position, we need to update the internals\n             * to make sure the edges are updated correctly\n             */ const typeChanged = prevType.current !== nodeType;\n            const sourcePosChanged = prevSourcePosition.current !== node.sourcePosition;\n            const targetPosChanged = prevTargetPosition.current !== node.targetPosition;\n            if (typeChanged || sourcePosChanged || targetPosChanged) {\n                prevType.current = nodeType;\n                prevSourcePosition.current = node.sourcePosition;\n                prevTargetPosition.current = node.targetPosition;\n                store.getState().updateNodeInternals(new Map([\n                    [\n                        node.id,\n                        {\n                            id: node.id,\n                            nodeElement: nodeRef.current,\n                            force: true\n                        }\n                    ]\n                ]));\n            }\n        }\n    }, [\n        node.id,\n        nodeType,\n        node.sourcePosition,\n        node.targetPosition\n    ]);\n    return nodeRef;\n}\nfunction NodeWrapper({ id, onClick, onMouseEnter, onMouseMove, onMouseLeave, onContextMenu, onDoubleClick, nodesDraggable, elementsSelectable, nodesConnectable, nodesFocusable, resizeObserver, noDragClassName, noPanClassName, disableKeyboardA11y, rfId, nodeTypes, nodeClickDistance, onError }) {\n    const { node, internals, isParent } = useStore((s)=>{\n        const node = s.nodeLookup.get(id);\n        const isParent = s.parentLookup.has(id);\n        return {\n            node,\n            internals: node.internals,\n            isParent\n        };\n    }, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    let nodeType = node.type || \"default\";\n    let NodeComponent = nodeTypes?.[nodeType] || builtinNodeTypes[nodeType];\n    if (NodeComponent === undefined) {\n        onError?.(\"003\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error003\"](nodeType));\n        nodeType = \"default\";\n        NodeComponent = nodeTypes?.[\"default\"] || builtinNodeTypes.default;\n    }\n    const isDraggable = !!(node.draggable || nodesDraggable && typeof node.draggable === \"undefined\");\n    const isSelectable = !!(node.selectable || elementsSelectable && typeof node.selectable === \"undefined\");\n    const isConnectable = !!(node.connectable || nodesConnectable && typeof node.connectable === \"undefined\");\n    const isFocusable = !!(node.focusable || nodesFocusable && typeof node.focusable === \"undefined\");\n    const store = useStoreApi();\n    const hasDimensions = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeHasDimensions)(node);\n    const nodeRef = useNodeObserver({\n        node,\n        nodeType,\n        hasDimensions,\n        resizeObserver\n    });\n    const dragging = useDrag({\n        nodeRef,\n        disabled: node.hidden || !isDraggable,\n        noDragClassName,\n        handleSelector: node.dragHandle,\n        nodeId: id,\n        isSelectable,\n        nodeClickDistance\n    });\n    const moveSelectedNodes = useMoveSelectedNodes();\n    if (node.hidden) {\n        return null;\n    }\n    const nodeDimensions = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodeDimensions)(node);\n    const inlineDimensions = getNodeInlineStyleDimensions(node);\n    const hasPointerEvents = isSelectable || isDraggable || onClick || onMouseEnter || onMouseMove || onMouseLeave;\n    const onMouseEnterHandler = onMouseEnter ? (event)=>onMouseEnter(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onMouseMoveHandler = onMouseMove ? (event)=>onMouseMove(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onMouseLeaveHandler = onMouseLeave ? (event)=>onMouseLeave(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onContextMenuHandler = onContextMenu ? (event)=>onContextMenu(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onDoubleClickHandler = onDoubleClick ? (event)=>onDoubleClick(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onSelectNodeHandler = (event)=>{\n        const { selectNodesOnDrag, nodeDragThreshold } = store.getState();\n        if (isSelectable && (!selectNodesOnDrag || !isDraggable || nodeDragThreshold > 0)) {\n            /*\n             * this handler gets called by XYDrag on drag start when selectNodesOnDrag=true\n             * here we only need to call it when selectNodesOnDrag=false\n             */ handleNodeClick({\n                id,\n                store,\n                nodeRef\n            });\n        }\n        if (onClick) {\n            onClick(event, {\n                ...internals.userNode\n            });\n        }\n    };\n    const onKeyDown = (event)=>{\n        if ((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isInputDOMNode)(event.nativeEvent) || disableKeyboardA11y) {\n            return;\n        }\n        if (_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.elementSelectionKeys.includes(event.key) && isSelectable) {\n            const unselect = event.key === \"Escape\";\n            handleNodeClick({\n                id,\n                store,\n                unselect,\n                nodeRef\n            });\n        } else if (isDraggable && node.selected && Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {\n            // prevent default scrolling behavior on arrow key press when node is moved\n            event.preventDefault();\n            const { ariaLabelConfig } = store.getState();\n            store.setState({\n                ariaLiveMessage: ariaLabelConfig[\"node.a11yDescription.ariaLiveMessage\"]({\n                    direction: event.key.replace(\"Arrow\", \"\").toLowerCase(),\n                    x: ~~internals.positionAbsolute.x,\n                    y: ~~internals.positionAbsolute.y\n                })\n            });\n            moveSelectedNodes({\n                direction: arrowKeyDiffs[event.key],\n                factor: event.shiftKey ? 4 : 1\n            });\n        }\n    };\n    const onFocus = ()=>{\n        if (disableKeyboardA11y || !nodeRef.current?.matches(\":focus-visible\")) {\n            return;\n        }\n        const { transform, width, height, autoPanOnNodeFocus, setCenter } = store.getState();\n        if (!autoPanOnNodeFocus) {\n            return;\n        }\n        const withinViewport = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesInside)(new Map([\n            [\n                id,\n                node\n            ]\n        ]), {\n            x: 0,\n            y: 0,\n            width,\n            height\n        }, transform, true).length > 0;\n        if (!withinViewport) {\n            setCenter(node.position.x + nodeDimensions.width / 2, node.position.y + nodeDimensions.height / 2, {\n                zoom: transform[2]\n            });\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__node\",\n            `react-flow__node-${nodeType}`,\n            {\n                // this is overwritable by passing `nopan` as a class name\n                [noPanClassName]: isDraggable\n            },\n            node.className,\n            {\n                selected: node.selected,\n                selectable: isSelectable,\n                parent: isParent,\n                draggable: isDraggable,\n                dragging\n            }\n        ]),\n        ref: nodeRef,\n        style: {\n            zIndex: internals.z,\n            transform: `translate(${internals.positionAbsolute.x}px,${internals.positionAbsolute.y}px)`,\n            pointerEvents: hasPointerEvents ? \"all\" : \"none\",\n            visibility: hasDimensions ? \"visible\" : \"hidden\",\n            ...node.style,\n            ...inlineDimensions\n        },\n        \"data-id\": id,\n        \"data-testid\": `rf__node-${id}`,\n        onMouseEnter: onMouseEnterHandler,\n        onMouseMove: onMouseMoveHandler,\n        onMouseLeave: onMouseLeaveHandler,\n        onContextMenu: onContextMenuHandler,\n        onClick: onSelectNodeHandler,\n        onDoubleClick: onDoubleClickHandler,\n        onKeyDown: isFocusable ? onKeyDown : undefined,\n        tabIndex: isFocusable ? 0 : undefined,\n        onFocus: isFocusable ? onFocus : undefined,\n        role: node.ariaRole ?? (isFocusable ? \"group\" : undefined),\n        \"aria-roledescription\": \"node\",\n        \"aria-describedby\": disableKeyboardA11y ? undefined : `${ARIA_NODE_DESC_KEY}-${rfId}`,\n        \"aria-label\": node.ariaLabel,\n        ...node.domAttributes,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Provider, {\n            value: id,\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponent, {\n                id: id,\n                data: node.data,\n                type: nodeType,\n                positionAbsoluteX: internals.positionAbsolute.x,\n                positionAbsoluteY: internals.positionAbsolute.y,\n                selected: node.selected ?? false,\n                selectable: isSelectable,\n                draggable: isDraggable,\n                deletable: node.deletable ?? true,\n                isConnectable: isConnectable,\n                sourcePosition: node.sourcePosition,\n                targetPosition: node.targetPosition,\n                dragging: dragging,\n                dragHandle: node.dragHandle,\n                zIndex: internals.z,\n                parentId: node.parentId,\n                ...nodeDimensions\n            })\n        })\n    });\n}\nvar NodeWrapper$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(NodeWrapper);\nconst selector$b = (s)=>({\n        nodesDraggable: s.nodesDraggable,\n        nodesConnectable: s.nodesConnectable,\n        nodesFocusable: s.nodesFocusable,\n        elementsSelectable: s.elementsSelectable,\n        onError: s.onError\n    });\nfunction NodeRendererComponent(props) {\n    const { nodesDraggable, nodesConnectable, nodesFocusable, elementsSelectable, onError } = useStore(selector$b, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const nodeIds = useVisibleNodeIds(props.onlyRenderVisibleElements);\n    const resizeObserver = useResizeObserver();\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__nodes\",\n        style: containerStyle,\n        children: nodeIds.map((nodeId)=>{\n            return(/*\n             * The split of responsibilities between NodeRenderer and\n             * NodeComponentWrapper may appear weird. However, it’s designed to\n             * minimize the cost of updates when individual nodes change.\n             *\n             * For example, when you’re dragging a single node, that node gets\n             * updated multiple times per second. If `NodeRenderer` were to update\n             * every time, it would have to re-run the `nodes.map()` loop every\n             * time. This gets pricey with hundreds of nodes, especially if every\n             * loop cycle does more than just rendering a JSX element!\n             *\n             * As a result of this choice, we took the following implementation\n             * decisions:\n             * - NodeRenderer subscribes *only* to node IDs – and therefore\n             *   rerender *only* when visible nodes are added or removed.\n             * - NodeRenderer performs all operations the result of which can be\n             *   shared between nodes (such as creating the `ResizeObserver`\n             *   instance, or subscribing to `selector`). This means extra prop\n             *   drilling into `NodeComponentWrapper`, but it means we need to run\n             *   these operations only once – instead of once per node.\n             * - Any operations that you’d normally write inside `nodes.map` are\n             *   moved into `NodeComponentWrapper`. This ensures they are\n             *   memorized – so if `NodeRenderer` *has* to rerender, it only\n             *   needs to regenerate the list of nodes, nothing else.\n             */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeWrapper$1, {\n                id: nodeId,\n                nodeTypes: props.nodeTypes,\n                nodeExtent: props.nodeExtent,\n                onClick: props.onNodeClick,\n                onMouseEnter: props.onNodeMouseEnter,\n                onMouseMove: props.onNodeMouseMove,\n                onMouseLeave: props.onNodeMouseLeave,\n                onContextMenu: props.onNodeContextMenu,\n                onDoubleClick: props.onNodeDoubleClick,\n                noDragClassName: props.noDragClassName,\n                noPanClassName: props.noPanClassName,\n                rfId: props.rfId,\n                disableKeyboardA11y: props.disableKeyboardA11y,\n                resizeObserver: resizeObserver,\n                nodesDraggable: nodesDraggable,\n                nodesConnectable: nodesConnectable,\n                nodesFocusable: nodesFocusable,\n                elementsSelectable: elementsSelectable,\n                nodeClickDistance: props.nodeClickDistance,\n                onError: onError\n            }, nodeId));\n        })\n    });\n}\nNodeRendererComponent.displayName = \"NodeRenderer\";\nconst NodeRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(NodeRendererComponent);\n/**\n * Hook for getting the visible edge ids from the store.\n *\n * @internal\n * @param onlyRenderVisible\n * @returns array with visible edge ids\n */ function useVisibleEdgeIds(onlyRenderVisible) {\n    const edgeIds = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((s)=>{\n        if (!onlyRenderVisible) {\n            return s.edges.map((edge)=>edge.id);\n        }\n        const visibleEdgeIds = [];\n        if (s.width && s.height) {\n            for (const edge of s.edges){\n                const sourceNode = s.nodeLookup.get(edge.source);\n                const targetNode = s.nodeLookup.get(edge.target);\n                if (sourceNode && targetNode && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isEdgeVisible)({\n                    sourceNode,\n                    targetNode,\n                    width: s.width,\n                    height: s.height,\n                    transform: s.transform\n                })) {\n                    visibleEdgeIds.push(edge.id);\n                }\n            }\n        }\n        return visibleEdgeIds;\n    }, [\n        onlyRenderVisible\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return edgeIds;\n}\nconst ArrowSymbol = ({ color = \"none\", strokeWidth = 1 })=>{\n    const style = {\n        strokeWidth,\n        ...color && {\n            stroke: color\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"polyline\", {\n        className: \"arrow\",\n        style: style,\n        strokeLinecap: \"round\",\n        fill: \"none\",\n        strokeLinejoin: \"round\",\n        points: \"-5,-4 0,0 -5,4\"\n    });\n};\nconst ArrowClosedSymbol = ({ color = \"none\", strokeWidth = 1 })=>{\n    const style = {\n        strokeWidth,\n        ...color && {\n            stroke: color,\n            fill: color\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"polyline\", {\n        className: \"arrowclosed\",\n        style: style,\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        points: \"-5,-4 0,0 -5,4 -5,-4\"\n    });\n};\nconst MarkerSymbols = {\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.MarkerType.Arrow]: ArrowSymbol,\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.MarkerType.ArrowClosed]: ArrowClosedSymbol\n};\nfunction useMarkerSymbol(type) {\n    const store = useStoreApi();\n    const symbol = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const symbolExists = Object.prototype.hasOwnProperty.call(MarkerSymbols, type);\n        if (!symbolExists) {\n            store.getState().onError?.(\"009\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error009\"](type));\n            return null;\n        }\n        return MarkerSymbols[type];\n    }, [\n        type\n    ]);\n    return symbol;\n}\nconst Marker = ({ id, type, color, width = 12.5, height = 12.5, markerUnits = \"strokeWidth\", strokeWidth, orient = \"auto-start-reverse\" })=>{\n    const Symbol = useMarkerSymbol(type);\n    if (!Symbol) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"marker\", {\n        className: \"react-flow__arrowhead\",\n        id: id,\n        markerWidth: `${width}`,\n        markerHeight: `${height}`,\n        viewBox: \"-10 -10 20 20\",\n        markerUnits: markerUnits,\n        orient: orient,\n        refX: \"0\",\n        refY: \"0\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Symbol, {\n            color: color,\n            strokeWidth: strokeWidth\n        })\n    });\n};\n/*\n * when you have multiple flows on a page and you hide the first one, the other ones have no markers anymore\n * when they do have markers with the same ids. To prevent this the user can pass a unique id to the react flow wrapper\n * that we can then use for creating our unique marker ids\n */ const MarkerDefinitions = ({ defaultColor, rfId })=>{\n    const edges = useStore((s)=>s.edges);\n    const defaultEdgeOptions = useStore((s)=>s.defaultEdgeOptions);\n    const markers = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const markers = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.createMarkerIds)(edges, {\n            id: rfId,\n            defaultColor,\n            defaultMarkerStart: defaultEdgeOptions?.markerStart,\n            defaultMarkerEnd: defaultEdgeOptions?.markerEnd\n        });\n        return markers;\n    }, [\n        edges,\n        defaultEdgeOptions,\n        rfId,\n        defaultColor\n    ]);\n    if (!markers.length) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        className: \"react-flow__marker\",\n        \"aria-hidden\": \"true\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"defs\", {\n            children: markers.map((marker)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Marker, {\n                    id: marker.id,\n                    type: marker.type,\n                    color: marker.color,\n                    width: marker.width,\n                    height: marker.height,\n                    markerUnits: marker.markerUnits,\n                    strokeWidth: marker.strokeWidth,\n                    orient: marker.orient\n                }, marker.id))\n        })\n    });\n};\nMarkerDefinitions.displayName = \"MarkerDefinitions\";\nvar MarkerDefinitions$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MarkerDefinitions);\nfunction EdgeTextComponent({ x, y, label, labelStyle, labelShowBg = true, labelBgStyle, labelBgPadding = [\n    2,\n    4\n], labelBgBorderRadius = 2, children, className, ...rest }) {\n    const [edgeTextBbox, setEdgeTextBbox] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        x: 1,\n        y: 0,\n        width: 0,\n        height: 0\n    });\n    const edgeTextClasses = (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n        \"react-flow__edge-textwrapper\",\n        className\n    ]);\n    const edgeTextRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (edgeTextRef.current) {\n            const textBbox = edgeTextRef.current.getBBox();\n            setEdgeTextBbox({\n                x: textBbox.x,\n                y: textBbox.y,\n                width: textBbox.width,\n                height: textBbox.height\n            });\n        }\n    }, [\n        label\n    ]);\n    if (!label) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", {\n        transform: `translate(${x - edgeTextBbox.width / 2} ${y - edgeTextBbox.height / 2})`,\n        className: edgeTextClasses,\n        visibility: edgeTextBbox.width ? \"visible\" : \"hidden\",\n        ...rest,\n        children: [\n            labelShowBg && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n                width: edgeTextBbox.width + 2 * labelBgPadding[0],\n                x: -labelBgPadding[0],\n                y: -labelBgPadding[1],\n                height: edgeTextBbox.height + 2 * labelBgPadding[1],\n                className: \"react-flow__edge-textbg\",\n                style: labelBgStyle,\n                rx: labelBgBorderRadius,\n                ry: labelBgBorderRadius\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"text\", {\n                className: \"react-flow__edge-text\",\n                y: edgeTextBbox.height / 2,\n                dy: \"0.3em\",\n                ref: edgeTextRef,\n                style: labelStyle,\n                children: label\n            }),\n            children\n        ]\n    });\n}\nEdgeTextComponent.displayName = \"EdgeText\";\n/**\n * You can use the `<EdgeText />` component as a helper component to display text\n * within your custom edges.\n *\n * @public\n *\n * @example\n * ```jsx\n * import { EdgeText } from '@xyflow/react';\n *\n * export function CustomEdgeLabel({ label }) {\n *   return (\n *     <EdgeText\n *       x={100}\n *       y={100}\n *       label={label}\n *       labelStyle={{ fill: 'white' }}\n *       labelShowBg\n *       labelBgStyle={{ fill: 'red' }}\n *       labelBgPadding={[2, 4]}\n *       labelBgBorderRadius={2}\n *     />\n *   );\n * }\n *```\n */ const EdgeText = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(EdgeTextComponent);\n/**\n * The `<BaseEdge />` component gets used internally for all the edges. It can be\n * used inside a custom edge and handles the invisible helper edge and the edge label\n * for you.\n *\n * @public\n * @example\n * ```jsx\n *import { BaseEdge } from '@xyflow/react';\n *\n *export function CustomEdge({ sourceX, sourceY, targetX, targetY, ...props }) {\n *  const [edgePath] = getStraightPath({\n *    sourceX,\n *    sourceY,\n *    targetX,\n *    targetY,\n *  });\n *\n *  return <BaseEdge path={edgePath} {...props} />;\n *}\n *```\n *\n * @remarks If you want to use an edge marker with the [`<BaseEdge />`](/api-reference/components/base-edge) component,\n * you can pass the `markerStart` or `markerEnd` props passed to your custom edge\n * through to the [`<BaseEdge />`](/api-reference/components/base-edge) component.\n * You can see all the props passed to a custom edge by looking at the [`EdgeProps`](/api-reference/types/edge-props) type.\n */ function BaseEdge({ path, labelX, labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, interactionWidth = 20, ...props }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                ...props,\n                d: path,\n                fill: \"none\",\n                className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                    \"react-flow__edge-path\",\n                    props.className\n                ])\n            }),\n            interactionWidth ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: path,\n                fill: \"none\",\n                strokeOpacity: 0,\n                strokeWidth: interactionWidth,\n                className: \"react-flow__edge-interaction\"\n            }) : null,\n            label && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(labelX) && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(labelY) ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeText, {\n                x: labelX,\n                y: labelY,\n                label: label,\n                labelStyle: labelStyle,\n                labelShowBg: labelShowBg,\n                labelBgStyle: labelBgStyle,\n                labelBgPadding: labelBgPadding,\n                labelBgBorderRadius: labelBgBorderRadius\n            }) : null\n        ]\n    });\n}\nfunction getControl({ pos, x1, y1, x2, y2 }) {\n    if (pos === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Left || pos === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Right) {\n        return [\n            0.5 * (x1 + x2),\n            y1\n        ];\n    }\n    return [\n        x1,\n        0.5 * (y1 + y2)\n    ];\n}\n/**\n * The `getSimpleBezierPath` util returns everything you need to render a simple\n * bezier edge between two nodes.\n * @public\n * @returns\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n */ function getSimpleBezierPath({ sourceX, sourceY, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom, targetX, targetY, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top }) {\n    const [sourceControlX, sourceControlY] = getControl({\n        pos: sourcePosition,\n        x1: sourceX,\n        y1: sourceY,\n        x2: targetX,\n        y2: targetY\n    });\n    const [targetControlX, targetControlY] = getControl({\n        pos: targetPosition,\n        x1: targetX,\n        y1: targetY,\n        x2: sourceX,\n        y2: sourceY\n    });\n    const [labelX, labelY, offsetX, offsetY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierEdgeCenter)({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n        sourceControlX,\n        sourceControlY,\n        targetControlX,\n        targetControlY\n    });\n    return [\n        `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY\n    ];\n}\nfunction createSimpleBezierEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth })=>{\n        const [path, labelX, labelY] = getSimpleBezierPath({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\nconst SimpleBezierEdge = createSimpleBezierEdge({\n    isInternal: false\n});\nconst SimpleBezierEdgeInternal = createSimpleBezierEdge({\n    isInternal: true\n});\nSimpleBezierEdge.displayName = \"SimpleBezierEdge\";\nSimpleBezierEdgeInternal.displayName = \"SimpleBezierEdgeInternal\";\nfunction createSmoothStepEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, markerEnd, markerStart, pathOptions, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath)({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition,\n            borderRadius: pathOptions?.borderRadius,\n            offset: pathOptions?.offset,\n            stepPosition: pathOptions?.stepPosition\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a smooth step edge.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { SmoothStepEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition }) {\n *   return (\n *     <SmoothStepEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *       sourcePosition={sourcePosition}\n *       targetPosition={targetPosition}\n *     />\n *   );\n * }\n * ```\n */ const SmoothStepEdge = createSmoothStepEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const SmoothStepEdgeInternal = createSmoothStepEdge({\n    isInternal: true\n});\nSmoothStepEdge.displayName = \"SmoothStepEdge\";\nSmoothStepEdgeInternal.displayName = \"SmoothStepEdgeInternal\";\nfunction createStepEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, ...props })=>{\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SmoothStepEdge, {\n            ...props,\n            id: _id,\n            pathOptions: (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>({\n                    borderRadius: 0,\n                    offset: props.pathOptions?.offset\n                }), [\n                props.pathOptions?.offset\n            ])\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a step edge.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { StepEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition }) {\n *   return (\n *     <StepEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *       sourcePosition={sourcePosition}\n *       targetPosition={targetPosition}\n *     />\n *   );\n * }\n * ```\n */ const StepEdge = createStepEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const StepEdgeInternal = createStepEdge({\n    isInternal: true\n});\nStepEdge.displayName = \"StepEdge\";\nStepEdgeInternal.displayName = \"StepEdgeInternal\";\nfunction createStraightEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getStraightPath)({\n            sourceX,\n            sourceY,\n            targetX,\n            targetY\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a straight line.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { StraightEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY }) {\n *   return (\n *     <StraightEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *     />\n *   );\n * }\n * ```\n */ const StraightEdge = createStraightEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const StraightEdgeInternal = createStraightEdge({\n    isInternal: true\n});\nStraightEdge.displayName = \"StraightEdge\";\nStraightEdgeInternal.displayName = \"StraightEdgeInternal\";\nfunction createBezierEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, pathOptions, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierPath)({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition,\n            curvature: pathOptions?.curvature\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a bezier curve.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { BezierEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition }) {\n *   return (\n *     <BezierEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *       sourcePosition={sourcePosition}\n *       targetPosition={targetPosition}\n *     />\n *   );\n * }\n * ```\n */ const BezierEdge = createBezierEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const BezierEdgeInternal = createBezierEdge({\n    isInternal: true\n});\nBezierEdge.displayName = \"BezierEdge\";\nBezierEdgeInternal.displayName = \"BezierEdgeInternal\";\nconst builtinEdgeTypes = {\n    default: BezierEdgeInternal,\n    straight: StraightEdgeInternal,\n    step: StepEdgeInternal,\n    smoothstep: SmoothStepEdgeInternal,\n    simplebezier: SimpleBezierEdgeInternal\n};\nconst nullPosition = {\n    sourceX: null,\n    sourceY: null,\n    targetX: null,\n    targetY: null,\n    sourcePosition: null,\n    targetPosition: null\n};\nconst shiftX = (x, shift, position)=>{\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Left) return x - shift;\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Right) return x + shift;\n    return x;\n};\nconst shiftY = (y, shift, position)=>{\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top) return y - shift;\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom) return y + shift;\n    return y;\n};\nconst EdgeUpdaterClassName = \"react-flow__edgeupdater\";\n/**\n * @internal\n */ function EdgeAnchor({ position, centerX, centerY, radius = 10, onMouseDown, onMouseEnter, onMouseOut, type }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n        onMouseDown: onMouseDown,\n        onMouseEnter: onMouseEnter,\n        onMouseOut: onMouseOut,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            EdgeUpdaterClassName,\n            `${EdgeUpdaterClassName}-${type}`\n        ]),\n        cx: shiftX(centerX, radius, position),\n        cy: shiftY(centerY, radius, position),\n        r: radius,\n        stroke: \"transparent\",\n        fill: \"transparent\"\n    });\n}\nfunction EdgeUpdateAnchors({ isReconnectable, reconnectRadius, edge, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, onReconnect, onReconnectStart, onReconnectEnd, setReconnecting, setUpdateHover }) {\n    const store = useStoreApi();\n    const handleEdgeUpdater = (event, oppositeHandle)=>{\n        // avoid triggering edge updater if mouse btn is not left\n        if (event.button !== 0) {\n            return;\n        }\n        const { autoPanOnConnect, domNode, isValidConnection, connectionMode, connectionRadius, lib, onConnectStart, onConnectEnd, cancelConnection, nodeLookup, rfId: flowId, panBy, updateConnection } = store.getState();\n        const isTarget = oppositeHandle.type === \"target\";\n        const _onReconnectEnd = (evt, connectionState)=>{\n            setReconnecting(false);\n            onReconnectEnd?.(evt, edge, oppositeHandle.type, connectionState);\n        };\n        const onConnectEdge = (connection)=>onReconnect?.(edge, connection);\n        const _onConnectStart = (_event, params)=>{\n            setReconnecting(true);\n            onReconnectStart?.(event, edge, oppositeHandle.type);\n            onConnectStart?.(_event, params);\n        };\n        _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYHandle.onPointerDown(event.nativeEvent, {\n            autoPanOnConnect,\n            connectionMode,\n            connectionRadius,\n            domNode,\n            handleId: oppositeHandle.id,\n            nodeId: oppositeHandle.nodeId,\n            nodeLookup,\n            isTarget,\n            edgeUpdaterType: oppositeHandle.type,\n            lib,\n            flowId,\n            cancelConnection,\n            panBy,\n            isValidConnection,\n            onConnect: onConnectEdge,\n            onConnectStart: _onConnectStart,\n            onConnectEnd,\n            onReconnectEnd: _onReconnectEnd,\n            updateConnection,\n            getTransform: ()=>store.getState().transform,\n            getFromHandle: ()=>store.getState().connection.fromHandle,\n            dragThreshold: store.getState().connectionDragThreshold,\n            handleDomNode: event.currentTarget\n        });\n    };\n    const onReconnectSourceMouseDown = (event)=>handleEdgeUpdater(event, {\n            nodeId: edge.target,\n            id: edge.targetHandle ?? null,\n            type: \"target\"\n        });\n    const onReconnectTargetMouseDown = (event)=>handleEdgeUpdater(event, {\n            nodeId: edge.source,\n            id: edge.sourceHandle ?? null,\n            type: \"source\"\n        });\n    const onReconnectMouseEnter = ()=>setUpdateHover(true);\n    const onReconnectMouseOut = ()=>setUpdateHover(false);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (isReconnectable === true || isReconnectable === \"source\") && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeAnchor, {\n                position: sourcePosition,\n                centerX: sourceX,\n                centerY: sourceY,\n                radius: reconnectRadius,\n                onMouseDown: onReconnectSourceMouseDown,\n                onMouseEnter: onReconnectMouseEnter,\n                onMouseOut: onReconnectMouseOut,\n                type: \"source\"\n            }),\n            (isReconnectable === true || isReconnectable === \"target\") && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeAnchor, {\n                position: targetPosition,\n                centerX: targetX,\n                centerY: targetY,\n                radius: reconnectRadius,\n                onMouseDown: onReconnectTargetMouseDown,\n                onMouseEnter: onReconnectMouseEnter,\n                onMouseOut: onReconnectMouseOut,\n                type: \"target\"\n            })\n        ]\n    });\n}\nfunction EdgeWrapper({ id, edgesFocusable, edgesReconnectable, elementsSelectable, onClick, onDoubleClick, onContextMenu, onMouseEnter, onMouseMove, onMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, rfId, edgeTypes, noPanClassName, onError, disableKeyboardA11y }) {\n    let edge = useStore((s)=>s.edgeLookup.get(id));\n    const defaultEdgeOptions = useStore((s)=>s.defaultEdgeOptions);\n    edge = defaultEdgeOptions ? {\n        ...defaultEdgeOptions,\n        ...edge\n    } : edge;\n    let edgeType = edge.type || \"default\";\n    let EdgeComponent = edgeTypes?.[edgeType] || builtinEdgeTypes[edgeType];\n    if (EdgeComponent === undefined) {\n        onError?.(\"011\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error011\"](edgeType));\n        edgeType = \"default\";\n        EdgeComponent = edgeTypes?.[\"default\"] || builtinEdgeTypes.default;\n    }\n    const isFocusable = !!(edge.focusable || edgesFocusable && typeof edge.focusable === \"undefined\");\n    const isReconnectable = typeof onReconnect !== \"undefined\" && (edge.reconnectable || edgesReconnectable && typeof edge.reconnectable === \"undefined\");\n    const isSelectable = !!(edge.selectable || elementsSelectable && typeof edge.selectable === \"undefined\");\n    const edgeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [updateHover, setUpdateHover] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [reconnecting, setReconnecting] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const store = useStoreApi();\n    const { zIndex, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition } = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((store)=>{\n        const sourceNode = store.nodeLookup.get(edge.source);\n        const targetNode = store.nodeLookup.get(edge.target);\n        if (!sourceNode || !targetNode) {\n            return {\n                zIndex: edge.zIndex,\n                ...nullPosition\n            };\n        }\n        const edgePosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEdgePosition)({\n            id,\n            sourceNode,\n            targetNode,\n            sourceHandle: edge.sourceHandle || null,\n            targetHandle: edge.targetHandle || null,\n            connectionMode: store.connectionMode,\n            onError\n        });\n        const zIndex = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getElevatedEdgeZIndex)({\n            selected: edge.selected,\n            zIndex: edge.zIndex,\n            sourceNode,\n            targetNode,\n            elevateOnSelect: store.elevateEdgesOnSelect\n        });\n        return {\n            zIndex,\n            ...edgePosition || nullPosition\n        };\n    }, [\n        edge.source,\n        edge.target,\n        edge.sourceHandle,\n        edge.targetHandle,\n        edge.selected,\n        edge.zIndex\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const markerStartUrl = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>edge.markerStart ? `url('#${(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getMarkerId)(edge.markerStart, rfId)}')` : undefined, [\n        edge.markerStart,\n        rfId\n    ]);\n    const markerEndUrl = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>edge.markerEnd ? `url('#${(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getMarkerId)(edge.markerEnd, rfId)}')` : undefined, [\n        edge.markerEnd,\n        rfId\n    ]);\n    if (edge.hidden || sourceX === null || sourceY === null || targetX === null || targetY === null) {\n        return null;\n    }\n    const onEdgeClick = (event)=>{\n        const { addSelectedEdges, unselectNodesAndEdges, multiSelectionActive } = store.getState();\n        if (isSelectable) {\n            store.setState({\n                nodesSelectionActive: false\n            });\n            if (edge.selected && multiSelectionActive) {\n                unselectNodesAndEdges({\n                    nodes: [],\n                    edges: [\n                        edge\n                    ]\n                });\n                edgeRef.current?.blur();\n            } else {\n                addSelectedEdges([\n                    id\n                ]);\n            }\n        }\n        if (onClick) {\n            onClick(event, edge);\n        }\n    };\n    const onEdgeDoubleClick = onDoubleClick ? (event)=>{\n        onDoubleClick(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeContextMenu = onContextMenu ? (event)=>{\n        onContextMenu(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseEnter = onMouseEnter ? (event)=>{\n        onMouseEnter(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseMove = onMouseMove ? (event)=>{\n        onMouseMove(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseLeave = onMouseLeave ? (event)=>{\n        onMouseLeave(event, {\n            ...edge\n        });\n    } : undefined;\n    const onKeyDown = (event)=>{\n        if (!disableKeyboardA11y && _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.elementSelectionKeys.includes(event.key) && isSelectable) {\n            const { unselectNodesAndEdges, addSelectedEdges } = store.getState();\n            const unselect = event.key === \"Escape\";\n            if (unselect) {\n                edgeRef.current?.blur();\n                unselectNodesAndEdges({\n                    edges: [\n                        edge\n                    ]\n                });\n            } else {\n                addSelectedEdges([\n                    id\n                ]);\n            }\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        style: {\n            zIndex\n        },\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", {\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                \"react-flow__edge\",\n                `react-flow__edge-${edgeType}`,\n                edge.className,\n                noPanClassName,\n                {\n                    selected: edge.selected,\n                    animated: edge.animated,\n                    inactive: !isSelectable && !onClick,\n                    updating: updateHover,\n                    selectable: isSelectable\n                }\n            ]),\n            onClick: onEdgeClick,\n            onDoubleClick: onEdgeDoubleClick,\n            onContextMenu: onEdgeContextMenu,\n            onMouseEnter: onEdgeMouseEnter,\n            onMouseMove: onEdgeMouseMove,\n            onMouseLeave: onEdgeMouseLeave,\n            onKeyDown: isFocusable ? onKeyDown : undefined,\n            tabIndex: isFocusable ? 0 : undefined,\n            role: edge.ariaRole ?? (isFocusable ? \"group\" : \"img\"),\n            \"aria-roledescription\": \"edge\",\n            \"data-id\": id,\n            \"data-testid\": `rf__edge-${id}`,\n            \"aria-label\": edge.ariaLabel === null ? undefined : edge.ariaLabel || `Edge from ${edge.source} to ${edge.target}`,\n            \"aria-describedby\": isFocusable ? `${ARIA_EDGE_DESC_KEY}-${rfId}` : undefined,\n            ref: edgeRef,\n            ...edge.domAttributes,\n            children: [\n                !reconnecting && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeComponent, {\n                    id: id,\n                    source: edge.source,\n                    target: edge.target,\n                    type: edge.type,\n                    selected: edge.selected,\n                    animated: edge.animated,\n                    selectable: isSelectable,\n                    deletable: edge.deletable ?? true,\n                    label: edge.label,\n                    labelStyle: edge.labelStyle,\n                    labelShowBg: edge.labelShowBg,\n                    labelBgStyle: edge.labelBgStyle,\n                    labelBgPadding: edge.labelBgPadding,\n                    labelBgBorderRadius: edge.labelBgBorderRadius,\n                    sourceX: sourceX,\n                    sourceY: sourceY,\n                    targetX: targetX,\n                    targetY: targetY,\n                    sourcePosition: sourcePosition,\n                    targetPosition: targetPosition,\n                    data: edge.data,\n                    style: edge.style,\n                    sourceHandleId: edge.sourceHandle,\n                    targetHandleId: edge.targetHandle,\n                    markerStart: markerStartUrl,\n                    markerEnd: markerEndUrl,\n                    pathOptions: \"pathOptions\" in edge ? edge.pathOptions : undefined,\n                    interactionWidth: edge.interactionWidth\n                }),\n                isReconnectable && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeUpdateAnchors, {\n                    edge: edge,\n                    isReconnectable: isReconnectable,\n                    reconnectRadius: reconnectRadius,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    sourceX: sourceX,\n                    sourceY: sourceY,\n                    targetX: targetX,\n                    targetY: targetY,\n                    sourcePosition: sourcePosition,\n                    targetPosition: targetPosition,\n                    setUpdateHover: setUpdateHover,\n                    setReconnecting: setReconnecting\n                })\n            ]\n        })\n    });\n}\nvar EdgeWrapper$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(EdgeWrapper);\nconst selector$a = (s)=>({\n        edgesFocusable: s.edgesFocusable,\n        edgesReconnectable: s.edgesReconnectable,\n        elementsSelectable: s.elementsSelectable,\n        connectionMode: s.connectionMode,\n        onError: s.onError\n    });\nfunction EdgeRendererComponent({ defaultMarkerColor, onlyRenderVisibleElements, rfId, edgeTypes, noPanClassName, onReconnect, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onEdgeClick, reconnectRadius, onEdgeDoubleClick, onReconnectStart, onReconnectEnd, disableKeyboardA11y }) {\n    const { edgesFocusable, edgesReconnectable, elementsSelectable, onError } = useStore(selector$a, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const edgeIds = useVisibleEdgeIds(onlyRenderVisibleElements);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n        className: \"react-flow__edges\",\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MarkerDefinitions$1, {\n                defaultColor: defaultMarkerColor,\n                rfId: rfId\n            }),\n            edgeIds.map((id)=>{\n                return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeWrapper$1, {\n                    id: id,\n                    edgesFocusable: edgesFocusable,\n                    edgesReconnectable: edgesReconnectable,\n                    elementsSelectable: elementsSelectable,\n                    noPanClassName: noPanClassName,\n                    onReconnect: onReconnect,\n                    onContextMenu: onEdgeContextMenu,\n                    onMouseEnter: onEdgeMouseEnter,\n                    onMouseMove: onEdgeMouseMove,\n                    onMouseLeave: onEdgeMouseLeave,\n                    onClick: onEdgeClick,\n                    reconnectRadius: reconnectRadius,\n                    onDoubleClick: onEdgeDoubleClick,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    rfId: rfId,\n                    onError: onError,\n                    edgeTypes: edgeTypes,\n                    disableKeyboardA11y: disableKeyboardA11y\n                }, id);\n            })\n        ]\n    });\n}\nEdgeRendererComponent.displayName = \"EdgeRenderer\";\nconst EdgeRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(EdgeRendererComponent);\nconst selector$9 = (s)=>`translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]})`;\nfunction Viewport({ children }) {\n    const transform = useStore(selector$9);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__viewport xyflow__viewport react-flow__container\",\n        style: {\n            transform\n        },\n        children: children\n    });\n}\n/**\n * Hook for calling onInit handler.\n *\n * @internal\n */ function useOnInitHandler(onInit) {\n    const rfInstance = useReactFlow();\n    const isInitialized = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!isInitialized.current && rfInstance.viewportInitialized && onInit) {\n            setTimeout(()=>onInit(rfInstance), 1);\n            isInitialized.current = true;\n        }\n    }, [\n        onInit,\n        rfInstance.viewportInitialized\n    ]);\n}\nconst selector$8 = (state)=>state.panZoom?.syncViewport;\n/**\n * Hook for syncing the viewport with the panzoom instance.\n *\n * @internal\n * @param viewport\n */ function useViewportSync(viewport) {\n    const syncViewport = useStore(selector$8);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (viewport) {\n            syncViewport?.(viewport);\n            store.setState({\n                transform: [\n                    viewport.x,\n                    viewport.y,\n                    viewport.zoom\n                ]\n            });\n        }\n    }, [\n        viewport,\n        syncViewport\n    ]);\n    return null;\n}\nfunction storeSelector$1(s) {\n    return s.connection.inProgress ? {\n        ...s.connection,\n        to: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.pointToRendererPoint)(s.connection.to, s.transform)\n    } : {\n        ...s.connection\n    };\n}\nfunction getSelector(connectionSelector) {\n    if (connectionSelector) {\n        const combinedSelector = (s)=>{\n            const connection = storeSelector$1(s);\n            return connectionSelector(connection);\n        };\n        return combinedSelector;\n    }\n    return storeSelector$1;\n}\n/**\n * The `useConnection` hook returns the current connection when there is an active\n * connection interaction. If no connection interaction is active, it returns null\n * for every property. A typical use case for this hook is to colorize handles\n * based on a certain condition (e.g. if the connection is valid or not).\n *\n * @public\n * @param connectionSelector - An optional selector function used to extract a slice of the\n * `ConnectionState` data. Using a selector can prevent component re-renders where data you don't\n * otherwise care about might change. If a selector is not provided, the entire `ConnectionState`\n * object is returned unchanged.\n * @example\n *\n * ```tsx\n *import { useConnection } from '@xyflow/react';\n *\n *function App() {\n *  const connection = useConnection();\n *\n *  return (\n *    <div> {connection ? `Someone is trying to make a connection from ${connection.fromNode} to this one.` : 'There are currently no incoming connections!'}\n *\n *   </div>\n *   );\n * }\n * ```\n *\n * @returns ConnectionState\n */ function useConnection(connectionSelector) {\n    const combinedSelector = getSelector(connectionSelector);\n    return useStore(combinedSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n}\nconst selector$7 = (s)=>({\n        nodesConnectable: s.nodesConnectable,\n        isValid: s.connection.isValid,\n        inProgress: s.connection.inProgress,\n        width: s.width,\n        height: s.height\n    });\nfunction ConnectionLineWrapper({ containerStyle, style, type, component }) {\n    const { nodesConnectable, width, height, isValid, inProgress } = useStore(selector$7, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const renderConnection = !!(width && nodesConnectable && inProgress);\n    if (!renderConnection) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        style: containerStyle,\n        width: width,\n        height: height,\n        className: \"react-flow__connectionline react-flow__container\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"g\", {\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                \"react-flow__connection\",\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getConnectionStatus)(isValid)\n            ]),\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionLine, {\n                style: style,\n                type: type,\n                CustomComponent: component,\n                isValid: isValid\n            })\n        })\n    });\n}\nconst ConnectionLine = ({ style, type = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Bezier, CustomComponent, isValid })=>{\n    const { inProgress, from, fromNode, fromHandle, fromPosition, to, toNode, toHandle, toPosition } = useConnection();\n    if (!inProgress) {\n        return;\n    }\n    if (CustomComponent) {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CustomComponent, {\n            connectionLineType: type,\n            connectionLineStyle: style,\n            fromNode: fromNode,\n            fromHandle: fromHandle,\n            fromX: from.x,\n            fromY: from.y,\n            toX: to.x,\n            toY: to.y,\n            fromPosition: fromPosition,\n            toPosition: toPosition,\n            connectionStatus: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getConnectionStatus)(isValid),\n            toNode: toNode,\n            toHandle: toHandle\n        });\n    }\n    let path = \"\";\n    const pathParams = {\n        sourceX: from.x,\n        sourceY: from.y,\n        sourcePosition: fromPosition,\n        targetX: to.x,\n        targetY: to.y,\n        targetPosition: toPosition\n    };\n    switch(type){\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Bezier:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierPath)(pathParams);\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.SimpleBezier:\n            [path] = getSimpleBezierPath(pathParams);\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Step:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath)({\n                ...pathParams,\n                borderRadius: 0\n            });\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.SmoothStep:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath)(pathParams);\n            break;\n        default:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getStraightPath)(pathParams);\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        d: path,\n        fill: \"none\",\n        className: \"react-flow__connection-path\",\n        style: style\n    });\n};\nConnectionLine.displayName = \"ConnectionLine\";\nconst emptyTypes = {};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction useNodeOrEdgeTypesWarning(nodeOrEdgeTypes = emptyTypes) {\n    const typesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(nodeOrEdgeTypes);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (true) {\n            const usedKeys = new Set([\n                ...Object.keys(typesRef.current),\n                ...Object.keys(nodeOrEdgeTypes)\n            ]);\n            for (const key of usedKeys){\n                if (typesRef.current[key] !== nodeOrEdgeTypes[key]) {\n                    store.getState().onError?.(\"002\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error002\"]());\n                    break;\n                }\n            }\n            typesRef.current = nodeOrEdgeTypes;\n        }\n    }, [\n        nodeOrEdgeTypes\n    ]);\n}\nfunction useStylesLoadedWarning() {\n    const store = useStoreApi();\n    const checked = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (true) {\n            if (!checked.current) {\n                const pane = document.querySelector(\".react-flow__pane\");\n                if (pane && !(window.getComputedStyle(pane).zIndex === \"1\")) {\n                    store.getState().onError?.(\"013\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error013\"](\"react\"));\n                }\n                checked.current = true;\n            }\n        }\n    }, []);\n}\nfunction GraphViewComponent({ nodeTypes, edgeTypes, onInit, onNodeClick, onEdgeClick, onNodeDoubleClick, onEdgeDoubleClick, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onSelectionContextMenu, onSelectionStart, onSelectionEnd, connectionLineType, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, selectionKeyCode, selectionOnDrag, selectionMode, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, deleteKeyCode, onlyRenderVisibleElements, elementsSelectable, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, defaultMarkerColor, zoomOnScroll, zoomOnPinch, panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance, nodeClickDistance, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, noDragClassName, noWheelClassName, noPanClassName, disableKeyboardA11y, nodeExtent, rfId, viewport, onViewportChange }) {\n    useNodeOrEdgeTypesWarning(nodeTypes);\n    useNodeOrEdgeTypesWarning(edgeTypes);\n    useStylesLoadedWarning();\n    useOnInitHandler(onInit);\n    useViewportSync(viewport);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FlowRenderer, {\n        onPaneClick: onPaneClick,\n        onPaneMouseEnter: onPaneMouseEnter,\n        onPaneMouseMove: onPaneMouseMove,\n        onPaneMouseLeave: onPaneMouseLeave,\n        onPaneContextMenu: onPaneContextMenu,\n        onPaneScroll: onPaneScroll,\n        paneClickDistance: paneClickDistance,\n        deleteKeyCode: deleteKeyCode,\n        selectionKeyCode: selectionKeyCode,\n        selectionOnDrag: selectionOnDrag,\n        selectionMode: selectionMode,\n        onSelectionStart: onSelectionStart,\n        onSelectionEnd: onSelectionEnd,\n        multiSelectionKeyCode: multiSelectionKeyCode,\n        panActivationKeyCode: panActivationKeyCode,\n        zoomActivationKeyCode: zoomActivationKeyCode,\n        elementsSelectable: elementsSelectable,\n        zoomOnScroll: zoomOnScroll,\n        zoomOnPinch: zoomOnPinch,\n        zoomOnDoubleClick: zoomOnDoubleClick,\n        panOnScroll: panOnScroll,\n        panOnScrollSpeed: panOnScrollSpeed,\n        panOnScrollMode: panOnScrollMode,\n        panOnDrag: panOnDrag,\n        defaultViewport: defaultViewport,\n        translateExtent: translateExtent,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        onSelectionContextMenu: onSelectionContextMenu,\n        preventScrolling: preventScrolling,\n        noDragClassName: noDragClassName,\n        noWheelClassName: noWheelClassName,\n        noPanClassName: noPanClassName,\n        disableKeyboardA11y: disableKeyboardA11y,\n        onViewportChange: onViewportChange,\n        isControlledViewport: !!viewport,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Viewport, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeRenderer, {\n                    edgeTypes: edgeTypes,\n                    onEdgeClick: onEdgeClick,\n                    onEdgeDoubleClick: onEdgeDoubleClick,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    onEdgeContextMenu: onEdgeContextMenu,\n                    onEdgeMouseEnter: onEdgeMouseEnter,\n                    onEdgeMouseMove: onEdgeMouseMove,\n                    onEdgeMouseLeave: onEdgeMouseLeave,\n                    reconnectRadius: reconnectRadius,\n                    defaultMarkerColor: defaultMarkerColor,\n                    noPanClassName: noPanClassName,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    rfId: rfId\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionLineWrapper, {\n                    style: connectionLineStyle,\n                    type: connectionLineType,\n                    component: connectionLineComponent,\n                    containerStyle: connectionLineContainerStyle\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                    className: \"react-flow__edgelabel-renderer\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeRenderer, {\n                    nodeTypes: nodeTypes,\n                    onNodeClick: onNodeClick,\n                    onNodeDoubleClick: onNodeDoubleClick,\n                    onNodeMouseEnter: onNodeMouseEnter,\n                    onNodeMouseMove: onNodeMouseMove,\n                    onNodeMouseLeave: onNodeMouseLeave,\n                    onNodeContextMenu: onNodeContextMenu,\n                    nodeClickDistance: nodeClickDistance,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    noPanClassName: noPanClassName,\n                    noDragClassName: noDragClassName,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    nodeExtent: nodeExtent,\n                    rfId: rfId\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                    className: \"react-flow__viewport-portal\"\n                })\n            ]\n        })\n    });\n}\nGraphViewComponent.displayName = \"GraphView\";\nconst GraphView = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(GraphViewComponent);\nconst getInitialState = ({ nodes, edges, defaultNodes, defaultEdges, width, height, fitView, fitViewOptions, minZoom = 0.5, maxZoom = 2, nodeOrigin, nodeExtent } = {})=>{\n    const nodeLookup = new Map();\n    const parentLookup = new Map();\n    const connectionLookup = new Map();\n    const edgeLookup = new Map();\n    const storeEdges = defaultEdges ?? edges ?? [];\n    const storeNodes = defaultNodes ?? nodes ?? [];\n    const storeNodeOrigin = nodeOrigin ?? [\n        0,\n        0\n    ];\n    const storeNodeExtent = nodeExtent ?? _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent;\n    (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateConnectionLookup)(connectionLookup, edgeLookup, storeEdges);\n    const nodesInitialized = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.adoptUserNodes)(storeNodes, nodeLookup, parentLookup, {\n        nodeOrigin: storeNodeOrigin,\n        nodeExtent: storeNodeExtent,\n        elevateNodesOnSelect: false\n    });\n    let transform = [\n        0,\n        0,\n        1\n    ];\n    if (fitView && width && height) {\n        const bounds = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(nodeLookup, {\n            filter: (node)=>!!((node.width || node.initialWidth) && (node.height || node.initialHeight))\n        });\n        const { x, y, zoom } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getViewportForBounds)(bounds, width, height, minZoom, maxZoom, fitViewOptions?.padding ?? 0.1);\n        transform = [\n            x,\n            y,\n            zoom\n        ];\n    }\n    return {\n        rfId: \"1\",\n        width: width ?? 0,\n        height: height ?? 0,\n        transform,\n        nodes: storeNodes,\n        nodesInitialized,\n        nodeLookup,\n        parentLookup,\n        edges: storeEdges,\n        edgeLookup,\n        connectionLookup,\n        onNodesChange: null,\n        onEdgesChange: null,\n        hasDefaultNodes: defaultNodes !== undefined,\n        hasDefaultEdges: defaultEdges !== undefined,\n        panZoom: null,\n        minZoom,\n        maxZoom,\n        translateExtent: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent,\n        nodeExtent: storeNodeExtent,\n        nodesSelectionActive: false,\n        userSelectionActive: false,\n        userSelectionRect: null,\n        connectionMode: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionMode.Strict,\n        domNode: null,\n        paneDragging: false,\n        noPanClassName: \"nopan\",\n        nodeOrigin: storeNodeOrigin,\n        nodeDragThreshold: 1,\n        connectionDragThreshold: 1,\n        snapGrid: [\n            15,\n            15\n        ],\n        snapToGrid: false,\n        nodesDraggable: true,\n        nodesConnectable: true,\n        nodesFocusable: true,\n        edgesFocusable: true,\n        edgesReconnectable: true,\n        elementsSelectable: true,\n        elevateNodesOnSelect: true,\n        elevateEdgesOnSelect: false,\n        selectNodesOnDrag: true,\n        multiSelectionActive: false,\n        fitViewQueued: fitView ?? false,\n        fitViewOptions,\n        fitViewResolver: null,\n        connection: {\n            ..._xyflow_system__WEBPACK_IMPORTED_MODULE_3__.initialConnection\n        },\n        connectionClickStartHandle: null,\n        connectOnClick: true,\n        ariaLiveMessage: \"\",\n        autoPanOnConnect: true,\n        autoPanOnNodeDrag: true,\n        autoPanOnNodeFocus: true,\n        autoPanSpeed: 15,\n        connectionRadius: 20,\n        onError: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.devWarn,\n        isValidConnection: undefined,\n        onSelectionChangeHandlers: [],\n        lib: \"react\",\n        debug: false,\n        ariaLabelConfig: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.defaultAriaLabelConfig\n    };\n};\nconst createStore = ({ nodes, edges, defaultNodes, defaultEdges, width, height, fitView, fitViewOptions, minZoom, maxZoom, nodeOrigin, nodeExtent })=>(0,zustand_traditional__WEBPACK_IMPORTED_MODULE_5__.createWithEqualityFn)((set, get)=>{\n        async function resolveFitView() {\n            const { nodeLookup, panZoom, fitViewOptions, fitViewResolver, width, height, minZoom, maxZoom } = get();\n            if (!panZoom) {\n                return;\n            }\n            await (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.fitViewport)({\n                nodes: nodeLookup,\n                width,\n                height,\n                panZoom,\n                minZoom,\n                maxZoom\n            }, fitViewOptions);\n            fitViewResolver?.resolve(true);\n            /**\n         * wait for the fitViewport to resolve before deleting the resolver,\n         * we want to reuse the old resolver if the user calls fitView again in the mean time\n         */ set({\n                fitViewResolver: null\n            });\n        }\n        return {\n            ...getInitialState({\n                nodes,\n                edges,\n                width,\n                height,\n                fitView,\n                fitViewOptions,\n                minZoom,\n                maxZoom,\n                nodeOrigin,\n                nodeExtent,\n                defaultNodes,\n                defaultEdges\n            }),\n            setNodes: (nodes)=>{\n                const { nodeLookup, parentLookup, nodeOrigin, elevateNodesOnSelect, fitViewQueued } = get();\n                /*\n             * setNodes() is called exclusively in response to user actions:\n             * - either when the `<ReactFlow nodes>` prop is updated in the controlled ReactFlow setup,\n             * - or when the user calls something like `reactFlowInstance.setNodes()` in an uncontrolled ReactFlow setup.\n             *\n             * When this happens, we take the note objects passed by the user and extend them with fields\n             * relevant for internal React Flow operations.\n             */ const nodesInitialized = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.adoptUserNodes)(nodes, nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent,\n                    elevateNodesOnSelect,\n                    checkEquality: true\n                });\n                if (fitViewQueued && nodesInitialized) {\n                    resolveFitView();\n                    set({\n                        nodes,\n                        nodesInitialized,\n                        fitViewQueued: false,\n                        fitViewOptions: undefined\n                    });\n                } else {\n                    set({\n                        nodes,\n                        nodesInitialized\n                    });\n                }\n            },\n            setEdges: (edges)=>{\n                const { connectionLookup, edgeLookup } = get();\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateConnectionLookup)(connectionLookup, edgeLookup, edges);\n                set({\n                    edges\n                });\n            },\n            setDefaultNodesAndEdges: (nodes, edges)=>{\n                if (nodes) {\n                    const { setNodes } = get();\n                    setNodes(nodes);\n                    set({\n                        hasDefaultNodes: true\n                    });\n                }\n                if (edges) {\n                    const { setEdges } = get();\n                    setEdges(edges);\n                    set({\n                        hasDefaultEdges: true\n                    });\n                }\n            },\n            /*\n         * Every node gets registerd at a ResizeObserver. Whenever a node\n         * changes its dimensions, this function is called to measure the\n         * new dimensions and update the nodes.\n         */ updateNodeInternals: (updates)=>{\n                const { triggerNodeChanges, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent, debug, fitViewQueued } = get();\n                const { changes, updatedInternals } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateNodeInternals)(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent);\n                if (!updatedInternals) {\n                    return;\n                }\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateAbsolutePositions)(nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent\n                });\n                if (fitViewQueued) {\n                    resolveFitView();\n                    set({\n                        fitViewQueued: false,\n                        fitViewOptions: undefined\n                    });\n                } else {\n                    // we always want to trigger useStore calls whenever updateNodeInternals is called\n                    set({});\n                }\n                if (changes?.length > 0) {\n                    if (debug) {\n                        console.log(\"React Flow: trigger node changes\", changes);\n                    }\n                    triggerNodeChanges?.(changes);\n                }\n            },\n            updateNodePositions: (nodeDragItems, dragging = false)=>{\n                const parentExpandChildren = [];\n                const changes = [];\n                const { nodeLookup, triggerNodeChanges } = get();\n                for (const [id, dragItem] of nodeDragItems){\n                    // we are using the nodelookup to be sure to use the current expandParent and parentId value\n                    const node = nodeLookup.get(id);\n                    const expandParent = !!(node?.expandParent && node?.parentId && dragItem?.position);\n                    const change = {\n                        id,\n                        type: \"position\",\n                        position: expandParent ? {\n                            x: Math.max(0, dragItem.position.x),\n                            y: Math.max(0, dragItem.position.y)\n                        } : dragItem.position,\n                        dragging\n                    };\n                    if (expandParent && node.parentId) {\n                        parentExpandChildren.push({\n                            id,\n                            parentId: node.parentId,\n                            rect: {\n                                ...dragItem.internals.positionAbsolute,\n                                width: dragItem.measured.width ?? 0,\n                                height: dragItem.measured.height ?? 0\n                            }\n                        });\n                    }\n                    changes.push(change);\n                }\n                if (parentExpandChildren.length > 0) {\n                    const { parentLookup, nodeOrigin } = get();\n                    const parentExpandChanges = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleExpandParent)(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);\n                    changes.push(...parentExpandChanges);\n                }\n                triggerNodeChanges(changes);\n            },\n            triggerNodeChanges: (changes)=>{\n                const { onNodesChange, setNodes, nodes, hasDefaultNodes, debug } = get();\n                if (changes?.length) {\n                    if (hasDefaultNodes) {\n                        const updatedNodes = applyNodeChanges(changes, nodes);\n                        setNodes(updatedNodes);\n                    }\n                    if (debug) {\n                        console.log(\"React Flow: trigger node changes\", changes);\n                    }\n                    onNodesChange?.(changes);\n                }\n            },\n            triggerEdgeChanges: (changes)=>{\n                const { onEdgesChange, setEdges, edges, hasDefaultEdges, debug } = get();\n                if (changes?.length) {\n                    if (hasDefaultEdges) {\n                        const updatedEdges = applyEdgeChanges(changes, edges);\n                        setEdges(updatedEdges);\n                    }\n                    if (debug) {\n                        console.log(\"React Flow: trigger edge changes\", changes);\n                    }\n                    onEdgesChange?.(changes);\n                }\n            },\n            addSelectedNodes: (selectedNodeIds)=>{\n                const { multiSelectionActive, edgeLookup, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                if (multiSelectionActive) {\n                    const nodeChanges = selectedNodeIds.map((nodeId)=>createSelectionChange(nodeId, true));\n                    triggerNodeChanges(nodeChanges);\n                    return;\n                }\n                triggerNodeChanges(getSelectionChanges(nodeLookup, new Set([\n                    ...selectedNodeIds\n                ]), true));\n                triggerEdgeChanges(getSelectionChanges(edgeLookup));\n            },\n            addSelectedEdges: (selectedEdgeIds)=>{\n                const { multiSelectionActive, edgeLookup, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                if (multiSelectionActive) {\n                    const changedEdges = selectedEdgeIds.map((edgeId)=>createSelectionChange(edgeId, true));\n                    triggerEdgeChanges(changedEdges);\n                    return;\n                }\n                triggerEdgeChanges(getSelectionChanges(edgeLookup, new Set([\n                    ...selectedEdgeIds\n                ])));\n                triggerNodeChanges(getSelectionChanges(nodeLookup, new Set(), true));\n            },\n            unselectNodesAndEdges: ({ nodes, edges } = {})=>{\n                const { edges: storeEdges, nodes: storeNodes, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                const nodesToUnselect = nodes ? nodes : storeNodes;\n                const edgesToUnselect = edges ? edges : storeEdges;\n                const nodeChanges = nodesToUnselect.map((n)=>{\n                    const internalNode = nodeLookup.get(n.id);\n                    if (internalNode) {\n                        /*\n                     * we need to unselect the internal node that was selected previously before we\n                     * send the change to the user to prevent it to be selected while dragging the new node\n                     */ internalNode.selected = false;\n                    }\n                    return createSelectionChange(n.id, false);\n                });\n                const edgeChanges = edgesToUnselect.map((edge)=>createSelectionChange(edge.id, false));\n                triggerNodeChanges(nodeChanges);\n                triggerEdgeChanges(edgeChanges);\n            },\n            setMinZoom: (minZoom)=>{\n                const { panZoom, maxZoom } = get();\n                panZoom?.setScaleExtent([\n                    minZoom,\n                    maxZoom\n                ]);\n                set({\n                    minZoom\n                });\n            },\n            setMaxZoom: (maxZoom)=>{\n                const { panZoom, minZoom } = get();\n                panZoom?.setScaleExtent([\n                    minZoom,\n                    maxZoom\n                ]);\n                set({\n                    maxZoom\n                });\n            },\n            setTranslateExtent: (translateExtent)=>{\n                get().panZoom?.setTranslateExtent(translateExtent);\n                set({\n                    translateExtent\n                });\n            },\n            setPaneClickDistance: (clickDistance)=>{\n                get().panZoom?.setClickDistance(clickDistance);\n            },\n            resetSelectedElements: ()=>{\n                const { edges, nodes, triggerNodeChanges, triggerEdgeChanges, elementsSelectable } = get();\n                if (!elementsSelectable) {\n                    return;\n                }\n                const nodeChanges = nodes.reduce((res, node)=>node.selected ? [\n                        ...res,\n                        createSelectionChange(node.id, false)\n                    ] : res, []);\n                const edgeChanges = edges.reduce((res, edge)=>edge.selected ? [\n                        ...res,\n                        createSelectionChange(edge.id, false)\n                    ] : res, []);\n                triggerNodeChanges(nodeChanges);\n                triggerEdgeChanges(edgeChanges);\n            },\n            setNodeExtent: (nextNodeExtent)=>{\n                const { nodes, nodeLookup, parentLookup, nodeOrigin, elevateNodesOnSelect, nodeExtent } = get();\n                if (nextNodeExtent[0][0] === nodeExtent[0][0] && nextNodeExtent[0][1] === nodeExtent[0][1] && nextNodeExtent[1][0] === nodeExtent[1][0] && nextNodeExtent[1][1] === nodeExtent[1][1]) {\n                    return;\n                }\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.adoptUserNodes)(nodes, nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent: nextNodeExtent,\n                    elevateNodesOnSelect,\n                    checkEquality: false\n                });\n                set({\n                    nodeExtent: nextNodeExtent\n                });\n            },\n            panBy: (delta)=>{\n                const { transform, width, height, panZoom, translateExtent } = get();\n                return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.panBy)({\n                    delta,\n                    panZoom,\n                    transform,\n                    translateExtent,\n                    width,\n                    height\n                });\n            },\n            setCenter: async (x, y, options)=>{\n                const { width, height, maxZoom, panZoom } = get();\n                if (!panZoom) {\n                    return Promise.resolve(false);\n                }\n                const nextZoom = typeof options?.zoom !== \"undefined\" ? options.zoom : maxZoom;\n                await panZoom.setViewport({\n                    x: width / 2 - x * nextZoom,\n                    y: height / 2 - y * nextZoom,\n                    zoom: nextZoom\n                }, {\n                    duration: options?.duration,\n                    ease: options?.ease,\n                    interpolate: options?.interpolate\n                });\n                return Promise.resolve(true);\n            },\n            cancelConnection: ()=>{\n                set({\n                    connection: {\n                        ..._xyflow_system__WEBPACK_IMPORTED_MODULE_3__.initialConnection\n                    }\n                });\n            },\n            updateConnection: (connection)=>{\n                set({\n                    connection\n                });\n            },\n            reset: ()=>set({\n                    ...getInitialState()\n                })\n        };\n    }, Object.is);\n/**\n * The `<ReactFlowProvider />` component is a [context provider](https://react.dev/learn/passing-data-deeply-with-context#)\n * that makes it possible to access a flow's internal state outside of the\n * [`<ReactFlow />`](/api-reference/react-flow) component. Many of the hooks we\n * provide rely on this component to work.\n * @public\n *\n * @example\n * ```tsx\n *import { ReactFlow, ReactFlowProvider, useNodes } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlowProvider>\n *      <ReactFlow nodes={...} edges={...} />\n *      <Sidebar />\n *    </ReactFlowProvider>\n *  );\n *}\n *\n *function Sidebar() {\n *  // This hook will only work if the component it's used in is a child of a\n *  // <ReactFlowProvider />.\n *  const nodes = useNodes()\n *\n *  return <aside>do something with nodes</aside>;\n *}\n *```\n *\n * @remarks If you're using a router and want your flow's state to persist across routes,\n * it's vital that you place the `<ReactFlowProvider />` component _outside_ of\n * your router. If you have multiple flows on the same page you will need to use a separate\n * `<ReactFlowProvider />` for each flow.\n */ function ReactFlowProvider({ initialNodes: nodes, initialEdges: edges, defaultNodes, defaultEdges, initialWidth: width, initialHeight: height, initialMinZoom: minZoom, initialMaxZoom: maxZoom, initialFitViewOptions: fitViewOptions, fitView, nodeOrigin, nodeExtent, children }) {\n    const [store] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>createStore({\n            nodes,\n            edges,\n            defaultNodes,\n            defaultEdges,\n            width,\n            height,\n            fitView,\n            minZoom,\n            maxZoom,\n            fitViewOptions,\n            nodeOrigin,\n            nodeExtent\n        }));\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Provider$1, {\n        value: store,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BatchProvider, {\n            children: children\n        })\n    });\n}\nfunction Wrapper({ children, nodes, edges, defaultNodes, defaultEdges, width, height, fitView, fitViewOptions, minZoom, maxZoom, nodeOrigin, nodeExtent }) {\n    const isWrapped = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StoreContext);\n    if (isWrapped) {\n        /*\n         * we need to wrap it with a fragment because it's not allowed for children to be a ReactNode\n         * https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18051\n         */ return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: children\n        });\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ReactFlowProvider, {\n        initialNodes: nodes,\n        initialEdges: edges,\n        defaultNodes: defaultNodes,\n        defaultEdges: defaultEdges,\n        initialWidth: width,\n        initialHeight: height,\n        fitView: fitView,\n        initialFitViewOptions: fitViewOptions,\n        initialMinZoom: minZoom,\n        initialMaxZoom: maxZoom,\n        nodeOrigin: nodeOrigin,\n        nodeExtent: nodeExtent,\n        children: children\n    });\n}\nconst wrapperStyle = {\n    width: \"100%\",\n    height: \"100%\",\n    overflow: \"hidden\",\n    position: \"relative\",\n    zIndex: 0\n};\nfunction ReactFlow({ nodes, edges, defaultNodes, defaultEdges, className, nodeTypes, edgeTypes, onNodeClick, onEdgeClick, onInit, onMove, onMoveStart, onMoveEnd, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onNodeDoubleClick, onNodeDragStart, onNodeDrag, onNodeDragStop, onNodesDelete, onEdgesDelete, onDelete, onSelectionChange, onSelectionDragStart, onSelectionDrag, onSelectionDragStop, onSelectionContextMenu, onSelectionStart, onSelectionEnd, onBeforeDelete, connectionMode, connectionLineType = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Bezier, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, deleteKeyCode = \"Backspace\", selectionKeyCode = \"Shift\", selectionOnDrag = false, selectionMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode.Full, panActivationKeyCode = \"Space\", multiSelectionKeyCode = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isMacOs)() ? \"Meta\" : \"Control\", zoomActivationKeyCode = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isMacOs)() ? \"Meta\" : \"Control\", snapToGrid, snapGrid, onlyRenderVisibleElements = false, selectNodesOnDrag, nodesDraggable, autoPanOnNodeFocus, nodesConnectable, nodesFocusable, nodeOrigin = defaultNodeOrigin, edgesFocusable, edgesReconnectable, elementsSelectable = true, defaultViewport: defaultViewport$1 = defaultViewport, minZoom = 0.5, maxZoom = 2, translateExtent = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent, preventScrolling = true, nodeExtent, defaultMarkerColor = \"#b1b1b7\", zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.PanOnScrollMode.Free, zoomOnDoubleClick = true, panOnDrag = true, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance = 0, nodeClickDistance = 0, children, onReconnect, onReconnectStart, onReconnectEnd, onEdgeContextMenu, onEdgeDoubleClick, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius = 10, onNodesChange, onEdgesChange, noDragClassName = \"nodrag\", noWheelClassName = \"nowheel\", noPanClassName = \"nopan\", fitView, fitViewOptions, connectOnClick, attributionPosition, proOptions, defaultEdgeOptions, elevateNodesOnSelect, elevateEdgesOnSelect, disableKeyboardA11y = false, autoPanOnConnect, autoPanOnNodeDrag, autoPanSpeed, connectionRadius, isValidConnection, onError, style, id, nodeDragThreshold, connectionDragThreshold, viewport, onViewportChange, width, height, colorMode = \"light\", debug, onScroll, ariaLabelConfig, ...rest }, ref) {\n    const rfId = id || \"1\";\n    const colorModeClassName = useColorModeClass(colorMode);\n    // Undo scroll events, preventing viewport from shifting when nodes outside of it are focused\n    const wrapperOnScroll = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((e)=>{\n        e.currentTarget.scrollTo({\n            top: 0,\n            left: 0,\n            behavior: \"instant\"\n        });\n        onScroll?.(e);\n    }, [\n        onScroll\n    ]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        \"data-testid\": \"rf__wrapper\",\n        ...rest,\n        onScroll: wrapperOnScroll,\n        style: {\n            ...style,\n            ...wrapperStyle\n        },\n        ref: ref,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow\",\n            className,\n            colorModeClassName\n        ]),\n        id: id,\n        role: \"application\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Wrapper, {\n            nodes: nodes,\n            edges: edges,\n            width: width,\n            height: height,\n            fitView: fitView,\n            fitViewOptions: fitViewOptions,\n            minZoom: minZoom,\n            maxZoom: maxZoom,\n            nodeOrigin: nodeOrigin,\n            nodeExtent: nodeExtent,\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(GraphView, {\n                    onInit: onInit,\n                    onNodeClick: onNodeClick,\n                    onEdgeClick: onEdgeClick,\n                    onNodeMouseEnter: onNodeMouseEnter,\n                    onNodeMouseMove: onNodeMouseMove,\n                    onNodeMouseLeave: onNodeMouseLeave,\n                    onNodeContextMenu: onNodeContextMenu,\n                    onNodeDoubleClick: onNodeDoubleClick,\n                    nodeTypes: nodeTypes,\n                    edgeTypes: edgeTypes,\n                    connectionLineType: connectionLineType,\n                    connectionLineStyle: connectionLineStyle,\n                    connectionLineComponent: connectionLineComponent,\n                    connectionLineContainerStyle: connectionLineContainerStyle,\n                    selectionKeyCode: selectionKeyCode,\n                    selectionOnDrag: selectionOnDrag,\n                    selectionMode: selectionMode,\n                    deleteKeyCode: deleteKeyCode,\n                    multiSelectionKeyCode: multiSelectionKeyCode,\n                    panActivationKeyCode: panActivationKeyCode,\n                    zoomActivationKeyCode: zoomActivationKeyCode,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    defaultViewport: defaultViewport$1,\n                    translateExtent: translateExtent,\n                    minZoom: minZoom,\n                    maxZoom: maxZoom,\n                    preventScrolling: preventScrolling,\n                    zoomOnScroll: zoomOnScroll,\n                    zoomOnPinch: zoomOnPinch,\n                    zoomOnDoubleClick: zoomOnDoubleClick,\n                    panOnScroll: panOnScroll,\n                    panOnScrollSpeed: panOnScrollSpeed,\n                    panOnScrollMode: panOnScrollMode,\n                    panOnDrag: panOnDrag,\n                    onPaneClick: onPaneClick,\n                    onPaneMouseEnter: onPaneMouseEnter,\n                    onPaneMouseMove: onPaneMouseMove,\n                    onPaneMouseLeave: onPaneMouseLeave,\n                    onPaneScroll: onPaneScroll,\n                    onPaneContextMenu: onPaneContextMenu,\n                    paneClickDistance: paneClickDistance,\n                    nodeClickDistance: nodeClickDistance,\n                    onSelectionContextMenu: onSelectionContextMenu,\n                    onSelectionStart: onSelectionStart,\n                    onSelectionEnd: onSelectionEnd,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    onEdgeContextMenu: onEdgeContextMenu,\n                    onEdgeDoubleClick: onEdgeDoubleClick,\n                    onEdgeMouseEnter: onEdgeMouseEnter,\n                    onEdgeMouseMove: onEdgeMouseMove,\n                    onEdgeMouseLeave: onEdgeMouseLeave,\n                    reconnectRadius: reconnectRadius,\n                    defaultMarkerColor: defaultMarkerColor,\n                    noDragClassName: noDragClassName,\n                    noWheelClassName: noWheelClassName,\n                    noPanClassName: noPanClassName,\n                    rfId: rfId,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    nodeExtent: nodeExtent,\n                    viewport: viewport,\n                    onViewportChange: onViewportChange\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StoreUpdater, {\n                    nodes: nodes,\n                    edges: edges,\n                    defaultNodes: defaultNodes,\n                    defaultEdges: defaultEdges,\n                    onConnect: onConnect,\n                    onConnectStart: onConnectStart,\n                    onConnectEnd: onConnectEnd,\n                    onClickConnectStart: onClickConnectStart,\n                    onClickConnectEnd: onClickConnectEnd,\n                    nodesDraggable: nodesDraggable,\n                    autoPanOnNodeFocus: autoPanOnNodeFocus,\n                    nodesConnectable: nodesConnectable,\n                    nodesFocusable: nodesFocusable,\n                    edgesFocusable: edgesFocusable,\n                    edgesReconnectable: edgesReconnectable,\n                    elementsSelectable: elementsSelectable,\n                    elevateNodesOnSelect: elevateNodesOnSelect,\n                    elevateEdgesOnSelect: elevateEdgesOnSelect,\n                    minZoom: minZoom,\n                    maxZoom: maxZoom,\n                    nodeExtent: nodeExtent,\n                    onNodesChange: onNodesChange,\n                    onEdgesChange: onEdgesChange,\n                    snapToGrid: snapToGrid,\n                    snapGrid: snapGrid,\n                    connectionMode: connectionMode,\n                    translateExtent: translateExtent,\n                    connectOnClick: connectOnClick,\n                    defaultEdgeOptions: defaultEdgeOptions,\n                    fitView: fitView,\n                    fitViewOptions: fitViewOptions,\n                    onNodesDelete: onNodesDelete,\n                    onEdgesDelete: onEdgesDelete,\n                    onDelete: onDelete,\n                    onNodeDragStart: onNodeDragStart,\n                    onNodeDrag: onNodeDrag,\n                    onNodeDragStop: onNodeDragStop,\n                    onSelectionDrag: onSelectionDrag,\n                    onSelectionDragStart: onSelectionDragStart,\n                    onSelectionDragStop: onSelectionDragStop,\n                    onMove: onMove,\n                    onMoveStart: onMoveStart,\n                    onMoveEnd: onMoveEnd,\n                    noPanClassName: noPanClassName,\n                    nodeOrigin: nodeOrigin,\n                    rfId: rfId,\n                    autoPanOnConnect: autoPanOnConnect,\n                    autoPanOnNodeDrag: autoPanOnNodeDrag,\n                    autoPanSpeed: autoPanSpeed,\n                    onError: onError,\n                    connectionRadius: connectionRadius,\n                    isValidConnection: isValidConnection,\n                    selectNodesOnDrag: selectNodesOnDrag,\n                    nodeDragThreshold: nodeDragThreshold,\n                    connectionDragThreshold: connectionDragThreshold,\n                    onBeforeDelete: onBeforeDelete,\n                    paneClickDistance: paneClickDistance,\n                    debug: debug,\n                    ariaLabelConfig: ariaLabelConfig\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectionListener, {\n                    onSelectionChange: onSelectionChange\n                }),\n                children,\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Attribution, {\n                    proOptions: proOptions,\n                    position: attributionPosition\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(A11yDescriptions, {\n                    rfId: rfId,\n                    disableKeyboardA11y: disableKeyboardA11y\n                })\n            ]\n        })\n    });\n}\n/**\n * The `<ReactFlow />` component is the heart of your React Flow application.\n * It renders your nodes and edges and handles user interaction\n *\n * @public\n *\n * @example\n * ```tsx\n *import { ReactFlow } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (<ReactFlow\n *    nodes={...}\n *    edges={...}\n *    onNodesChange={...}\n *    ...\n *  />);\n *}\n *```\n */ var index = fixedForwardRef(ReactFlow);\nconst selector$6 = (s)=>s.domNode?.querySelector(\".react-flow__edgelabel-renderer\");\n/**\n * Edges are SVG-based. If you want to render more complex labels you can use the\n * `<EdgeLabelRenderer />` component to access a div based renderer. This component\n * is a portal that renders the label in a `<div />` that is positioned on top of\n * the edges. You can see an example usage of the component in the\n * [edge label renderer example](/examples/edges/edge-label-renderer).\n * @public\n *\n * @example\n * ```jsx\n * import React from 'react';\n * import { getBezierPath, EdgeLabelRenderer, BaseEdge } from '@xyflow/react';\n *\n * export function CustomEdge({ id, data, ...props }) {\n *   const [edgePath, labelX, labelY] = getBezierPath(props);\n *\n *   return (\n *     <>\n *       <BaseEdge id={id} path={edgePath} />\n *       <EdgeLabelRenderer>\n *         <div\n *           style={{\n *             position: 'absolute',\n *             transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,\n *             background: '#ffcc00',\n *             padding: 10,\n *         }}\n *           className=\"nodrag nopan\"\n *         >\n *          {data.label}\n *         </div>\n *       </EdgeLabelRenderer>\n *     </>\n *   );\n * };\n * ```\n *\n * @remarks The `<EdgeLabelRenderer />` has no pointer events by default. If you want to\n * add mouse interactions you need to set the style `pointerEvents: all` and add\n * the `nopan` class on the label or the element you want to interact with.\n */ function EdgeLabelRenderer({ children }) {\n    const edgeLabelRenderer = useStore(selector$6);\n    if (!edgeLabelRenderer) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, edgeLabelRenderer);\n}\nconst selector$5 = (s)=>s.domNode?.querySelector(\".react-flow__viewport-portal\");\n/**\n * The `<ViewportPortal />` component can be used to add components to the same viewport\n * of the flow where nodes and edges are rendered. This is useful when you want to render\n * your own components that are adhere to the same coordinate system as the nodes & edges\n * and are also affected by zooming and panning\n * @public\n * @example\n *\n * ```jsx\n *import React from 'react';\n *import { ViewportPortal } from '@xyflow/react';\n *\n *export default function () {\n *  return (\n *    <ViewportPortal>\n *      <div\n *        style={{ transform: 'translate(100px, 100px)', position: 'absolute' }}\n *      >\n *        This div is positioned at [100, 100] on the flow.\n *      </div>\n *    </ViewportPortal>\n *  );\n *}\n *```\n */ function ViewportPortal({ children }) {\n    const viewPortalDiv = useStore(selector$5);\n    if (!viewPortalDiv) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, viewPortalDiv);\n}\n/**\n * When you programmatically add or remove handles to a node or update a node's\n * handle position, you need to let React Flow know about it using this hook. This\n * will update the internal dimensions of the node and properly reposition handles\n * on the canvas if necessary.\n *\n * @public\n * @returns Use this function to tell React Flow to update the internal state of one or more nodes\n * that you have changed programmatically.\n *\n * @example\n * ```jsx\n *import { useCallback, useState } from 'react';\n *import { Handle, useUpdateNodeInternals } from '@xyflow/react';\n *\n *export default function RandomHandleNode({ id }) {\n *  const updateNodeInternals = useUpdateNodeInternals();\n *  const [handleCount, setHandleCount] = useState(0);\n *  const randomizeHandleCount = useCallback(() => {\n *   setHandleCount(Math.floor(Math.random() * 10));\n *    updateNodeInternals(id);\n *  }, [id, updateNodeInternals]);\n *\n *  return (\n *    <>\n *      {Array.from({ length: handleCount }).map((_, index) => (\n *        <Handle\n *          key={index}\n *          type=\"target\"\n *          position=\"left\"\n *          id={`handle-${index}`}\n *        />\n *      ))}\n *\n *      <div>\n *        <button onClick={randomizeHandleCount}>Randomize handle count</button>\n *        <p>There are {handleCount} handles on this node.</p>\n *      </div>\n *    </>\n *  );\n *}\n *```\n * @remarks This hook can only be used in a component that is a child of a\n *{@link ReactFlowProvider} or a {@link ReactFlow} component.\n */ function useUpdateNodeInternals() {\n    const store = useStoreApi();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((id)=>{\n        const { domNode, updateNodeInternals } = store.getState();\n        const updateIds = Array.isArray(id) ? id : [\n            id\n        ];\n        const updates = new Map();\n        updateIds.forEach((updateId)=>{\n            const nodeElement = domNode?.querySelector(`.react-flow__node[data-id=\"${updateId}\"]`);\n            if (nodeElement) {\n                updates.set(updateId, {\n                    id: updateId,\n                    nodeElement,\n                    force: true\n                });\n            }\n        });\n        requestAnimationFrame(()=>updateNodeInternals(updates, {\n                triggerFitView: false\n            }));\n    }, []);\n}\nconst nodesSelector = (state)=>state.nodes;\n/**\n * This hook returns an array of the current nodes. Components that use this hook\n * will re-render **whenever any node changes**, including when a node is selected\n * or moved.\n *\n * @public\n * @returns An array of all nodes currently in the flow.\n *\n * @example\n * ```jsx\n *import { useNodes } from '@xyflow/react';\n *\n *export default function() {\n *  const nodes = useNodes();\n *\n *  return <div>There are currently {nodes.length} nodes!</div>;\n *}\n *```\n */ function useNodes() {\n    const nodes = useStore(nodesSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return nodes;\n}\nconst edgesSelector = (state)=>state.edges;\n/**\n * This hook returns an array of the current edges. Components that use this hook\n * will re-render **whenever any edge changes**.\n *\n * @public\n * @returns An array of all edges currently in the flow.\n *\n * @example\n * ```tsx\n *import { useEdges } from '@xyflow/react';\n *\n *export default function () {\n *  const edges = useEdges();\n *\n *  return <div>There are currently {edges.length} edges!</div>;\n *}\n *```\n */ function useEdges() {\n    const edges = useStore(edgesSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return edges;\n}\nconst viewportSelector = (state)=>({\n        x: state.transform[0],\n        y: state.transform[1],\n        zoom: state.transform[2]\n    });\n/**\n * The `useViewport` hook is a convenient way to read the current state of the\n * {@link Viewport} in a component. Components that use this hook\n * will re-render **whenever the viewport changes**.\n *\n * @public\n * @returns The current viewport.\n *\n * @example\n *\n *```jsx\n *import { useViewport } from '@xyflow/react';\n *\n *export default function ViewportDisplay() {\n *  const { x, y, zoom } = useViewport();\n *\n *  return (\n *    <div>\n *      <p>\n *        The viewport is currently at ({x}, {y}) and zoomed to {zoom}.\n *      </p>\n *    </div>\n *  );\n *}\n *```\n *\n * @remarks This hook can only be used in a component that is a child of a\n *{@link ReactFlowProvider} or a {@link ReactFlow} component.\n */ function useViewport() {\n    const viewport = useStore(viewportSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return viewport;\n}\n/**\n * This hook makes it easy to prototype a controlled flow where you manage the\n * state of nodes and edges outside the `ReactFlowInstance`. You can think of it\n * like React's `useState` hook with an additional helper callback.\n *\n * @public\n * @returns\n * - `nodes`: The current array of nodes. You might pass this directly to the `nodes` prop of your\n * `<ReactFlow />` component, or you may want to manipulate it first to perform some layouting,\n * for example.\n * - `setNodes`: A function that you can use to update the nodes. You can pass it a new array of\n * nodes or a callback that receives the current array of nodes and returns a new array of nodes.\n * This is the same as the second element of the tuple returned by React's `useState` hook.\n * - `onNodesChange`: A handy callback that can take an array of `NodeChanges` and update the nodes\n * state accordingly. You'll typically pass this directly to the `onNodesChange` prop of your\n * `<ReactFlow />` component.\n * @example\n *\n *```tsx\n *import { ReactFlow, useNodesState, useEdgesState } from '@xyflow/react';\n *\n *const initialNodes = [];\n *const initialEdges = [];\n *\n *export default function () {\n *  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n *  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n *\n *  return (\n *    <ReactFlow\n *      nodes={nodes}\n *      edges={edges}\n *      onNodesChange={onNodesChange}\n *      onEdgesChange={onEdgesChange}\n *    />\n *  );\n *}\n *```\n *\n * @remarks This hook was created to make prototyping easier and our documentation\n * examples clearer. Although it is OK to use this hook in production, in\n * practice you may want to use a more sophisticated state management solution\n * like Zustand {@link https://reactflow.dev/docs/guides/state-management/} instead.\n *\n */ function useNodesState(initialNodes) {\n    const [nodes, setNodes] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialNodes);\n    const onNodesChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((changes)=>setNodes((nds)=>applyNodeChanges(changes, nds)), []);\n    return [\n        nodes,\n        setNodes,\n        onNodesChange\n    ];\n}\n/**\n * This hook makes it easy to prototype a controlled flow where you manage the\n * state of nodes and edges outside the `ReactFlowInstance`. You can think of it\n * like React's `useState` hook with an additional helper callback.\n *\n * @public\n * @returns\n * - `edges`: The current array of edges. You might pass this directly to the `edges` prop of your\n * `<ReactFlow />` component, or you may want to manipulate it first to perform some layouting,\n * for example.\n *\n * - `setEdges`: A function that you can use to update the edges. You can pass it a new array of\n * edges or a callback that receives the current array of edges and returns a new array of edges.\n * This is the same as the second element of the tuple returned by React's `useState` hook.\n *\n * - `onEdgesChange`: A handy callback that can take an array of `EdgeChanges` and update the edges\n * state accordingly. You'll typically pass this directly to the `onEdgesChange` prop of your\n * `<ReactFlow />` component.\n * @example\n *\n *```tsx\n *import { ReactFlow, useNodesState, useEdgesState } from '@xyflow/react';\n *\n *const initialNodes = [];\n *const initialEdges = [];\n *\n *export default function () {\n *  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n *  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n *\n *  return (\n *    <ReactFlow\n *      nodes={nodes}\n *      edges={edges}\n *      onNodesChange={onNodesChange}\n *      onEdgesChange={onEdgesChange}\n *    />\n *  );\n *}\n *```\n *\n * @remarks This hook was created to make prototyping easier and our documentation\n * examples clearer. Although it is OK to use this hook in production, in\n * practice you may want to use a more sophisticated state management solution\n * like Zustand {@link https://reactflow.dev/docs/guides/state-management/} instead.\n *\n */ function useEdgesState(initialEdges) {\n    const [edges, setEdges] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialEdges);\n    const onEdgesChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((changes)=>setEdges((eds)=>applyEdgeChanges(changes, eds)), []);\n    return [\n        edges,\n        setEdges,\n        onEdgesChange\n    ];\n}\n/**\n * The `useOnViewportChange` hook lets you listen for changes to the viewport such\n * as panning and zooming. You can provide a callback for each phase of a viewport\n * change: `onStart`, `onChange`, and `onEnd`.\n *\n * @public\n * @example\n * ```jsx\n *import { useCallback } from 'react';\n *import { useOnViewportChange } from '@xyflow/react';\n *\n *function ViewportChangeLogger() {\n *  useOnViewportChange({\n *    onStart: (viewport: Viewport) => console.log('start', viewport),\n *    onChange: (viewport: Viewport) => console.log('change', viewport),\n *    onEnd: (viewport: Viewport) => console.log('end', viewport),\n *  });\n *\n *  return null;\n *}\n *```\n */ function useOnViewportChange({ onStart, onChange, onEnd }) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        store.setState({\n            onViewportChangeStart: onStart\n        });\n    }, [\n        onStart\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        store.setState({\n            onViewportChange: onChange\n        });\n    }, [\n        onChange\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        store.setState({\n            onViewportChangeEnd: onEnd\n        });\n    }, [\n        onEnd\n    ]);\n}\n/**\n * This hook lets you listen for changes to both node and edge selection. As the\n *name implies, the callback you provide will be called whenever the selection of\n *_either_ nodes or edges changes.\n *\n * @public\n * @example\n * ```jsx\n *import { useState } from 'react';\n *import { ReactFlow, useOnSelectionChange } from '@xyflow/react';\n *\n *function SelectionDisplay() {\n *  const [selectedNodes, setSelectedNodes] = useState([]);\n *  const [selectedEdges, setSelectedEdges] = useState([]);\n *\n *  // the passed handler has to be memoized, otherwise the hook will not work correctly\n *  const onChange = useCallback(({ nodes, edges }) => {\n *    setSelectedNodes(nodes.map((node) => node.id));\n *    setSelectedEdges(edges.map((edge) => edge.id));\n *  }, []);\n *\n *  useOnSelectionChange({\n *    onChange,\n *  });\n *\n *  return (\n *    <div>\n *      <p>Selected nodes: {selectedNodes.join(', ')}</p>\n *      <p>Selected edges: {selectedEdges.join(', ')}</p>\n *    </div>\n *  );\n *}\n *```\n *\n * @remarks You need to memoize the passed `onChange` handler, otherwise the hook will not work correctly.\n */ function useOnSelectionChange({ onChange }) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const nextOnSelectionChangeHandlers = [\n            ...store.getState().onSelectionChangeHandlers,\n            onChange\n        ];\n        store.setState({\n            onSelectionChangeHandlers: nextOnSelectionChangeHandlers\n        });\n        return ()=>{\n            const nextHandlers = store.getState().onSelectionChangeHandlers.filter((fn)=>fn !== onChange);\n            store.setState({\n                onSelectionChangeHandlers: nextHandlers\n            });\n        };\n    }, [\n        onChange\n    ]);\n}\nconst selector$4 = (options)=>(s)=>{\n        if (!options.includeHiddenNodes) {\n            return s.nodesInitialized;\n        }\n        if (s.nodeLookup.size === 0) {\n            return false;\n        }\n        for (const [, { internals }] of s.nodeLookup){\n            if (internals.handleBounds === undefined || !(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeHasDimensions)(internals.userNode)) {\n                return false;\n            }\n        }\n        return true;\n    };\n/**\n * This hook tells you whether all the nodes in a flow have been measured and given\n *a width and height. When you add a node to the flow, this hook will return\n *`false` and then `true` again once the node has been measured.\n *\n * @public\n * @returns Whether or not the nodes have been initialized by the `<ReactFlow />` component and\n * given a width and height.\n *\n * @example\n * ```jsx\n *import { useReactFlow, useNodesInitialized } from '@xyflow/react';\n *import { useEffect, useState } from 'react';\n *\n *const options = {\n *  includeHiddenNodes: false,\n *};\n *\n *export default function useLayout() {\n *  const { getNodes } = useReactFlow();\n *  const nodesInitialized = useNodesInitialized(options);\n *  const [layoutedNodes, setLayoutedNodes] = useState(getNodes());\n *\n *  useEffect(() => {\n *    if (nodesInitialized) {\n *      setLayoutedNodes(yourLayoutingFunction(getNodes()));\n *    }\n *  }, [nodesInitialized]);\n *\n *  return layoutedNodes;\n *}\n *```\n */ function useNodesInitialized(options = {\n    includeHiddenNodes: false\n}) {\n    const initialized = useStore(selector$4(options));\n    return initialized;\n}\n/**\n * Hook to check if a <Handle /> is connected to another <Handle /> and get the connections.\n *\n * @public\n * @deprecated Use `useNodeConnections` instead.\n * @returns An array with handle connections.\n */ function useHandleConnections({ type, id, nodeId, onConnect, onDisconnect }) {\n    console.warn(\"[DEPRECATED] `useHandleConnections` is deprecated. Instead use `useNodeConnections` https://reactflow.dev/api-reference/hooks/useNodeConnections\");\n    const _nodeId = useNodeId();\n    const currentNodeId = nodeId ?? _nodeId;\n    const prevConnections = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const connections = useStore((state)=>state.connectionLookup.get(`${currentNodeId}-${type}${id ? `-${id}` : \"\"}`), _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areConnectionMapsEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // @todo dicuss if onConnect/onDisconnect should be called when the component mounts/unmounts\n        if (prevConnections.current && prevConnections.current !== connections) {\n            const _connections = connections ?? new Map();\n            (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(prevConnections.current, _connections, onDisconnect);\n            (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(_connections, prevConnections.current, onConnect);\n        }\n        prevConnections.current = connections ?? new Map();\n    }, [\n        connections,\n        onConnect,\n        onDisconnect\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>Array.from(connections?.values() ?? []), [\n        connections\n    ]);\n}\nconst error014 = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error014\"]();\n/**\n * This hook returns an array of connections on a specific node, handle type ('source', 'target') or handle ID.\n *\n * @public\n * @returns An array with connections.\n *\n * @example\n * ```jsx\n *import { useNodeConnections } from '@xyflow/react';\n *\n *export default function () {\n *  const connections = useNodeConnections({\n *    handleType: 'target',\n *    handleId: 'my-handle',\n *  });\n *\n *  return (\n *    <div>There are currently {connections.length} incoming connections!</div>\n *  );\n *}\n *```\n */ function useNodeConnections({ id, handleType, handleId, onConnect, onDisconnect } = {}) {\n    const nodeId = useNodeId();\n    const currentNodeId = id ?? nodeId;\n    if (!currentNodeId) {\n        throw new Error(error014);\n    }\n    const prevConnections = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const connections = useStore((state)=>state.connectionLookup.get(`${currentNodeId}${handleType ? handleId ? `-${handleType}-${handleId}` : `-${handleType}` : \"\"}`), _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areConnectionMapsEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // @todo discuss if onConnect/onDisconnect should be called when the component mounts/unmounts\n        if (prevConnections.current && prevConnections.current !== connections) {\n            const _connections = connections ?? new Map();\n            (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(prevConnections.current, _connections, onDisconnect);\n            (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(_connections, prevConnections.current, onConnect);\n        }\n        prevConnections.current = connections ?? new Map();\n    }, [\n        connections,\n        onConnect,\n        onDisconnect\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>Array.from(connections?.values() ?? []), [\n        connections\n    ]);\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction useNodesData(nodeIds) {\n    const nodesData = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((s)=>{\n        const data = [];\n        const isArrayOfIds = Array.isArray(nodeIds);\n        const _nodeIds = isArrayOfIds ? nodeIds : [\n            nodeIds\n        ];\n        for (const nodeId of _nodeIds){\n            const node = s.nodeLookup.get(nodeId);\n            if (node) {\n                data.push({\n                    id: node.id,\n                    type: node.type,\n                    data: node.data\n                });\n            }\n        }\n        return isArrayOfIds ? data : data[0] ?? null;\n    }, [\n        nodeIds\n    ]), _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.shallowNodeData);\n    return nodesData;\n}\n/**\n * This hook returns the internal representation of a specific node.\n * Components that use this hook will re-render **whenever the node changes**,\n * including when a node is selected or moved.\n *\n * @public\n * @param id - The ID of a node you want to observe.\n * @returns The `InternalNode` object for the node with the given ID.\n *\n * @example\n * ```tsx\n *import { useInternalNode } from '@xyflow/react';\n *\n *export default function () {\n *  const internalNode = useInternalNode('node-1');\n *  const absolutePosition = internalNode.internals.positionAbsolute;\n *\n *  return (\n *    <div>\n *      The absolute position of the node is at:\n *      <p>x: {absolutePosition.x}</p>\n *      <p>y: {absolutePosition.y}</p>\n *    </div>\n *  );\n *}\n *```\n */ function useInternalNode(id) {\n    const node = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((s)=>s.nodeLookup.get(id), [\n        id\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return node;\n}\nfunction LinePattern({ dimensions, lineWidth, variant, className }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        strokeWidth: lineWidth,\n        d: `M${dimensions[0] / 2} 0 V${dimensions[1]} M0 ${dimensions[1] / 2} H${dimensions[0]}`,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__background-pattern\",\n            variant,\n            className\n        ])\n    });\n}\nfunction DotPattern({ radius, className }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n        cx: radius,\n        cy: radius,\n        r: radius,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__background-pattern\",\n            \"dots\",\n            className\n        ])\n    });\n}\n/**\n * The three variants are exported as an enum for convenience. You can either import\n * the enum and use it like `BackgroundVariant.Lines` or you can use the raw string\n * value directly.\n * @public\n */ var BackgroundVariant;\n(function(BackgroundVariant) {\n    BackgroundVariant[\"Lines\"] = \"lines\";\n    BackgroundVariant[\"Dots\"] = \"dots\";\n    BackgroundVariant[\"Cross\"] = \"cross\";\n})(BackgroundVariant || (BackgroundVariant = {}));\nconst defaultSize = {\n    [BackgroundVariant.Dots]: 1,\n    [BackgroundVariant.Lines]: 1,\n    [BackgroundVariant.Cross]: 6\n};\nconst selector$3 = (s)=>({\n        transform: s.transform,\n        patternId: `pattern-${s.rfId}`\n    });\nfunction BackgroundComponent({ id, variant = BackgroundVariant.Dots, // only used for dots and cross\ngap = 20, // only used for lines and cross\nsize, lineWidth = 1, offset = 0, color, bgColor, style, className, patternClassName }) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { transform, patternId } = useStore(selector$3, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const patternSize = size || defaultSize[variant];\n    const isDots = variant === BackgroundVariant.Dots;\n    const isCross = variant === BackgroundVariant.Cross;\n    const gapXY = Array.isArray(gap) ? gap : [\n        gap,\n        gap\n    ];\n    const scaledGap = [\n        gapXY[0] * transform[2] || 1,\n        gapXY[1] * transform[2] || 1\n    ];\n    const scaledSize = patternSize * transform[2];\n    const offsetXY = Array.isArray(offset) ? offset : [\n        offset,\n        offset\n    ];\n    const patternDimensions = isCross ? [\n        scaledSize,\n        scaledSize\n    ] : scaledGap;\n    const scaledOffset = [\n        offsetXY[0] * transform[2] || 1 + patternDimensions[0] / 2,\n        offsetXY[1] * transform[2] || 1 + patternDimensions[1] / 2\n    ];\n    const _patternId = `${patternId}${id ? id : \"\"}`;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__background\",\n            className\n        ]),\n        style: {\n            ...style,\n            ...containerStyle,\n            \"--xy-background-color-props\": bgColor,\n            \"--xy-background-pattern-color-props\": color\n        },\n        ref: ref,\n        \"data-testid\": \"rf__background\",\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"pattern\", {\n                id: _patternId,\n                x: transform[0] % scaledGap[0],\n                y: transform[1] % scaledGap[1],\n                width: scaledGap[0],\n                height: scaledGap[1],\n                patternUnits: \"userSpaceOnUse\",\n                patternTransform: `translate(-${scaledOffset[0]},-${scaledOffset[1]})`,\n                children: isDots ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DotPattern, {\n                    radius: scaledSize / 2,\n                    className: patternClassName\n                }) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LinePattern, {\n                    dimensions: patternDimensions,\n                    lineWidth: lineWidth,\n                    variant: variant,\n                    className: patternClassName\n                })\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n                x: \"0\",\n                y: \"0\",\n                width: \"100%\",\n                height: \"100%\",\n                fill: `url(#${_patternId})`\n            })\n        ]\n    });\n}\nBackgroundComponent.displayName = \"Background\";\n/**\n * The `<Background />` component makes it convenient to render different types of backgrounds common in node-based UIs. It comes with three variants: lines, dots and cross.\n *\n * @example\n *\n * A simple example of how to use the Background component.\n *\n * ```tsx\n * import { useState } from 'react';\n * import { ReactFlow, Background, BackgroundVariant } from '@xyflow/react';\n *\n * export default function Flow() {\n *   return (\n *     <ReactFlow defaultNodes={[...]} defaultEdges={[...]}>\n *       <Background color=\"#ccc\" variant={BackgroundVariant.Dots} />\n *     </ReactFlow>\n *   );\n * }\n * ```\n *\n * @example\n *\n * In this example you can see how to combine multiple backgrounds\n *\n * ```tsx\n * import { ReactFlow, Background, BackgroundVariant } from '@xyflow/react';\n * import '@xyflow/react/dist/style.css';\n *\n * export default function Flow() {\n *   return (\n *     <ReactFlow defaultNodes={[...]} defaultEdges={[...]}>\n *       <Background\n *         id=\"1\"\n *         gap={10}\n *         color=\"#f1f1f1\"\n *         variant={BackgroundVariant.Lines}\n *       />\n *       <Background\n *         id=\"2\"\n *         gap={100}\n *         color=\"#ccc\"\n *         variant={BackgroundVariant.Lines}\n *       />\n *     </ReactFlow>\n *   );\n * }\n * ```\n *\n * @remarks\n *\n * When combining multiple <Background /> components it’s important to give each of them a unique id prop!\n *\n */ const Background = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(BackgroundComponent);\nfunction PlusIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z\"\n        })\n    });\n}\nfunction MinusIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 5\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M0 0h32v4.2H0z\"\n        })\n    });\n}\nfunction FitViewIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 30\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z\"\n        })\n    });\n}\nfunction LockIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 25 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z\"\n        })\n    });\n}\nfunction UnlockIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 25 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z\"\n        })\n    });\n}\n/**\n * You can add buttons to the control panel by using the `<ControlButton />` component\n * and pass it as a child to the [`<Controls />`](/api-reference/components/controls) component.\n *\n * @public\n * @example\n *```jsx\n *import { MagicWand } from '@radix-ui/react-icons'\n *import { ReactFlow, Controls, ControlButton } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[...]} edges={[...]}>\n *      <Controls>\n *        <ControlButton onClick={() => alert('Something magical just happened. ✨')}>\n *          <MagicWand />\n *        </ControlButton>\n *      </Controls>\n *    </ReactFlow>\n *  )\n *}\n *```\n */ function ControlButton({ children, className, ...rest }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n        type: \"button\",\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__controls-button\",\n            className\n        ]),\n        ...rest,\n        children: children\n    });\n}\nconst selector$2 = (s)=>({\n        isInteractive: s.nodesDraggable || s.nodesConnectable || s.elementsSelectable,\n        minZoomReached: s.transform[2] <= s.minZoom,\n        maxZoomReached: s.transform[2] >= s.maxZoom,\n        ariaLabelConfig: s.ariaLabelConfig\n    });\nfunction ControlsComponent({ style, showZoom = true, showFitView = true, showInteractive = true, fitViewOptions, onZoomIn, onZoomOut, onFitView, onInteractiveChange, className, children, position = \"bottom-left\", orientation = \"vertical\", \"aria-label\": ariaLabel }) {\n    const store = useStoreApi();\n    const { isInteractive, minZoomReached, maxZoomReached, ariaLabelConfig } = useStore(selector$2, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const { zoomIn, zoomOut, fitView } = useReactFlow();\n    const onZoomInHandler = ()=>{\n        zoomIn();\n        onZoomIn?.();\n    };\n    const onZoomOutHandler = ()=>{\n        zoomOut();\n        onZoomOut?.();\n    };\n    const onFitViewHandler = ()=>{\n        fitView(fitViewOptions);\n        onFitView?.();\n    };\n    const onToggleInteractivity = ()=>{\n        store.setState({\n            nodesDraggable: !isInteractive,\n            nodesConnectable: !isInteractive,\n            elementsSelectable: !isInteractive\n        });\n        onInteractiveChange?.(!isInteractive);\n    };\n    const orientationClass = orientation === \"horizontal\" ? \"horizontal\" : \"vertical\";\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Panel, {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__controls\",\n            orientationClass,\n            className\n        ]),\n        position: position,\n        style: style,\n        \"data-testid\": \"rf__controls\",\n        \"aria-label\": ariaLabel ?? ariaLabelConfig[\"controls.ariaLabel\"],\n        children: [\n            showZoom && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                children: [\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                        onClick: onZoomInHandler,\n                        className: \"react-flow__controls-zoomin\",\n                        title: ariaLabelConfig[\"controls.zoomIn.ariaLabel\"],\n                        \"aria-label\": ariaLabelConfig[\"controls.zoomIn.ariaLabel\"],\n                        disabled: maxZoomReached,\n                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PlusIcon, {})\n                    }),\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                        onClick: onZoomOutHandler,\n                        className: \"react-flow__controls-zoomout\",\n                        title: ariaLabelConfig[\"controls.zoomOut.ariaLabel\"],\n                        \"aria-label\": ariaLabelConfig[\"controls.zoomOut.ariaLabel\"],\n                        disabled: minZoomReached,\n                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MinusIcon, {})\n                    })\n                ]\n            }),\n            showFitView && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                className: \"react-flow__controls-fitview\",\n                onClick: onFitViewHandler,\n                title: ariaLabelConfig[\"controls.fitView.ariaLabel\"],\n                \"aria-label\": ariaLabelConfig[\"controls.fitView.ariaLabel\"],\n                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FitViewIcon, {})\n            }),\n            showInteractive && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                className: \"react-flow__controls-interactive\",\n                onClick: onToggleInteractivity,\n                title: ariaLabelConfig[\"controls.interactive.ariaLabel\"],\n                \"aria-label\": ariaLabelConfig[\"controls.interactive.ariaLabel\"],\n                children: isInteractive ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UnlockIcon, {}) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LockIcon, {})\n            }),\n            children\n        ]\n    });\n}\nControlsComponent.displayName = \"Controls\";\n/**\n * The `<Controls />` component renders a small panel that contains convenient\n * buttons to zoom in, zoom out, fit the view, and lock the viewport.\n *\n * @public\n * @example\n *```tsx\n *import { ReactFlow, Controls } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[...]} edges={[...]}>\n *      <Controls />\n *    </ReactFlow>\n *  )\n *}\n *```\n *\n * @remarks To extend or customise the controls, you can use the [`<ControlButton />`](/api-reference/components/control-button) component\n *\n */ const Controls = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(ControlsComponent);\nfunction MiniMapNodeComponent({ id, x, y, width, height, style, color, strokeColor, strokeWidth, className, borderRadius, shapeRendering, selected, onClick }) {\n    const { background, backgroundColor } = style || {};\n    const fill = color || background || backgroundColor;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__minimap-node\",\n            {\n                selected\n            },\n            className\n        ]),\n        x: x,\n        y: y,\n        rx: borderRadius,\n        ry: borderRadius,\n        width: width,\n        height: height,\n        style: {\n            fill,\n            stroke: strokeColor,\n            strokeWidth\n        },\n        shapeRendering: shapeRendering,\n        onClick: onClick ? (event)=>onClick(event, id) : undefined\n    });\n}\nconst MiniMapNode = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MiniMapNodeComponent);\nconst selectorNodeIds = (s)=>s.nodes.map((node)=>node.id);\nconst getAttrFunction = (func)=>func instanceof Function ? func : ()=>func;\nfunction MiniMapNodes({ nodeStrokeColor, nodeColor, nodeClassName = \"\", nodeBorderRadius = 5, nodeStrokeWidth, /*\n * We need to rename the prop to be `CapitalCase` so that JSX will render it as\n * a component properly.\n */ nodeComponent: NodeComponent = MiniMapNode, onClick }) {\n    const nodeIds = useStore(selectorNodeIds, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const nodeColorFunc = getAttrFunction(nodeColor);\n    const nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor);\n    const nodeClassNameFunc = getAttrFunction(nodeClassName);\n    const shapeRendering =  true ? \"crispEdges\" : 0;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: nodeIds.map((nodeId)=>/*\n         * The split of responsibilities between MiniMapNodes and\n         * NodeComponentWrapper may appear weird. However, it’s designed to\n         * minimize the cost of updates when individual nodes change.\n         *\n         * For more details, see a similar commit in `NodeRenderer/index.tsx`.\n         */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponentWrapper, {\n                id: nodeId,\n                nodeColorFunc: nodeColorFunc,\n                nodeStrokeColorFunc: nodeStrokeColorFunc,\n                nodeClassNameFunc: nodeClassNameFunc,\n                nodeBorderRadius: nodeBorderRadius,\n                nodeStrokeWidth: nodeStrokeWidth,\n                NodeComponent: NodeComponent,\n                onClick: onClick,\n                shapeRendering: shapeRendering\n            }, nodeId))\n    });\n}\nfunction NodeComponentWrapperInner({ id, nodeColorFunc, nodeStrokeColorFunc, nodeClassNameFunc, nodeBorderRadius, nodeStrokeWidth, shapeRendering, NodeComponent, onClick }) {\n    const { node, x, y, width, height } = useStore((s)=>{\n        const { internals } = s.nodeLookup.get(id);\n        const node = internals.userNode;\n        const { x, y } = internals.positionAbsolute;\n        const { width, height } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodeDimensions)(node);\n        return {\n            node,\n            x,\n            y,\n            width,\n            height\n        };\n    }, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    if (!node || node.hidden || !(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeHasDimensions)(node)) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponent, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        style: node.style,\n        selected: !!node.selected,\n        className: nodeClassNameFunc(node),\n        color: nodeColorFunc(node),\n        borderRadius: nodeBorderRadius,\n        strokeColor: nodeStrokeColorFunc(node),\n        strokeWidth: nodeStrokeWidth,\n        shapeRendering: shapeRendering,\n        onClick: onClick,\n        id: node.id\n    });\n}\nconst NodeComponentWrapper = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(NodeComponentWrapperInner);\nvar MiniMapNodes$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MiniMapNodes);\nconst defaultWidth = 200;\nconst defaultHeight = 150;\nconst filterHidden = (node)=>!node.hidden;\nconst selector$1 = (s)=>{\n    const viewBB = {\n        x: -s.transform[0] / s.transform[2],\n        y: -s.transform[1] / s.transform[2],\n        width: s.width / s.transform[2],\n        height: s.height / s.transform[2]\n    };\n    return {\n        viewBB,\n        boundingRect: s.nodeLookup.size > 0 ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBoundsOfRects)((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(s.nodeLookup, {\n            filter: filterHidden\n        }), viewBB) : viewBB,\n        rfId: s.rfId,\n        panZoom: s.panZoom,\n        translateExtent: s.translateExtent,\n        flowWidth: s.width,\n        flowHeight: s.height,\n        ariaLabelConfig: s.ariaLabelConfig\n    };\n};\nconst ARIA_LABEL_KEY = \"react-flow__minimap-desc\";\nfunction MiniMapComponent({ style, className, nodeStrokeColor, nodeColor, nodeClassName = \"\", nodeBorderRadius = 5, nodeStrokeWidth, /*\n * We need to rename the prop to be `CapitalCase` so that JSX will render it as\n * a component properly.\n */ nodeComponent, bgColor, maskColor, maskStrokeColor, maskStrokeWidth, position = \"bottom-right\", onClick, onNodeClick, pannable = false, zoomable = false, ariaLabel, inversePan, zoomStep = 1, offsetScale = 5 }) {\n    const store = useStoreApi();\n    const svg = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { boundingRect, viewBB, rfId, panZoom, translateExtent, flowWidth, flowHeight, ariaLabelConfig } = useStore(selector$1, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const elementWidth = style?.width ?? defaultWidth;\n    const elementHeight = style?.height ?? defaultHeight;\n    const scaledWidth = boundingRect.width / elementWidth;\n    const scaledHeight = boundingRect.height / elementHeight;\n    const viewScale = Math.max(scaledWidth, scaledHeight);\n    const viewWidth = viewScale * elementWidth;\n    const viewHeight = viewScale * elementHeight;\n    const offset = offsetScale * viewScale;\n    const x = boundingRect.x - (viewWidth - boundingRect.width) / 2 - offset;\n    const y = boundingRect.y - (viewHeight - boundingRect.height) / 2 - offset;\n    const width = viewWidth + offset * 2;\n    const height = viewHeight + offset * 2;\n    const labelledBy = `${ARIA_LABEL_KEY}-${rfId}`;\n    const viewScaleRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const minimapInstance = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    viewScaleRef.current = viewScale;\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (svg.current && panZoom) {\n            minimapInstance.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYMinimap)({\n                domNode: svg.current,\n                panZoom,\n                getTransform: ()=>store.getState().transform,\n                getViewScale: ()=>viewScaleRef.current\n            });\n            return ()=>{\n                minimapInstance.current?.destroy();\n            };\n        }\n    }, [\n        panZoom\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        minimapInstance.current?.update({\n            translateExtent,\n            width: flowWidth,\n            height: flowHeight,\n            inversePan,\n            pannable,\n            zoomStep,\n            zoomable\n        });\n    }, [\n        pannable,\n        zoomable,\n        inversePan,\n        zoomStep,\n        translateExtent,\n        flowWidth,\n        flowHeight\n    ]);\n    const onSvgClick = onClick ? (event)=>{\n        const [x, y] = minimapInstance.current?.pointer(event) || [\n            0,\n            0\n        ];\n        onClick(event, {\n            x,\n            y\n        });\n    } : undefined;\n    const onSvgNodeClick = onNodeClick ? (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event, nodeId)=>{\n        const node = store.getState().nodeLookup.get(nodeId).internals.userNode;\n        onNodeClick(event, node);\n    }, []) : undefined;\n    const _ariaLabel = ariaLabel ?? ariaLabelConfig[\"minimap.ariaLabel\"];\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Panel, {\n        position: position,\n        style: {\n            ...style,\n            \"--xy-minimap-background-color-props\": typeof bgColor === \"string\" ? bgColor : undefined,\n            \"--xy-minimap-mask-background-color-props\": typeof maskColor === \"string\" ? maskColor : undefined,\n            \"--xy-minimap-mask-stroke-color-props\": typeof maskStrokeColor === \"string\" ? maskStrokeColor : undefined,\n            \"--xy-minimap-mask-stroke-width-props\": typeof maskStrokeWidth === \"number\" ? maskStrokeWidth * viewScale : undefined,\n            \"--xy-minimap-node-background-color-props\": typeof nodeColor === \"string\" ? nodeColor : undefined,\n            \"--xy-minimap-node-stroke-color-props\": typeof nodeStrokeColor === \"string\" ? nodeStrokeColor : undefined,\n            \"--xy-minimap-node-stroke-width-props\": typeof nodeStrokeWidth === \"number\" ? nodeStrokeWidth : undefined\n        },\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__minimap\",\n            className\n        ]),\n        \"data-testid\": \"rf__minimap\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", {\n            width: elementWidth,\n            height: elementHeight,\n            viewBox: `${x} ${y} ${width} ${height}`,\n            className: \"react-flow__minimap-svg\",\n            role: \"img\",\n            \"aria-labelledby\": labelledBy,\n            ref: svg,\n            onClick: onSvgClick,\n            children: [\n                _ariaLabel && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"title\", {\n                    id: labelledBy,\n                    children: _ariaLabel\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MiniMapNodes$1, {\n                    onClick: onSvgNodeClick,\n                    nodeColor: nodeColor,\n                    nodeStrokeColor: nodeStrokeColor,\n                    nodeBorderRadius: nodeBorderRadius,\n                    nodeClassName: nodeClassName,\n                    nodeStrokeWidth: nodeStrokeWidth,\n                    nodeComponent: nodeComponent\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    className: \"react-flow__minimap-mask\",\n                    d: `M${x - offset},${y - offset}h${width + offset * 2}v${height + offset * 2}h${-width - offset * 2}z\n        M${viewBB.x},${viewBB.y}h${viewBB.width}v${viewBB.height}h${-viewBB.width}z`,\n                    fillRule: \"evenodd\",\n                    pointerEvents: \"none\"\n                })\n            ]\n        })\n    });\n}\nMiniMapComponent.displayName = \"MiniMap\";\n/**\n * The `<MiniMap />` component can be used to render an overview of your flow. It\n * renders each node as an SVG element and visualizes where the current viewport is\n * in relation to the rest of the flow.\n *\n * @public\n * @example\n *\n * ```jsx\n *import { ReactFlow, MiniMap } from '@xyflow/react';\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[...]]} edges={[...]]}>\n *      <MiniMap nodeStrokeWidth={3} />\n *    </ReactFlow>\n *  );\n *}\n *```\n */ const MiniMap = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MiniMapComponent);\nconst scaleSelector = (calculateScale)=>(store)=>calculateScale ? `${Math.max(1 / store.transform[2], 1)}` : undefined;\nconst defaultPositions = {\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Line]: \"right\",\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Handle]: \"bottom-right\"\n};\nfunction ResizeControl({ nodeId, position, variant = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Handle, className, style = undefined, children, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, resizeDirection, autoScale = true, shouldResize, onResizeStart, onResize, onResizeEnd }) {\n    const contextNodeId = useNodeId();\n    const id = typeof nodeId === \"string\" ? nodeId : contextNodeId;\n    const store = useStoreApi();\n    const resizeControlRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const isHandleControl = variant === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Handle;\n    const scale = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(scaleSelector(isHandleControl && autoScale), [\n        isHandleControl,\n        autoScale\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const resizer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const controlPosition = position ?? defaultPositions[variant];\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!resizeControlRef.current || !id) {\n            return;\n        }\n        if (!resizer.current) {\n            resizer.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYResizer)({\n                domNode: resizeControlRef.current,\n                nodeId: id,\n                getStoreItems: ()=>{\n                    const { nodeLookup, transform, snapGrid, snapToGrid, nodeOrigin, domNode } = store.getState();\n                    return {\n                        nodeLookup,\n                        transform,\n                        snapGrid,\n                        snapToGrid,\n                        nodeOrigin,\n                        paneDomNode: domNode\n                    };\n                },\n                onChange: (change, childChanges)=>{\n                    const { triggerNodeChanges, nodeLookup, parentLookup, nodeOrigin } = store.getState();\n                    const changes = [];\n                    const nextPosition = {\n                        x: change.x,\n                        y: change.y\n                    };\n                    const node = nodeLookup.get(id);\n                    if (node && node.expandParent && node.parentId) {\n                        const origin = node.origin ?? nodeOrigin;\n                        const width = change.width ?? node.measured.width ?? 0;\n                        const height = change.height ?? node.measured.height ?? 0;\n                        const child = {\n                            id: node.id,\n                            parentId: node.parentId,\n                            rect: {\n                                width,\n                                height,\n                                ...(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.evaluateAbsolutePosition)({\n                                    x: change.x ?? node.position.x,\n                                    y: change.y ?? node.position.y\n                                }, {\n                                    width,\n                                    height\n                                }, node.parentId, nodeLookup, origin)\n                            }\n                        };\n                        const parentExpandChanges = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleExpandParent)([\n                            child\n                        ], nodeLookup, parentLookup, nodeOrigin);\n                        changes.push(...parentExpandChanges);\n                        /*\n                         * when the parent was expanded by the child node, its position will be clamped at\n                         * 0,0 when node origin is 0,0 and to width, height if it's 1,1\n                         */ nextPosition.x = change.x ? Math.max(origin[0] * width, change.x) : undefined;\n                        nextPosition.y = change.y ? Math.max(origin[1] * height, change.y) : undefined;\n                    }\n                    if (nextPosition.x !== undefined && nextPosition.y !== undefined) {\n                        const positionChange = {\n                            id,\n                            type: \"position\",\n                            position: {\n                                ...nextPosition\n                            }\n                        };\n                        changes.push(positionChange);\n                    }\n                    if (change.width !== undefined && change.height !== undefined) {\n                        const setAttributes = !resizeDirection ? true : resizeDirection === \"horizontal\" ? \"width\" : \"height\";\n                        const dimensionChange = {\n                            id,\n                            type: \"dimensions\",\n                            resizing: true,\n                            setAttributes,\n                            dimensions: {\n                                width: change.width,\n                                height: change.height\n                            }\n                        };\n                        changes.push(dimensionChange);\n                    }\n                    for (const childChange of childChanges){\n                        const positionChange = {\n                            ...childChange,\n                            type: \"position\"\n                        };\n                        changes.push(positionChange);\n                    }\n                    triggerNodeChanges(changes);\n                },\n                onEnd: ({ width, height })=>{\n                    const dimensionChange = {\n                        id: id,\n                        type: \"dimensions\",\n                        resizing: false,\n                        dimensions: {\n                            width,\n                            height\n                        }\n                    };\n                    store.getState().triggerNodeChanges([\n                        dimensionChange\n                    ]);\n                }\n            });\n        }\n        resizer.current.update({\n            controlPosition,\n            boundaries: {\n                minWidth,\n                minHeight,\n                maxWidth,\n                maxHeight\n            },\n            keepAspectRatio,\n            resizeDirection,\n            onResizeStart,\n            onResize,\n            onResizeEnd,\n            shouldResize\n        });\n        return ()=>{\n            resizer.current?.destroy();\n        };\n    }, [\n        controlPosition,\n        minWidth,\n        minHeight,\n        maxWidth,\n        maxHeight,\n        keepAspectRatio,\n        onResizeStart,\n        onResize,\n        onResizeEnd,\n        shouldResize\n    ]);\n    const positionClassNames = controlPosition.split(\"-\");\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__resize-control\",\n            \"nodrag\",\n            ...positionClassNames,\n            variant,\n            className\n        ]),\n        ref: resizeControlRef,\n        style: {\n            ...style,\n            scale,\n            ...color && {\n                [isHandleControl ? \"backgroundColor\" : \"borderColor\"]: color\n            }\n        },\n        children: children\n    });\n}\n/**\n * To create your own resizing UI, you can use the `NodeResizeControl` component where you can pass children (such as icons).\n * @public\n *\n */ const NodeResizeControl = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(ResizeControl);\n/**\n * The `<NodeResizer />` component can be used to add a resize functionality to your\n * nodes. It renders draggable controls around the node to resize in all directions.\n * @public\n *\n * @example\n *```jsx\n *import { memo } from 'react';\n *import { Handle, Position, NodeResizer } from '@xyflow/react';\n *\n *function ResizableNode({ data }) {\n *  return (\n *    <>\n *      <NodeResizer minWidth={100} minHeight={30} />\n *      <Handle type=\"target\" position={Position.Left} />\n *      <div style={{ padding: 10 }}>{data.label}</div>\n *      <Handle type=\"source\" position={Position.Right} />\n *    </>\n *  );\n *};\n *\n *export default memo(ResizableNode);\n *```\n */ function NodeResizer({ nodeId, isVisible = true, handleClassName, handleStyle, lineClassName, lineStyle, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, autoScale = true, shouldResize, onResizeStart, onResize, onResizeEnd }) {\n    if (!isVisible) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XY_RESIZER_LINE_POSITIONS.map((position)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeResizeControl, {\n                    className: lineClassName,\n                    style: lineStyle,\n                    nodeId: nodeId,\n                    position: position,\n                    variant: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Line,\n                    color: color,\n                    minWidth: minWidth,\n                    minHeight: minHeight,\n                    maxWidth: maxWidth,\n                    maxHeight: maxHeight,\n                    onResizeStart: onResizeStart,\n                    keepAspectRatio: keepAspectRatio,\n                    autoScale: autoScale,\n                    shouldResize: shouldResize,\n                    onResize: onResize,\n                    onResizeEnd: onResizeEnd\n                }, position)),\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XY_RESIZER_HANDLE_POSITIONS.map((position)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeResizeControl, {\n                    className: handleClassName,\n                    style: handleStyle,\n                    nodeId: nodeId,\n                    position: position,\n                    color: color,\n                    minWidth: minWidth,\n                    minHeight: minHeight,\n                    maxWidth: maxWidth,\n                    maxHeight: maxHeight,\n                    onResizeStart: onResizeStart,\n                    keepAspectRatio: keepAspectRatio,\n                    autoScale: autoScale,\n                    shouldResize: shouldResize,\n                    onResize: onResize,\n                    onResizeEnd: onResizeEnd\n                }, position))\n        ]\n    });\n}\nconst selector = (state)=>state.domNode?.querySelector(\".react-flow__renderer\");\nfunction NodeToolbarPortal({ children }) {\n    const wrapperRef = useStore(selector);\n    if (!wrapperRef) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, wrapperRef);\n}\nconst nodeEqualityFn = (a, b)=>a?.internals.positionAbsolute.x !== b?.internals.positionAbsolute.x || a?.internals.positionAbsolute.y !== b?.internals.positionAbsolute.y || a?.measured.width !== b?.measured.width || a?.measured.height !== b?.measured.height || a?.selected !== b?.selected || a?.internals.z !== b?.internals.z;\nconst nodesEqualityFn = (a, b)=>{\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const [key, node] of a){\n        if (nodeEqualityFn(node, b.get(key))) {\n            return false;\n        }\n    }\n    return true;\n};\nconst storeSelector = (state)=>({\n        x: state.transform[0],\n        y: state.transform[1],\n        zoom: state.transform[2],\n        selectedNodesCount: state.nodes.filter((node)=>node.selected).length\n    });\n/**\n * This component can render a toolbar or tooltip to one side of a custom node. This\n * toolbar doesn't scale with the viewport so that the content is always visible.\n *\n * @public\n * @example\n * ```jsx\n *import { memo } from 'react';\n *import { Handle, Position, NodeToolbar } from '@xyflow/react';\n *\n *function CustomNode({ data }) {\n *  return (\n *    <>\n *      <NodeToolbar isVisible={data.toolbarVisible} position={data.toolbarPosition}>\n *        <button>delete</button>\n *        <button>copy</button>\n *        <button>expand</button>\n *      </NodeToolbar>\n *\n *      <div style={{ padding: '10px 20px' }}>\n *        {data.label}\n *      </div>\n *\n *      <Handle type=\"target\" position={Position.Left} />\n *      <Handle type=\"source\" position={Position.Right} />\n *    </>\n *  );\n *};\n *\n *export default memo(CustomNode);\n *```\n * @remarks By default, the toolbar is only visible when a node is selected. If multiple\n * nodes are selected it will not be visible to prevent overlapping toolbars or\n * clutter. You can override this behavior by setting the `isVisible` prop to `true`.\n */ function NodeToolbar({ nodeId, children, className, style, isVisible, position = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, offset = 10, align = \"center\", ...rest }) {\n    const contextNodeId = useNodeId();\n    const nodesSelector = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((state)=>{\n        const nodeIds = Array.isArray(nodeId) ? nodeId : [\n            nodeId || contextNodeId || \"\"\n        ];\n        const internalNodes = nodeIds.reduce((res, id)=>{\n            const node = state.nodeLookup.get(id);\n            if (node) {\n                res.set(node.id, node);\n            }\n            return res;\n        }, new Map());\n        return internalNodes;\n    }, [\n        nodeId,\n        contextNodeId\n    ]);\n    const nodes = useStore(nodesSelector, nodesEqualityFn);\n    const { x, y, zoom, selectedNodesCount } = useStore(storeSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    // if isVisible is not set, we show the toolbar only if its node is selected and no other node is selected\n    const isActive = typeof isVisible === \"boolean\" ? isVisible : nodes.size === 1 && nodes.values().next().value?.selected && selectedNodesCount === 1;\n    if (!isActive || !nodes.size) {\n        return null;\n    }\n    const nodeRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(nodes);\n    const nodesArray = Array.from(nodes.values());\n    const zIndex = Math.max(...nodesArray.map((node)=>node.internals.z + 1));\n    const wrapperStyle = {\n        position: \"absolute\",\n        transform: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodeToolbarTransform)(nodeRect, {\n            x,\n            y,\n            zoom\n        }, position, offset, align),\n        zIndex,\n        ...style\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeToolbarPortal, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n            style: wrapperStyle,\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                \"react-flow__node-toolbar\",\n                className\n            ]),\n            ...rest,\n            \"data-id\": nodesArray.reduce((acc, node)=>`${acc}${node.id} `, \"\").trim(),\n            children: children\n        })\n    });\n}\nconst zoomSelector = (state)=>state.transform[2];\n/**\n * This component can render a toolbar or tooltip to one side of a custom edge. This\n * toolbar doesn't scale with the viewport so that the content stays the same size.\n *\n * @public\n * @example\n * ```jsx\n * import { EdgeToolbar, BaseEdge, getBezierPath, type EdgeProps } from \"@xyflow/react\";\n *\n * export function CustomEdge({ id, data, ...props }: EdgeProps) {\n *   const [edgePath, centerX, centerY] = getBezierPath(props);\n *\n *   return (\n *     <>\n *       <BaseEdge id={id} path={edgePath} />\n *       <EdgeToolbar edgeId={id} x={centerX} y={centerY} isVisible>\n *         <button onClick={() => console.log('edge', id, 'click')}}>Click me</button>\n *       </EdgeToolbar>\n *     </>\n *   );\n * }\n * ```\n */ function EdgeToolbar({ edgeId, x, y, children, className, style, isVisible, alignX = \"center\", alignY = \"center\", ...rest }) {\n    const edgeSelector = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((state)=>state.edgeLookup.get(edgeId), [\n        edgeId\n    ]);\n    const edge = useStore(edgeSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const isActive = typeof isVisible === \"boolean\" ? isVisible : edge?.selected;\n    const zoom = useStore(zoomSelector);\n    if (!isActive) {\n        return null;\n    }\n    const zIndex = (edge?.zIndex ?? 0) + 1;\n    const transform = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEdgeToolbarTransform)(x, y, zoom, alignX, alignY);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeLabelRenderer, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n            style: {\n                position: \"absolute\",\n                transform,\n                zIndex,\n                pointerEvents: \"all\",\n                transformOrigin: \"0 0\",\n                ...style\n            },\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                \"react-flow__edge-toolbar\",\n                className\n            ]),\n            \"data-id\": edge?.id ?? \"\",\n            ...rest,\n            children: children\n        })\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9yZWFjdC9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzQ4QkFDd0Q7QUFDZ0Y7QUFDOUc7QUFDMnRDO0FBQ242QjtBQUMvUDtBQUN6QztBQUNEO0FBRXpDLE1BQU04Riw2QkFBZTNGLG9EQUFhQSxDQUFDO0FBQ25DLE1BQU00RixhQUFhRCxhQUFhRSxRQUFRO0FBRXhDLE1BQU1DLHNCQUFzQm5GLHlEQUFhLENBQUMsV0FBVztBQUNyRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNCQyxHQUNELFNBQVNvRixTQUFTQyxRQUFRLEVBQUVDLFVBQVU7SUFDbEMsTUFBTUMsUUFBUWpHLGlEQUFVQSxDQUFDMEY7SUFDekIsSUFBSU8sVUFBVSxNQUFNO1FBQ2hCLE1BQU0sSUFBSUMsTUFBTUw7SUFDcEI7SUFDQSxPQUFPUCwyRUFBc0JBLENBQUNXLE9BQU9GLFVBQVVDO0FBQ25EO0FBQ0E7Ozs7Ozs7Ozs7OztDQVlDLEdBQ0QsU0FBU0c7SUFDTCxNQUFNRixRQUFRakcsaURBQVVBLENBQUMwRjtJQUN6QixJQUFJTyxVQUFVLE1BQU07UUFDaEIsTUFBTSxJQUFJQyxNQUFNTDtJQUNwQjtJQUNBLE9BQU81Riw4Q0FBT0EsQ0FBQyxJQUFPO1lBQ2xCbUcsVUFBVUgsTUFBTUcsUUFBUTtZQUN4QkMsVUFBVUosTUFBTUksUUFBUTtZQUN4QkMsV0FBV0wsTUFBTUssU0FBUztRQUM5QixJQUFJO1FBQUNMO0tBQU07QUFDZjtBQUVBLE1BQU1NLFFBQVE7SUFBRUMsU0FBUztBQUFPO0FBQ2hDLE1BQU1DLGdCQUFnQjtJQUNsQkMsVUFBVTtJQUNWQyxPQUFPO0lBQ1BDLFFBQVE7SUFDUkMsUUFBUSxDQUFDO0lBQ1RDLFFBQVE7SUFDUkMsU0FBUztJQUNUQyxVQUFVO0lBQ1ZDLE1BQU07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NEJ5SDthQUFVO1lBQUcsV0FBV3FCLE1BQU0xQixNQUFNO1lBQUksR0FBR00sSUFBSTtZQUFFTCxVQUFVQTtRQUFTO0lBQUc7QUFDakk7QUFFMHJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2FpbG8tZ3Jvd3RoLW5leHRqcy8uL25vZGVfbW9kdWxlcy9AeHlmbG93L3JlYWN0L2Rpc3QvZXNtL2luZGV4LmpzP2ZhM2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCJcbmltcG9ydCB7IGpzeHMsIEZyYWdtZW50LCBqc3ggfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VNZW1vLCBmb3J3YXJkUmVmLCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUxheW91dEVmZmVjdCwgdXNlQ2FsbGJhY2ssIG1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY2MgZnJvbSAnY2xhc3NjYXQnO1xuaW1wb3J0IHsgZXJyb3JNZXNzYWdlcywgbWVyZ2VBcmlhTGFiZWxDb25maWcsIGluZmluaXRlRXh0ZW50LCBpc0lucHV0RE9NTm9kZSwgZ2V0Vmlld3BvcnRGb3JCb3VuZHMsIHBvaW50VG9SZW5kZXJlclBvaW50LCByZW5kZXJlclBvaW50VG9Qb2ludCwgaXNOb2RlQmFzZSwgaXNFZGdlQmFzZSwgZ2V0RWxlbWVudHNUb1JlbW92ZSwgaXNSZWN0T2JqZWN0LCBub2RlVG9SZWN0LCBnZXRPdmVybGFwcGluZ0FyZWEsIGdldE5vZGVzQm91bmRzLCB3aXRoUmVzb2x2ZXJzLCBldmFsdWF0ZUFic29sdXRlUG9zaXRpb24sIGdldERpbWVuc2lvbnMsIFhZUGFuWm9vbSwgUGFuT25TY3JvbGxNb2RlLCBTZWxlY3Rpb25Nb2RlLCBnZXRFdmVudFBvc2l0aW9uLCBnZXROb2Rlc0luc2lkZSwgYXJlU2V0c0VxdWFsLCBYWURyYWcsIHNuYXBQb3NpdGlvbiwgY2FsY3VsYXRlTm9kZVBvc2l0aW9uLCBQb3NpdGlvbiwgQ29ubmVjdGlvbk1vZGUsIGlzTW91c2VFdmVudCwgWFlIYW5kbGUsIGdldEhvc3RGb3JFbGVtZW50LCBhZGRFZGdlLCBnZXRJbnRlcm5hbE5vZGVzQm91bmRzLCBpc051bWVyaWMsIG5vZGVIYXNEaW1lbnNpb25zLCBnZXROb2RlRGltZW5zaW9ucywgZWxlbWVudFNlbGVjdGlvbktleXMsIGlzRWRnZVZpc2libGUsIE1hcmtlclR5cGUsIGNyZWF0ZU1hcmtlcklkcywgZ2V0QmV6aWVyRWRnZUNlbnRlciwgZ2V0U21vb3RoU3RlcFBhdGgsIGdldFN0cmFpZ2h0UGF0aCwgZ2V0QmV6aWVyUGF0aCwgZ2V0RWRnZVBvc2l0aW9uLCBnZXRFbGV2YXRlZEVkZ2VaSW5kZXgsIGdldE1hcmtlcklkLCBnZXRDb25uZWN0aW9uU3RhdHVzLCBDb25uZWN0aW9uTGluZVR5cGUsIHVwZGF0ZUNvbm5lY3Rpb25Mb29rdXAsIGFkb3B0VXNlck5vZGVzLCBpbml0aWFsQ29ubmVjdGlvbiwgZGV2V2FybiwgZGVmYXVsdEFyaWFMYWJlbENvbmZpZywgdXBkYXRlTm9kZUludGVybmFscywgdXBkYXRlQWJzb2x1dGVQb3NpdGlvbnMsIGhhbmRsZUV4cGFuZFBhcmVudCwgcGFuQnksIGZpdFZpZXdwb3J0LCBpc01hY09zLCBhcmVDb25uZWN0aW9uTWFwc0VxdWFsLCBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlLCBzaGFsbG93Tm9kZURhdGEsIFhZTWluaW1hcCwgZ2V0Qm91bmRzT2ZSZWN0cywgUmVzaXplQ29udHJvbFZhcmlhbnQsIFhZUmVzaXplciwgWFlfUkVTSVpFUl9MSU5FX1BPU0lUSU9OUywgWFlfUkVTSVpFUl9IQU5ETEVfUE9TSVRJT05TLCBnZXROb2RlVG9vbGJhclRyYW5zZm9ybSwgZ2V0RWRnZVRvb2xiYXJUcmFuc2Zvcm0gfSBmcm9tICdAeHlmbG93L3N5c3RlbSc7XG5leHBvcnQgeyBDb25uZWN0aW9uTGluZVR5cGUsIENvbm5lY3Rpb25Nb2RlLCBNYXJrZXJUeXBlLCBQYW5PblNjcm9sbE1vZGUsIFBvc2l0aW9uLCBSZXNpemVDb250cm9sVmFyaWFudCwgU2VsZWN0aW9uTW9kZSwgYWRkRWRnZSwgZ2V0QmV6aWVyRWRnZUNlbnRlciwgZ2V0QmV6aWVyUGF0aCwgZ2V0Q29ubmVjdGVkRWRnZXMsIGdldEVkZ2VDZW50ZXIsIGdldEluY29tZXJzLCBnZXROb2Rlc0JvdW5kcywgZ2V0T3V0Z29lcnMsIGdldFNtb290aFN0ZXBQYXRoLCBnZXRTdHJhaWdodFBhdGgsIGdldFZpZXdwb3J0Rm9yQm91bmRzLCByZWNvbm5lY3RFZGdlIH0gZnJvbSAnQHh5Zmxvdy9zeXN0ZW0nO1xuaW1wb3J0IHsgdXNlU3RvcmVXaXRoRXF1YWxpdHlGbiwgY3JlYXRlV2l0aEVxdWFsaXR5Rm4gfSBmcm9tICd6dXN0YW5kL3RyYWRpdGlvbmFsJztcbmltcG9ydCB7IHNoYWxsb3cgfSBmcm9tICd6dXN0YW5kL3NoYWxsb3cnO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIH0gZnJvbSAncmVhY3QtZG9tJztcblxuY29uc3QgU3RvcmVDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcbmNvbnN0IFByb3ZpZGVyJDEgPSBTdG9yZUNvbnRleHQuUHJvdmlkZXI7XG5cbmNvbnN0IHp1c3RhbmRFcnJvck1lc3NhZ2UgPSBlcnJvck1lc3NhZ2VzWydlcnJvcjAwMSddKCk7XG4vKipcbiAqIFRoaXMgaG9vayBjYW4gYmUgdXNlZCB0byBzdWJzY3JpYmUgdG8gaW50ZXJuYWwgc3RhdGUgY2hhbmdlcyBvZiB0aGUgUmVhY3QgRmxvd1xuICogY29tcG9uZW50LiBUaGUgYHVzZVN0b3JlYCBob29rIGlzIHJlLWV4cG9ydGVkIGZyb20gdGhlIFtadXN0YW5kXShodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3p1c3RhbmQpXG4gKiBzdGF0ZSBtYW5hZ2VtZW50IGxpYnJhcnksIHNvIHlvdSBzaG91bGQgY2hlY2sgb3V0IHRoZWlyIGRvY3MgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gc2VsZWN0b3IgLSBBIHNlbGVjdG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNsaWNlIG9mIHRoZSBmbG93J3MgaW50ZXJuYWwgc3RhdGUuXG4gKiBFeHRyYWN0aW5nIG9yIHRyYW5zZm9ybWluZyBqdXN0IHRoZSBzdGF0ZSB5b3UgbmVlZCBpcyBhIGdvb2QgcHJhY3RpY2UgdG8gYXZvaWQgdW5uZWNlc3NhcnlcbiAqIHJlLXJlbmRlcnMuXG4gKiBAcGFyYW0gZXF1YWxpdHlGbiAtIEEgZnVuY3Rpb24gdG8gY29tcGFyZSB0aGUgcHJldmlvdXMgYW5kIG5leHQgdmFsdWUuIFRoaXMgaXMgaW5jcmVkaWJseSB1c2VmdWxcbiAqIGZvciBwcmV2ZW50aW5nIHVubmVjZXNzYXJ5IHJlLXJlbmRlcnMuIEdvb2Qgc2Vuc2libGUgZGVmYXVsdHMgYXJlIHVzaW5nIGBPYmplY3QuaXNgIG9yIGltcG9ydGluZ1xuICogYHp1c3RhbmQvc2hhbGxvd2AsIGJ1dCB5b3UgY2FuIGJlIGFzIGdyYW51bGFyIGFzIHlvdSBsaWtlLlxuICogQHJldHVybnMgVGhlIHNlbGVjdGVkIHN0YXRlIHNsaWNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29uc3Qgbm9kZXMgPSB1c2VTdG9yZSgoc3RhdGUpID0+IHN0YXRlLm5vZGVzKTtcbiAqIGBgYFxuICpcbiAqIEByZW1hcmtzIFRoaXMgaG9vayBzaG91bGQgb25seSBiZSB1c2VkIGlmIHRoZXJlIGlzIG5vIG90aGVyIHdheSB0byBhY2Nlc3MgdGhlIGludGVybmFsXG4gKiBzdGF0ZS4gRm9yIG1hbnkgb2YgdGhlIGNvbW1vbiB1c2UgY2FzZXMsIHRoZXJlIGFyZSBkZWRpY2F0ZWQgaG9va3MgYXZhaWxhYmxlXG4gKiBzdWNoIGFzIHtAbGluayB1c2VSZWFjdEZsb3d9LCB7QGxpbmsgdXNlVmlld3BvcnR9LCBldGMuXG4gKi9cbmZ1bmN0aW9uIHVzZVN0b3JlKHNlbGVjdG9yLCBlcXVhbGl0eUZuKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VDb250ZXh0KFN0b3JlQ29udGV4dCk7XG4gICAgaWYgKHN0b3JlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih6dXN0YW5kRXJyb3JNZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZVN0b3JlV2l0aEVxdWFsaXR5Rm4oc3RvcmUsIHNlbGVjdG9yLCBlcXVhbGl0eUZuKTtcbn1cbi8qKlxuICogSW4gc29tZSBjYXNlcywgeW91IG1pZ2h0IG5lZWQgdG8gYWNjZXNzIHRoZSBzdG9yZSBkaXJlY3RseS4gVGhpcyBob29rIHJldHVybnMgdGhlIHN0b3JlIG9iamVjdCB3aGljaCBjYW4gYmUgdXNlZCBvbiBkZW1hbmQgdG8gYWNjZXNzIHRoZSBzdGF0ZSBvciBkaXNwYXRjaCBhY3Rpb25zLlxuICpcbiAqIEByZXR1cm5zIFRoZSBzdG9yZSBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAqIGBgYFxuICpcbiAqIEByZW1hcmtzIFRoaXMgaG9vayBzaG91bGQgb25seSBiZSB1c2VkIGlmIHRoZXJlIGlzIG5vIG90aGVyIHdheSB0byBhY2Nlc3MgdGhlIGludGVybmFsXG4gKiBzdGF0ZS4gRm9yIG1hbnkgb2YgdGhlIGNvbW1vbiB1c2UgY2FzZXMsIHRoZXJlIGFyZSBkZWRpY2F0ZWQgaG9va3MgYXZhaWxhYmxlXG4gKiBzdWNoIGFzIHtAbGluayB1c2VSZWFjdEZsb3d9LCB7QGxpbmsgdXNlVmlld3BvcnR9LCBldGMuXG4gKi9cbmZ1bmN0aW9uIHVzZVN0b3JlQXBpKCkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlQ29udGV4dChTdG9yZUNvbnRleHQpO1xuICAgIGlmIChzdG9yZSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoenVzdGFuZEVycm9yTWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiB1c2VNZW1vKCgpID0+ICh7XG4gICAgICAgIGdldFN0YXRlOiBzdG9yZS5nZXRTdGF0ZSxcbiAgICAgICAgc2V0U3RhdGU6IHN0b3JlLnNldFN0YXRlLFxuICAgICAgICBzdWJzY3JpYmU6IHN0b3JlLnN1YnNjcmliZSxcbiAgICB9KSwgW3N0b3JlXSk7XG59XG5cbmNvbnN0IHN0eWxlID0geyBkaXNwbGF5OiAnbm9uZScgfTtcbmNvbnN0IGFyaWFMaXZlU3R5bGUgPSB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgd2lkdGg6IDEsXG4gICAgaGVpZ2h0OiAxLFxuICAgIG1hcmdpbjogLTEsXG4gICAgYm9yZGVyOiAwLFxuICAgIHBhZGRpbmc6IDAsXG4gICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgIGNsaXA6ICdyZWN0KDBweCwgMHB4LCAwcHgsIDBweCknLFxuICAgIGNsaXBQYXRoOiAnaW5zZXQoMTAwJSknLFxufTtcbmNvbnN0IEFSSUFfTk9ERV9ERVNDX0tFWSA9ICdyZWFjdC1mbG93X19ub2RlLWRlc2MnO1xuY29uc3QgQVJJQV9FREdFX0RFU0NfS0VZID0gJ3JlYWN0LWZsb3dfX2VkZ2UtZGVzYyc7XG5jb25zdCBBUklBX0xJVkVfTUVTU0FHRSA9ICdyZWFjdC1mbG93X19hcmlhLWxpdmUnO1xuY29uc3QgYXJpYUxpdmVTZWxlY3RvciA9IChzKSA9PiBzLmFyaWFMaXZlTWVzc2FnZTtcbmNvbnN0IGFyaWFMYWJlbENvbmZpZ1NlbGVjdG9yID0gKHMpID0+IHMuYXJpYUxhYmVsQ29uZmlnO1xuZnVuY3Rpb24gQXJpYUxpdmVNZXNzYWdlKHsgcmZJZCB9KSB7XG4gICAgY29uc3QgYXJpYUxpdmVNZXNzYWdlID0gdXNlU3RvcmUoYXJpYUxpdmVTZWxlY3Rvcik7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBpZDogYCR7QVJJQV9MSVZFX01FU1NBR0V9LSR7cmZJZH1gLCBcImFyaWEtbGl2ZVwiOiBcImFzc2VydGl2ZVwiLCBcImFyaWEtYXRvbWljXCI6IFwidHJ1ZVwiLCBzdHlsZTogYXJpYUxpdmVTdHlsZSwgY2hpbGRyZW46IGFyaWFMaXZlTWVzc2FnZSB9KSk7XG59XG5mdW5jdGlvbiBBMTF5RGVzY3JpcHRpb25zKHsgcmZJZCwgZGlzYWJsZUtleWJvYXJkQTExeSB9KSB7XG4gICAgY29uc3QgYXJpYUxhYmVsQ29uZmlnID0gdXNlU3RvcmUoYXJpYUxhYmVsQ29uZmlnU2VsZWN0b3IpO1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeChcImRpdlwiLCB7IGlkOiBgJHtBUklBX05PREVfREVTQ19LRVl9LSR7cmZJZH1gLCBzdHlsZTogc3R5bGUsIGNoaWxkcmVuOiBkaXNhYmxlS2V5Ym9hcmRBMTF5XG4gICAgICAgICAgICAgICAgICAgID8gYXJpYUxhYmVsQ29uZmlnWydub2RlLmExMXlEZXNjcmlwdGlvbi5kZWZhdWx0J11cbiAgICAgICAgICAgICAgICAgICAgOiBhcmlhTGFiZWxDb25maWdbJ25vZGUuYTExeURlc2NyaXB0aW9uLmtleWJvYXJkRGlzYWJsZWQnXSB9KSwganN4KFwiZGl2XCIsIHsgaWQ6IGAke0FSSUFfRURHRV9ERVNDX0tFWX0tJHtyZklkfWAsIHN0eWxlOiBzdHlsZSwgY2hpbGRyZW46IGFyaWFMYWJlbENvbmZpZ1snZWRnZS5hMTF5RGVzY3JpcHRpb24uZGVmYXVsdCddIH0pLCAhZGlzYWJsZUtleWJvYXJkQTExeSAmJiBqc3goQXJpYUxpdmVNZXNzYWdlLCB7IHJmSWQ6IHJmSWQgfSldIH0pKTtcbn1cblxuLyoqXG4gKiBUaGUgYDxQYW5lbCAvPmAgY29tcG9uZW50IGhlbHBzIHlvdSBwb3NpdGlvbiBjb250ZW50IGFib3ZlIHRoZSB2aWV3cG9ydC5cbiAqIEl0IGlzIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgW2A8TWluaU1hcCAvPmBdKC9hcGktcmVmZXJlbmNlL2NvbXBvbmVudHMvbWluaW1hcClcbiAqIGFuZCBbYDxDb250cm9scyAvPmBdKC9hcGktcmVmZXJlbmNlL2NvbXBvbmVudHMvY29udHJvbHMpIGNvbXBvbmVudHMuXG4gKlxuICogQHB1YmxpY1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCBCYWNrZ3JvdW5kLCBQYW5lbCB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmxvdygpIHtcbiAqICByZXR1cm4gKFxuICogICAgPFJlYWN0RmxvdyBub2Rlcz17W119IGZpdFZpZXc+XG4gKiAgICAgIDxQYW5lbCBwb3NpdGlvbj1cInRvcC1sZWZ0XCI+dG9wLWxlZnQ8L1BhbmVsPlxuICogICAgICA8UGFuZWwgcG9zaXRpb249XCJ0b3AtY2VudGVyXCI+dG9wLWNlbnRlcjwvUGFuZWw+XG4gKiAgICAgIDxQYW5lbCBwb3NpdGlvbj1cInRvcC1yaWdodFwiPnRvcC1yaWdodDwvUGFuZWw+XG4gKiAgICAgIDxQYW5lbCBwb3NpdGlvbj1cImJvdHRvbS1sZWZ0XCI+Ym90dG9tLWxlZnQ8L1BhbmVsPlxuICogICAgICA8UGFuZWwgcG9zaXRpb249XCJib3R0b20tY2VudGVyXCI+Ym90dG9tLWNlbnRlcjwvUGFuZWw+XG4gKiAgICAgIDxQYW5lbCBwb3NpdGlvbj1cImJvdHRvbS1yaWdodFwiPmJvdHRvbS1yaWdodDwvUGFuZWw+XG4gKiAgICA8L1JlYWN0Rmxvdz5cbiAqICApO1xuICp9XG4gKmBgYFxuICovXG5jb25zdCBQYW5lbCA9IGZvcndhcmRSZWYoKHsgcG9zaXRpb24gPSAndG9wLWxlZnQnLCBjaGlsZHJlbiwgY2xhc3NOYW1lLCBzdHlsZSwgLi4ucmVzdCB9LCByZWYpID0+IHtcbiAgICBjb25zdCBwb3NpdGlvbkNsYXNzZXMgPSBgJHtwb3NpdGlvbn1gLnNwbGl0KCctJyk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fcGFuZWwnLCBjbGFzc05hbWUsIC4uLnBvc2l0aW9uQ2xhc3Nlc10pLCBzdHlsZTogc3R5bGUsIHJlZjogcmVmLCAuLi5yZXN0LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufSk7XG5QYW5lbC5kaXNwbGF5TmFtZSA9ICdQYW5lbCc7XG5cbmZ1bmN0aW9uIEF0dHJpYnV0aW9uKHsgcHJvT3B0aW9ucywgcG9zaXRpb24gPSAnYm90dG9tLXJpZ2h0JyB9KSB7XG4gICAgaWYgKHByb09wdGlvbnM/LmhpZGVBdHRyaWJ1dGlvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goUGFuZWwsIHsgcG9zaXRpb246IHBvc2l0aW9uLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fYXR0cmlidXRpb25cIiwgXCJkYXRhLW1lc3NhZ2VcIjogXCJQbGVhc2Ugb25seSBoaWRlIHRoaXMgYXR0cmlidXRpb24gd2hlbiB5b3UgYXJlIHN1YnNjcmliZWQgdG8gUmVhY3QgRmxvdyBQcm86IGh0dHBzOi8vcHJvLnJlYWN0Zmxvdy5kZXZcIiwgY2hpbGRyZW46IGpzeChcImFcIiwgeyBocmVmOiBcImh0dHBzOi8vcmVhY3RmbG93LmRldlwiLCB0YXJnZXQ6IFwiX2JsYW5rXCIsIHJlbDogXCJub29wZW5lciBub3JlZmVycmVyXCIsIFwiYXJpYS1sYWJlbFwiOiBcIlJlYWN0IEZsb3cgYXR0cmlidXRpb25cIiwgY2hpbGRyZW46IFwiUmVhY3QgRmxvd1wiIH0pIH0pKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkbSA9IChzKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0ZWROb2RlcyA9IFtdO1xuICAgIGNvbnN0IHNlbGVjdGVkRWRnZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFssIG5vZGVdIG9mIHMubm9kZUxvb2t1cCkge1xuICAgICAgICBpZiAobm9kZS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgc2VsZWN0ZWROb2Rlcy5wdXNoKG5vZGUuaW50ZXJuYWxzLnVzZXJOb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IFssIGVkZ2VdIG9mIHMuZWRnZUxvb2t1cCkge1xuICAgICAgICBpZiAoZWRnZS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgc2VsZWN0ZWRFZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHNlbGVjdGVkTm9kZXMsIHNlbGVjdGVkRWRnZXMgfTtcbn07XG5jb25zdCBzZWxlY3RJZCA9IChvYmopID0+IG9iai5pZDtcbmZ1bmN0aW9uIGFyZUVxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gKHNoYWxsb3coYS5zZWxlY3RlZE5vZGVzLm1hcChzZWxlY3RJZCksIGIuc2VsZWN0ZWROb2Rlcy5tYXAoc2VsZWN0SWQpKSAmJlxuICAgICAgICBzaGFsbG93KGEuc2VsZWN0ZWRFZGdlcy5tYXAoc2VsZWN0SWQpLCBiLnNlbGVjdGVkRWRnZXMubWFwKHNlbGVjdElkKSkpO1xufVxuZnVuY3Rpb24gU2VsZWN0aW9uTGlzdGVuZXJJbm5lcih7IG9uU2VsZWN0aW9uQ2hhbmdlLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHsgc2VsZWN0ZWROb2Rlcywgc2VsZWN0ZWRFZGdlcyB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkbSwgYXJlRXF1YWwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHsgbm9kZXM6IHNlbGVjdGVkTm9kZXMsIGVkZ2VzOiBzZWxlY3RlZEVkZ2VzIH07XG4gICAgICAgIG9uU2VsZWN0aW9uQ2hhbmdlPy4ocGFyYW1zKTtcbiAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5vblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzLmZvckVhY2goKGZuKSA9PiBmbihwYXJhbXMpKTtcbiAgICB9LCBbc2VsZWN0ZWROb2Rlcywgc2VsZWN0ZWRFZGdlcywgb25TZWxlY3Rpb25DaGFuZ2VdKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbmNvbnN0IGNoYW5nZVNlbGVjdG9yID0gKHMpID0+ICEhcy5vblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzO1xuZnVuY3Rpb24gU2VsZWN0aW9uTGlzdGVuZXIoeyBvblNlbGVjdGlvbkNoYW5nZSwgfSkge1xuICAgIGNvbnN0IHN0b3JlSGFzU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMgPSB1c2VTdG9yZShjaGFuZ2VTZWxlY3Rvcik7XG4gICAgaWYgKG9uU2VsZWN0aW9uQ2hhbmdlIHx8IHN0b3JlSGFzU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMpIHtcbiAgICAgICAgcmV0dXJuIGpzeChTZWxlY3Rpb25MaXN0ZW5lcklubmVyLCB7IG9uU2VsZWN0aW9uQ2hhbmdlOiBvblNlbGVjdGlvbkNoYW5nZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmNvbnN0IGRlZmF1bHROb2RlT3JpZ2luID0gWzAsIDBdO1xuY29uc3QgZGVmYXVsdFZpZXdwb3J0ID0geyB4OiAwLCB5OiAwLCB6b29tOiAxIH07XG5cbi8qXG4gKiBUaGlzIGNvbXBvbmVudCBoZWxwcyB1cyB0byB1cGRhdGUgdGhlIHN0b3JlIHdpdGggdGhlIHZhbHVlcyBjb21pbmcgZnJvbSB0aGUgdXNlci5cbiAqIFdlIGRpc3Rpbmd1aXNoIGJldHdlZW4gdmFsdWVzIHdlIGNhbiB1cGRhdGUgZGlyZWN0bHkgd2l0aCBgdXNlRGlyZWN0U3RvcmVVcGRhdGVyYCAobGlrZSBgc25hcEdyaWRgKVxuICogYW5kIHZhbHVlcyB0aGF0IGhhdmUgYSBkZWRpY2F0ZWQgc2V0dGVyIGZ1bmN0aW9uIGluIHRoZSBzdG9yZSAobGlrZSBgc2V0Tm9kZXNgKS5cbiAqL1xuLy8gVGhlc2UgZmllbGRzIGV4aXN0IGluIHRoZSBnbG9iYWwgc3RvcmUsIGFuZCB3ZSBuZWVkIHRvIGtlZXAgdGhlbSB1cCB0byBkYXRlXG5jb25zdCByZWFjdEZsb3dGaWVsZHNUb1RyYWNrID0gW1xuICAgICdub2RlcycsXG4gICAgJ2VkZ2VzJyxcbiAgICAnZGVmYXVsdE5vZGVzJyxcbiAgICAnZGVmYXVsdEVkZ2VzJyxcbiAgICAnb25Db25uZWN0JyxcbiAgICAnb25Db25uZWN0U3RhcnQnLFxuICAgICdvbkNvbm5lY3RFbmQnLFxuICAgICdvbkNsaWNrQ29ubmVjdFN0YXJ0JyxcbiAgICAnb25DbGlja0Nvbm5lY3RFbmQnLFxuICAgICdub2Rlc0RyYWdnYWJsZScsXG4gICAgJ2F1dG9QYW5Pbk5vZGVGb2N1cycsXG4gICAgJ25vZGVzQ29ubmVjdGFibGUnLFxuICAgICdub2Rlc0ZvY3VzYWJsZScsXG4gICAgJ2VkZ2VzRm9jdXNhYmxlJyxcbiAgICAnZWRnZXNSZWNvbm5lY3RhYmxlJyxcbiAgICAnZWxldmF0ZU5vZGVzT25TZWxlY3QnLFxuICAgICdlbGV2YXRlRWRnZXNPblNlbGVjdCcsXG4gICAgJ21pblpvb20nLFxuICAgICdtYXhab29tJyxcbiAgICAnbm9kZUV4dGVudCcsXG4gICAgJ29uTm9kZXNDaGFuZ2UnLFxuICAgICdvbkVkZ2VzQ2hhbmdlJyxcbiAgICAnZWxlbWVudHNTZWxlY3RhYmxlJyxcbiAgICAnY29ubmVjdGlvbk1vZGUnLFxuICAgICdzbmFwR3JpZCcsXG4gICAgJ3NuYXBUb0dyaWQnLFxuICAgICd0cmFuc2xhdGVFeHRlbnQnLFxuICAgICdjb25uZWN0T25DbGljaycsXG4gICAgJ2RlZmF1bHRFZGdlT3B0aW9ucycsXG4gICAgJ2ZpdFZpZXcnLFxuICAgICdmaXRWaWV3T3B0aW9ucycsXG4gICAgJ29uTm9kZXNEZWxldGUnLFxuICAgICdvbkVkZ2VzRGVsZXRlJyxcbiAgICAnb25EZWxldGUnLFxuICAgICdvbk5vZGVEcmFnJyxcbiAgICAnb25Ob2RlRHJhZ1N0YXJ0JyxcbiAgICAnb25Ob2RlRHJhZ1N0b3AnLFxuICAgICdvblNlbGVjdGlvbkRyYWcnLFxuICAgICdvblNlbGVjdGlvbkRyYWdTdGFydCcsXG4gICAgJ29uU2VsZWN0aW9uRHJhZ1N0b3AnLFxuICAgICdvbk1vdmVTdGFydCcsXG4gICAgJ29uTW92ZScsXG4gICAgJ29uTW92ZUVuZCcsXG4gICAgJ25vUGFuQ2xhc3NOYW1lJyxcbiAgICAnbm9kZU9yaWdpbicsXG4gICAgJ2F1dG9QYW5PbkNvbm5lY3QnLFxuICAgICdhdXRvUGFuT25Ob2RlRHJhZycsXG4gICAgJ29uRXJyb3InLFxuICAgICdjb25uZWN0aW9uUmFkaXVzJyxcbiAgICAnaXNWYWxpZENvbm5lY3Rpb24nLFxuICAgICdzZWxlY3ROb2Rlc09uRHJhZycsXG4gICAgJ25vZGVEcmFnVGhyZXNob2xkJyxcbiAgICAnY29ubmVjdGlvbkRyYWdUaHJlc2hvbGQnLFxuICAgICdvbkJlZm9yZURlbGV0ZScsXG4gICAgJ2RlYnVnJyxcbiAgICAnYXV0b1BhblNwZWVkJyxcbiAgICAncGFuZUNsaWNrRGlzdGFuY2UnLFxuICAgICdhcmlhTGFiZWxDb25maWcnLFxuXTtcbi8vIHJmSWQgZG9lc24ndCBleGlzdCBpbiBSZWFjdEZsb3dQcm9wcywgYnV0IGl0J3Mgb25lIG9mIHRoZSBmaWVsZHMgd2Ugd2FudCB0byB1cGRhdGVcbmNvbnN0IGZpZWxkc1RvVHJhY2sgPSBbLi4ucmVhY3RGbG93RmllbGRzVG9UcmFjaywgJ3JmSWQnXTtcbmNvbnN0IHNlbGVjdG9yJGwgPSAocykgPT4gKHtcbiAgICBzZXROb2Rlczogcy5zZXROb2RlcyxcbiAgICBzZXRFZGdlczogcy5zZXRFZGdlcyxcbiAgICBzZXRNaW5ab29tOiBzLnNldE1pblpvb20sXG4gICAgc2V0TWF4Wm9vbTogcy5zZXRNYXhab29tLFxuICAgIHNldFRyYW5zbGF0ZUV4dGVudDogcy5zZXRUcmFuc2xhdGVFeHRlbnQsXG4gICAgc2V0Tm9kZUV4dGVudDogcy5zZXROb2RlRXh0ZW50LFxuICAgIHJlc2V0OiBzLnJlc2V0LFxuICAgIHNldERlZmF1bHROb2Rlc0FuZEVkZ2VzOiBzLnNldERlZmF1bHROb2Rlc0FuZEVkZ2VzLFxuICAgIHNldFBhbmVDbGlja0Rpc3RhbmNlOiBzLnNldFBhbmVDbGlja0Rpc3RhbmNlLFxufSk7XG5jb25zdCBpbml0UHJldlZhbHVlcyA9IHtcbiAgICAvKlxuICAgICAqIHRoZXNlIGFyZSB2YWx1ZXMgdGhhdCBhcmUgYWxzbyBwYXNzZWQgZGlyZWN0bHkgdG8gb3RoZXIgY29tcG9uZW50c1xuICAgICAqIHRoYW4gdGhlIFN0b3JlVXBkYXRlci4gV2UgY2FuIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNldFN0b3JlIGNhbGxzXG4gICAgICogYnkgc2V0dGluZyB0aGUgc2FtZSB2YWx1ZXMgaGVyZSBhcyBwcmV2IGZpZWxkcy5cbiAgICAgKi9cbiAgICB0cmFuc2xhdGVFeHRlbnQ6IGluZmluaXRlRXh0ZW50LFxuICAgIG5vZGVPcmlnaW46IGRlZmF1bHROb2RlT3JpZ2luLFxuICAgIG1pblpvb206IDAuNSxcbiAgICBtYXhab29tOiAyLFxuICAgIGVsZW1lbnRzU2VsZWN0YWJsZTogdHJ1ZSxcbiAgICBub1BhbkNsYXNzTmFtZTogJ25vcGFuJyxcbiAgICByZklkOiAnMScsXG4gICAgcGFuZUNsaWNrRGlzdGFuY2U6IDAsXG59O1xuZnVuY3Rpb24gU3RvcmVVcGRhdGVyKHByb3BzKSB7XG4gICAgY29uc3QgeyBzZXROb2Rlcywgc2V0RWRnZXMsIHNldE1pblpvb20sIHNldE1heFpvb20sIHNldFRyYW5zbGF0ZUV4dGVudCwgc2V0Tm9kZUV4dGVudCwgcmVzZXQsIHNldERlZmF1bHROb2Rlc0FuZEVkZ2VzLCBzZXRQYW5lQ2xpY2tEaXN0YW5jZSwgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGwsIHNoYWxsb3cpO1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzZXREZWZhdWx0Tm9kZXNBbmRFZGdlcyhwcm9wcy5kZWZhdWx0Tm9kZXMsIHByb3BzLmRlZmF1bHRFZGdlcyk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAvLyB3aGVuIHdlIHJlc2V0IHRoZSBzdG9yZSB3ZSBhbHNvIG5lZWQgdG8gcmVzZXQgdGhlIHByZXZpb3VzIGZpZWxkc1xuICAgICAgICAgICAgcHJldmlvdXNGaWVsZHMuY3VycmVudCA9IGluaXRQcmV2VmFsdWVzO1xuICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgcHJldmlvdXNGaWVsZHMgPSB1c2VSZWYoaW5pdFByZXZWYWx1ZXMpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGROYW1lIG9mIGZpZWxkc1RvVHJhY2spIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkVmFsdWUgPSBwcm9wc1tmaWVsZE5hbWVdO1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNGaWVsZFZhbHVlID0gcHJldmlvdXNGaWVsZHMuY3VycmVudFtmaWVsZE5hbWVdO1xuICAgICAgICAgICAgaWYgKGZpZWxkVmFsdWUgPT09IHByZXZpb3VzRmllbGRWYWx1ZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcHNbZmllbGROYW1lXSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAvLyBDdXN0b20gaGFuZGxpbmcgd2l0aCBkZWRpY2F0ZWQgc2V0dGVycyBmb3Igc29tZSBmaWVsZHNcbiAgICAgICAgICAgIGlmIChmaWVsZE5hbWUgPT09ICdub2RlcycpXG4gICAgICAgICAgICAgICAgc2V0Tm9kZXMoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZE5hbWUgPT09ICdlZGdlcycpXG4gICAgICAgICAgICAgICAgc2V0RWRnZXMoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZE5hbWUgPT09ICdtaW5ab29tJylcbiAgICAgICAgICAgICAgICBzZXRNaW5ab29tKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAnbWF4Wm9vbScpXG4gICAgICAgICAgICAgICAgc2V0TWF4Wm9vbShmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ3RyYW5zbGF0ZUV4dGVudCcpXG4gICAgICAgICAgICAgICAgc2V0VHJhbnNsYXRlRXh0ZW50KGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAnbm9kZUV4dGVudCcpXG4gICAgICAgICAgICAgICAgc2V0Tm9kZUV4dGVudChmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ3BhbmVDbGlja0Rpc3RhbmNlJylcbiAgICAgICAgICAgICAgICBzZXRQYW5lQ2xpY2tEaXN0YW5jZShmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ2FyaWFMYWJlbENvbmZpZycpXG4gICAgICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBhcmlhTGFiZWxDb25maWc6IG1lcmdlQXJpYUxhYmVsQ29uZmlnKGZpZWxkVmFsdWUpIH0pO1xuICAgICAgICAgICAgLy8gUmVuYW1lZCBmaWVsZHNcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ2ZpdFZpZXcnKVxuICAgICAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgZml0Vmlld1F1ZXVlZDogZmllbGRWYWx1ZSB9KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ2ZpdFZpZXdPcHRpb25zJylcbiAgICAgICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IGZpdFZpZXdPcHRpb25zOiBmaWVsZFZhbHVlIH0pO1xuICAgICAgICAgICAgLy8gR2VuZXJhbCBjYXNlXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBbZmllbGROYW1lXTogZmllbGRWYWx1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c0ZpZWxkcy5jdXJyZW50ID0gcHJvcHM7XG4gICAgfSwgXG4gICAgLy8gT25seSByZS1ydW4gdGhlIGVmZmVjdCBpZiBvbmUgb2YgdGhlIGZpZWxkcyB3ZSB0cmFjayBjaGFuZ2VzXG4gICAgZmllbGRzVG9UcmFjay5tYXAoKGZpZWxkTmFtZSkgPT4gcHJvcHNbZmllbGROYW1lXSkpO1xuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRNZWRpYVF1ZXJ5KCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhd2luZG93Lm1hdGNoTWVkaWEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB3aW5kb3cubWF0Y2hNZWRpYSgnKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKScpO1xufVxuLyoqXG4gKiBIb29rIGZvciByZWNlaXZpbmcgdGhlIGN1cnJlbnQgY29sb3IgbW9kZSBjbGFzcyAnZGFyaycgb3IgJ2xpZ2h0Jy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBjb2xvck1vZGUgLSBUaGUgY29sb3IgbW9kZSB0byB1c2UgKCdkYXJrJywgJ2xpZ2h0JyBvciAnc3lzdGVtJylcbiAqL1xuZnVuY3Rpb24gdXNlQ29sb3JNb2RlQ2xhc3MoY29sb3JNb2RlKSB7XG4gICAgY29uc3QgW2NvbG9yTW9kZUNsYXNzLCBzZXRDb2xvck1vZGVDbGFzc10gPSB1c2VTdGF0ZShjb2xvck1vZGUgPT09ICdzeXN0ZW0nID8gbnVsbCA6IGNvbG9yTW9kZSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGNvbG9yTW9kZSAhPT0gJ3N5c3RlbScpIHtcbiAgICAgICAgICAgIHNldENvbG9yTW9kZUNsYXNzKGNvbG9yTW9kZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVkaWFRdWVyeSA9IGdldE1lZGlhUXVlcnkoKTtcbiAgICAgICAgY29uc3QgdXBkYXRlQ29sb3JNb2RlQ2xhc3MgPSAoKSA9PiBzZXRDb2xvck1vZGVDbGFzcyhtZWRpYVF1ZXJ5Py5tYXRjaGVzID8gJ2RhcmsnIDogJ2xpZ2h0Jyk7XG4gICAgICAgIHVwZGF0ZUNvbG9yTW9kZUNsYXNzKCk7XG4gICAgICAgIG1lZGlhUXVlcnk/LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHVwZGF0ZUNvbG9yTW9kZUNsYXNzKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIG1lZGlhUXVlcnk/LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHVwZGF0ZUNvbG9yTW9kZUNsYXNzKTtcbiAgICAgICAgfTtcbiAgICB9LCBbY29sb3JNb2RlXSk7XG4gICAgcmV0dXJuIGNvbG9yTW9kZUNsYXNzICE9PSBudWxsID8gY29sb3JNb2RlQ2xhc3MgOiBnZXRNZWRpYVF1ZXJ5KCk/Lm1hdGNoZXMgPyAnZGFyaycgOiAnbGlnaHQnO1xufVxuXG5jb25zdCBkZWZhdWx0RG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogbnVsbDtcbi8qKlxuICogVGhpcyBob29rIGxldHMgeW91IGxpc3RlbiBmb3Igc3BlY2lmaWMga2V5IGNvZGVzIGFuZCB0ZWxscyB5b3Ugd2hldGhlciB0aGV5IGFyZVxuICogY3VycmVudGx5IHByZXNzZWQgb3Igbm90LlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uc1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqaW1wb3J0IHsgdXNlS2V5UHJlc3MgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcbiAqICBjb25zdCBzcGFjZVByZXNzZWQgPSB1c2VLZXlQcmVzcygnU3BhY2UnKTtcbiAqICBjb25zdCBjbWRBbmRTUHJlc3NlZCA9IHVzZUtleVByZXNzKFsnTWV0YStzJywgJ1N0cmcrcyddKTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxkaXY+XG4gKiAgICAge3NwYWNlUHJlc3NlZCAmJiA8cD5TcGFjZSBwcmVzc2VkITwvcD59XG4gKiAgICAge2NtZEFuZFNQcmVzc2VkICYmIDxwPkNtZCArIFMgcHJlc3NlZCE8L3A+fVxuICogICAgPC9kaXY+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqL1xuZnVuY3Rpb24gdXNlS2V5UHJlc3MoXG4vKipcbiAqIFRoZSBrZXkgY29kZSAoc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MpIHNwZWNpZmllcyB3aGljaCBrZXkocykgc2hvdWxkIHRyaWdnZXJcbiAqIGFuIGFjdGlvbi5cbiAqXG4gKiBBICoqc3RyaW5nKiogY2FuIHJlcHJlc2VudDpcbiAqIC0gQSAqKnNpbmdsZSBrZXkqKiwgZS5nLiBgJ2EnYFxuICogLSBBICoqa2V5IGNvbWJpbmF0aW9uKiosIHVzaW5nIGAnKydgIHRvIHNlcGFyYXRlIGtleXMsIGUuZy4gYCdhK2QnYFxuICpcbiAqIEFuICAqKmFycmF5IG9mIHN0cmluZ3MqKiByZXByZXNlbnRzICoqbXVsdGlwbGUgcG9zc2libGUga2V5IGlucHV0cyoqLiBGb3IgZXhhbXBsZSwgYFsnYScsICdkK3MnXWBcbiAqIG1lYW5zIHRoZSB1c2VyIGNhbiBwcmVzcyBlaXRoZXIgdGhlIHNpbmdsZSBrZXkgYCdhJ2Agb3IgdGhlIGNvbWJpbmF0aW9uIG9mIGAnZCdgIGFuZCBgJ3MnYC5cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xua2V5Q29kZSA9IG51bGwsIG9wdGlvbnMgPSB7IHRhcmdldDogZGVmYXVsdERvYywgYWN0SW5zaWRlSW5wdXRXaXRoTW9kaWZpZXI6IHRydWUgfSkge1xuICAgIGNvbnN0IFtrZXlQcmVzc2VkLCBzZXRLZXlQcmVzc2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICAvLyB3ZSBuZWVkIHRvIHJlbWVtYmVyIGlmIGEgbW9kaWZpZXIga2V5IGlzIHByZXNzZWQgaW4gb3JkZXIgdG8gdHJhY2sgaXRcbiAgICBjb25zdCBtb2RpZmllclByZXNzZWQgPSB1c2VSZWYoZmFsc2UpO1xuICAgIC8vIHdlIG5lZWQgdG8gcmVtZW1iZXIgdGhlIHByZXNzZWQga2V5cyBpbiBvcmRlciB0byBzdXBwb3J0IGNvbWJpbmF0aW9uc1xuICAgIGNvbnN0IHByZXNzZWRLZXlzID0gdXNlUmVmKG5ldyBTZXQoW10pKTtcbiAgICAvKlxuICAgICAqIGtleUNvZGVzID0gYXJyYXkgd2l0aCBzaW5nbGUga2V5cyBbWydhJ11dIG9yIGtleSBjb21iaW5hdGlvbnMgW1snYScsICdzJ11dXG4gICAgICoga2V5c1RvV2F0Y2ggPSBhcnJheSB3aXRoIGFsbCBrZXlzIGZsYXR0ZW5lZCBbJ2EnLCAnZCcsICdTaGlmdExlZnQnXVxuICAgICAqIHVzZWQgdG8gY2hlY2sgaWYgd2Ugc3RvcmUgZXZlbnQuY29kZSBvciBldmVudC5rZXkuIFdoZW4gdGhlIGNvZGUgaXMgaW4gdGhlIGxpc3Qgb2Yga2V5c1RvV2F0Y2hcbiAgICAgKiB3ZSB1c2UgdGhlIGNvZGUgb3RoZXJ3aXNlIHRoZSBrZXkuIEV4cGxhaW5lcjogV2hlbiB5b3UgcHJlc3MgdGhlIGxlZnQgXCJjb21tYW5kXCIga2V5LCB0aGUgY29kZSBpcyBcIk1ldGFMZWZ0XCJcbiAgICAgKiBhbmQgdGhlIGtleSBpcyBcIk1ldGFcIi4gV2Ugd2FudCB1c2VycyB0byBiZSBhYmxlIHRvIHBhc3Mga2V5cyBhbmQgY29kZXMgc28gd2UgYXNzdW1lIHRoYXQgdGhlIGtleSBpcyBtZWFudCB3aGVuXG4gICAgICogd2UgY2FuJ3QgZmluZCBpdCBpbiB0aGUgbGlzdCBvZiBrZXlzVG9XYXRjaC5cbiAgICAgKi9cbiAgICBjb25zdCBba2V5Q29kZXMsIGtleXNUb1dhdGNoXSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoa2V5Q29kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qga2V5Q29kZUFyciA9IEFycmF5LmlzQXJyYXkoa2V5Q29kZSkgPyBrZXlDb2RlIDogW2tleUNvZGVdO1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IGtleUNvZGVBcnJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChrYykgPT4gdHlwZW9mIGtjID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIHdlIGZpcnN0IHJlcGxhY2UgYWxsICcrJyB3aXRoICdcXG4nICB3aGljaCB3ZSB3aWxsIHVzZSB0byBzcGxpdCB0aGUga2V5cyBvblxuICAgICAgICAgICAgICAgICAqIHRoZW4gd2UgcmVwbGFjZSAnXFxuXFxuJyB3aXRoICdcXG4rJywgdGhpcyB3YXkgd2UgY2FuIGFsc28gc3VwcG9ydCB0aGUgY29tYmluYXRpb24gJ2tleSsrJ1xuICAgICAgICAgICAgICAgICAqIGluIHRoZSBlbmQgd2Ugc2ltcGx5IHNwbGl0IG9uICdcXG4nIHRvIGdldCB0aGUga2V5IGFycmF5XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgLm1hcCgoa2MpID0+IGtjLnJlcGxhY2UoJysnLCAnXFxuJykucmVwbGFjZSgnXFxuXFxuJywgJ1xcbisnKS5zcGxpdCgnXFxuJykpO1xuICAgICAgICAgICAgY29uc3Qga2V5c0ZsYXQgPSBrZXlzLnJlZHVjZSgocmVzLCBpdGVtKSA9PiByZXMuY29uY2F0KC4uLml0ZW0pLCBbXSk7XG4gICAgICAgICAgICByZXR1cm4gW2tleXMsIGtleXNGbGF0XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1tdLCBbXV07XG4gICAgfSwgW2tleUNvZGVdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBvcHRpb25zPy50YXJnZXQgPz8gZGVmYXVsdERvYztcbiAgICAgICAgY29uc3QgYWN0SW5zaWRlSW5wdXRXaXRoTW9kaWZpZXIgPSBvcHRpb25zPy5hY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllciA/PyB0cnVlO1xuICAgICAgICBpZiAoa2V5Q29kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZG93bkhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBtb2RpZmllclByZXNzZWQuY3VycmVudCA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5hbHRLZXk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldmVudEFjdGlvbiA9ICghbW9kaWZpZXJQcmVzc2VkLmN1cnJlbnQgfHwgKG1vZGlmaWVyUHJlc3NlZC5jdXJyZW50ICYmICFhY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllcikpICYmXG4gICAgICAgICAgICAgICAgICAgIGlzSW5wdXRET01Ob2RlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAocHJldmVudEFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGtleU9yQ29kZSA9IHVzZUtleU9yQ29kZShldmVudC5jb2RlLCBrZXlzVG9XYXRjaCk7XG4gICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5hZGQoZXZlbnRba2V5T3JDb2RlXSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTWF0Y2hpbmdLZXkoa2V5Q29kZXMsIHByZXNzZWRLZXlzLmN1cnJlbnQsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAoZXZlbnQuY29tcG9zZWRQYXRoPy4oKT8uWzBdIHx8IGV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzSW50ZXJhY3RpdmVFbGVtZW50ID0gdGFyZ2V0Py5ub2RlTmFtZSA9PT0gJ0JVVFRPTicgfHwgdGFyZ2V0Py5ub2RlTmFtZSA9PT0gJ0EnO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wcmV2ZW50RGVmYXVsdCAhPT0gZmFsc2UgJiYgKG1vZGlmaWVyUHJlc3NlZC5jdXJyZW50IHx8ICFpc0ludGVyYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0S2V5UHJlc3NlZCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdXBIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5T3JDb2RlID0gdXNlS2V5T3JDb2RlKGV2ZW50LmNvZGUsIGtleXNUb1dhdGNoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNNYXRjaGluZ0tleShrZXlDb2RlcywgcHJlc3NlZEtleXMuY3VycmVudCwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0S2V5UHJlc3NlZChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHByZXNzZWRLZXlzLmN1cnJlbnQuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXNzZWRLZXlzLmN1cnJlbnQuZGVsZXRlKGV2ZW50W2tleU9yQ29kZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBmaXggZm9yIE1hYzogd2hlbiBjbWQga2V5IGlzIHByZXNzZWQsIGtleXVwIGlzIG5vdCB0cmlnZ2VyZWQgZm9yIGFueSBvdGhlciBrZXksIHNlZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjczODAwMTgvd2hlbi1jbWQta2V5LWlzLWtlcHQtcHJlc3NlZC1rZXl1cC1pcy1ub3QtdHJpZ2dlcmVkLWZvci1hbnktb3RoZXIta2V5XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ01ldGEnKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXNzZWRLZXlzLmN1cnJlbnQuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW9kaWZpZXJQcmVzc2VkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXNldEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHNldEtleVByZXNzZWQoZmFsc2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRhcmdldD8uYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGRvd25IYW5kbGVyKTtcbiAgICAgICAgICAgIHRhcmdldD8uYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB1cEhhbmRsZXIpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCByZXNldEhhbmRsZXIpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgcmVzZXRIYW5kbGVyKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Py5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZG93bkhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHRhcmdldD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB1cEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgcmVzZXRIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCByZXNldEhhbmRsZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtrZXlDb2RlLCBzZXRLZXlQcmVzc2VkXSk7XG4gICAgcmV0dXJuIGtleVByZXNzZWQ7XG59XG4vLyB1dGlsc1xuZnVuY3Rpb24gaXNNYXRjaGluZ0tleShrZXlDb2RlcywgcHJlc3NlZEtleXMsIGlzVXApIHtcbiAgICByZXR1cm4gKGtleUNvZGVzXG4gICAgICAgIC8qXG4gICAgICAgICAqIHdlIG9ubHkgd2FudCB0byBjb21wYXJlIHNhbWUgc2l6ZXMgb2Yga2V5Q29kZSBkZWZpbml0aW9uc1xuICAgICAgICAgKiBhbmQgcHJlc3NlZCBrZXlzLiBXaGVuIHRoZSB1c2VyIHNwZWNpZmllZCAnTWV0YScgYXMgYSBrZXkgc29tZXdoZXJlXG4gICAgICAgICAqIHRoaXMgd291bGQgYWxzbyBiZSB0cnV0aHkgd2l0aG91dCB0aGlzIGZpbHRlciB3aGVuIHVzZXIgcHJlc3NlcyAnTWV0YScgKyAncidcbiAgICAgICAgICovXG4gICAgICAgIC5maWx0ZXIoKGtleXMpID0+IGlzVXAgfHwga2V5cy5sZW5ndGggPT09IHByZXNzZWRLZXlzLnNpemUpXG4gICAgICAgIC8qXG4gICAgICAgICAqIHNpbmNlIHdlIHdhbnQgdG8gc3VwcG9ydCBtdWx0aXBsZSBwb3NzaWJpbGl0aWVzIG9ubHkgb25lIG9mIHRoZVxuICAgICAgICAgKiBjb21iaW5hdGlvbnMgbmVlZCB0byBiZSBwYXJ0IG9mIHRoZSBwcmVzc2VkIGtleXNcbiAgICAgICAgICovXG4gICAgICAgIC5zb21lKChrZXlzKSA9PiBrZXlzLmV2ZXJ5KChrKSA9PiBwcmVzc2VkS2V5cy5oYXMoaykpKSk7XG59XG5mdW5jdGlvbiB1c2VLZXlPckNvZGUoZXZlbnRDb2RlLCBrZXlzVG9XYXRjaCkge1xuICAgIHJldHVybiBrZXlzVG9XYXRjaC5pbmNsdWRlcyhldmVudENvZGUpID8gJ2NvZGUnIDogJ2tleSc7XG59XG5cbi8qKlxuICogSG9vayBmb3IgZ2V0dGluZyB2aWV3cG9ydCBoZWxwZXIgZnVuY3Rpb25zLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHJldHVybnMgdmlld3BvcnQgaGVscGVyIGZ1bmN0aW9uc1xuICovXG5jb25zdCB1c2VWaWV3cG9ydEhlbHBlciA9ICgpID0+IHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgem9vbUluOiAob3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGFuWm9vbSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFuWm9vbSA/IHBhblpvb20uc2NhbGVCeSgxLjIsIHsgZHVyYXRpb246IG9wdGlvbnM/LmR1cmF0aW9uIH0pIDogUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB6b29tT3V0OiAob3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGFuWm9vbSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFuWm9vbSA/IHBhblpvb20uc2NhbGVCeSgxIC8gMS4yLCB7IGR1cmF0aW9uOiBvcHRpb25zPy5kdXJhdGlvbiB9KSA6IFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgem9vbVRvOiAoem9vbUxldmVsLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYW5ab29tIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYW5ab29tID8gcGFuWm9vbS5zY2FsZVRvKHpvb21MZXZlbCwgeyBkdXJhdGlvbjogb3B0aW9ucz8uZHVyYXRpb24gfSkgOiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFpvb206ICgpID0+IHN0b3JlLmdldFN0YXRlKCkudHJhbnNmb3JtWzJdLFxuICAgICAgICAgICAgc2V0Vmlld3BvcnQ6IGFzeW5jICh2aWV3cG9ydCwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtOiBbdFgsIHRZLCB0Wm9vbV0sIHBhblpvb20sIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmICghcGFuWm9vbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgcGFuWm9vbS5zZXRWaWV3cG9ydCh7XG4gICAgICAgICAgICAgICAgICAgIHg6IHZpZXdwb3J0LnggPz8gdFgsXG4gICAgICAgICAgICAgICAgICAgIHk6IHZpZXdwb3J0LnkgPz8gdFksXG4gICAgICAgICAgICAgICAgICAgIHpvb206IHZpZXdwb3J0Lnpvb20gPz8gdFpvb20sXG4gICAgICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRWaWV3cG9ydDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IFt4LCB5LCB6b29tXSA9IHN0b3JlLmdldFN0YXRlKCkudHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHksIHpvb20gfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRDZW50ZXI6IGFzeW5jICh4LCB5LCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlLmdldFN0YXRlKCkuc2V0Q2VudGVyKHgsIHksIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpdEJvdW5kczogYXN5bmMgKGJvdW5kcywgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgbWluWm9vbSwgbWF4Wm9vbSwgcGFuWm9vbSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3cG9ydCA9IGdldFZpZXdwb3J0Rm9yQm91bmRzKGJvdW5kcywgd2lkdGgsIGhlaWdodCwgbWluWm9vbSwgbWF4Wm9vbSwgb3B0aW9ucz8ucGFkZGluZyA/PyAwLjEpO1xuICAgICAgICAgICAgICAgIGlmICghcGFuWm9vbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgcGFuWm9vbS5zZXRWaWV3cG9ydCh2aWV3cG9ydCwge1xuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucz8uZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGVhc2U6IG9wdGlvbnM/LmVhc2UsXG4gICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRlOiBvcHRpb25zPy5pbnRlcnBvbGF0ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNjcmVlblRvRmxvd1Bvc2l0aW9uOiAoY2xpZW50UG9zaXRpb24sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgZG9tTm9kZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRvbU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsaWVudFBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHg6IGRvbVgsIHk6IGRvbVkgfSA9IGRvbU5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29ycmVjdGVkUG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGNsaWVudFBvc2l0aW9uLnggLSBkb21YLFxuICAgICAgICAgICAgICAgICAgICB5OiBjbGllbnRQb3NpdGlvbi55IC0gZG9tWSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IF9zbmFwR3JpZCA9IG9wdGlvbnMuc25hcEdyaWQgPz8gc25hcEdyaWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgX3NuYXBUb0dyaWQgPSBvcHRpb25zLnNuYXBUb0dyaWQgPz8gc25hcFRvR3JpZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnRUb1JlbmRlcmVyUG9pbnQoY29ycmVjdGVkUG9zaXRpb24sIHRyYW5zZm9ybSwgX3NuYXBUb0dyaWQsIF9zbmFwR3JpZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmxvd1RvU2NyZWVuUG9zaXRpb246IChmbG93UG9zaXRpb24pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHRyYW5zZm9ybSwgZG9tTm9kZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRvbU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZsb3dQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyB4OiBkb21YLCB5OiBkb21ZIH0gPSBkb21Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVyUG9zaXRpb24gPSByZW5kZXJlclBvaW50VG9Qb2ludChmbG93UG9zaXRpb24sIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgeDogcmVuZGVyZXJQb3NpdGlvbi54ICsgZG9tWCxcbiAgICAgICAgICAgICAgICAgICAgeTogcmVuZGVyZXJQb3NpdGlvbi55ICsgZG9tWSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG59O1xuXG4vKlxuICogVGhpcyBmdW5jdGlvbiBhcHBsaWVzIGNoYW5nZXMgdG8gbm9kZXMgb3IgZWRnZXMgdGhhdCBhcmUgdHJpZ2dlcmVkIGJ5IFJlYWN0IEZsb3cgaW50ZXJuYWxseS5cbiAqIFdoZW4geW91IGRyYWcgYSBub2RlIGZvciBleGFtcGxlLCBSZWFjdCBGbG93IHdpbGwgc2VuZCBhIHBvc2l0aW9uIGNoYW5nZSB1cGRhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIHRoZW4gYXBwbGllcyB0aGUgY2hhbmdlcyBhbmQgcmV0dXJucyB0aGUgdXBkYXRlZCBlbGVtZW50cy5cbiAqL1xuZnVuY3Rpb24gYXBwbHlDaGFuZ2VzKGNoYW5nZXMsIGVsZW1lbnRzKSB7XG4gICAgY29uc3QgdXBkYXRlZEVsZW1lbnRzID0gW107XG4gICAgLypcbiAgICAgKiBCeSBzdG9yaW5nIGEgbWFwIG9mIGNoYW5nZXMgZm9yIGVhY2ggZWxlbWVudCwgd2UgY2FuIGEgcXVpY2sgbG9va3VwIGFzIHdlXG4gICAgICogaXRlcmF0ZSBvdmVyIHRoZSBlbGVtZW50cyBhcnJheSFcbiAgICAgKi9cbiAgICBjb25zdCBjaGFuZ2VzTWFwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGFkZEl0ZW1DaGFuZ2VzID0gW107XG4gICAgZm9yIChjb25zdCBjaGFuZ2Ugb2YgY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlLnR5cGUgPT09ICdhZGQnKSB7XG4gICAgICAgICAgICBhZGRJdGVtQ2hhbmdlcy5wdXNoKGNoYW5nZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFuZ2UudHlwZSA9PT0gJ3JlbW92ZScgfHwgY2hhbmdlLnR5cGUgPT09ICdyZXBsYWNlJykge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIEZvciBhICdyZW1vdmUnIGNoYW5nZSB3ZSBjYW4gc2FmZWx5IGlnbm9yZSBhbnkgb3RoZXIgY2hhbmdlcyBxdWV1ZWQgZm9yXG4gICAgICAgICAgICAgKiB0aGUgc2FtZSBlbGVtZW50LCBpdCdzIGdvaW5nIHRvIGJlIHJlbW92ZWQgYW55d2F5IVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjaGFuZ2VzTWFwLnNldChjaGFuZ2UuaWQsIFtjaGFuZ2VdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRDaGFuZ2VzID0gY2hhbmdlc01hcC5nZXQoY2hhbmdlLmlkKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50Q2hhbmdlcykge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogSWYgd2UgaGF2ZSBzb21lIGNoYW5nZXMgcXVldWVkIGFscmVhZHksIHdlIGNhbiBkbyBhIG11dGFibGUgdXBkYXRlIG9mXG4gICAgICAgICAgICAgICAgICogdGhhdCBhcnJheSBhbmQgc2F2ZSBvdXJzZWx2ZXMgc29tZSBjb3B5aW5nLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGVsZW1lbnRDaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoYW5nZXNNYXAuc2V0KGNoYW5nZS5pZCwgW2NoYW5nZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICBjb25zdCBjaGFuZ2VzID0gY2hhbmdlc01hcC5nZXQoZWxlbWVudC5pZCk7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFdoZW4gdGhlcmUgYXJlIG5vIGNoYW5nZXMgZm9yIGFuIGVsZW1lbnQgd2UgY2FuIGp1c3QgcHVzaCBpdCB1bm1vZGlmaWVkLFxuICAgICAgICAgKiBubyBuZWVkIHRvIGNvcHkgaXQuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoIWNoYW5nZXMpIHtcbiAgICAgICAgICAgIHVwZGF0ZWRFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhICdyZW1vdmUnIGNoYW5nZSBxdWV1ZWQsIGl0J2xsIGJlIHRoZSBvbmx5IGNoYW5nZSBpbiB0aGUgYXJyYXlcbiAgICAgICAgaWYgKGNoYW5nZXNbMF0udHlwZSA9PT0gJ3JlbW92ZScpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWzBdLnR5cGUgPT09ICdyZXBsYWNlJykge1xuICAgICAgICAgICAgdXBkYXRlZEVsZW1lbnRzLnB1c2goeyAuLi5jaGFuZ2VzWzBdLml0ZW0gfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRm9yIG90aGVyIHR5cGVzIG9mIGNoYW5nZXMsIHdlIHdhbnQgdG8gc3RhcnQgd2l0aCBhIHNoYWxsb3cgY29weSBvZiB0aGVcbiAgICAgICAgICogb2JqZWN0IHNvIFJlYWN0IGtub3dzIHRoaXMgZWxlbWVudCBoYXMgY2hhbmdlZC4gU2VxdWVudGlhbCBjaGFuZ2VzIHdpbGxcbiAgICAgICAgICogZWFjaCBfbXV0YXRlXyB0aGlzIG9iamVjdCwgc28gdGhlcmUncyBvbmx5IGV2ZXIgb25lIGNvcHkuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCB1cGRhdGVkRWxlbWVudCA9IHsgLi4uZWxlbWVudCB9O1xuICAgICAgICBmb3IgKGNvbnN0IGNoYW5nZSBvZiBjaGFuZ2VzKSB7XG4gICAgICAgICAgICBhcHBseUNoYW5nZShjaGFuZ2UsIHVwZGF0ZWRFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVkRWxlbWVudHMucHVzaCh1cGRhdGVkRWxlbWVudCk7XG4gICAgfVxuICAgIC8qXG4gICAgICogd2UgbmVlZCB0byB3YWl0IGZvciBhbGwgY2hhbmdlcyB0byBiZSBhcHBsaWVkIGJlZm9yZSBhZGRpbmcgbmV3IGl0ZW1zXG4gICAgICogdG8gYmUgYWJsZSB0byBhZGQgdGhlbSBhdCB0aGUgY29ycmVjdCBpbmRleFxuICAgICAqL1xuICAgIGlmIChhZGRJdGVtQ2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgYWRkSXRlbUNoYW5nZXMuZm9yRWFjaCgoY2hhbmdlKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlLmluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVkRWxlbWVudHMuc3BsaWNlKGNoYW5nZS5pbmRleCwgMCwgeyAuLi5jaGFuZ2UuaXRlbSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwZGF0ZWRFbGVtZW50cy5wdXNoKHsgLi4uY2hhbmdlLml0ZW0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlZEVsZW1lbnRzO1xufVxuLy8gQXBwbGllcyBhIHNpbmdsZSBjaGFuZ2UgdG8gYW4gZWxlbWVudC4gVGhpcyBpcyBhICptdXRhYmxlKiB1cGRhdGUuXG5mdW5jdGlvbiBhcHBseUNoYW5nZShjaGFuZ2UsIGVsZW1lbnQpIHtcbiAgICBzd2l0Y2ggKGNoYW5nZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3NlbGVjdCc6IHtcbiAgICAgICAgICAgIGVsZW1lbnQuc2VsZWN0ZWQgPSBjaGFuZ2Uuc2VsZWN0ZWQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdwb3NpdGlvbic6IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhbmdlLnBvc2l0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucG9zaXRpb24gPSBjaGFuZ2UucG9zaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoYW5nZS5kcmFnZ2luZyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmRyYWdnaW5nID0gY2hhbmdlLmRyYWdnaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZGltZW5zaW9ucyc6IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhbmdlLmRpbWVuc2lvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5tZWFzdXJlZCA/Pz0ge307XG4gICAgICAgICAgICAgICAgZWxlbWVudC5tZWFzdXJlZC53aWR0aCA9IGNoYW5nZS5kaW1lbnNpb25zLndpZHRoO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQubWVhc3VyZWQuaGVpZ2h0ID0gY2hhbmdlLmRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2Uuc2V0QXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnNldEF0dHJpYnV0ZXMgPT09IHRydWUgfHwgY2hhbmdlLnNldEF0dHJpYnV0ZXMgPT09ICd3aWR0aCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQud2lkdGggPSBjaGFuZ2UuZGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnNldEF0dHJpYnV0ZXMgPT09IHRydWUgfHwgY2hhbmdlLnNldEF0dHJpYnV0ZXMgPT09ICdoZWlnaHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmhlaWdodCA9IGNoYW5nZS5kaW1lbnNpb25zLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhbmdlLnJlc2l6aW5nID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlc2l6aW5nID0gY2hhbmdlLnJlc2l6aW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIERyb3AgaW4gZnVuY3Rpb24gdGhhdCBhcHBsaWVzIG5vZGUgY2hhbmdlcyB0byBhbiBhcnJheSBvZiBub2Rlcy5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBjaGFuZ2VzIC0gQXJyYXkgb2YgY2hhbmdlcyB0byBhcHBseS5cbiAqIEBwYXJhbSBub2RlcyAtIEFycmF5IG9mIG5vZGVzIHRvIGFwcGx5IHRoZSBjaGFuZ2VzIHRvLlxuICogQHJldHVybnMgQXJyYXkgb2YgdXBkYXRlZCBub2Rlcy5cbiAqIEBleGFtcGxlXG4gKmBgYHRzeFxuICppbXBvcnQgeyB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG4gKmltcG9ydCB7IFJlYWN0RmxvdywgYXBwbHlOb2RlQ2hhbmdlcywgdHlwZSBOb2RlLCB0eXBlIEVkZ2UsIHR5cGUgT25Ob2Rlc0NoYW5nZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmxvdygpIHtcbiAqICBjb25zdCBbbm9kZXMsIHNldE5vZGVzXSA9IHVzZVN0YXRlPE5vZGVbXT4oW10pO1xuICogIGNvbnN0IFtlZGdlcywgc2V0RWRnZXNdID0gdXNlU3RhdGU8RWRnZVtdPihbXSk7XG4gKiAgY29uc3Qgb25Ob2Rlc0NoYW5nZTogT25Ob2Rlc0NoYW5nZSA9IHVzZUNhbGxiYWNrKFxuICogICAgKGNoYW5nZXMpID0+IHtcbiAqICAgICAgc2V0Tm9kZXMoKG9sZE5vZGVzKSA9PiBhcHBseU5vZGVDaGFuZ2VzKGNoYW5nZXMsIG9sZE5vZGVzKSk7XG4gKiAgICB9LFxuICogICAgW3NldE5vZGVzXSxcbiAqICApO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPFJlYWN0RmxvdyBub2Rlcz17bm9kZXN9IGVkZ2VzPXtlZGdlc30gb25Ob2Rlc0NoYW5nZT17b25Ob2Rlc0NoYW5nZX0gLz5cbiAqICApO1xuICp9XG4gKmBgYFxuICogQHJlbWFya3MgVmFyaW91cyBldmVudHMgb24gdGhlIDxSZWFjdEZsb3cgLz4gY29tcG9uZW50IGNhbiBwcm9kdWNlIGFuIHtAbGluayBOb2RlQ2hhbmdlfVxuICogdGhhdCBkZXNjcmliZXMgaG93IHRvIHVwZGF0ZSB0aGUgZWRnZXMgb2YgeW91ciBmbG93IGluIHNvbWUgd2F5LlxuICogSWYgeW91IGRvbid0IG5lZWQgYW55IGN1c3RvbSBiZWhhdmlvdXIsIHRoaXMgdXRpbCBjYW4gYmUgdXNlZCB0byB0YWtlIGFuIGFycmF5XG4gKiBvZiB0aGVzZSBjaGFuZ2VzIGFuZCBhcHBseSB0aGVtIHRvIHlvdXIgZWRnZXMuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5Tm9kZUNoYW5nZXMoY2hhbmdlcywgbm9kZXMpIHtcbiAgICByZXR1cm4gYXBwbHlDaGFuZ2VzKGNoYW5nZXMsIG5vZGVzKTtcbn1cbi8qKlxuICogRHJvcCBpbiBmdW5jdGlvbiB0aGF0IGFwcGxpZXMgZWRnZSBjaGFuZ2VzIHRvIGFuIGFycmF5IG9mIGVkZ2VzLlxuICogQHB1YmxpY1xuICogQHBhcmFtIGNoYW5nZXMgLSBBcnJheSBvZiBjaGFuZ2VzIHRvIGFwcGx5LlxuICogQHBhcmFtIGVkZ2VzIC0gQXJyYXkgb2YgZWRnZSB0byBhcHBseSB0aGUgY2hhbmdlcyB0by5cbiAqIEByZXR1cm5zIEFycmF5IG9mIHVwZGF0ZWQgZWRnZXMuXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKmltcG9ydCB7IHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCBhcHBseUVkZ2VDaGFuZ2VzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogIGNvbnN0IFtub2Rlcywgc2V0Tm9kZXNdID0gdXNlU3RhdGUoW10pO1xuICogIGNvbnN0IFtlZGdlcywgc2V0RWRnZXNdID0gdXNlU3RhdGUoW10pO1xuICogIGNvbnN0IG9uRWRnZXNDaGFuZ2UgPSB1c2VDYWxsYmFjayhcbiAqICAgIChjaGFuZ2VzKSA9PiB7XG4gKiAgICAgIHNldEVkZ2VzKChvbGRFZGdlcykgPT4gYXBwbHlFZGdlQ2hhbmdlcyhjaGFuZ2VzLCBvbGRFZGdlcykpO1xuICogICAgfSxcbiAqICAgIFtzZXRFZGdlc10sXG4gKiAgKTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxSZWFjdEZsb3cgbm9kZXM9e25vZGVzfSBlZGdlcz17ZWRnZXN9IG9uRWRnZXNDaGFuZ2U9e29uRWRnZXNDaGFuZ2V9IC8+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqIEByZW1hcmtzIFZhcmlvdXMgZXZlbnRzIG9uIHRoZSA8UmVhY3RGbG93IC8+IGNvbXBvbmVudCBjYW4gcHJvZHVjZSBhbiB7QGxpbmsgRWRnZUNoYW5nZX1cbiAqIHRoYXQgZGVzY3JpYmVzIGhvdyB0byB1cGRhdGUgdGhlIGVkZ2VzIG9mIHlvdXIgZmxvdyBpbiBzb21lIHdheS5cbiAqIElmIHlvdSBkb24ndCBuZWVkIGFueSBjdXN0b20gYmVoYXZpb3VyLCB0aGlzIHV0aWwgY2FuIGJlIHVzZWQgdG8gdGFrZSBhbiBhcnJheVxuICogb2YgdGhlc2UgY2hhbmdlcyBhbmQgYXBwbHkgdGhlbSB0byB5b3VyIGVkZ2VzLlxuICovXG5mdW5jdGlvbiBhcHBseUVkZ2VDaGFuZ2VzKGNoYW5nZXMsIGVkZ2VzKSB7XG4gICAgcmV0dXJuIGFwcGx5Q2hhbmdlcyhjaGFuZ2VzLCBlZGdlcyk7XG59XG5mdW5jdGlvbiBjcmVhdGVTZWxlY3Rpb25DaGFuZ2UoaWQsIHNlbGVjdGVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQsXG4gICAgICAgIHR5cGU6ICdzZWxlY3QnLFxuICAgICAgICBzZWxlY3RlZCxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uQ2hhbmdlcyhpdGVtcywgc2VsZWN0ZWRJZHMgPSBuZXcgU2V0KCksIG11dGF0ZUl0ZW0gPSBmYWxzZSkge1xuICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtpZCwgaXRlbV0gb2YgaXRlbXMpIHtcbiAgICAgICAgY29uc3Qgd2lsbEJlU2VsZWN0ZWQgPSBzZWxlY3RlZElkcy5oYXMoaWQpO1xuICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIHNldCBhbGwgaXRlbXMgdG8gc2VsZWN0ZWQ9ZmFsc2Ugb24gdGhlIGZpcnN0IHNlbGVjdGlvblxuICAgICAgICBpZiAoIShpdGVtLnNlbGVjdGVkID09PSB1bmRlZmluZWQgJiYgIXdpbGxCZVNlbGVjdGVkKSAmJiBpdGVtLnNlbGVjdGVkICE9PSB3aWxsQmVTZWxlY3RlZCkge1xuICAgICAgICAgICAgaWYgKG11dGF0ZUl0ZW0pIHtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIHRoaXMgaGFjayBpcyBuZWVkZWQgZm9yIG5vZGVzLiBXaGVuIHRoZSB1c2VyIGRyYWdnZWQgYSBub2RlLCBpdCdzIHNlbGVjdGVkLlxuICAgICAgICAgICAgICAgICAqIFdoZW4gYW5vdGhlciBub2RlIGdldHMgZHJhZ2dlZCwgd2UgbmVlZCB0byBkZXNlbGVjdCB0aGUgcHJldmlvdXMgb25lLFxuICAgICAgICAgICAgICAgICAqIGluIG9yZGVyIHRvIGhhdmUgb25seSBvbmUgc2VsZWN0ZWQgbm9kZSBhdCBhIHRpbWUgLSB0aGUgb25Ob2Rlc0NoYW5nZSBjYWxsYmFjayBjb21lcyB0b28gbGF0ZSBoZXJlIDovXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaXRlbS5zZWxlY3RlZCA9IHdpbGxCZVNlbGVjdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKGNyZWF0ZVNlbGVjdGlvbkNoYW5nZShpdGVtLmlkLCB3aWxsQmVTZWxlY3RlZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VzO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudHNEaWZmQ2hhbmdlcyh7IGl0ZW1zID0gW10sIGxvb2t1cCwgfSkge1xuICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgICBjb25zdCBpdGVtc0xvb2t1cCA9IG5ldyBNYXAoaXRlbXMubWFwKChpdGVtKSA9PiBbaXRlbS5pZCwgaXRlbV0pKTtcbiAgICBmb3IgKGNvbnN0IFtpbmRleCwgaXRlbV0gb2YgaXRlbXMuZW50cmllcygpKSB7XG4gICAgICAgIGNvbnN0IGxvb2t1cEl0ZW0gPSBsb29rdXAuZ2V0KGl0ZW0uaWQpO1xuICAgICAgICBjb25zdCBzdG9yZUl0ZW0gPSBsb29rdXBJdGVtPy5pbnRlcm5hbHM/LnVzZXJOb2RlID8/IGxvb2t1cEl0ZW07XG4gICAgICAgIGlmIChzdG9yZUl0ZW0gIT09IHVuZGVmaW5lZCAmJiBzdG9yZUl0ZW0gIT09IGl0ZW0pIHtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGlkOiBpdGVtLmlkLCBpdGVtOiBpdGVtLCB0eXBlOiAncmVwbGFjZScgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0b3JlSXRlbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBpdGVtOiBpdGVtLCB0eXBlOiAnYWRkJywgaW5kZXggfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBbaWRdIG9mIGxvb2t1cCkge1xuICAgICAgICBjb25zdCBuZXh0Tm9kZSA9IGl0ZW1zTG9va3VwLmdldChpZCk7XG4gICAgICAgIGlmIChuZXh0Tm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBpZCwgdHlwZTogJ3JlbW92ZScgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZXM7XG59XG5mdW5jdGlvbiBlbGVtZW50VG9SZW1vdmVDaGFuZ2UoaXRlbSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICB0eXBlOiAncmVtb3ZlJyxcbiAgICB9O1xufVxuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBhbiBvYmplY3QgaXMgdXNhYmxlIGFzIGFuIFtgTm9kZWBdKC9hcGktcmVmZXJlbmNlL3R5cGVzL25vZGUpLlxuICogSW4gVHlwZVNjcmlwdCB0aGlzIGlzIGEgdHlwZSBndWFyZCB0aGF0IHdpbGwgbmFycm93IHRoZSB0eXBlIG9mIHdoYXRldmVyIHlvdSBwYXNzIGluIHRvXG4gKiBbYE5vZGVgXSgvYXBpLXJlZmVyZW5jZS90eXBlcy9ub2RlKSBpZiBpdCByZXR1cm5zIGB0cnVlYC5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmVtYXJrcyBJbiBUeXBlU2NyaXB0IHRoaXMgaXMgYSB0eXBlIGd1YXJkIHRoYXQgd2lsbCBuYXJyb3cgdGhlIHR5cGUgb2Ygd2hhdGV2ZXIgeW91IHBhc3MgaW4gdG8gTm9kZSBpZiBpdCByZXR1cm5zIHRydWVcbiAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgdG8gdGVzdC5cbiAqIEByZXR1cm5zIFRlc3RzIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHZhbHVlIGNhbiBiZSB1c2VkIGFzIGEgYE5vZGVgLiBJZiB5b3UncmUgdXNpbmcgVHlwZVNjcmlwdCxcbiAqIHRoaXMgZnVuY3Rpb24gYWN0cyBhcyBhIHR5cGUgZ3VhcmQgYW5kIHdpbGwgbmFycm93IHRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB0byBgTm9kZWAgaWYgaXQgcmV0dXJuc1xuICogYHRydWVgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICppbXBvcnQgeyBpc05vZGUgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmlmIChpc05vZGUobm9kZSkpIHtcbiAqIC8vIC4uLlxuICp9XG4gKmBgYFxuICovXG5jb25zdCBpc05vZGUgPSAoZWxlbWVudCkgPT4gaXNOb2RlQmFzZShlbGVtZW50KTtcbi8qKlxuICogVGVzdCB3aGV0aGVyIGFuIG9iamVjdCBpcyB1c2FibGUgYXMgYW4gW2BFZGdlYF0oL2FwaS1yZWZlcmVuY2UvdHlwZXMvZWRnZSkuXG4gKiBJbiBUeXBlU2NyaXB0IHRoaXMgaXMgYSB0eXBlIGd1YXJkIHRoYXQgd2lsbCBuYXJyb3cgdGhlIHR5cGUgb2Ygd2hhdGV2ZXIgeW91IHBhc3MgaW4gdG9cbiAqIFtgRWRnZWBdKC9hcGktcmVmZXJlbmNlL3R5cGVzL2VkZ2UpIGlmIGl0IHJldHVybnMgYHRydWVgLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZW1hcmtzIEluIFR5cGVTY3JpcHQgdGhpcyBpcyBhIHR5cGUgZ3VhcmQgdGhhdCB3aWxsIG5hcnJvdyB0aGUgdHlwZSBvZiB3aGF0ZXZlciB5b3UgcGFzcyBpbiB0byBFZGdlIGlmIGl0IHJldHVybnMgdHJ1ZVxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byB0ZXN0XG4gKiBAcmV0dXJucyBUZXN0cyB3aGV0aGVyIHRoZSBwcm92aWRlZCB2YWx1ZSBjYW4gYmUgdXNlZCBhcyBhbiBgRWRnZWAuIElmIHlvdSdyZSB1c2luZyBUeXBlU2NyaXB0LFxuICogdGhpcyBmdW5jdGlvbiBhY3RzIGFzIGEgdHlwZSBndWFyZCBhbmQgd2lsbCBuYXJyb3cgdGhlIHR5cGUgb2YgdGhlIHZhbHVlIHRvIGBFZGdlYCBpZiBpdCByZXR1cm5zXG4gKiBgdHJ1ZWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKmltcG9ydCB7IGlzRWRnZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqaWYgKGlzRWRnZShlZGdlKSkge1xuICogLy8gLi4uXG4gKn1cbiAqYGBgXG4gKi9cbmNvbnN0IGlzRWRnZSA9IChlbGVtZW50KSA9PiBpc0VkZ2VCYXNlKGVsZW1lbnQpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1vYmplY3QtdHlwZVxuZnVuY3Rpb24gZml4ZWRGb3J3YXJkUmVmKHJlbmRlcikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgcmV0dXJuIGZvcndhcmRSZWYocmVuZGVyKTtcbn1cblxuLy8gd2UgbmVlZCB0aGlzIGhvb2sgdG8gcHJldmVudCBhIHdhcm5pbmcgd2hlbiB1c2luZyByZWFjdC1mbG93IGluIFNTUlxuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG4vKipcbiAqIFRoaXMgaG9vayByZXR1cm5zIGEgcXVldWUgdGhhdCBjYW4gYmUgdXNlZCB0byBiYXRjaCB1cGRhdGVzLlxuICpcbiAqIEBwYXJhbSBydW5RdWV1ZSAtIGEgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCB3aGVuIHRoZSBxdWV1ZSBpcyBmbHVzaGVkXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBAcmV0dXJucyBhIFF1ZXVlIG9iamVjdFxuICovXG5mdW5jdGlvbiB1c2VRdWV1ZShydW5RdWV1ZSkge1xuICAgIC8qXG4gICAgICogQmVjYXVzZSB3ZSdyZSB1c2luZyBhIHJlZiBhYm92ZSwgd2UgbmVlZCBzb21lIHdheSB0byBsZXQgUmVhY3Qga25vdyB3aGVuIHRvXG4gICAgICogYWN0dWFsbHkgcHJvY2VzcyB0aGUgcXVldWUuIFdlIGluY3JlbWVudCB0aGlzIG51bWJlciBhbnkgdGltZSB3ZSBtdXRhdGUgdGhlXG4gICAgICogcXVldWUsIGNyZWF0aW5nIGEgbmV3IHN0YXRlIHRvIHRyaWdnZXIgdGhlIGxheW91dCBlZmZlY3QgYmVsb3cuXG4gICAgICogVXNpbmcgYSBib29sZWFuIGRpcnR5IGZsYWcgaGVyZSBpbnN0ZWFkIHdvdWxkIGxlYWQgdG8gaXNzdWVzIHJlbGF0ZWQgdG9cbiAgICAgKiBhdXRvbWF0aWMgYmF0Y2hpbmcuIChodHRwczovL2dpdGh1Yi5jb20veHlmbG93L3h5Zmxvdy9pc3N1ZXMvNDc3OSlcbiAgICAgKi9cbiAgICBjb25zdCBbc2VyaWFsLCBzZXRTZXJpYWxdID0gdXNlU3RhdGUoQmlnSW50KDApKTtcbiAgICAvKlxuICAgICAqIEEgcmVmZXJlbmNlIG9mIGFsbCB0aGUgYmF0Y2hlZCB1cGRhdGVzIHRvIHByb2Nlc3MgYmVmb3JlIHRoZSBuZXh0IHJlbmRlci4gV2VcbiAgICAgKiB3YW50IGEgcmVmZXJlbmNlIGhlcmUgc28gbXVsdGlwbGUgc3luY2hyb25vdXMgY2FsbHMgdG8gYHNldE5vZGVzYCBldGMgY2FuIGJlXG4gICAgICogYmF0Y2hlZCB0b2dldGhlci5cbiAgICAgKi9cbiAgICBjb25zdCBbcXVldWVdID0gdXNlU3RhdGUoKCkgPT4gY3JlYXRlUXVldWUoKCkgPT4gc2V0U2VyaWFsKG4gPT4gbiArIEJpZ0ludCgxKSkpKTtcbiAgICAvKlxuICAgICAqIExheW91dCBlZmZlY3RzIGFyZSBndWFyYW50ZWVkIHRvIHJ1biBiZWZvcmUgdGhlIG5leHQgcmVuZGVyIHdoaWNoIG1lYW5zIHdlXG4gICAgICogc2hvdWxkbid0IHJ1biBpbnRvIGFueSBpc3N1ZXMgd2l0aCBzdGFsZSBzdGF0ZSBvciB3ZWlyZCBpc3N1ZXMgdGhhdCBjb21lIGZyb21cbiAgICAgKiByZW5kZXJpbmcgdGhpbmdzIG9uZSBmcmFtZSBsYXRlciB0aGFuIGV4cGVjdGVkICh3ZSB1c2VkIHRvIHVzZSBgc2V0VGltZW91dGApLlxuICAgICAqL1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBxdWV1ZUl0ZW1zID0gcXVldWUuZ2V0KCk7XG4gICAgICAgIGlmIChxdWV1ZUl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgcnVuUXVldWUocXVldWVJdGVtcyk7XG4gICAgICAgICAgICBxdWV1ZS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgfSwgW3NlcmlhbF0pO1xuICAgIHJldHVybiBxdWV1ZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVF1ZXVlKGNiKSB7XG4gICAgbGV0IHF1ZXVlID0gW107XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0OiAoKSA9PiBxdWV1ZSxcbiAgICAgICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIH0sXG4gICAgICAgIHB1c2g6IChpdGVtKSA9PiB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG5jb25zdCBCYXRjaENvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuLyoqXG4gKiBUaGlzIGlzIGEgY29udGV4dCBwcm92aWRlciB0aGF0IGhvbGRzIGFuZCBwcm9jZXNzZXMgdGhlIG5vZGUgYW5kIGVkZ2UgdXBkYXRlIHF1ZXVlc1xuICogdGhhdCBhcmUgbmVlZGVkIHRvIGhhbmRsZSBzZXROb2RlcywgYWRkTm9kZXMsIHNldEVkZ2VzIGFuZCBhZGRFZGdlcy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gQmF0Y2hQcm92aWRlcih7IGNoaWxkcmVuLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IG5vZGVRdWV1ZUhhbmRsZXIgPSB1c2VDYWxsYmFjaygocXVldWVJdGVtcykgPT4ge1xuICAgICAgICBjb25zdCB7IG5vZGVzID0gW10sIHNldE5vZGVzLCBoYXNEZWZhdWx0Tm9kZXMsIG9uTm9kZXNDaGFuZ2UsIG5vZGVMb29rdXAsIGZpdFZpZXdRdWV1ZWQgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFRoaXMgaXMgZXNzZW50aWFsbHkgYW4gYEFycmF5LnJlZHVjZWAgaW4gaW1wZXJhdGl2ZSBjbG90aGluZy4gUHJvY2Vzc2luZ1xuICAgICAgICAgKiB0aGlzIHF1ZXVlIGlzIGEgcmVsYXRpdmVseSBob3QgcGF0aCBzbyB3ZSdkIGxpa2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkIG9mXG4gICAgICAgICAqIGFycmF5IG1ldGhvZHMgd2hlcmUgd2UgY2FuLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IG5leHQgPSBub2RlcztcbiAgICAgICAgZm9yIChjb25zdCBwYXlsb2FkIG9mIHF1ZXVlSXRlbXMpIHtcbiAgICAgICAgICAgIG5leHQgPSB0eXBlb2YgcGF5bG9hZCA9PT0gJ2Z1bmN0aW9uJyA/IHBheWxvYWQobmV4dCkgOiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBnZXRFbGVtZW50c0RpZmZDaGFuZ2VzKHtcbiAgICAgICAgICAgIGl0ZW1zOiBuZXh0LFxuICAgICAgICAgICAgbG9va3VwOiBub2RlTG9va3VwLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGhhc0RlZmF1bHROb2Rlcykge1xuICAgICAgICAgICAgc2V0Tm9kZXMobmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2Ugb25seSB3YW50IHRvIGZpcmUgb25Ob2Rlc0NoYW5nZSBpZiB0aGVyZSBhcmUgY2hhbmdlcyB0byB0aGUgbm9kZXNcbiAgICAgICAgaWYgKGNoYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgb25Ob2Rlc0NoYW5nZT8uKGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpdFZpZXdRdWV1ZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBjaGFuZ2VzIHRvIHRoZSBub2Rlcywgd2Ugc3RpbGwgbmVlZCB0byBjYWxsIHNldE5vZGVzXG4gICAgICAgICAgICAvLyB0byB0cmlnZ2VyIGEgcmUtcmVuZGVyIGFuZCBmaXRWaWV3LlxuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBmaXRWaWV3UXVldWVkLCBub2Rlcywgc2V0Tm9kZXMgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpdFZpZXdRdWV1ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0Tm9kZXMobm9kZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IG5vZGVRdWV1ZSA9IHVzZVF1ZXVlKG5vZGVRdWV1ZUhhbmRsZXIpO1xuICAgIGNvbnN0IGVkZ2VRdWV1ZUhhbmRsZXIgPSB1c2VDYWxsYmFjaygocXVldWVJdGVtcykgPT4ge1xuICAgICAgICBjb25zdCB7IGVkZ2VzID0gW10sIHNldEVkZ2VzLCBoYXNEZWZhdWx0RWRnZXMsIG9uRWRnZXNDaGFuZ2UsIGVkZ2VMb29rdXAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGxldCBuZXh0ID0gZWRnZXM7XG4gICAgICAgIGZvciAoY29uc3QgcGF5bG9hZCBvZiBxdWV1ZUl0ZW1zKSB7XG4gICAgICAgICAgICBuZXh0ID0gdHlwZW9mIHBheWxvYWQgPT09ICdmdW5jdGlvbicgPyBwYXlsb2FkKG5leHQpIDogcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzRGVmYXVsdEVkZ2VzKSB7XG4gICAgICAgICAgICBzZXRFZGdlcyhuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvbkVkZ2VzQ2hhbmdlKSB7XG4gICAgICAgICAgICBvbkVkZ2VzQ2hhbmdlKGdldEVsZW1lbnRzRGlmZkNoYW5nZXMoe1xuICAgICAgICAgICAgICAgIGl0ZW1zOiBuZXh0LFxuICAgICAgICAgICAgICAgIGxvb2t1cDogZWRnZUxvb2t1cCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICBjb25zdCBlZGdlUXVldWUgPSB1c2VRdWV1ZShlZGdlUXVldWVIYW5kbGVyKTtcbiAgICBjb25zdCB2YWx1ZSA9IHVzZU1lbW8oKCkgPT4gKHsgbm9kZVF1ZXVlLCBlZGdlUXVldWUgfSksIFtdKTtcbiAgICByZXR1cm4ganN4KEJhdGNoQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdmFsdWUsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KTtcbn1cbmZ1bmN0aW9uIHVzZUJhdGNoQ29udGV4dCgpIHtcbiAgICBjb25zdCBiYXRjaENvbnRleHQgPSB1c2VDb250ZXh0KEJhdGNoQ29udGV4dCk7XG4gICAgaWYgKCFiYXRjaENvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1c2VCYXRjaENvbnRleHQgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIEJhdGNoUHJvdmlkZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIGJhdGNoQ29udGV4dDtcbn1cblxuY29uc3Qgc2VsZWN0b3IkayA9IChzKSA9PiAhIXMucGFuWm9vbTtcbi8qKlxuICogVGhpcyBob29rIHJldHVybnMgYSBSZWFjdEZsb3dJbnN0YW5jZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHVwZGF0ZSBub2RlcyBhbmQgZWRnZXMsIG1hbmlwdWxhdGUgdGhlIHZpZXdwb3J0LCBvciBxdWVyeSB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZmxvdy5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgdXNlUmVhY3RGbG93IH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZnVuY3Rpb24gTm9kZUNvdW50ZXIoKSB7XG4gKiAgY29uc3QgcmVhY3RGbG93ID0gdXNlUmVhY3RGbG93KCk7XG4gKiAgY29uc3QgW2NvdW50LCBzZXRDb3VudF0gPSB1c2VTdGF0ZSgwKTtcbiAqICBjb25zdCBjb3VudE5vZGVzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICogICAgc2V0Q291bnQocmVhY3RGbG93LmdldE5vZGVzKCkubGVuZ3RoKTtcbiAqICAgIC8vIHlvdSBuZWVkIHRvIHBhc3MgaXQgYXMgYSBkZXBlbmRlbmN5IGlmIHlvdSBhcmUgdXNpbmcgaXQgd2l0aCB1c2VFZmZlY3Qgb3IgdXNlQ2FsbGJhY2tcbiAqICAgIC8vIGJlY2F1c2UgYXQgdGhlIGZpcnN0IHJlbmRlciwgaXQncyBub3QgaW5pdGlhbGl6ZWQgeWV0IGFuZCBzb21lIGZ1bmN0aW9ucyBtaWdodCBub3Qgd29yay5cbiAqICB9LCBbcmVhY3RGbG93XSk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8ZGl2PlxuICogICAgICA8YnV0dG9uIG9uQ2xpY2s9e2NvdW50Tm9kZXN9PlVwZGF0ZSBjb3VudDwvYnV0dG9uPlxuICogICAgICA8cD5UaGVyZSBhcmUge2NvdW50fSBub2RlcyBpbiB0aGUgZmxvdy48L3A+XG4gKiAgICA8L2Rpdj5cbiAqICApO1xuICp9XG4gKmBgYFxuICovXG5mdW5jdGlvbiB1c2VSZWFjdEZsb3coKSB7XG4gICAgY29uc3Qgdmlld3BvcnRIZWxwZXIgPSB1c2VWaWV3cG9ydEhlbHBlcigpO1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBiYXRjaENvbnRleHQgPSB1c2VCYXRjaENvbnRleHQoKTtcbiAgICBjb25zdCB2aWV3cG9ydEluaXRpYWxpemVkID0gdXNlU3RvcmUoc2VsZWN0b3Ikayk7XG4gICAgY29uc3QgZ2VuZXJhbEhlbHBlciA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBnZXRJbnRlcm5hbE5vZGUgPSAoaWQpID0+IHN0b3JlLmdldFN0YXRlKCkubm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgICAgICBjb25zdCBzZXROb2RlcyA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICBiYXRjaENvbnRleHQubm9kZVF1ZXVlLnB1c2gocGF5bG9hZCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNldEVkZ2VzID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIGJhdGNoQ29udGV4dC5lZGdlUXVldWUucHVzaChwYXlsb2FkKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZ2V0Tm9kZVJlY3QgPSAobm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCBub2RlT3JpZ2luIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZVRvVXNlID0gaXNOb2RlKG5vZGUpID8gbm9kZSA6IG5vZGVMb29rdXAuZ2V0KG5vZGUuaWQpO1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBub2RlVG9Vc2UucGFyZW50SWRcbiAgICAgICAgICAgICAgICA/IGV2YWx1YXRlQWJzb2x1dGVQb3NpdGlvbihub2RlVG9Vc2UucG9zaXRpb24sIG5vZGVUb1VzZS5tZWFzdXJlZCwgbm9kZVRvVXNlLnBhcmVudElkLCBub2RlTG9va3VwLCBub2RlT3JpZ2luKVxuICAgICAgICAgICAgICAgIDogbm9kZVRvVXNlLnBvc2l0aW9uO1xuICAgICAgICAgICAgY29uc3Qgbm9kZVdpdGhQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAuLi5ub2RlVG9Vc2UsXG4gICAgICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgd2lkdGg6IG5vZGVUb1VzZS5tZWFzdXJlZD8ud2lkdGggPz8gbm9kZVRvVXNlLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogbm9kZVRvVXNlLm1lYXN1cmVkPy5oZWlnaHQgPz8gbm9kZVRvVXNlLmhlaWdodCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbm9kZVRvUmVjdChub2RlV2l0aFBvc2l0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdXBkYXRlTm9kZSA9IChpZCwgbm9kZVVwZGF0ZSwgb3B0aW9ucyA9IHsgcmVwbGFjZTogZmFsc2UgfSkgPT4ge1xuICAgICAgICAgICAgc2V0Tm9kZXMoKHByZXZOb2RlcykgPT4gcHJldk5vZGVzLm1hcCgobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0Tm9kZSA9IHR5cGVvZiBub2RlVXBkYXRlID09PSAnZnVuY3Rpb24nID8gbm9kZVVwZGF0ZShub2RlKSA6IG5vZGVVcGRhdGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnJlcGxhY2UgJiYgaXNOb2RlKG5leHROb2RlKSA/IG5leHROb2RlIDogeyAuLi5ub2RlLCAuLi5uZXh0Tm9kZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdXBkYXRlRWRnZSA9IChpZCwgZWRnZVVwZGF0ZSwgb3B0aW9ucyA9IHsgcmVwbGFjZTogZmFsc2UgfSkgPT4ge1xuICAgICAgICAgICAgc2V0RWRnZXMoKHByZXZFZGdlcykgPT4gcHJldkVkZ2VzLm1hcCgoZWRnZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlZGdlLmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0RWRnZSA9IHR5cGVvZiBlZGdlVXBkYXRlID09PSAnZnVuY3Rpb24nID8gZWRnZVVwZGF0ZShlZGdlKSA6IGVkZ2VVcGRhdGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnJlcGxhY2UgJiYgaXNFZGdlKG5leHRFZGdlKSA/IG5leHRFZGdlIDogeyAuLi5lZGdlLCAuLi5uZXh0RWRnZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZWRnZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldE5vZGVzOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLm5vZGVzLm1hcCgobikgPT4gKHsgLi4ubiB9KSksXG4gICAgICAgICAgICBnZXROb2RlOiAoaWQpID0+IGdldEludGVybmFsTm9kZShpZCk/LmludGVybmFscy51c2VyTm9kZSxcbiAgICAgICAgICAgIGdldEludGVybmFsTm9kZSxcbiAgICAgICAgICAgIGdldEVkZ2VzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlZGdlcyA9IFtdIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlZGdlcy5tYXAoKGUpID0+ICh7IC4uLmUgfSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEVkZ2U6IChpZCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS5lZGdlTG9va3VwLmdldChpZCksXG4gICAgICAgICAgICBzZXROb2RlcyxcbiAgICAgICAgICAgIHNldEVkZ2VzLFxuICAgICAgICAgICAgYWRkTm9kZXM6IChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Tm9kZXMgPSBBcnJheS5pc0FycmF5KHBheWxvYWQpID8gcGF5bG9hZCA6IFtwYXlsb2FkXTtcbiAgICAgICAgICAgICAgICBiYXRjaENvbnRleHQubm9kZVF1ZXVlLnB1c2goKG5vZGVzKSA9PiBbLi4ubm9kZXMsIC4uLm5ld05vZGVzXSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWRkRWRnZXM6IChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RWRnZXMgPSBBcnJheS5pc0FycmF5KHBheWxvYWQpID8gcGF5bG9hZCA6IFtwYXlsb2FkXTtcbiAgICAgICAgICAgICAgICBiYXRjaENvbnRleHQuZWRnZVF1ZXVlLnB1c2goKGVkZ2VzKSA9PiBbLi4uZWRnZXMsIC4uLm5ld0VkZ2VzXSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9PYmplY3Q6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG5vZGVzID0gW10sIGVkZ2VzID0gW10sIHRyYW5zZm9ybSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBbeCwgeSwgem9vbV0gPSB0cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXM6IG5vZGVzLm1hcCgobikgPT4gKHsgLi4ubiB9KSksXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VzOiBlZGdlcy5tYXAoKGUpID0+ICh7IC4uLmUgfSkpLFxuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgICAgICAgICB6b29tLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVsZXRlRWxlbWVudHM6IGFzeW5jICh7IG5vZGVzOiBub2Rlc1RvUmVtb3ZlID0gW10sIGVkZ2VzOiBlZGdlc1RvUmVtb3ZlID0gW10gfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZXMsIGVkZ2VzLCBvbk5vZGVzRGVsZXRlLCBvbkVkZ2VzRGVsZXRlLCB0cmlnZ2VyTm9kZUNoYW5nZXMsIHRyaWdnZXJFZGdlQ2hhbmdlcywgb25EZWxldGUsIG9uQmVmb3JlRGVsZXRlLCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG5vZGVzOiBtYXRjaGluZ05vZGVzLCBlZGdlczogbWF0Y2hpbmdFZGdlcyB9ID0gYXdhaXQgZ2V0RWxlbWVudHNUb1JlbW92ZSh7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzVG9SZW1vdmUsXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VzVG9SZW1vdmUsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLFxuICAgICAgICAgICAgICAgICAgICBlZGdlcyxcbiAgICAgICAgICAgICAgICAgICAgb25CZWZvcmVEZWxldGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzTWF0Y2hpbmdFZGdlcyA9IG1hdGNoaW5nRWRnZXMubGVuZ3RoID4gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNNYXRjaGluZ05vZGVzID0gbWF0Y2hpbmdOb2Rlcy5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgIGlmIChoYXNNYXRjaGluZ0VkZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVkZ2VDaGFuZ2VzID0gbWF0Y2hpbmdFZGdlcy5tYXAoZWxlbWVudFRvUmVtb3ZlQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgb25FZGdlc0RlbGV0ZT8uKG1hdGNoaW5nRWRnZXMpO1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyRWRnZUNoYW5nZXMoZWRnZUNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWF0Y2hpbmdOb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlQ2hhbmdlcyA9IG1hdGNoaW5nTm9kZXMubWFwKGVsZW1lbnRUb1JlbW92ZUNoYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIG9uTm9kZXNEZWxldGU/LihtYXRjaGluZ05vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKG5vZGVDaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhc01hdGNoaW5nTm9kZXMgfHwgaGFzTWF0Y2hpbmdFZGdlcykge1xuICAgICAgICAgICAgICAgICAgICBvbkRlbGV0ZT8uKHsgbm9kZXM6IG1hdGNoaW5nTm9kZXMsIGVkZ2VzOiBtYXRjaGluZ0VkZ2VzIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBkZWxldGVkTm9kZXM6IG1hdGNoaW5nTm9kZXMsIGRlbGV0ZWRFZGdlczogbWF0Y2hpbmdFZGdlcyB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUGFydGlhbCBpcyBkZWZpbmVkIGFzIFwidGhlIDIgbm9kZXMvYXJlYXMgYXJlIGludGVyc2VjdGluZyBwYXJ0aWFsbHlcIi5cbiAgICAgICAgICAgICAqIElmIGEgaXMgY29udGFpbmVkIGluIGIgb3IgYiBpcyBjb250YWluZWQgaW4gYSwgdGhleSBhcmUgYm90aFxuICAgICAgICAgICAgICogY29uc2lkZXJlZCBmdWxseSBpbnRlcnNlY3RpbmcuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldEludGVyc2VjdGluZ05vZGVzOiAobm9kZU9yUmVjdCwgcGFydGlhbGx5ID0gdHJ1ZSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JlY3QgPSBpc1JlY3RPYmplY3Qobm9kZU9yUmVjdCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZVJlY3QgPSBpc1JlY3QgPyBub2RlT3JSZWN0IDogZ2V0Tm9kZVJlY3Qobm9kZU9yUmVjdCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzTm9kZXNPcHRpb24gPSBub2RlcyAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZVJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKG5vZGVzIHx8IHN0b3JlLmdldFN0YXRlKCkubm9kZXMpLmZpbHRlcigobikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnRlcm5hbE5vZGUgPSBzdG9yZS5nZXRTdGF0ZSgpLm5vZGVMb29rdXAuZ2V0KG4uaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxOb2RlICYmICFpc1JlY3QgJiYgKG4uaWQgPT09IG5vZGVPclJlY3QuaWQgfHwgIWludGVybmFsTm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyTm9kZVJlY3QgPSBub2RlVG9SZWN0KGhhc05vZGVzT3B0aW9uID8gbiA6IGludGVybmFsTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXBwaW5nQXJlYSA9IGdldE92ZXJsYXBwaW5nQXJlYShjdXJyTm9kZVJlY3QsIG5vZGVSZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydGlhbGx5VmlzaWJsZSA9IHBhcnRpYWxseSAmJiBvdmVybGFwcGluZ0FyZWEgPiAwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHBhcnRpYWxseVZpc2libGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBwaW5nQXJlYSA+PSBjdXJyTm9kZVJlY3Qud2lkdGggKiBjdXJyTm9kZVJlY3QuaGVpZ2h0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGFwcGluZ0FyZWEgPj0gbm9kZVJlY3Qud2lkdGggKiBub2RlUmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzTm9kZUludGVyc2VjdGluZzogKG5vZGVPclJlY3QsIGFyZWEsIHBhcnRpYWxseSA9IHRydWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JlY3QgPSBpc1JlY3RPYmplY3Qobm9kZU9yUmVjdCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZVJlY3QgPSBpc1JlY3QgPyBub2RlT3JSZWN0IDogZ2V0Tm9kZVJlY3Qobm9kZU9yUmVjdCk7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlUmVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXBwaW5nQXJlYSA9IGdldE92ZXJsYXBwaW5nQXJlYShub2RlUmVjdCwgYXJlYSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydGlhbGx5VmlzaWJsZSA9IHBhcnRpYWxseSAmJiBvdmVybGFwcGluZ0FyZWEgPiAwO1xuICAgICAgICAgICAgICAgIHJldHVybiAocGFydGlhbGx5VmlzaWJsZSB8fFxuICAgICAgICAgICAgICAgICAgICBvdmVybGFwcGluZ0FyZWEgPj0gYXJlYS53aWR0aCAqIGFyZWEuaGVpZ2h0IHx8XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXBwaW5nQXJlYSA+PSBub2RlUmVjdC53aWR0aCAqIG5vZGVSZWN0LmhlaWdodCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlTm9kZSxcbiAgICAgICAgICAgIHVwZGF0ZU5vZGVEYXRhOiAoaWQsIGRhdGFVcGRhdGUsIG9wdGlvbnMgPSB7IHJlcGxhY2U6IGZhbHNlIH0pID0+IHtcbiAgICAgICAgICAgICAgICB1cGRhdGVOb2RlKGlkLCAobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0RGF0YSA9IHR5cGVvZiBkYXRhVXBkYXRlID09PSAnZnVuY3Rpb24nID8gZGF0YVVwZGF0ZShub2RlKSA6IGRhdGFVcGRhdGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnJlcGxhY2UgPyB7IC4uLm5vZGUsIGRhdGE6IG5leHREYXRhIH0gOiB7IC4uLm5vZGUsIGRhdGE6IHsgLi4ubm9kZS5kYXRhLCAuLi5uZXh0RGF0YSB9IH07XG4gICAgICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlRWRnZSxcbiAgICAgICAgICAgIHVwZGF0ZUVkZ2VEYXRhOiAoaWQsIGRhdGFVcGRhdGUsIG9wdGlvbnMgPSB7IHJlcGxhY2U6IGZhbHNlIH0pID0+IHtcbiAgICAgICAgICAgICAgICB1cGRhdGVFZGdlKGlkLCAoZWRnZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0RGF0YSA9IHR5cGVvZiBkYXRhVXBkYXRlID09PSAnZnVuY3Rpb24nID8gZGF0YVVwZGF0ZShlZGdlKSA6IGRhdGFVcGRhdGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnJlcGxhY2UgPyB7IC4uLmVkZ2UsIGRhdGE6IG5leHREYXRhIH0gOiB7IC4uLmVkZ2UsIGRhdGE6IHsgLi4uZWRnZS5kYXRhLCAuLi5uZXh0RGF0YSB9IH07XG4gICAgICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Tm9kZXNCb3VuZHM6IChub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgbm9kZU9yaWdpbiB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Tm9kZXNCb3VuZHMobm9kZXMsIHsgbm9kZUxvb2t1cCwgbm9kZU9yaWdpbiB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRIYW5kbGVDb25uZWN0aW9uczogKHsgdHlwZSwgaWQsIG5vZGVJZCB9KSA9PiBBcnJheS5mcm9tKHN0b3JlXG4gICAgICAgICAgICAgICAgLmdldFN0YXRlKClcbiAgICAgICAgICAgICAgICAuY29ubmVjdGlvbkxvb2t1cC5nZXQoYCR7bm9kZUlkfS0ke3R5cGV9JHtpZCA/IGAtJHtpZH1gIDogJyd9YClcbiAgICAgICAgICAgICAgICA/LnZhbHVlcygpID8/IFtdKSxcbiAgICAgICAgICAgIGdldE5vZGVDb25uZWN0aW9uczogKHsgdHlwZSwgaGFuZGxlSWQsIG5vZGVJZCB9KSA9PiBBcnJheS5mcm9tKHN0b3JlXG4gICAgICAgICAgICAgICAgLmdldFN0YXRlKClcbiAgICAgICAgICAgICAgICAuY29ubmVjdGlvbkxvb2t1cC5nZXQoYCR7bm9kZUlkfSR7dHlwZSA/IChoYW5kbGVJZCA/IGAtJHt0eXBlfS0ke2hhbmRsZUlkfWAgOiBgLSR7dHlwZX1gKSA6ICcnfWApXG4gICAgICAgICAgICAgICAgPy52YWx1ZXMoKSA/PyBbXSksXG4gICAgICAgICAgICBmaXRWaWV3OiBhc3luYyAob3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFdlIGVpdGhlciBjcmVhdGUgYSBuZXcgUHJvbWlzZSBvciByZXVzZSB0aGUgZXhpc3Rpbmcgb25lXG4gICAgICAgICAgICAgICAgLy8gRXZlbiBpZiBmaXRWaWV3IGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBpbiBhIHJvdywgd2Ugb25seSBlbmQgdXAgd2l0aCBhIHNpbmdsZSBQcm9taXNlXG4gICAgICAgICAgICAgICAgY29uc3QgZml0Vmlld1Jlc29sdmVyID0gc3RvcmUuZ2V0U3RhdGUoKS5maXRWaWV3UmVzb2x2ZXIgPz8gd2l0aFJlc29sdmVycygpO1xuICAgICAgICAgICAgICAgIC8vIFdlIHNjaGVkdWxlIGEgZml0VmlldyBieSBzZXR0aW5nIGZpdFZpZXdRdWV1ZWQgYW5kIHRyaWdnZXJpbmcgYSBzZXROb2Rlc1xuICAgICAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgZml0Vmlld1F1ZXVlZDogdHJ1ZSwgZml0Vmlld09wdGlvbnM6IG9wdGlvbnMsIGZpdFZpZXdSZXNvbHZlciB9KTtcbiAgICAgICAgICAgICAgICBiYXRjaENvbnRleHQubm9kZVF1ZXVlLnB1c2goKG5vZGVzKSA9PiBbLi4ubm9kZXNdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZml0Vmlld1Jlc29sdmVyLnByb21pc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5nZW5lcmFsSGVscGVyLFxuICAgICAgICAgICAgLi4udmlld3BvcnRIZWxwZXIsXG4gICAgICAgICAgICB2aWV3cG9ydEluaXRpYWxpemVkLFxuICAgICAgICB9O1xuICAgIH0sIFt2aWV3cG9ydEluaXRpYWxpemVkXSk7XG59XG5cbmNvbnN0IHNlbGVjdGVkID0gKGl0ZW0pID0+IGl0ZW0uc2VsZWN0ZWQ7XG5jb25zdCB3aW4kMSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdW5kZWZpbmVkO1xuLyoqXG4gKiBIb29rIGZvciBoYW5kbGluZyBnbG9iYWwga2V5IGV2ZW50cy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlR2xvYmFsS2V5SGFuZGxlcih7IGRlbGV0ZUtleUNvZGUsIG11bHRpU2VsZWN0aW9uS2V5Q29kZSwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCB7IGRlbGV0ZUVsZW1lbnRzIH0gPSB1c2VSZWFjdEZsb3coKTtcbiAgICBjb25zdCBkZWxldGVLZXlQcmVzc2VkID0gdXNlS2V5UHJlc3MoZGVsZXRlS2V5Q29kZSwgeyBhY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllcjogZmFsc2UgfSk7XG4gICAgY29uc3QgbXVsdGlTZWxlY3Rpb25LZXlQcmVzc2VkID0gdXNlS2V5UHJlc3MobXVsdGlTZWxlY3Rpb25LZXlDb2RlLCB7IHRhcmdldDogd2luJDEgfSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGRlbGV0ZUtleVByZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZWRnZXMsIG5vZGVzIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgZGVsZXRlRWxlbWVudHMoeyBub2Rlczogbm9kZXMuZmlsdGVyKHNlbGVjdGVkKSwgZWRnZXM6IGVkZ2VzLmZpbHRlcihzZWxlY3RlZCkgfSk7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG5vZGVzU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtkZWxldGVLZXlQcmVzc2VkXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBtdWx0aVNlbGVjdGlvbkFjdGl2ZTogbXVsdGlTZWxlY3Rpb25LZXlQcmVzc2VkIH0pO1xuICAgIH0sIFttdWx0aVNlbGVjdGlvbktleVByZXNzZWRdKTtcbn1cblxuLyoqXG4gKiBIb29rIGZvciBoYW5kbGluZyByZXNpemUgZXZlbnRzLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VSZXNpemVIYW5kbGVyKGRvbU5vZGUpIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlRGltZW5zaW9ucyA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghZG9tTm9kZS5jdXJyZW50IHx8ICEoZG9tTm9kZS5jdXJyZW50LmNoZWNrVmlzaWJpbGl0eT8uKCkgPz8gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzaXplID0gZ2V0RGltZW5zaW9ucyhkb21Ob2RlLmN1cnJlbnQpO1xuICAgICAgICAgICAgaWYgKHNpemUuaGVpZ2h0ID09PSAwIHx8IHNpemUud2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uRXJyb3I/LignMDA0JywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDQnXSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgd2lkdGg6IHNpemUud2lkdGggfHwgNTAwLCBoZWlnaHQ6IHNpemUuaGVpZ2h0IHx8IDUwMCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRvbU5vZGUuY3VycmVudCkge1xuICAgICAgICAgICAgdXBkYXRlRGltZW5zaW9ucygpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZURpbWVuc2lvbnMpO1xuICAgICAgICAgICAgY29uc3QgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4gdXBkYXRlRGltZW5zaW9ucygpKTtcbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoZG9tTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZURpbWVuc2lvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNpemVPYnNlcnZlciAmJiBkb21Ob2RlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKGRvbU5vZGUuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbn1cblxuY29uc3QgY29udGFpbmVyU3R5bGUgPSB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMCxcbn07XG5cbmNvbnN0IHNlbGVjdG9yJGogPSAocykgPT4gKHtcbiAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBzLnVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgbGliOiBzLmxpYixcbiAgICBjb25uZWN0aW9uSW5Qcm9ncmVzczogcy5jb25uZWN0aW9uLmluUHJvZ3Jlc3MsXG59KTtcbmZ1bmN0aW9uIFpvb21QYW5lKHsgb25QYW5lQ29udGV4dE1lbnUsIHpvb21PblNjcm9sbCA9IHRydWUsIHpvb21PblBpbmNoID0gdHJ1ZSwgcGFuT25TY3JvbGwgPSBmYWxzZSwgcGFuT25TY3JvbGxTcGVlZCA9IDAuNSwgcGFuT25TY3JvbGxNb2RlID0gUGFuT25TY3JvbGxNb2RlLkZyZWUsIHpvb21PbkRvdWJsZUNsaWNrID0gdHJ1ZSwgcGFuT25EcmFnID0gdHJ1ZSwgZGVmYXVsdFZpZXdwb3J0LCB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb20sIG1heFpvb20sIHpvb21BY3RpdmF0aW9uS2V5Q29kZSwgcHJldmVudFNjcm9sbGluZyA9IHRydWUsIGNoaWxkcmVuLCBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZSwgb25WaWV3cG9ydENoYW5nZSwgaXNDb250cm9sbGVkVmlld3BvcnQsIHBhbmVDbGlja0Rpc3RhbmNlLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHpvb21QYW5lID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHsgdXNlclNlbGVjdGlvbkFjdGl2ZSwgbGliLCBjb25uZWN0aW9uSW5Qcm9ncmVzcyB9ID0gdXNlU3RvcmUoc2VsZWN0b3Ikaiwgc2hhbGxvdyk7XG4gICAgY29uc3Qgem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkID0gdXNlS2V5UHJlc3Moem9vbUFjdGl2YXRpb25LZXlDb2RlKTtcbiAgICBjb25zdCBwYW5ab29tID0gdXNlUmVmKCk7XG4gICAgdXNlUmVzaXplSGFuZGxlcih6b29tUGFuZSk7XG4gICAgY29uc3Qgb25UcmFuc2Zvcm1DaGFuZ2UgPSB1c2VDYWxsYmFjaygodHJhbnNmb3JtKSA9PiB7XG4gICAgICAgIG9uVmlld3BvcnRDaGFuZ2U/Lih7IHg6IHRyYW5zZm9ybVswXSwgeTogdHJhbnNmb3JtWzFdLCB6b29tOiB0cmFuc2Zvcm1bMl0gfSk7XG4gICAgICAgIGlmICghaXNDb250cm9sbGVkVmlld3BvcnQpIHtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgdHJhbnNmb3JtIH0pO1xuICAgICAgICB9XG4gICAgfSwgW29uVmlld3BvcnRDaGFuZ2UsIGlzQ29udHJvbGxlZFZpZXdwb3J0XSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHpvb21QYW5lLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHBhblpvb20uY3VycmVudCA9IFhZUGFuWm9vbSh7XG4gICAgICAgICAgICAgICAgZG9tTm9kZTogem9vbVBhbmUuY3VycmVudCxcbiAgICAgICAgICAgICAgICBtaW5ab29tLFxuICAgICAgICAgICAgICAgIG1heFpvb20sXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlRXh0ZW50LFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0OiBkZWZhdWx0Vmlld3BvcnQsXG4gICAgICAgICAgICAgICAgcGFuZUNsaWNrRGlzdGFuY2UsXG4gICAgICAgICAgICAgICAgb25EcmFnZ2luZ0NoYW5nZTogKHBhbmVEcmFnZ2luZykgPT4gc3RvcmUuc2V0U3RhdGUoeyBwYW5lRHJhZ2dpbmcgfSksXG4gICAgICAgICAgICAgICAgb25QYW5ab29tU3RhcnQ6IChldmVudCwgdnApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBvblZpZXdwb3J0Q2hhbmdlU3RhcnQsIG9uTW92ZVN0YXJ0IH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBvbk1vdmVTdGFydD8uKGV2ZW50LCB2cCk7XG4gICAgICAgICAgICAgICAgICAgIG9uVmlld3BvcnRDaGFuZ2VTdGFydD8uKHZwKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uUGFuWm9vbTogKGV2ZW50LCB2cCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG9uVmlld3BvcnRDaGFuZ2UsIG9uTW92ZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgb25Nb3ZlPy4oZXZlbnQsIHZwKTtcbiAgICAgICAgICAgICAgICAgICAgb25WaWV3cG9ydENoYW5nZT8uKHZwKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uUGFuWm9vbUVuZDogKGV2ZW50LCB2cCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG9uVmlld3BvcnRDaGFuZ2VFbmQsIG9uTW92ZUVuZCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgb25Nb3ZlRW5kPy4oZXZlbnQsIHZwKTtcbiAgICAgICAgICAgICAgICAgICAgb25WaWV3cG9ydENoYW5nZUVuZD8uKHZwKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHksIHpvb20gfSA9IHBhblpvb20uY3VycmVudC5nZXRWaWV3cG9ydCgpO1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIHBhblpvb206IHBhblpvb20uY3VycmVudCxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFt4LCB5LCB6b29tXSxcbiAgICAgICAgICAgICAgICBkb21Ob2RlOiB6b29tUGFuZS5jdXJyZW50LmNsb3Nlc3QoJy5yZWFjdC1mbG93JyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcGFuWm9vbS5jdXJyZW50Py5kZXN0cm95KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHBhblpvb20uY3VycmVudD8udXBkYXRlKHtcbiAgICAgICAgICAgIG9uUGFuZUNvbnRleHRNZW51LFxuICAgICAgICAgICAgem9vbU9uU2Nyb2xsLFxuICAgICAgICAgICAgem9vbU9uUGluY2gsXG4gICAgICAgICAgICBwYW5PblNjcm9sbCxcbiAgICAgICAgICAgIHBhbk9uU2Nyb2xsU3BlZWQsXG4gICAgICAgICAgICBwYW5PblNjcm9sbE1vZGUsXG4gICAgICAgICAgICB6b29tT25Eb3VibGVDbGljayxcbiAgICAgICAgICAgIHBhbk9uRHJhZyxcbiAgICAgICAgICAgIHpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCxcbiAgICAgICAgICAgIHByZXZlbnRTY3JvbGxpbmcsXG4gICAgICAgICAgICBub1BhbkNsYXNzTmFtZSxcbiAgICAgICAgICAgIHVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgICAgICAgICBub1doZWVsQ2xhc3NOYW1lLFxuICAgICAgICAgICAgbGliLFxuICAgICAgICAgICAgb25UcmFuc2Zvcm1DaGFuZ2UsXG4gICAgICAgICAgICBjb25uZWN0aW9uSW5Qcm9ncmVzcyxcbiAgICAgICAgfSk7XG4gICAgfSwgW1xuICAgICAgICBvblBhbmVDb250ZXh0TWVudSxcbiAgICAgICAgem9vbU9uU2Nyb2xsLFxuICAgICAgICB6b29tT25QaW5jaCxcbiAgICAgICAgcGFuT25TY3JvbGwsXG4gICAgICAgIHBhbk9uU2Nyb2xsU3BlZWQsXG4gICAgICAgIHBhbk9uU2Nyb2xsTW9kZSxcbiAgICAgICAgem9vbU9uRG91YmxlQ2xpY2ssXG4gICAgICAgIHBhbk9uRHJhZyxcbiAgICAgICAgem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsaW5nLFxuICAgICAgICBub1BhbkNsYXNzTmFtZSxcbiAgICAgICAgdXNlclNlbGVjdGlvbkFjdGl2ZSxcbiAgICAgICAgbm9XaGVlbENsYXNzTmFtZSxcbiAgICAgICAgbGliLFxuICAgICAgICBvblRyYW5zZm9ybUNoYW5nZSxcbiAgICAgICAgY29ubmVjdGlvbkluUHJvZ3Jlc3MsXG4gICAgXSk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fcmVuZGVyZXJcIiwgcmVmOiB6b29tUGFuZSwgc3R5bGU6IGNvbnRhaW5lclN0eWxlLCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufVxuXG5jb25zdCBzZWxlY3RvciRpID0gKHMpID0+ICh7XG4gICAgdXNlclNlbGVjdGlvbkFjdGl2ZTogcy51c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgIHVzZXJTZWxlY3Rpb25SZWN0OiBzLnVzZXJTZWxlY3Rpb25SZWN0LFxufSk7XG5mdW5jdGlvbiBVc2VyU2VsZWN0aW9uKCkge1xuICAgIGNvbnN0IHsgdXNlclNlbGVjdGlvbkFjdGl2ZSwgdXNlclNlbGVjdGlvblJlY3QgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGksIHNoYWxsb3cpO1xuICAgIGNvbnN0IGlzQWN0aXZlID0gdXNlclNlbGVjdGlvbkFjdGl2ZSAmJiB1c2VyU2VsZWN0aW9uUmVjdDtcbiAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19zZWxlY3Rpb24gcmVhY3QtZmxvd19fY29udGFpbmVyXCIsIHN0eWxlOiB7XG4gICAgICAgICAgICB3aWR0aDogdXNlclNlbGVjdGlvblJlY3Qud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHVzZXJTZWxlY3Rpb25SZWN0LmhlaWdodCxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgke3VzZXJTZWxlY3Rpb25SZWN0Lnh9cHgsICR7dXNlclNlbGVjdGlvblJlY3QueX1weClgLFxuICAgICAgICB9IH0pKTtcbn1cblxuY29uc3Qgd3JhcEhhbmRsZXIgPSAoaGFuZGxlciwgY29udGFpbmVyUmVmKSA9PiB7XG4gICAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSBjb250YWluZXJSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZXI/LihldmVudCk7XG4gICAgfTtcbn07XG5jb25zdCBzZWxlY3RvciRoID0gKHMpID0+ICh7XG4gICAgdXNlclNlbGVjdGlvbkFjdGl2ZTogcy51c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgIGVsZW1lbnRzU2VsZWN0YWJsZTogcy5lbGVtZW50c1NlbGVjdGFibGUsXG4gICAgY29ubmVjdGlvbkluUHJvZ3Jlc3M6IHMuY29ubmVjdGlvbi5pblByb2dyZXNzLFxuICAgIGRyYWdnaW5nOiBzLnBhbmVEcmFnZ2luZyxcbn0pO1xuZnVuY3Rpb24gUGFuZSh7IGlzU2VsZWN0aW5nLCBzZWxlY3Rpb25LZXlQcmVzc2VkLCBzZWxlY3Rpb25Nb2RlID0gU2VsZWN0aW9uTW9kZS5GdWxsLCBwYW5PbkRyYWcsIHNlbGVjdGlvbk9uRHJhZywgb25TZWxlY3Rpb25TdGFydCwgb25TZWxlY3Rpb25FbmQsIG9uUGFuZUNsaWNrLCBvblBhbmVDb250ZXh0TWVudSwgb25QYW5lU2Nyb2xsLCBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmUsIGNoaWxkcmVuLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHsgdXNlclNlbGVjdGlvbkFjdGl2ZSwgZWxlbWVudHNTZWxlY3RhYmxlLCBkcmFnZ2luZywgY29ubmVjdGlvbkluUHJvZ3Jlc3MgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGgsIHNoYWxsb3cpO1xuICAgIGNvbnN0IGhhc0FjdGl2ZVNlbGVjdGlvbiA9IGVsZW1lbnRzU2VsZWN0YWJsZSAmJiAoaXNTZWxlY3RpbmcgfHwgdXNlclNlbGVjdGlvbkFjdGl2ZSk7XG4gICAgY29uc3QgY29udGFpbmVyID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGNvbnRhaW5lckJvdW5kcyA9IHVzZVJlZigpO1xuICAgIGNvbnN0IHNlbGVjdGVkTm9kZUlkcyA9IHVzZVJlZihuZXcgU2V0KCkpO1xuICAgIGNvbnN0IHNlbGVjdGVkRWRnZUlkcyA9IHVzZVJlZihuZXcgU2V0KCkpO1xuICAgIC8vIFVzZWQgdG8gcHJldmVudCBjbGljayBldmVudHMgd2hlbiB0aGUgdXNlciBsZXRzIGdvIG9mIHRoZSBzZWxlY3Rpb25LZXkgZHVyaW5nIGEgc2VsZWN0aW9uXG4gICAgY29uc3Qgc2VsZWN0aW9uSW5Qcm9ncmVzcyA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3Qgc2VsZWN0aW9uU3RhcnRlZCA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3Qgb25DbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICAvLyBXZSBwcmV2ZW50IGNsaWNrIGV2ZW50cyB3aGVuIHRoZSB1c2VyIGxldCBnbyBvZiB0aGUgc2VsZWN0aW9uS2V5IGR1cmluZyBhIHNlbGVjdGlvblxuICAgICAgICAvLyBXZSBhbHNvIHByZXZlbnQgY2xpY2sgZXZlbnRzIHdoZW4gYSBjb25uZWN0aW9uIGlzIGluIHByb2dyZXNzXG4gICAgICAgIGlmIChzZWxlY3Rpb25JblByb2dyZXNzLmN1cnJlbnQgfHwgY29ubmVjdGlvbkluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbkluUHJvZ3Jlc3MuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9uUGFuZUNsaWNrPy4oZXZlbnQpO1xuICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLnJlc2V0U2VsZWN0ZWRFbGVtZW50cygpO1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG5vZGVzU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uQ29udGV4dE1lbnUgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFuT25EcmFnKSAmJiBwYW5PbkRyYWc/LmluY2x1ZGVzKDIpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9uUGFuZUNvbnRleHRNZW51Py4oZXZlbnQpO1xuICAgIH07XG4gICAgY29uc3Qgb25XaGVlbCA9IG9uUGFuZVNjcm9sbCA/IChldmVudCkgPT4gb25QYW5lU2Nyb2xsKGV2ZW50KSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbkNsaWNrQ2FwdHVyZSA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBpc1NlbGVjdGlvbk9uRHJhZ0FjdGl2ZSA9IChzZWxlY3Rpb25PbkRyYWcgJiYgY29udGFpbmVyLmN1cnJlbnQgPT09IGV2ZW50LnRhcmdldCkgfHwgIXNlbGVjdGlvbk9uRHJhZyB8fCBzZWxlY3Rpb25LZXlQcmVzc2VkO1xuICAgICAgICBpZiAoIWlzU2VsZWN0aW9uT25EcmFnQWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfTtcbiAgICAvLyBXZSBhcmUgdXNpbmcgY2FwdHVyZSBoZXJlIGluIG9yZGVyIHRvIHByZXZlbnQgb3RoZXIgcG9pbnRlciBldmVudHNcbiAgICAvLyB0byBiZSBhYmxlIHRvIGNyZWF0ZSBhIHNlbGVjdGlvbiBhYm92ZSBhIG5vZGUgb3IgYW4gZWRnZVxuICAgIGNvbnN0IG9uUG9pbnRlckRvd25DYXB0dXJlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmVzZXRTZWxlY3RlZEVsZW1lbnRzLCBkb21Ob2RlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb250YWluZXJCb3VuZHMuY3VycmVudCA9IGRvbU5vZGU/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCBpc05vS2V5RXZlbnQgPSBldmVudC50YXJnZXQgIT09IGNvbnRhaW5lci5jdXJyZW50ICYmICEhZXZlbnQudGFyZ2V0LmNsb3Nlc3QoJy5ub2tleScpO1xuICAgICAgICBjb25zdCBpc1NlbGVjdGlvbkFjdGl2ZSA9IChzZWxlY3Rpb25PbkRyYWcgJiYgY29udGFpbmVyLmN1cnJlbnQgPT09IGV2ZW50LnRhcmdldCkgfHwgIXNlbGVjdGlvbk9uRHJhZyB8fCBzZWxlY3Rpb25LZXlQcmVzc2VkO1xuICAgICAgICBpZiAoIWVsZW1lbnRzU2VsZWN0YWJsZSB8fFxuICAgICAgICAgICAgIWlzU2VsZWN0aW5nIHx8XG4gICAgICAgICAgICBldmVudC5idXR0b24gIT09IDAgfHxcbiAgICAgICAgICAgICFjb250YWluZXJCb3VuZHMuY3VycmVudCB8fFxuICAgICAgICAgICAgaXNOb0tleUV2ZW50IHx8XG4gICAgICAgICAgICAhaXNTZWxlY3Rpb25BY3RpdmUgfHxcbiAgICAgICAgICAgICFldmVudC5pc1ByaW1hcnkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQudGFyZ2V0Py5zZXRQb2ludGVyQ2FwdHVyZT8uKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIHNlbGVjdGlvblN0YXJ0ZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgIHNlbGVjdGlvbkluUHJvZ3Jlc3MuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQubmF0aXZlRXZlbnQsIGNvbnRhaW5lckJvdW5kcy5jdXJyZW50KTtcbiAgICAgICAgcmVzZXRTZWxlY3RlZEVsZW1lbnRzKCk7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHVzZXJTZWxlY3Rpb25SZWN0OiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgICAgIHN0YXJ0WDogeCxcbiAgICAgICAgICAgICAgICBzdGFydFk6IHksXG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIG9uU2VsZWN0aW9uU3RhcnQ/LihldmVudCk7XG4gICAgfTtcbiAgICBjb25zdCBvblBvaW50ZXJNb3ZlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdXNlclNlbGVjdGlvblJlY3QsIHRyYW5zZm9ybSwgbm9kZUxvb2t1cCwgZWRnZUxvb2t1cCwgY29ubmVjdGlvbkxvb2t1cCwgdHJpZ2dlck5vZGVDaGFuZ2VzLCB0cmlnZ2VyRWRnZUNoYW5nZXMsIGRlZmF1bHRFZGdlT3B0aW9ucywgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmICghY29udGFpbmVyQm91bmRzLmN1cnJlbnQgfHwgIXVzZXJTZWxlY3Rpb25SZWN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0aW9uSW5Qcm9ncmVzcy5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyB4OiBtb3VzZVgsIHk6IG1vdXNlWSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudC5uYXRpdmVFdmVudCwgY29udGFpbmVyQm91bmRzLmN1cnJlbnQpO1xuICAgICAgICBjb25zdCB7IHN0YXJ0WCwgc3RhcnRZIH0gPSB1c2VyU2VsZWN0aW9uUmVjdDtcbiAgICAgICAgY29uc3QgbmV4dFVzZXJTZWxlY3RSZWN0ID0ge1xuICAgICAgICAgICAgc3RhcnRYLFxuICAgICAgICAgICAgc3RhcnRZLFxuICAgICAgICAgICAgeDogbW91c2VYIDwgc3RhcnRYID8gbW91c2VYIDogc3RhcnRYLFxuICAgICAgICAgICAgeTogbW91c2VZIDwgc3RhcnRZID8gbW91c2VZIDogc3RhcnRZLFxuICAgICAgICAgICAgd2lkdGg6IE1hdGguYWJzKG1vdXNlWCAtIHN0YXJ0WCksXG4gICAgICAgICAgICBoZWlnaHQ6IE1hdGguYWJzKG1vdXNlWSAtIHN0YXJ0WSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHByZXZTZWxlY3RlZE5vZGVJZHMgPSBzZWxlY3RlZE5vZGVJZHMuY3VycmVudDtcbiAgICAgICAgY29uc3QgcHJldlNlbGVjdGVkRWRnZUlkcyA9IHNlbGVjdGVkRWRnZUlkcy5jdXJyZW50O1xuICAgICAgICBzZWxlY3RlZE5vZGVJZHMuY3VycmVudCA9IG5ldyBTZXQoZ2V0Tm9kZXNJbnNpZGUobm9kZUxvb2t1cCwgbmV4dFVzZXJTZWxlY3RSZWN0LCB0cmFuc2Zvcm0sIHNlbGVjdGlvbk1vZGUgPT09IFNlbGVjdGlvbk1vZGUuUGFydGlhbCwgdHJ1ZSkubWFwKChub2RlKSA9PiBub2RlLmlkKSk7XG4gICAgICAgIHNlbGVjdGVkRWRnZUlkcy5jdXJyZW50ID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBlZGdlc1NlbGVjdGFibGUgPSBkZWZhdWx0RWRnZU9wdGlvbnM/LnNlbGVjdGFibGUgPz8gdHJ1ZTtcbiAgICAgICAgLy8gV2UgbG9vayBmb3IgYWxsIGVkZ2VzIGNvbm5lY3RlZCB0byB0aGUgc2VsZWN0ZWQgbm9kZXNcbiAgICAgICAgZm9yIChjb25zdCBub2RlSWQgb2Ygc2VsZWN0ZWROb2RlSWRzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gY29ubmVjdGlvbkxvb2t1cC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgIGlmICghY29ubmVjdGlvbnMpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgZWRnZUlkIH0gb2YgY29ubmVjdGlvbnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlZGdlID0gZWRnZUxvb2t1cC5nZXQoZWRnZUlkKTtcbiAgICAgICAgICAgICAgICBpZiAoZWRnZSAmJiAoZWRnZS5zZWxlY3RhYmxlID8/IGVkZ2VzU2VsZWN0YWJsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRFZGdlSWRzLmN1cnJlbnQuYWRkKGVkZ2VJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYXJlU2V0c0VxdWFsKHByZXZTZWxlY3RlZE5vZGVJZHMsIHNlbGVjdGVkTm9kZUlkcy5jdXJyZW50KSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IGdldFNlbGVjdGlvbkNoYW5nZXMobm9kZUxvb2t1cCwgc2VsZWN0ZWROb2RlSWRzLmN1cnJlbnQsIHRydWUpO1xuICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYXJlU2V0c0VxdWFsKHByZXZTZWxlY3RlZEVkZ2VJZHMsIHNlbGVjdGVkRWRnZUlkcy5jdXJyZW50KSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IGdldFNlbGVjdGlvbkNoYW5nZXMoZWRnZUxvb2t1cCwgc2VsZWN0ZWRFZGdlSWRzLmN1cnJlbnQpO1xuICAgICAgICAgICAgdHJpZ2dlckVkZ2VDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHVzZXJTZWxlY3Rpb25SZWN0OiBuZXh0VXNlclNlbGVjdFJlY3QsXG4gICAgICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiB0cnVlLFxuICAgICAgICAgICAgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uUG9pbnRlclVwID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgIXNlbGVjdGlvblN0YXJ0ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnRhcmdldD8ucmVsZWFzZVBvaW50ZXJDYXB0dXJlPy4oZXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgY29uc3QgeyB1c2VyU2VsZWN0aW9uUmVjdCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgLypcbiAgICAgICAgICogV2Ugb25seSB3YW50IHRvIHRyaWdnZXIgY2xpY2sgZnVuY3Rpb25zIHdoZW4gaW4gc2VsZWN0aW9uIG1vZGUgaWZcbiAgICAgICAgICogdGhlIHVzZXIgZGlkIG5vdCBtb3ZlIHRoZSBtb3VzZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmICghdXNlclNlbGVjdGlvbkFjdGl2ZSAmJiB1c2VyU2VsZWN0aW9uUmVjdCAmJiBldmVudC50YXJnZXQgPT09IGNvbnRhaW5lci5jdXJyZW50KSB7XG4gICAgICAgICAgICBvbkNsaWNrPy4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHVzZXJTZWxlY3Rpb25BY3RpdmU6IGZhbHNlLFxuICAgICAgICAgICAgdXNlclNlbGVjdGlvblJlY3Q6IG51bGwsXG4gICAgICAgICAgICBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogc2VsZWN0ZWROb2RlSWRzLmN1cnJlbnQuc2l6ZSA+IDAsXG4gICAgICAgIH0pO1xuICAgICAgICBvblNlbGVjdGlvbkVuZD8uKGV2ZW50KTtcbiAgICAgICAgLypcbiAgICAgICAgICogSWYgdGhlIHVzZXIga2VwdCBob2xkaW5nIHRoZSBzZWxlY3Rpb25LZXkgZHVyaW5nIHRoZSBzZWxlY3Rpb24sXG4gICAgICAgICAqIHdlIG5lZWQgdG8gcmVzZXQgdGhlIHNlbGVjdGlvbkluUHJvZ3Jlc3MsIHNvIHRoZSBuZXh0IGNsaWNrIGV2ZW50IGlzIG5vdCBwcmV2ZW50ZWRcbiAgICAgICAgICovXG4gICAgICAgIGlmIChzZWxlY3Rpb25LZXlQcmVzc2VkIHx8IHNlbGVjdGlvbk9uRHJhZykge1xuICAgICAgICAgICAgc2VsZWN0aW9uSW5Qcm9ncmVzcy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0aW9uU3RhcnRlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCBkcmFnZ2FibGUgPSBwYW5PbkRyYWcgPT09IHRydWUgfHwgKEFycmF5LmlzQXJyYXkocGFuT25EcmFnKSAmJiBwYW5PbkRyYWcuaW5jbHVkZXMoMCkpO1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19wYW5lJywgeyBkcmFnZ2FibGUsIGRyYWdnaW5nLCBzZWxlY3Rpb246IGlzU2VsZWN0aW5nIH1dKSwgb25DbGljazogaGFzQWN0aXZlU2VsZWN0aW9uID8gdW5kZWZpbmVkIDogd3JhcEhhbmRsZXIob25DbGljaywgY29udGFpbmVyKSwgb25Db250ZXh0TWVudTogd3JhcEhhbmRsZXIob25Db250ZXh0TWVudSwgY29udGFpbmVyKSwgb25XaGVlbDogd3JhcEhhbmRsZXIob25XaGVlbCwgY29udGFpbmVyKSwgb25Qb2ludGVyRW50ZXI6IGhhc0FjdGl2ZVNlbGVjdGlvbiA/IHVuZGVmaW5lZCA6IG9uUGFuZU1vdXNlRW50ZXIsIG9uUG9pbnRlck1vdmU6IGhhc0FjdGl2ZVNlbGVjdGlvbiA/IG9uUG9pbnRlck1vdmUgOiBvblBhbmVNb3VzZU1vdmUsIG9uUG9pbnRlclVwOiBoYXNBY3RpdmVTZWxlY3Rpb24gPyBvblBvaW50ZXJVcCA6IHVuZGVmaW5lZCwgb25Qb2ludGVyRG93bkNhcHR1cmU6IGhhc0FjdGl2ZVNlbGVjdGlvbiA/IG9uUG9pbnRlckRvd25DYXB0dXJlIDogdW5kZWZpbmVkLCBvbkNsaWNrQ2FwdHVyZTogaGFzQWN0aXZlU2VsZWN0aW9uID8gb25DbGlja0NhcHR1cmUgOiB1bmRlZmluZWQsIG9uUG9pbnRlckxlYXZlOiBvblBhbmVNb3VzZUxlYXZlLCByZWY6IGNvbnRhaW5lciwgc3R5bGU6IGNvbnRhaW5lclN0eWxlLCBjaGlsZHJlbjogW2NoaWxkcmVuLCBqc3goVXNlclNlbGVjdGlvbiwge30pXSB9KSk7XG59XG5cbi8qXG4gKiB0aGlzIGhhbmRsZXIgaXMgY2FsbGVkIGJ5XG4gKiAxLiB0aGUgY2xpY2sgaGFuZGxlciB3aGVuIG5vZGUgaXMgbm90IGRyYWdnYWJsZSBvciBzZWxlY3ROb2Rlc09uRHJhZyA9IGZhbHNlXG4gKiBvclxuICogMi4gdGhlIG9uIGRyYWcgc3RhcnQgaGFuZGxlciB3aGVuIG5vZGUgaXMgZHJhZ2dhYmxlIGFuZCBzZWxlY3ROb2Rlc09uRHJhZyA9IHRydWVcbiAqL1xuZnVuY3Rpb24gaGFuZGxlTm9kZUNsaWNrKHsgaWQsIHN0b3JlLCB1bnNlbGVjdCA9IGZhbHNlLCBub2RlUmVmLCB9KSB7XG4gICAgY29uc3QgeyBhZGRTZWxlY3RlZE5vZGVzLCB1bnNlbGVjdE5vZGVzQW5kRWRnZXMsIG11bHRpU2VsZWN0aW9uQWN0aXZlLCBub2RlTG9va3VwLCBvbkVycm9yIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IG5vZGUgPSBub2RlTG9va3VwLmdldChpZCk7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICAgIG9uRXJyb3I/LignMDEyJywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMTInXShpZCkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0b3JlLnNldFN0YXRlKHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlIH0pO1xuICAgIGlmICghbm9kZS5zZWxlY3RlZCkge1xuICAgICAgICBhZGRTZWxlY3RlZE5vZGVzKFtpZF0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh1bnNlbGVjdCB8fCAobm9kZS5zZWxlY3RlZCAmJiBtdWx0aVNlbGVjdGlvbkFjdGl2ZSkpIHtcbiAgICAgICAgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzKHsgbm9kZXM6IFtub2RlXSwgZWRnZXM6IFtdIH0pO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gbm9kZVJlZj8uY3VycmVudD8uYmx1cigpKTtcbiAgICB9XG59XG5cbi8qKlxuICogSG9vayBmb3IgY2FsbGluZyBYWURyYWcgaGVscGVyIGZyb20gQHh5Zmxvdy9zeXN0ZW0uXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZURyYWcoeyBub2RlUmVmLCBkaXNhYmxlZCA9IGZhbHNlLCBub0RyYWdDbGFzc05hbWUsIGhhbmRsZVNlbGVjdG9yLCBub2RlSWQsIGlzU2VsZWN0YWJsZSwgbm9kZUNsaWNrRGlzdGFuY2UsIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgW2RyYWdnaW5nLCBzZXREcmFnZ2luZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgeHlEcmFnID0gdXNlUmVmKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgeHlEcmFnLmN1cnJlbnQgPSBYWURyYWcoe1xuICAgICAgICAgICAgZ2V0U3RvcmVJdGVtczogKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKSxcbiAgICAgICAgICAgIG9uTm9kZU1vdXNlRG93bjogKGlkKSA9PiB7XG4gICAgICAgICAgICAgICAgaGFuZGxlTm9kZUNsaWNrKHtcbiAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgICAgICAgICAgICBub2RlUmVmLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRHJhZ1N0YXJ0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0RHJhZ2dpbmcodHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25EcmFnU3RvcDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldERyYWdnaW5nKGZhbHNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH0sIFtdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHh5RHJhZy5jdXJyZW50Py5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICB4eURyYWcuY3VycmVudD8udXBkYXRlKHtcbiAgICAgICAgICAgICAgICBub0RyYWdDbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgaGFuZGxlU2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgZG9tTm9kZTogbm9kZVJlZi5jdXJyZW50LFxuICAgICAgICAgICAgICAgIGlzU2VsZWN0YWJsZSxcbiAgICAgICAgICAgICAgICBub2RlSWQsXG4gICAgICAgICAgICAgICAgbm9kZUNsaWNrRGlzdGFuY2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgeHlEcmFnLmN1cnJlbnQ/LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCBbbm9EcmFnQ2xhc3NOYW1lLCBoYW5kbGVTZWxlY3RvciwgZGlzYWJsZWQsIGlzU2VsZWN0YWJsZSwgbm9kZVJlZiwgbm9kZUlkXSk7XG4gICAgcmV0dXJuIGRyYWdnaW5nO1xufVxuXG5jb25zdCBzZWxlY3RlZEFuZERyYWdnYWJsZSA9IChub2Rlc0RyYWdnYWJsZSkgPT4gKG4pID0+IG4uc2VsZWN0ZWQgJiYgKG4uZHJhZ2dhYmxlIHx8IChub2Rlc0RyYWdnYWJsZSAmJiB0eXBlb2Ygbi5kcmFnZ2FibGUgPT09ICd1bmRlZmluZWQnKSk7XG4vKipcbiAqIEhvb2sgZm9yIHVwZGF0aW5nIG5vZGUgcG9zaXRpb25zIGJ5IHBhc3NpbmcgYSBkaXJlY3Rpb24gYW5kIGZhY3RvclxuICpcbiAqIEBpbnRlcm5hbFxuICogQHJldHVybnMgZnVuY3Rpb24gZm9yIHVwZGF0aW5nIG5vZGUgcG9zaXRpb25zXG4gKi9cbmZ1bmN0aW9uIHVzZU1vdmVTZWxlY3RlZE5vZGVzKCkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBtb3ZlU2VsZWN0ZWROb2RlcyA9IHVzZUNhbGxiYWNrKChwYXJhbXMpID0+IHtcbiAgICAgICAgY29uc3QgeyBub2RlRXh0ZW50LCBzbmFwVG9HcmlkLCBzbmFwR3JpZCwgbm9kZXNEcmFnZ2FibGUsIG9uRXJyb3IsIHVwZGF0ZU5vZGVQb3NpdGlvbnMsIG5vZGVMb29rdXAsIG5vZGVPcmlnaW4gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IG5vZGVVcGRhdGVzID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBpc1NlbGVjdGVkID0gc2VsZWN0ZWRBbmREcmFnZ2FibGUobm9kZXNEcmFnZ2FibGUpO1xuICAgICAgICAvKlxuICAgICAgICAgKiBieSBkZWZhdWx0IGEgbm9kZSBtb3ZlcyA1cHggb24gZWFjaCBrZXkgcHJlc3NcbiAgICAgICAgICogaWYgc25hcCBncmlkIGlzIGVuYWJsZWQsIHdlIHVzZSB0aGF0IGZvciB0aGUgdmVsb2NpdHlcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHhWZWxvID0gc25hcFRvR3JpZCA/IHNuYXBHcmlkWzBdIDogNTtcbiAgICAgICAgY29uc3QgeVZlbG8gPSBzbmFwVG9HcmlkID8gc25hcEdyaWRbMV0gOiA1O1xuICAgICAgICBjb25zdCB4RGlmZiA9IHBhcmFtcy5kaXJlY3Rpb24ueCAqIHhWZWxvICogcGFyYW1zLmZhY3RvcjtcbiAgICAgICAgY29uc3QgeURpZmYgPSBwYXJhbXMuZGlyZWN0aW9uLnkgKiB5VmVsbyAqIHBhcmFtcy5mYWN0b3I7XG4gICAgICAgIGZvciAoY29uc3QgWywgbm9kZV0gb2Ygbm9kZUxvb2t1cCkge1xuICAgICAgICAgICAgaWYgKCFpc1NlbGVjdGVkKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbmV4dFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIHg6IG5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueCArIHhEaWZmLFxuICAgICAgICAgICAgICAgIHk6IG5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueSArIHlEaWZmLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChzbmFwVG9HcmlkKSB7XG4gICAgICAgICAgICAgICAgbmV4dFBvc2l0aW9uID0gc25hcFBvc2l0aW9uKG5leHRQb3NpdGlvbiwgc25hcEdyaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBwb3NpdGlvbiwgcG9zaXRpb25BYnNvbHV0ZSB9ID0gY2FsY3VsYXRlTm9kZVBvc2l0aW9uKHtcbiAgICAgICAgICAgICAgICBub2RlSWQ6IG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgbmV4dFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgICAgICAgICAgbm9kZUV4dGVudCxcbiAgICAgICAgICAgICAgICBub2RlT3JpZ2luLFxuICAgICAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5vZGUucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgICAgIG5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUgPSBwb3NpdGlvbkFic29sdXRlO1xuICAgICAgICAgICAgbm9kZVVwZGF0ZXMuc2V0KG5vZGUuaWQsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZU5vZGVQb3NpdGlvbnMobm9kZVVwZGF0ZXMpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gbW92ZVNlbGVjdGVkTm9kZXM7XG59XG5cbmNvbnN0IE5vZGVJZENvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgUHJvdmlkZXIgPSBOb2RlSWRDb250ZXh0LlByb3ZpZGVyO1xuTm9kZUlkQ29udGV4dC5Db25zdW1lcjtcbi8qKlxuICogWW91IGNhbiB1c2UgdGhpcyBob29rIHRvIGdldCB0aGUgaWQgb2YgdGhlIG5vZGUgaXQgaXMgdXNlZCBpbnNpZGUuIEl0IGlzIHVzZWZ1bFxuICogaWYgeW91IG5lZWQgdGhlIG5vZGUncyBpZCBkZWVwZXIgaW4gdGhlIHJlbmRlciB0cmVlIGJ1dCBkb24ndCB3YW50IHRvIG1hbnVhbGx5XG4gKiBkcmlsbCBkb3duIHRoZSBpZCBhcyBhIHByb3AuXG4gKlxuICogQHB1YmxpY1xuICogQHJldHVybnMgVGhlIGlkIGZvciBhIG5vZGUgaW4gdGhlIGZsb3cuXG4gKlxuICogQGV4YW1wbGVcbiAqYGBganN4XG4gKmltcG9ydCB7IHVzZU5vZGVJZCB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ3VzdG9tTm9kZSgpIHtcbiAqICByZXR1cm4gKFxuICogICAgPGRpdj5cbiAqICAgICAgPHNwYW4+VGhpcyBub2RlIGhhcyBhbiBpZCBvZiA8L3NwYW4+XG4gKiAgICAgIDxOb2RlSWREaXNwbGF5IC8+XG4gKiAgICA8L2Rpdj5cbiAqICApO1xuICp9XG4gKlxuICpmdW5jdGlvbiBOb2RlSWREaXNwbGF5KCkge1xuICogIGNvbnN0IG5vZGVJZCA9IHVzZU5vZGVJZCgpO1xuICpcbiAqICByZXR1cm4gPHNwYW4+e25vZGVJZH08L3NwYW4+O1xuICp9XG4gKmBgYFxuICovXG5jb25zdCB1c2VOb2RlSWQgPSAoKSA9PiB7XG4gICAgY29uc3Qgbm9kZUlkID0gdXNlQ29udGV4dChOb2RlSWRDb250ZXh0KTtcbiAgICByZXR1cm4gbm9kZUlkO1xufTtcblxuY29uc3Qgc2VsZWN0b3IkZyA9IChzKSA9PiAoe1xuICAgIGNvbm5lY3RPbkNsaWNrOiBzLmNvbm5lY3RPbkNsaWNrLFxuICAgIG5vUGFuQ2xhc3NOYW1lOiBzLm5vUGFuQ2xhc3NOYW1lLFxuICAgIHJmSWQ6IHMucmZJZCxcbn0pO1xuY29uc3QgY29ubmVjdGluZ1NlbGVjdG9yID0gKG5vZGVJZCwgaGFuZGxlSWQsIHR5cGUpID0+IChzdGF0ZSkgPT4ge1xuICAgIGNvbnN0IHsgY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGU6IGNsaWNrSGFuZGxlLCBjb25uZWN0aW9uTW9kZSwgY29ubmVjdGlvbiB9ID0gc3RhdGU7XG4gICAgY29uc3QgeyBmcm9tSGFuZGxlLCB0b0hhbmRsZSwgaXNWYWxpZCB9ID0gY29ubmVjdGlvbjtcbiAgICBjb25zdCBjb25uZWN0aW5nVG8gPSB0b0hhbmRsZT8ubm9kZUlkID09PSBub2RlSWQgJiYgdG9IYW5kbGU/LmlkID09PSBoYW5kbGVJZCAmJiB0b0hhbmRsZT8udHlwZSA9PT0gdHlwZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb25uZWN0aW5nRnJvbTogZnJvbUhhbmRsZT8ubm9kZUlkID09PSBub2RlSWQgJiYgZnJvbUhhbmRsZT8uaWQgPT09IGhhbmRsZUlkICYmIGZyb21IYW5kbGU/LnR5cGUgPT09IHR5cGUsXG4gICAgICAgIGNvbm5lY3RpbmdUbyxcbiAgICAgICAgY2xpY2tDb25uZWN0aW5nOiBjbGlja0hhbmRsZT8ubm9kZUlkID09PSBub2RlSWQgJiYgY2xpY2tIYW5kbGU/LmlkID09PSBoYW5kbGVJZCAmJiBjbGlja0hhbmRsZT8udHlwZSA9PT0gdHlwZSxcbiAgICAgICAgaXNQb3NzaWJsZUVuZEhhbmRsZTogY29ubmVjdGlvbk1vZGUgPT09IENvbm5lY3Rpb25Nb2RlLlN0cmljdFxuICAgICAgICAgICAgPyBmcm9tSGFuZGxlPy50eXBlICE9PSB0eXBlXG4gICAgICAgICAgICA6IG5vZGVJZCAhPT0gZnJvbUhhbmRsZT8ubm9kZUlkIHx8IGhhbmRsZUlkICE9PSBmcm9tSGFuZGxlPy5pZCxcbiAgICAgICAgY29ubmVjdGlvbkluUHJvY2VzczogISFmcm9tSGFuZGxlLFxuICAgICAgICBjbGlja0Nvbm5lY3Rpb25JblByb2Nlc3M6ICEhY2xpY2tIYW5kbGUsXG4gICAgICAgIHZhbGlkOiBjb25uZWN0aW5nVG8gJiYgaXNWYWxpZCxcbiAgICB9O1xufTtcbmZ1bmN0aW9uIEhhbmRsZUNvbXBvbmVudCh7IHR5cGUgPSAnc291cmNlJywgcG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIGlzVmFsaWRDb25uZWN0aW9uLCBpc0Nvbm5lY3RhYmxlID0gdHJ1ZSwgaXNDb25uZWN0YWJsZVN0YXJ0ID0gdHJ1ZSwgaXNDb25uZWN0YWJsZUVuZCA9IHRydWUsIGlkLCBvbkNvbm5lY3QsIGNoaWxkcmVuLCBjbGFzc05hbWUsIG9uTW91c2VEb3duLCBvblRvdWNoU3RhcnQsIC4uLnJlc3QgfSwgcmVmKSB7XG4gICAgY29uc3QgaGFuZGxlSWQgPSBpZCB8fCBudWxsO1xuICAgIGNvbnN0IGlzVGFyZ2V0ID0gdHlwZSA9PT0gJ3RhcmdldCc7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IG5vZGVJZCA9IHVzZU5vZGVJZCgpO1xuICAgIGNvbnN0IHsgY29ubmVjdE9uQ2xpY2ssIG5vUGFuQ2xhc3NOYW1lLCByZklkIH0gPSB1c2VTdG9yZShzZWxlY3RvciRnLCBzaGFsbG93KTtcbiAgICBjb25zdCB7IGNvbm5lY3RpbmdGcm9tLCBjb25uZWN0aW5nVG8sIGNsaWNrQ29ubmVjdGluZywgaXNQb3NzaWJsZUVuZEhhbmRsZSwgY29ubmVjdGlvbkluUHJvY2VzcywgY2xpY2tDb25uZWN0aW9uSW5Qcm9jZXNzLCB2YWxpZCwgfSA9IHVzZVN0b3JlKGNvbm5lY3RpbmdTZWxlY3Rvcihub2RlSWQsIGhhbmRsZUlkLCB0eXBlKSwgc2hhbGxvdyk7XG4gICAgaWYgKCFub2RlSWQpIHtcbiAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5vbkVycm9yPy4oJzAxMCcsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDEwJ10oKSk7XG4gICAgfVxuICAgIGNvbnN0IG9uQ29ubmVjdEV4dGVuZGVkID0gKHBhcmFtcykgPT4ge1xuICAgICAgICBjb25zdCB7IGRlZmF1bHRFZGdlT3B0aW9ucywgb25Db25uZWN0OiBvbkNvbm5lY3RBY3Rpb24sIGhhc0RlZmF1bHRFZGdlcyB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3QgZWRnZVBhcmFtcyA9IHtcbiAgICAgICAgICAgIC4uLmRlZmF1bHRFZGdlT3B0aW9ucyxcbiAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGhhc0RlZmF1bHRFZGdlcykge1xuICAgICAgICAgICAgY29uc3QgeyBlZGdlcywgc2V0RWRnZXMgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBzZXRFZGdlcyhhZGRFZGdlKGVkZ2VQYXJhbXMsIGVkZ2VzKSk7XG4gICAgICAgIH1cbiAgICAgICAgb25Db25uZWN0QWN0aW9uPy4oZWRnZVBhcmFtcyk7XG4gICAgICAgIG9uQ29ubmVjdD8uKGVkZ2VQYXJhbXMpO1xuICAgIH07XG4gICAgY29uc3Qgb25Qb2ludGVyRG93biA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoIW5vZGVJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzTW91c2VUcmlnZ2VyZWQgPSBpc01vdXNlRXZlbnQoZXZlbnQubmF0aXZlRXZlbnQpO1xuICAgICAgICBpZiAoaXNDb25uZWN0YWJsZVN0YXJ0ICYmXG4gICAgICAgICAgICAoKGlzTW91c2VUcmlnZ2VyZWQgJiYgZXZlbnQuYnV0dG9uID09PSAwKSB8fCAhaXNNb3VzZVRyaWdnZXJlZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdG9yZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBYWUhhbmRsZS5vblBvaW50ZXJEb3duKGV2ZW50Lm5hdGl2ZUV2ZW50LCB7XG4gICAgICAgICAgICAgICAgaGFuZGxlRG9tTm9kZTogZXZlbnQuY3VycmVudFRhcmdldCxcbiAgICAgICAgICAgICAgICBhdXRvUGFuT25Db25uZWN0OiBjdXJyZW50U3RvcmUuYXV0b1Bhbk9uQ29ubmVjdCxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uTW9kZTogY3VycmVudFN0b3JlLmNvbm5lY3Rpb25Nb2RlLFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25SYWRpdXM6IGN1cnJlbnRTdG9yZS5jb25uZWN0aW9uUmFkaXVzLFxuICAgICAgICAgICAgICAgIGRvbU5vZGU6IGN1cnJlbnRTdG9yZS5kb21Ob2RlLFxuICAgICAgICAgICAgICAgIG5vZGVMb29rdXA6IGN1cnJlbnRTdG9yZS5ub2RlTG9va3VwLFxuICAgICAgICAgICAgICAgIGxpYjogY3VycmVudFN0b3JlLmxpYixcbiAgICAgICAgICAgICAgICBpc1RhcmdldCxcbiAgICAgICAgICAgICAgICBoYW5kbGVJZCxcbiAgICAgICAgICAgICAgICBub2RlSWQsXG4gICAgICAgICAgICAgICAgZmxvd0lkOiBjdXJyZW50U3RvcmUucmZJZCxcbiAgICAgICAgICAgICAgICBwYW5CeTogY3VycmVudFN0b3JlLnBhbkJ5LFxuICAgICAgICAgICAgICAgIGNhbmNlbENvbm5lY3Rpb246IGN1cnJlbnRTdG9yZS5jYW5jZWxDb25uZWN0aW9uLFxuICAgICAgICAgICAgICAgIG9uQ29ubmVjdFN0YXJ0OiBjdXJyZW50U3RvcmUub25Db25uZWN0U3RhcnQsXG4gICAgICAgICAgICAgICAgb25Db25uZWN0RW5kOiBjdXJyZW50U3RvcmUub25Db25uZWN0RW5kLFxuICAgICAgICAgICAgICAgIHVwZGF0ZUNvbm5lY3Rpb246IGN1cnJlbnRTdG9yZS51cGRhdGVDb25uZWN0aW9uLFxuICAgICAgICAgICAgICAgIG9uQ29ubmVjdDogb25Db25uZWN0RXh0ZW5kZWQsXG4gICAgICAgICAgICAgICAgaXNWYWxpZENvbm5lY3Rpb246IGlzVmFsaWRDb25uZWN0aW9uIHx8IGN1cnJlbnRTdG9yZS5pc1ZhbGlkQ29ubmVjdGlvbixcbiAgICAgICAgICAgICAgICBnZXRUcmFuc2Zvcm06ICgpID0+IHN0b3JlLmdldFN0YXRlKCkudHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgIGdldEZyb21IYW5kbGU6ICgpID0+IHN0b3JlLmdldFN0YXRlKCkuY29ubmVjdGlvbi5mcm9tSGFuZGxlLFxuICAgICAgICAgICAgICAgIGF1dG9QYW5TcGVlZDogY3VycmVudFN0b3JlLmF1dG9QYW5TcGVlZCxcbiAgICAgICAgICAgICAgICBkcmFnVGhyZXNob2xkOiBjdXJyZW50U3RvcmUuY29ubmVjdGlvbkRyYWdUaHJlc2hvbGQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNNb3VzZVRyaWdnZXJlZCkge1xuICAgICAgICAgICAgb25Nb3VzZURvd24/LihldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvblRvdWNoU3RhcnQ/LihldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG9uQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgeyBvbkNsaWNrQ29ubmVjdFN0YXJ0LCBvbkNsaWNrQ29ubmVjdEVuZCwgY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUsIGNvbm5lY3Rpb25Nb2RlLCBpc1ZhbGlkQ29ubmVjdGlvbjogaXNWYWxpZENvbm5lY3Rpb25TdG9yZSwgbGliLCByZklkOiBmbG93SWQsIG5vZGVMb29rdXAsIGNvbm5lY3Rpb246IGNvbm5lY3Rpb25TdGF0ZSwgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmICghbm9kZUlkIHx8ICghY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUgJiYgIWlzQ29ubmVjdGFibGVTdGFydCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlKSB7XG4gICAgICAgICAgICBvbkNsaWNrQ29ubmVjdFN0YXJ0Py4oZXZlbnQubmF0aXZlRXZlbnQsIHsgbm9kZUlkLCBoYW5kbGVJZCwgaGFuZGxlVHlwZTogdHlwZSB9KTtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGU6IHsgbm9kZUlkLCB0eXBlLCBpZDogaGFuZGxlSWQgfSB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkb2MgPSBnZXRIb3N0Rm9yRWxlbWVudChldmVudC50YXJnZXQpO1xuICAgICAgICBjb25zdCBpc1ZhbGlkQ29ubmVjdGlvbkhhbmRsZXIgPSBpc1ZhbGlkQ29ubmVjdGlvbiB8fCBpc1ZhbGlkQ29ubmVjdGlvblN0b3JlO1xuICAgICAgICBjb25zdCB7IGNvbm5lY3Rpb24sIGlzVmFsaWQgfSA9IFhZSGFuZGxlLmlzVmFsaWQoZXZlbnQubmF0aXZlRXZlbnQsIHtcbiAgICAgICAgICAgIGhhbmRsZToge1xuICAgICAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgICAgICBpZDogaGFuZGxlSWQsXG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25uZWN0aW9uTW9kZSxcbiAgICAgICAgICAgIGZyb21Ob2RlSWQ6IGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlLm5vZGVJZCxcbiAgICAgICAgICAgIGZyb21IYW5kbGVJZDogY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUuaWQgfHwgbnVsbCxcbiAgICAgICAgICAgIGZyb21UeXBlOiBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZS50eXBlLFxuICAgICAgICAgICAgaXNWYWxpZENvbm5lY3Rpb246IGlzVmFsaWRDb25uZWN0aW9uSGFuZGxlcixcbiAgICAgICAgICAgIGZsb3dJZCxcbiAgICAgICAgICAgIGRvYyxcbiAgICAgICAgICAgIGxpYixcbiAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNWYWxpZCAmJiBjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICBvbkNvbm5lY3RFeHRlbmRlZChjb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25uZWN0aW9uQ2xvbmUgPSBzdHJ1Y3R1cmVkQ2xvbmUoY29ubmVjdGlvblN0YXRlKTtcbiAgICAgICAgZGVsZXRlIGNvbm5lY3Rpb25DbG9uZS5pblByb2dyZXNzO1xuICAgICAgICBjb25uZWN0aW9uQ2xvbmUudG9Qb3NpdGlvbiA9IGNvbm5lY3Rpb25DbG9uZS50b0hhbmRsZSA/IGNvbm5lY3Rpb25DbG9uZS50b0hhbmRsZS5wb3NpdGlvbiA6IG51bGw7XG4gICAgICAgIG9uQ2xpY2tDb25uZWN0RW5kPy4oZXZlbnQsIGNvbm5lY3Rpb25DbG9uZSk7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGU6IG51bGwgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IFwiZGF0YS1oYW5kbGVpZFwiOiBoYW5kbGVJZCwgXCJkYXRhLW5vZGVpZFwiOiBub2RlSWQsIFwiZGF0YS1oYW5kbGVwb3NcIjogcG9zaXRpb24sIFwiZGF0YS1pZFwiOiBgJHtyZklkfS0ke25vZGVJZH0tJHtoYW5kbGVJZH0tJHt0eXBlfWAsIGNsYXNzTmFtZTogY2MoW1xuICAgICAgICAgICAgJ3JlYWN0LWZsb3dfX2hhbmRsZScsXG4gICAgICAgICAgICBgcmVhY3QtZmxvd19faGFuZGxlLSR7cG9zaXRpb259YCxcbiAgICAgICAgICAgICdub2RyYWcnLFxuICAgICAgICAgICAgbm9QYW5DbGFzc05hbWUsXG4gICAgICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc291cmNlOiAhaXNUYXJnZXQsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBpc1RhcmdldCxcbiAgICAgICAgICAgICAgICBjb25uZWN0YWJsZTogaXNDb25uZWN0YWJsZSxcbiAgICAgICAgICAgICAgICBjb25uZWN0YWJsZXN0YXJ0OiBpc0Nvbm5lY3RhYmxlU3RhcnQsXG4gICAgICAgICAgICAgICAgY29ubmVjdGFibGVlbmQ6IGlzQ29ubmVjdGFibGVFbmQsXG4gICAgICAgICAgICAgICAgY2xpY2tjb25uZWN0aW5nOiBjbGlja0Nvbm5lY3RpbmcsXG4gICAgICAgICAgICAgICAgY29ubmVjdGluZ2Zyb206IGNvbm5lY3RpbmdGcm9tLFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpbmd0bzogY29ubmVjdGluZ1RvLFxuICAgICAgICAgICAgICAgIHZhbGlkLFxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogc2hvd3Mgd2hlcmUgeW91IGNhbiBzdGFydCBhIGNvbm5lY3Rpb24gZnJvbVxuICAgICAgICAgICAgICAgICAqIGFuZCB3aGVyZSB5b3UgY2FuIGVuZCBpdCB3aGlsZSBjb25uZWN0aW5nXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbmluZGljYXRvcjogaXNDb25uZWN0YWJsZSAmJlxuICAgICAgICAgICAgICAgICAgICAoIWNvbm5lY3Rpb25JblByb2Nlc3MgfHwgaXNQb3NzaWJsZUVuZEhhbmRsZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGNvbm5lY3Rpb25JblByb2Nlc3MgfHwgY2xpY2tDb25uZWN0aW9uSW5Qcm9jZXNzID8gaXNDb25uZWN0YWJsZUVuZCA6IGlzQ29ubmVjdGFibGVTdGFydCksXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKSwgb25Nb3VzZURvd246IG9uUG9pbnRlckRvd24sIG9uVG91Y2hTdGFydDogb25Qb2ludGVyRG93biwgb25DbGljazogY29ubmVjdE9uQ2xpY2sgPyBvbkNsaWNrIDogdW5kZWZpbmVkLCByZWY6IHJlZiwgLi4ucmVzdCwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn1cbi8qKlxuICogVGhlIGA8SGFuZGxlIC8+YCBjb21wb25lbnQgaXMgdXNlZCBpbiB5b3VyIFtjdXN0b20gbm9kZXNdKC9sZWFybi9jdXN0b21pemF0aW9uL2N1c3RvbS1ub2RlcylcbiAqIHRvIGRlZmluZSBjb25uZWN0aW9uIHBvaW50cy5cbiAqXG4gKkBwdWJsaWNcbiAqXG4gKkBleGFtcGxlXG4gKlxuICpgYGBqc3hcbiAqaW1wb3J0IHsgSGFuZGxlLCBQb3NpdGlvbiB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGZ1bmN0aW9uIEN1c3RvbU5vZGUoeyBkYXRhIH0pIHtcbiAqICByZXR1cm4gKFxuICogICAgPD5cbiAqICAgICAgPGRpdiBzdHlsZT17eyBwYWRkaW5nOiAnMTBweCAyMHB4JyB9fT5cbiAqICAgICAgICB7ZGF0YS5sYWJlbH1cbiAqICAgICAgPC9kaXY+XG4gKlxuICogICAgICA8SGFuZGxlIHR5cGU9XCJ0YXJnZXRcIiBwb3NpdGlvbj17UG9zaXRpb24uTGVmdH0gLz5cbiAqICAgICAgPEhhbmRsZSB0eXBlPVwic291cmNlXCIgcG9zaXRpb249e1Bvc2l0aW9uLlJpZ2h0fSAvPlxuICogICAgPC8+XG4gKiAgKTtcbiAqfTtcbiAqYGBgXG4gKi9cbmNvbnN0IEhhbmRsZSA9IG1lbW8oZml4ZWRGb3J3YXJkUmVmKEhhbmRsZUNvbXBvbmVudCkpO1xuXG5mdW5jdGlvbiBJbnB1dE5vZGUoeyBkYXRhLCBpc0Nvbm5lY3RhYmxlLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSB9KSB7XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbZGF0YT8ubGFiZWwsIGpzeChIYW5kbGUsIHsgdHlwZTogXCJzb3VyY2VcIiwgcG9zaXRpb246IHNvdXJjZVBvc2l0aW9uLCBpc0Nvbm5lY3RhYmxlOiBpc0Nvbm5lY3RhYmxlIH0pXSB9KSk7XG59XG5cbmZ1bmN0aW9uIERlZmF1bHROb2RlKHsgZGF0YSwgaXNDb25uZWN0YWJsZSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB9KSB7XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4KEhhbmRsZSwgeyB0eXBlOiBcInRhcmdldFwiLCBwb3NpdGlvbjogdGFyZ2V0UG9zaXRpb24sIGlzQ29ubmVjdGFibGU6IGlzQ29ubmVjdGFibGUgfSksIGRhdGE/LmxhYmVsLCBqc3goSGFuZGxlLCB7IHR5cGU6IFwic291cmNlXCIsIHBvc2l0aW9uOiBzb3VyY2VQb3NpdGlvbiwgaXNDb25uZWN0YWJsZTogaXNDb25uZWN0YWJsZSB9KV0gfSkpO1xufVxuXG5mdW5jdGlvbiBHcm91cE5vZGUoKSB7XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIE91dHB1dE5vZGUoeyBkYXRhLCBpc0Nvbm5lY3RhYmxlLCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCB9KSB7XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4KEhhbmRsZSwgeyB0eXBlOiBcInRhcmdldFwiLCBwb3NpdGlvbjogdGFyZ2V0UG9zaXRpb24sIGlzQ29ubmVjdGFibGU6IGlzQ29ubmVjdGFibGUgfSksIGRhdGE/LmxhYmVsXSB9KSk7XG59XG5cbmNvbnN0IGFycm93S2V5RGlmZnMgPSB7XG4gICAgQXJyb3dVcDogeyB4OiAwLCB5OiAtMSB9LFxuICAgIEFycm93RG93bjogeyB4OiAwLCB5OiAxIH0sXG4gICAgQXJyb3dMZWZ0OiB7IHg6IC0xLCB5OiAwIH0sXG4gICAgQXJyb3dSaWdodDogeyB4OiAxLCB5OiAwIH0sXG59O1xuY29uc3QgYnVpbHRpbk5vZGVUeXBlcyA9IHtcbiAgICBpbnB1dDogSW5wdXROb2RlLFxuICAgIGRlZmF1bHQ6IERlZmF1bHROb2RlLFxuICAgIG91dHB1dDogT3V0cHV0Tm9kZSxcbiAgICBncm91cDogR3JvdXBOb2RlLFxufTtcbmZ1bmN0aW9uIGdldE5vZGVJbmxpbmVTdHlsZURpbWVuc2lvbnMobm9kZSkge1xuICAgIGlmIChub2RlLmludGVybmFscy5oYW5kbGVCb3VuZHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IG5vZGUud2lkdGggPz8gbm9kZS5pbml0aWFsV2lkdGggPz8gbm9kZS5zdHlsZT8ud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IG5vZGUuaGVpZ2h0ID8/IG5vZGUuaW5pdGlhbEhlaWdodCA/PyBub2RlLnN0eWxlPy5oZWlnaHQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBub2RlLndpZHRoID8/IG5vZGUuc3R5bGU/LndpZHRoLFxuICAgICAgICBoZWlnaHQ6IG5vZGUuaGVpZ2h0ID8/IG5vZGUuc3R5bGU/LmhlaWdodCxcbiAgICB9O1xufVxuXG5jb25zdCBzZWxlY3RvciRmID0gKHMpID0+IHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIHgsIHkgfSA9IGdldEludGVybmFsTm9kZXNCb3VuZHMocy5ub2RlTG9va3VwLCB7XG4gICAgICAgIGZpbHRlcjogKG5vZGUpID0+ICEhbm9kZS5zZWxlY3RlZCxcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogaXNOdW1lcmljKHdpZHRoKSA/IHdpZHRoIDogbnVsbCxcbiAgICAgICAgaGVpZ2h0OiBpc051bWVyaWMoaGVpZ2h0KSA/IGhlaWdodCA6IG51bGwsXG4gICAgICAgIHVzZXJTZWxlY3Rpb25BY3RpdmU6IHMudXNlclNlbGVjdGlvbkFjdGl2ZSxcbiAgICAgICAgdHJhbnNmb3JtU3RyaW5nOiBgdHJhbnNsYXRlKCR7cy50cmFuc2Zvcm1bMF19cHgsJHtzLnRyYW5zZm9ybVsxXX1weCkgc2NhbGUoJHtzLnRyYW5zZm9ybVsyXX0pIHRyYW5zbGF0ZSgke3h9cHgsJHt5fXB4KWAsXG4gICAgfTtcbn07XG5mdW5jdGlvbiBOb2Rlc1NlbGVjdGlvbih7IG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5LCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgdHJhbnNmb3JtU3RyaW5nLCB1c2VyU2VsZWN0aW9uQWN0aXZlIH0gPSB1c2VTdG9yZShzZWxlY3RvciRmLCBzaGFsbG93KTtcbiAgICBjb25zdCBtb3ZlU2VsZWN0ZWROb2RlcyA9IHVzZU1vdmVTZWxlY3RlZE5vZGVzKCk7XG4gICAgY29uc3Qgbm9kZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWRpc2FibGVLZXlib2FyZEExMXkpIHtcbiAgICAgICAgICAgIG5vZGVSZWYuY3VycmVudD8uZm9jdXMoe1xuICAgICAgICAgICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtkaXNhYmxlS2V5Ym9hcmRBMTF5XSk7XG4gICAgdXNlRHJhZyh7XG4gICAgICAgIG5vZGVSZWYsXG4gICAgfSk7XG4gICAgaWYgKHVzZXJTZWxlY3Rpb25BY3RpdmUgfHwgIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG9uQ29udGV4dE1lbnUgPSBvblNlbGVjdGlvbkNvbnRleHRNZW51XG4gICAgICAgID8gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZE5vZGVzID0gc3RvcmUuZ2V0U3RhdGUoKS5ub2Rlcy5maWx0ZXIoKG4pID0+IG4uc2VsZWN0ZWQpO1xuICAgICAgICAgICAgb25TZWxlY3Rpb25Db250ZXh0TWVudShldmVudCwgc2VsZWN0ZWROb2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25LZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXJyb3dLZXlEaWZmcywgZXZlbnQua2V5KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIG1vdmVTZWxlY3RlZE5vZGVzKHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246IGFycm93S2V5RGlmZnNbZXZlbnQua2V5XSxcbiAgICAgICAgICAgICAgICBmYWN0b3I6IGV2ZW50LnNoaWZ0S2V5ID8gNCA6IDEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fbm9kZXNzZWxlY3Rpb24nLCAncmVhY3QtZmxvd19fY29udGFpbmVyJywgbm9QYW5DbGFzc05hbWVdKSwgc3R5bGU6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtU3RyaW5nLFxuICAgICAgICB9LCBjaGlsZHJlbjoganN4KFwiZGl2XCIsIHsgcmVmOiBub2RlUmVmLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fbm9kZXNzZWxlY3Rpb24tcmVjdFwiLCBvbkNvbnRleHRNZW51OiBvbkNvbnRleHRNZW51LCB0YWJJbmRleDogZGlzYWJsZUtleWJvYXJkQTExeSA/IHVuZGVmaW5lZCA6IC0xLCBvbktleURvd246IGRpc2FibGVLZXlib2FyZEExMXkgPyB1bmRlZmluZWQgOiBvbktleURvd24sIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgfSB9KSB9KSk7XG59XG5cbmNvbnN0IHdpbiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdW5kZWZpbmVkO1xuY29uc3Qgc2VsZWN0b3IkZSA9IChzKSA9PiB7XG4gICAgcmV0dXJuIHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IHMubm9kZXNTZWxlY3Rpb25BY3RpdmUsIHVzZXJTZWxlY3Rpb25BY3RpdmU6IHMudXNlclNlbGVjdGlvbkFjdGl2ZSB9O1xufTtcbmZ1bmN0aW9uIEZsb3dSZW5kZXJlckNvbXBvbmVudCh7IGNoaWxkcmVuLCBvblBhbmVDbGljaywgb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlLCBvblBhbmVNb3VzZUxlYXZlLCBvblBhbmVDb250ZXh0TWVudSwgb25QYW5lU2Nyb2xsLCBwYW5lQ2xpY2tEaXN0YW5jZSwgZGVsZXRlS2V5Q29kZSwgc2VsZWN0aW9uS2V5Q29kZSwgc2VsZWN0aW9uT25EcmFnLCBzZWxlY3Rpb25Nb2RlLCBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZCwgbXVsdGlTZWxlY3Rpb25LZXlDb2RlLCBwYW5BY3RpdmF0aW9uS2V5Q29kZSwgem9vbUFjdGl2YXRpb25LZXlDb2RlLCBlbGVtZW50c1NlbGVjdGFibGUsIHpvb21PblNjcm9sbCwgem9vbU9uUGluY2gsIHBhbk9uU2Nyb2xsOiBfcGFuT25TY3JvbGwsIHBhbk9uU2Nyb2xsU3BlZWQsIHBhbk9uU2Nyb2xsTW9kZSwgem9vbU9uRG91YmxlQ2xpY2ssIHBhbk9uRHJhZzogX3Bhbk9uRHJhZywgZGVmYXVsdFZpZXdwb3J0LCB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb20sIG1heFpvb20sIHByZXZlbnRTY3JvbGxpbmcsIG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5LCBvblZpZXdwb3J0Q2hhbmdlLCBpc0NvbnRyb2xsZWRWaWV3cG9ydCwgfSkge1xuICAgIGNvbnN0IHsgbm9kZXNTZWxlY3Rpb25BY3RpdmUsIHVzZXJTZWxlY3Rpb25BY3RpdmUgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGUpO1xuICAgIGNvbnN0IHNlbGVjdGlvbktleVByZXNzZWQgPSB1c2VLZXlQcmVzcyhzZWxlY3Rpb25LZXlDb2RlLCB7IHRhcmdldDogd2luIH0pO1xuICAgIGNvbnN0IHBhbkFjdGl2YXRpb25LZXlQcmVzc2VkID0gdXNlS2V5UHJlc3MocGFuQWN0aXZhdGlvbktleUNvZGUsIHsgdGFyZ2V0OiB3aW4gfSk7XG4gICAgY29uc3QgcGFuT25EcmFnID0gcGFuQWN0aXZhdGlvbktleVByZXNzZWQgfHwgX3Bhbk9uRHJhZztcbiAgICBjb25zdCBwYW5PblNjcm9sbCA9IHBhbkFjdGl2YXRpb25LZXlQcmVzc2VkIHx8IF9wYW5PblNjcm9sbDtcbiAgICBjb25zdCBfc2VsZWN0aW9uT25EcmFnID0gc2VsZWN0aW9uT25EcmFnICYmIHBhbk9uRHJhZyAhPT0gdHJ1ZTtcbiAgICBjb25zdCBpc1NlbGVjdGluZyA9IHNlbGVjdGlvbktleVByZXNzZWQgfHwgdXNlclNlbGVjdGlvbkFjdGl2ZSB8fCBfc2VsZWN0aW9uT25EcmFnO1xuICAgIHVzZUdsb2JhbEtleUhhbmRsZXIoeyBkZWxldGVLZXlDb2RlLCBtdWx0aVNlbGVjdGlvbktleUNvZGUgfSk7XG4gICAgcmV0dXJuIChqc3goWm9vbVBhbmUsIHsgb25QYW5lQ29udGV4dE1lbnU6IG9uUGFuZUNvbnRleHRNZW51LCBlbGVtZW50c1NlbGVjdGFibGU6IGVsZW1lbnRzU2VsZWN0YWJsZSwgem9vbU9uU2Nyb2xsOiB6b29tT25TY3JvbGwsIHpvb21PblBpbmNoOiB6b29tT25QaW5jaCwgcGFuT25TY3JvbGw6IHBhbk9uU2Nyb2xsLCBwYW5PblNjcm9sbFNwZWVkOiBwYW5PblNjcm9sbFNwZWVkLCBwYW5PblNjcm9sbE1vZGU6IHBhbk9uU2Nyb2xsTW9kZSwgem9vbU9uRG91YmxlQ2xpY2s6IHpvb21PbkRvdWJsZUNsaWNrLCBwYW5PbkRyYWc6ICFzZWxlY3Rpb25LZXlQcmVzc2VkICYmIHBhbk9uRHJhZywgZGVmYXVsdFZpZXdwb3J0OiBkZWZhdWx0Vmlld3BvcnQsIHRyYW5zbGF0ZUV4dGVudDogdHJhbnNsYXRlRXh0ZW50LCBtaW5ab29tOiBtaW5ab29tLCBtYXhab29tOiBtYXhab29tLCB6b29tQWN0aXZhdGlvbktleUNvZGU6IHpvb21BY3RpdmF0aW9uS2V5Q29kZSwgcHJldmVudFNjcm9sbGluZzogcHJldmVudFNjcm9sbGluZywgbm9XaGVlbENsYXNzTmFtZTogbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBvblZpZXdwb3J0Q2hhbmdlOiBvblZpZXdwb3J0Q2hhbmdlLCBpc0NvbnRyb2xsZWRWaWV3cG9ydDogaXNDb250cm9sbGVkVmlld3BvcnQsIHBhbmVDbGlja0Rpc3RhbmNlOiBwYW5lQ2xpY2tEaXN0YW5jZSwgY2hpbGRyZW46IGpzeHMoUGFuZSwgeyBvblNlbGVjdGlvblN0YXJ0OiBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZDogb25TZWxlY3Rpb25FbmQsIG9uUGFuZUNsaWNrOiBvblBhbmVDbGljaywgb25QYW5lTW91c2VFbnRlcjogb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlOiBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmU6IG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZUNvbnRleHRNZW51OiBvblBhbmVDb250ZXh0TWVudSwgb25QYW5lU2Nyb2xsOiBvblBhbmVTY3JvbGwsIHBhbk9uRHJhZzogcGFuT25EcmFnLCBpc1NlbGVjdGluZzogISFpc1NlbGVjdGluZywgc2VsZWN0aW9uTW9kZTogc2VsZWN0aW9uTW9kZSwgc2VsZWN0aW9uS2V5UHJlc3NlZDogc2VsZWN0aW9uS2V5UHJlc3NlZCwgc2VsZWN0aW9uT25EcmFnOiBfc2VsZWN0aW9uT25EcmFnLCBjaGlsZHJlbjogW2NoaWxkcmVuLCBub2Rlc1NlbGVjdGlvbkFjdGl2ZSAmJiAoanN4KE5vZGVzU2VsZWN0aW9uLCB7IG9uU2VsZWN0aW9uQ29udGV4dE1lbnU6IG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeTogZGlzYWJsZUtleWJvYXJkQTExeSB9KSldIH0pIH0pKTtcbn1cbkZsb3dSZW5kZXJlckNvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdGbG93UmVuZGVyZXInO1xuY29uc3QgRmxvd1JlbmRlcmVyID0gbWVtbyhGbG93UmVuZGVyZXJDb21wb25lbnQpO1xuXG5jb25zdCBzZWxlY3RvciRkID0gKG9ubHlSZW5kZXJWaXNpYmxlKSA9PiAocykgPT4ge1xuICAgIHJldHVybiBvbmx5UmVuZGVyVmlzaWJsZVxuICAgICAgICA/IGdldE5vZGVzSW5zaWRlKHMubm9kZUxvb2t1cCwgeyB4OiAwLCB5OiAwLCB3aWR0aDogcy53aWR0aCwgaGVpZ2h0OiBzLmhlaWdodCB9LCBzLnRyYW5zZm9ybSwgdHJ1ZSkubWFwKChub2RlKSA9PiBub2RlLmlkKVxuICAgICAgICA6IEFycmF5LmZyb20ocy5ub2RlTG9va3VwLmtleXMoKSk7XG59O1xuLyoqXG4gKiBIb29rIGZvciBnZXR0aW5nIHRoZSB2aXNpYmxlIG5vZGUgaWRzIGZyb20gdGhlIHN0b3JlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIG9ubHlSZW5kZXJWaXNpYmxlXG4gKiBAcmV0dXJucyBhcnJheSB3aXRoIHZpc2libGUgbm9kZSBpZHNcbiAqL1xuZnVuY3Rpb24gdXNlVmlzaWJsZU5vZGVJZHMob25seVJlbmRlclZpc2libGUpIHtcbiAgICBjb25zdCBub2RlSWRzID0gdXNlU3RvcmUodXNlQ2FsbGJhY2soc2VsZWN0b3IkZChvbmx5UmVuZGVyVmlzaWJsZSksIFtvbmx5UmVuZGVyVmlzaWJsZV0pLCBzaGFsbG93KTtcbiAgICByZXR1cm4gbm9kZUlkcztcbn1cblxuY29uc3Qgc2VsZWN0b3IkYyA9IChzKSA9PiBzLnVwZGF0ZU5vZGVJbnRlcm5hbHM7XG5mdW5jdGlvbiB1c2VSZXNpemVPYnNlcnZlcigpIHtcbiAgICBjb25zdCB1cGRhdGVOb2RlSW50ZXJuYWxzID0gdXNlU3RvcmUoc2VsZWN0b3IkYyk7XG4gICAgY29uc3QgW3Jlc2l6ZU9ic2VydmVyXSA9IHVzZVN0YXRlKCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBlbnRyeS50YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWlkJyk7XG4gICAgICAgICAgICAgICAgdXBkYXRlcy5zZXQoaWQsIHtcbiAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVFbGVtZW50OiBlbnRyeS50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB1cGRhdGVOb2RlSW50ZXJuYWxzKHVwZGF0ZXMpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXI/LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbcmVzaXplT2JzZXJ2ZXJdKTtcbiAgICByZXR1cm4gcmVzaXplT2JzZXJ2ZXI7XG59XG5cbi8qKlxuICogSG9vayB0byBoYW5kbGUgdGhlIHJlc2l6ZSBvYnNlcnZhdGlvbiArIGludGVybmFsIHVwZGF0ZXMgZm9yIHRoZSBwYXNzZWQgbm9kZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEByZXR1cm5zIG5vZGVSZWYgLSByZWZlcmVuY2UgdG8gdGhlIG5vZGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiB1c2VOb2RlT2JzZXJ2ZXIoeyBub2RlLCBub2RlVHlwZSwgaGFzRGltZW5zaW9ucywgcmVzaXplT2JzZXJ2ZXIsIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgbm9kZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBvYnNlcnZlZE5vZGUgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgcHJldlNvdXJjZVBvc2l0aW9uID0gdXNlUmVmKG5vZGUuc291cmNlUG9zaXRpb24pO1xuICAgIGNvbnN0IHByZXZUYXJnZXRQb3NpdGlvbiA9IHVzZVJlZihub2RlLnRhcmdldFBvc2l0aW9uKTtcbiAgICBjb25zdCBwcmV2VHlwZSA9IHVzZVJlZihub2RlVHlwZSk7XG4gICAgY29uc3QgaXNJbml0aWFsaXplZCA9IGhhc0RpbWVuc2lvbnMgJiYgISFub2RlLmludGVybmFscy5oYW5kbGVCb3VuZHM7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKG5vZGVSZWYuY3VycmVudCAmJiAhbm9kZS5oaWRkZW4gJiYgKCFpc0luaXRpYWxpemVkIHx8IG9ic2VydmVkTm9kZS5jdXJyZW50ICE9PSBub2RlUmVmLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICBpZiAob2JzZXJ2ZWROb2RlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXNpemVPYnNlcnZlcj8udW5vYnNlcnZlKG9ic2VydmVkTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyPy5vYnNlcnZlKG5vZGVSZWYuY3VycmVudCk7XG4gICAgICAgICAgICBvYnNlcnZlZE5vZGUuY3VycmVudCA9IG5vZGVSZWYuY3VycmVudDtcbiAgICAgICAgfVxuICAgIH0sIFtpc0luaXRpYWxpemVkLCBub2RlLmhpZGRlbl0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAob2JzZXJ2ZWROb2RlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXNpemVPYnNlcnZlcj8udW5vYnNlcnZlKG9ic2VydmVkTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlZE5vZGUuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChub2RlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiB3aGVuIHRoZSB1c2VyIHByb2dyYW1tYXRpY2FsbHkgY2hhbmdlcyB0aGUgc291cmNlIG9yIGhhbmRsZSBwb3NpdGlvbiwgd2UgbmVlZCB0byB1cGRhdGUgdGhlIGludGVybmFsc1xuICAgICAgICAgICAgICogdG8gbWFrZSBzdXJlIHRoZSBlZGdlcyBhcmUgdXBkYXRlZCBjb3JyZWN0bHlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgdHlwZUNoYW5nZWQgPSBwcmV2VHlwZS5jdXJyZW50ICE9PSBub2RlVHlwZTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZVBvc0NoYW5nZWQgPSBwcmV2U291cmNlUG9zaXRpb24uY3VycmVudCAhPT0gbm9kZS5zb3VyY2VQb3NpdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFBvc0NoYW5nZWQgPSBwcmV2VGFyZ2V0UG9zaXRpb24uY3VycmVudCAhPT0gbm9kZS50YXJnZXRQb3NpdGlvbjtcbiAgICAgICAgICAgIGlmICh0eXBlQ2hhbmdlZCB8fCBzb3VyY2VQb3NDaGFuZ2VkIHx8IHRhcmdldFBvc0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBwcmV2VHlwZS5jdXJyZW50ID0gbm9kZVR5cGU7XG4gICAgICAgICAgICAgICAgcHJldlNvdXJjZVBvc2l0aW9uLmN1cnJlbnQgPSBub2RlLnNvdXJjZVBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIHByZXZUYXJnZXRQb3NpdGlvbi5jdXJyZW50ID0gbm9kZS50YXJnZXRQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBzdG9yZVxuICAgICAgICAgICAgICAgICAgICAuZ2V0U3RhdGUoKVxuICAgICAgICAgICAgICAgICAgICAudXBkYXRlTm9kZUludGVybmFscyhuZXcgTWFwKFtbbm9kZS5pZCwgeyBpZDogbm9kZS5pZCwgbm9kZUVsZW1lbnQ6IG5vZGVSZWYuY3VycmVudCwgZm9yY2U6IHRydWUgfV1dKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbbm9kZS5pZCwgbm9kZVR5cGUsIG5vZGUuc291cmNlUG9zaXRpb24sIG5vZGUudGFyZ2V0UG9zaXRpb25dKTtcbiAgICByZXR1cm4gbm9kZVJlZjtcbn1cblxuZnVuY3Rpb24gTm9kZVdyYXBwZXIoeyBpZCwgb25DbGljaywgb25Nb3VzZUVudGVyLCBvbk1vdXNlTW92ZSwgb25Nb3VzZUxlYXZlLCBvbkNvbnRleHRNZW51LCBvbkRvdWJsZUNsaWNrLCBub2Rlc0RyYWdnYWJsZSwgZWxlbWVudHNTZWxlY3RhYmxlLCBub2Rlc0Nvbm5lY3RhYmxlLCBub2Rlc0ZvY3VzYWJsZSwgcmVzaXplT2JzZXJ2ZXIsIG5vRHJhZ0NsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXksIHJmSWQsIG5vZGVUeXBlcywgbm9kZUNsaWNrRGlzdGFuY2UsIG9uRXJyb3IsIH0pIHtcbiAgICBjb25zdCB7IG5vZGUsIGludGVybmFscywgaXNQYXJlbnQgfSA9IHVzZVN0b3JlKChzKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBzLm5vZGVMb29rdXAuZ2V0KGlkKTtcbiAgICAgICAgY29uc3QgaXNQYXJlbnQgPSBzLnBhcmVudExvb2t1cC5oYXMoaWQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIGludGVybmFsczogbm9kZS5pbnRlcm5hbHMsXG4gICAgICAgICAgICBpc1BhcmVudCxcbiAgICAgICAgfTtcbiAgICB9LCBzaGFsbG93KTtcbiAgICBsZXQgbm9kZVR5cGUgPSBub2RlLnR5cGUgfHwgJ2RlZmF1bHQnO1xuICAgIGxldCBOb2RlQ29tcG9uZW50ID0gbm9kZVR5cGVzPy5bbm9kZVR5cGVdIHx8IGJ1aWx0aW5Ob2RlVHlwZXNbbm9kZVR5cGVdO1xuICAgIGlmIChOb2RlQ29tcG9uZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb25FcnJvcj8uKCcwMDMnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwMyddKG5vZGVUeXBlKSk7XG4gICAgICAgIG5vZGVUeXBlID0gJ2RlZmF1bHQnO1xuICAgICAgICBOb2RlQ29tcG9uZW50ID0gbm9kZVR5cGVzPy5bJ2RlZmF1bHQnXSB8fCBidWlsdGluTm9kZVR5cGVzLmRlZmF1bHQ7XG4gICAgfVxuICAgIGNvbnN0IGlzRHJhZ2dhYmxlID0gISEobm9kZS5kcmFnZ2FibGUgfHwgKG5vZGVzRHJhZ2dhYmxlICYmIHR5cGVvZiBub2RlLmRyYWdnYWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICBjb25zdCBpc1NlbGVjdGFibGUgPSAhIShub2RlLnNlbGVjdGFibGUgfHwgKGVsZW1lbnRzU2VsZWN0YWJsZSAmJiB0eXBlb2Ygbm9kZS5zZWxlY3RhYmxlID09PSAndW5kZWZpbmVkJykpO1xuICAgIGNvbnN0IGlzQ29ubmVjdGFibGUgPSAhIShub2RlLmNvbm5lY3RhYmxlIHx8IChub2Rlc0Nvbm5lY3RhYmxlICYmIHR5cGVvZiBub2RlLmNvbm5lY3RhYmxlID09PSAndW5kZWZpbmVkJykpO1xuICAgIGNvbnN0IGlzRm9jdXNhYmxlID0gISEobm9kZS5mb2N1c2FibGUgfHwgKG5vZGVzRm9jdXNhYmxlICYmIHR5cGVvZiBub2RlLmZvY3VzYWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgaGFzRGltZW5zaW9ucyA9IG5vZGVIYXNEaW1lbnNpb25zKG5vZGUpO1xuICAgIGNvbnN0IG5vZGVSZWYgPSB1c2VOb2RlT2JzZXJ2ZXIoeyBub2RlLCBub2RlVHlwZSwgaGFzRGltZW5zaW9ucywgcmVzaXplT2JzZXJ2ZXIgfSk7XG4gICAgY29uc3QgZHJhZ2dpbmcgPSB1c2VEcmFnKHtcbiAgICAgICAgbm9kZVJlZixcbiAgICAgICAgZGlzYWJsZWQ6IG5vZGUuaGlkZGVuIHx8ICFpc0RyYWdnYWJsZSxcbiAgICAgICAgbm9EcmFnQ2xhc3NOYW1lLFxuICAgICAgICBoYW5kbGVTZWxlY3Rvcjogbm9kZS5kcmFnSGFuZGxlLFxuICAgICAgICBub2RlSWQ6IGlkLFxuICAgICAgICBpc1NlbGVjdGFibGUsXG4gICAgICAgIG5vZGVDbGlja0Rpc3RhbmNlLFxuICAgIH0pO1xuICAgIGNvbnN0IG1vdmVTZWxlY3RlZE5vZGVzID0gdXNlTW92ZVNlbGVjdGVkTm9kZXMoKTtcbiAgICBpZiAobm9kZS5oaWRkZW4pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG5vZGVEaW1lbnNpb25zID0gZ2V0Tm9kZURpbWVuc2lvbnMobm9kZSk7XG4gICAgY29uc3QgaW5saW5lRGltZW5zaW9ucyA9IGdldE5vZGVJbmxpbmVTdHlsZURpbWVuc2lvbnMobm9kZSk7XG4gICAgY29uc3QgaGFzUG9pbnRlckV2ZW50cyA9IGlzU2VsZWN0YWJsZSB8fCBpc0RyYWdnYWJsZSB8fCBvbkNsaWNrIHx8IG9uTW91c2VFbnRlciB8fCBvbk1vdXNlTW92ZSB8fCBvbk1vdXNlTGVhdmU7XG4gICAgY29uc3Qgb25Nb3VzZUVudGVySGFuZGxlciA9IG9uTW91c2VFbnRlclxuICAgICAgICA/IChldmVudCkgPT4gb25Nb3VzZUVudGVyKGV2ZW50LCB7IC4uLmludGVybmFscy51c2VyTm9kZSB9KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbk1vdXNlTW92ZUhhbmRsZXIgPSBvbk1vdXNlTW92ZVxuICAgICAgICA/IChldmVudCkgPT4gb25Nb3VzZU1vdmUoZXZlbnQsIHsgLi4uaW50ZXJuYWxzLnVzZXJOb2RlIH0pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uTW91c2VMZWF2ZUhhbmRsZXIgPSBvbk1vdXNlTGVhdmVcbiAgICAgICAgPyAoZXZlbnQpID0+IG9uTW91c2VMZWF2ZShldmVudCwgeyAuLi5pbnRlcm5hbHMudXNlck5vZGUgfSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25Db250ZXh0TWVudUhhbmRsZXIgPSBvbkNvbnRleHRNZW51XG4gICAgICAgID8gKGV2ZW50KSA9PiBvbkNvbnRleHRNZW51KGV2ZW50LCB7IC4uLmludGVybmFscy51c2VyTm9kZSB9KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbkRvdWJsZUNsaWNrSGFuZGxlciA9IG9uRG91YmxlQ2xpY2tcbiAgICAgICAgPyAoZXZlbnQpID0+IG9uRG91YmxlQ2xpY2soZXZlbnQsIHsgLi4uaW50ZXJuYWxzLnVzZXJOb2RlIH0pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uU2VsZWN0Tm9kZUhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgeyBzZWxlY3ROb2Rlc09uRHJhZywgbm9kZURyYWdUaHJlc2hvbGQgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmIChpc1NlbGVjdGFibGUgJiYgKCFzZWxlY3ROb2Rlc09uRHJhZyB8fCAhaXNEcmFnZ2FibGUgfHwgbm9kZURyYWdUaHJlc2hvbGQgPiAwKSkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIHRoaXMgaGFuZGxlciBnZXRzIGNhbGxlZCBieSBYWURyYWcgb24gZHJhZyBzdGFydCB3aGVuIHNlbGVjdE5vZGVzT25EcmFnPXRydWVcbiAgICAgICAgICAgICAqIGhlcmUgd2Ugb25seSBuZWVkIHRvIGNhbGwgaXQgd2hlbiBzZWxlY3ROb2Rlc09uRHJhZz1mYWxzZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBoYW5kbGVOb2RlQ2xpY2soe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgICAgICAgIG5vZGVSZWYsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25DbGljaykge1xuICAgICAgICAgICAgb25DbGljayhldmVudCwgeyAuLi5pbnRlcm5hbHMudXNlck5vZGUgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG9uS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoaXNJbnB1dERPTU5vZGUoZXZlbnQubmF0aXZlRXZlbnQpIHx8IGRpc2FibGVLZXlib2FyZEExMXkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudFNlbGVjdGlvbktleXMuaW5jbHVkZXMoZXZlbnQua2V5KSAmJiBpc1NlbGVjdGFibGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHVuc2VsZWN0ID0gZXZlbnQua2V5ID09PSAnRXNjYXBlJztcbiAgICAgICAgICAgIGhhbmRsZU5vZGVDbGljayh7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgICAgICAgdW5zZWxlY3QsXG4gICAgICAgICAgICAgICAgbm9kZVJlZixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRHJhZ2dhYmxlICYmIG5vZGUuc2VsZWN0ZWQgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFycm93S2V5RGlmZnMsIGV2ZW50LmtleSkpIHtcbiAgICAgICAgICAgIC8vIHByZXZlbnQgZGVmYXVsdCBzY3JvbGxpbmcgYmVoYXZpb3Igb24gYXJyb3cga2V5IHByZXNzIHdoZW4gbm9kZSBpcyBtb3ZlZFxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgYXJpYUxhYmVsQ29uZmlnIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGFyaWFMaXZlTWVzc2FnZTogYXJpYUxhYmVsQ29uZmlnWydub2RlLmExMXlEZXNjcmlwdGlvbi5hcmlhTGl2ZU1lc3NhZ2UnXSh7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogZXZlbnQua2V5LnJlcGxhY2UoJ0Fycm93JywgJycpLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICAgIHg6IH5+aW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueCxcbiAgICAgICAgICAgICAgICAgICAgeTogfn5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtb3ZlU2VsZWN0ZWROb2Rlcyh7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBhcnJvd0tleURpZmZzW2V2ZW50LmtleV0sXG4gICAgICAgICAgICAgICAgZmFjdG9yOiBldmVudC5zaGlmdEtleSA/IDQgOiAxLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG9uRm9jdXMgPSAoKSA9PiB7XG4gICAgICAgIGlmIChkaXNhYmxlS2V5Ym9hcmRBMTF5IHx8ICFub2RlUmVmLmN1cnJlbnQ/Lm1hdGNoZXMoJzpmb2N1cy12aXNpYmxlJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHRyYW5zZm9ybSwgd2lkdGgsIGhlaWdodCwgYXV0b1Bhbk9uTm9kZUZvY3VzLCBzZXRDZW50ZXIgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmICghYXV0b1Bhbk9uTm9kZUZvY3VzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2l0aGluVmlld3BvcnQgPSBnZXROb2Rlc0luc2lkZShuZXcgTWFwKFtbaWQsIG5vZGVdXSksIHsgeDogMCwgeTogMCwgd2lkdGgsIGhlaWdodCB9LCB0cmFuc2Zvcm0sIHRydWUpLmxlbmd0aCA+IDA7XG4gICAgICAgIGlmICghd2l0aGluVmlld3BvcnQpIHtcbiAgICAgICAgICAgIHNldENlbnRlcihub2RlLnBvc2l0aW9uLnggKyBub2RlRGltZW5zaW9ucy53aWR0aCAvIDIsIG5vZGUucG9zaXRpb24ueSArIG5vZGVEaW1lbnNpb25zLmhlaWdodCAvIDIsIHtcbiAgICAgICAgICAgICAgICB6b29tOiB0cmFuc2Zvcm1bMl0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNjKFtcbiAgICAgICAgICAgICdyZWFjdC1mbG93X19ub2RlJyxcbiAgICAgICAgICAgIGByZWFjdC1mbG93X19ub2RlLSR7bm9kZVR5cGV9YCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG92ZXJ3cml0YWJsZSBieSBwYXNzaW5nIGBub3BhbmAgYXMgYSBjbGFzcyBuYW1lXG4gICAgICAgICAgICAgICAgW25vUGFuQ2xhc3NOYW1lXTogaXNEcmFnZ2FibGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbm9kZS5jbGFzc05hbWUsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IG5vZGUuc2VsZWN0ZWQsXG4gICAgICAgICAgICAgICAgc2VsZWN0YWJsZTogaXNTZWxlY3RhYmxlLFxuICAgICAgICAgICAgICAgIHBhcmVudDogaXNQYXJlbnQsXG4gICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiBpc0RyYWdnYWJsZSxcbiAgICAgICAgICAgICAgICBkcmFnZ2luZyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pLCByZWY6IG5vZGVSZWYsIHN0eWxlOiB7XG4gICAgICAgICAgICB6SW5kZXg6IGludGVybmFscy56LFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7aW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueH1weCwke2ludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnl9cHgpYCxcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IGhhc1BvaW50ZXJFdmVudHMgPyAnYWxsJyA6ICdub25lJyxcbiAgICAgICAgICAgIHZpc2liaWxpdHk6IGhhc0RpbWVuc2lvbnMgPyAndmlzaWJsZScgOiAnaGlkZGVuJyxcbiAgICAgICAgICAgIC4uLm5vZGUuc3R5bGUsXG4gICAgICAgICAgICAuLi5pbmxpbmVEaW1lbnNpb25zLFxuICAgICAgICB9LCBcImRhdGEtaWRcIjogaWQsIFwiZGF0YS10ZXN0aWRcIjogYHJmX19ub2RlLSR7aWR9YCwgb25Nb3VzZUVudGVyOiBvbk1vdXNlRW50ZXJIYW5kbGVyLCBvbk1vdXNlTW92ZTogb25Nb3VzZU1vdmVIYW5kbGVyLCBvbk1vdXNlTGVhdmU6IG9uTW91c2VMZWF2ZUhhbmRsZXIsIG9uQ29udGV4dE1lbnU6IG9uQ29udGV4dE1lbnVIYW5kbGVyLCBvbkNsaWNrOiBvblNlbGVjdE5vZGVIYW5kbGVyLCBvbkRvdWJsZUNsaWNrOiBvbkRvdWJsZUNsaWNrSGFuZGxlciwgb25LZXlEb3duOiBpc0ZvY3VzYWJsZSA/IG9uS2V5RG93biA6IHVuZGVmaW5lZCwgdGFiSW5kZXg6IGlzRm9jdXNhYmxlID8gMCA6IHVuZGVmaW5lZCwgb25Gb2N1czogaXNGb2N1c2FibGUgPyBvbkZvY3VzIDogdW5kZWZpbmVkLCByb2xlOiBub2RlLmFyaWFSb2xlID8/IChpc0ZvY3VzYWJsZSA/ICdncm91cCcgOiB1bmRlZmluZWQpLCBcImFyaWEtcm9sZWRlc2NyaXB0aW9uXCI6IFwibm9kZVwiLCBcImFyaWEtZGVzY3JpYmVkYnlcIjogZGlzYWJsZUtleWJvYXJkQTExeSA/IHVuZGVmaW5lZCA6IGAke0FSSUFfTk9ERV9ERVNDX0tFWX0tJHtyZklkfWAsIFwiYXJpYS1sYWJlbFwiOiBub2RlLmFyaWFMYWJlbCwgLi4ubm9kZS5kb21BdHRyaWJ1dGVzLCBjaGlsZHJlbjoganN4KFByb3ZpZGVyLCB7IHZhbHVlOiBpZCwgY2hpbGRyZW46IGpzeChOb2RlQ29tcG9uZW50LCB7IGlkOiBpZCwgZGF0YTogbm9kZS5kYXRhLCB0eXBlOiBub2RlVHlwZSwgcG9zaXRpb25BYnNvbHV0ZVg6IGludGVybmFscy5wb3NpdGlvbkFic29sdXRlLngsIHBvc2l0aW9uQWJzb2x1dGVZOiBpbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55LCBzZWxlY3RlZDogbm9kZS5zZWxlY3RlZCA/PyBmYWxzZSwgc2VsZWN0YWJsZTogaXNTZWxlY3RhYmxlLCBkcmFnZ2FibGU6IGlzRHJhZ2dhYmxlLCBkZWxldGFibGU6IG5vZGUuZGVsZXRhYmxlID8/IHRydWUsIGlzQ29ubmVjdGFibGU6IGlzQ29ubmVjdGFibGUsIHNvdXJjZVBvc2l0aW9uOiBub2RlLnNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbjogbm9kZS50YXJnZXRQb3NpdGlvbiwgZHJhZ2dpbmc6IGRyYWdnaW5nLCBkcmFnSGFuZGxlOiBub2RlLmRyYWdIYW5kbGUsIHpJbmRleDogaW50ZXJuYWxzLnosIHBhcmVudElkOiBub2RlLnBhcmVudElkLCAuLi5ub2RlRGltZW5zaW9ucyB9KSB9KSB9KSk7XG59XG52YXIgTm9kZVdyYXBwZXIkMSA9IG1lbW8oTm9kZVdyYXBwZXIpO1xuXG5jb25zdCBzZWxlY3RvciRiID0gKHMpID0+ICh7XG4gICAgbm9kZXNEcmFnZ2FibGU6IHMubm9kZXNEcmFnZ2FibGUsXG4gICAgbm9kZXNDb25uZWN0YWJsZTogcy5ub2Rlc0Nvbm5lY3RhYmxlLFxuICAgIG5vZGVzRm9jdXNhYmxlOiBzLm5vZGVzRm9jdXNhYmxlLFxuICAgIGVsZW1lbnRzU2VsZWN0YWJsZTogcy5lbGVtZW50c1NlbGVjdGFibGUsXG4gICAgb25FcnJvcjogcy5vbkVycm9yLFxufSk7XG5mdW5jdGlvbiBOb2RlUmVuZGVyZXJDb21wb25lbnQocHJvcHMpIHtcbiAgICBjb25zdCB7IG5vZGVzRHJhZ2dhYmxlLCBub2Rlc0Nvbm5lY3RhYmxlLCBub2Rlc0ZvY3VzYWJsZSwgZWxlbWVudHNTZWxlY3RhYmxlLCBvbkVycm9yIH0gPSB1c2VTdG9yZShzZWxlY3RvciRiLCBzaGFsbG93KTtcbiAgICBjb25zdCBub2RlSWRzID0gdXNlVmlzaWJsZU5vZGVJZHMocHJvcHMub25seVJlbmRlclZpc2libGVFbGVtZW50cyk7XG4gICAgY29uc3QgcmVzaXplT2JzZXJ2ZXIgPSB1c2VSZXNpemVPYnNlcnZlcigpO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX25vZGVzXCIsIHN0eWxlOiBjb250YWluZXJTdHlsZSwgY2hpbGRyZW46IG5vZGVJZHMubWFwKChub2RlSWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogVGhlIHNwbGl0IG9mIHJlc3BvbnNpYmlsaXRpZXMgYmV0d2VlbiBOb2RlUmVuZGVyZXIgYW5kXG4gICAgICAgICAgICAgKiBOb2RlQ29tcG9uZW50V3JhcHBlciBtYXkgYXBwZWFyIHdlaXJkLiBIb3dldmVyLCBpdOKAmXMgZGVzaWduZWQgdG9cbiAgICAgICAgICAgICAqIG1pbmltaXplIHRoZSBjb3N0IG9mIHVwZGF0ZXMgd2hlbiBpbmRpdmlkdWFsIG5vZGVzIGNoYW5nZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBGb3IgZXhhbXBsZSwgd2hlbiB5b3XigJlyZSBkcmFnZ2luZyBhIHNpbmdsZSBub2RlLCB0aGF0IG5vZGUgZ2V0c1xuICAgICAgICAgICAgICogdXBkYXRlZCBtdWx0aXBsZSB0aW1lcyBwZXIgc2Vjb25kLiBJZiBgTm9kZVJlbmRlcmVyYCB3ZXJlIHRvIHVwZGF0ZVxuICAgICAgICAgICAgICogZXZlcnkgdGltZSwgaXQgd291bGQgaGF2ZSB0byByZS1ydW4gdGhlIGBub2Rlcy5tYXAoKWAgbG9vcCBldmVyeVxuICAgICAgICAgICAgICogdGltZS4gVGhpcyBnZXRzIHByaWNleSB3aXRoIGh1bmRyZWRzIG9mIG5vZGVzLCBlc3BlY2lhbGx5IGlmIGV2ZXJ5XG4gICAgICAgICAgICAgKiBsb29wIGN5Y2xlIGRvZXMgbW9yZSB0aGFuIGp1c3QgcmVuZGVyaW5nIGEgSlNYIGVsZW1lbnQhXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQXMgYSByZXN1bHQgb2YgdGhpcyBjaG9pY2UsIHdlIHRvb2sgdGhlIGZvbGxvd2luZyBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgICogZGVjaXNpb25zOlxuICAgICAgICAgICAgICogLSBOb2RlUmVuZGVyZXIgc3Vic2NyaWJlcyAqb25seSogdG8gbm9kZSBJRHMg4oCTIGFuZCB0aGVyZWZvcmVcbiAgICAgICAgICAgICAqICAgcmVyZW5kZXIgKm9ubHkqIHdoZW4gdmlzaWJsZSBub2RlcyBhcmUgYWRkZWQgb3IgcmVtb3ZlZC5cbiAgICAgICAgICAgICAqIC0gTm9kZVJlbmRlcmVyIHBlcmZvcm1zIGFsbCBvcGVyYXRpb25zIHRoZSByZXN1bHQgb2Ygd2hpY2ggY2FuIGJlXG4gICAgICAgICAgICAgKiAgIHNoYXJlZCBiZXR3ZWVuIG5vZGVzIChzdWNoIGFzIGNyZWF0aW5nIHRoZSBgUmVzaXplT2JzZXJ2ZXJgXG4gICAgICAgICAgICAgKiAgIGluc3RhbmNlLCBvciBzdWJzY3JpYmluZyB0byBgc2VsZWN0b3JgKS4gVGhpcyBtZWFucyBleHRyYSBwcm9wXG4gICAgICAgICAgICAgKiAgIGRyaWxsaW5nIGludG8gYE5vZGVDb21wb25lbnRXcmFwcGVyYCwgYnV0IGl0IG1lYW5zIHdlIG5lZWQgdG8gcnVuXG4gICAgICAgICAgICAgKiAgIHRoZXNlIG9wZXJhdGlvbnMgb25seSBvbmNlIOKAkyBpbnN0ZWFkIG9mIG9uY2UgcGVyIG5vZGUuXG4gICAgICAgICAgICAgKiAtIEFueSBvcGVyYXRpb25zIHRoYXQgeW914oCZZCBub3JtYWxseSB3cml0ZSBpbnNpZGUgYG5vZGVzLm1hcGAgYXJlXG4gICAgICAgICAgICAgKiAgIG1vdmVkIGludG8gYE5vZGVDb21wb25lbnRXcmFwcGVyYC4gVGhpcyBlbnN1cmVzIHRoZXkgYXJlXG4gICAgICAgICAgICAgKiAgIG1lbW9yaXplZCDigJMgc28gaWYgYE5vZGVSZW5kZXJlcmAgKmhhcyogdG8gcmVyZW5kZXIsIGl0IG9ubHlcbiAgICAgICAgICAgICAqICAgbmVlZHMgdG8gcmVnZW5lcmF0ZSB0aGUgbGlzdCBvZiBub2Rlcywgbm90aGluZyBlbHNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBqc3goTm9kZVdyYXBwZXIkMSwgeyBpZDogbm9kZUlkLCBub2RlVHlwZXM6IHByb3BzLm5vZGVUeXBlcywgbm9kZUV4dGVudDogcHJvcHMubm9kZUV4dGVudCwgb25DbGljazogcHJvcHMub25Ob2RlQ2xpY2ssIG9uTW91c2VFbnRlcjogcHJvcHMub25Ob2RlTW91c2VFbnRlciwgb25Nb3VzZU1vdmU6IHByb3BzLm9uTm9kZU1vdXNlTW92ZSwgb25Nb3VzZUxlYXZlOiBwcm9wcy5vbk5vZGVNb3VzZUxlYXZlLCBvbkNvbnRleHRNZW51OiBwcm9wcy5vbk5vZGVDb250ZXh0TWVudSwgb25Eb3VibGVDbGljazogcHJvcHMub25Ob2RlRG91YmxlQ2xpY2ssIG5vRHJhZ0NsYXNzTmFtZTogcHJvcHMubm9EcmFnQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZTogcHJvcHMubm9QYW5DbGFzc05hbWUsIHJmSWQ6IHByb3BzLnJmSWQsIGRpc2FibGVLZXlib2FyZEExMXk6IHByb3BzLmRpc2FibGVLZXlib2FyZEExMXksIHJlc2l6ZU9ic2VydmVyOiByZXNpemVPYnNlcnZlciwgbm9kZXNEcmFnZ2FibGU6IG5vZGVzRHJhZ2dhYmxlLCBub2Rlc0Nvbm5lY3RhYmxlOiBub2Rlc0Nvbm5lY3RhYmxlLCBub2Rlc0ZvY3VzYWJsZTogbm9kZXNGb2N1c2FibGUsIGVsZW1lbnRzU2VsZWN0YWJsZTogZWxlbWVudHNTZWxlY3RhYmxlLCBub2RlQ2xpY2tEaXN0YW5jZTogcHJvcHMubm9kZUNsaWNrRGlzdGFuY2UsIG9uRXJyb3I6IG9uRXJyb3IgfSwgbm9kZUlkKSk7XG4gICAgICAgIH0pIH0pKTtcbn1cbk5vZGVSZW5kZXJlckNvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdOb2RlUmVuZGVyZXInO1xuY29uc3QgTm9kZVJlbmRlcmVyID0gbWVtbyhOb2RlUmVuZGVyZXJDb21wb25lbnQpO1xuXG4vKipcbiAqIEhvb2sgZm9yIGdldHRpbmcgdGhlIHZpc2libGUgZWRnZSBpZHMgZnJvbSB0aGUgc3RvcmUuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0gb25seVJlbmRlclZpc2libGVcbiAqIEByZXR1cm5zIGFycmF5IHdpdGggdmlzaWJsZSBlZGdlIGlkc1xuICovXG5mdW5jdGlvbiB1c2VWaXNpYmxlRWRnZUlkcyhvbmx5UmVuZGVyVmlzaWJsZSkge1xuICAgIGNvbnN0IGVkZ2VJZHMgPSB1c2VTdG9yZSh1c2VDYWxsYmFjaygocykgPT4ge1xuICAgICAgICBpZiAoIW9ubHlSZW5kZXJWaXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gcy5lZGdlcy5tYXAoKGVkZ2UpID0+IGVkZ2UuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZpc2libGVFZGdlSWRzID0gW107XG4gICAgICAgIGlmIChzLndpZHRoICYmIHMuaGVpZ2h0KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVkZ2Ugb2Ygcy5lZGdlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZU5vZGUgPSBzLm5vZGVMb29rdXAuZ2V0KGVkZ2Uuc291cmNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXROb2RlID0gcy5ub2RlTG9va3VwLmdldChlZGdlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZU5vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICBpc0VkZ2VWaXNpYmxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZU5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBzLnRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZUVkZ2VJZHMucHVzaChlZGdlLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZpc2libGVFZGdlSWRzO1xuICAgIH0sIFtvbmx5UmVuZGVyVmlzaWJsZV0pLCBzaGFsbG93KTtcbiAgICByZXR1cm4gZWRnZUlkcztcbn1cblxuY29uc3QgQXJyb3dTeW1ib2wgPSAoeyBjb2xvciA9ICdub25lJywgc3Ryb2tlV2lkdGggPSAxIH0pID0+IHtcbiAgICBjb25zdCBzdHlsZSA9IHtcbiAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIC4uLihjb2xvciAmJiB7IHN0cm9rZTogY29sb3IgfSksXG4gICAgfTtcbiAgICByZXR1cm4gKGpzeChcInBvbHlsaW5lXCIsIHsgY2xhc3NOYW1lOiBcImFycm93XCIsIHN0eWxlOiBzdHlsZSwgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLCBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiwgcG9pbnRzOiBcIi01LC00IDAsMCAtNSw0XCIgfSkpO1xufTtcbmNvbnN0IEFycm93Q2xvc2VkU3ltYm9sID0gKHsgY29sb3IgPSAnbm9uZScsIHN0cm9rZVdpZHRoID0gMSB9KSA9PiB7XG4gICAgY29uc3Qgc3R5bGUgPSB7XG4gICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICAuLi4oY29sb3IgJiYgeyBzdHJva2U6IGNvbG9yLCBmaWxsOiBjb2xvciB9KSxcbiAgICB9O1xuICAgIHJldHVybiAoanN4KFwicG9seWxpbmVcIiwgeyBjbGFzc05hbWU6IFwiYXJyb3djbG9zZWRcIiwgc3R5bGU6IHN0eWxlLCBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsIHBvaW50czogXCItNSwtNCAwLDAgLTUsNCAtNSwtNFwiIH0pKTtcbn07XG5jb25zdCBNYXJrZXJTeW1ib2xzID0ge1xuICAgIFtNYXJrZXJUeXBlLkFycm93XTogQXJyb3dTeW1ib2wsXG4gICAgW01hcmtlclR5cGUuQXJyb3dDbG9zZWRdOiBBcnJvd0Nsb3NlZFN5bWJvbCxcbn07XG5mdW5jdGlvbiB1c2VNYXJrZXJTeW1ib2wodHlwZSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBzeW1ib2wgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc3ltYm9sRXhpc3RzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKE1hcmtlclN5bWJvbHMsIHR5cGUpO1xuICAgICAgICBpZiAoIXN5bWJvbEV4aXN0cykge1xuICAgICAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5vbkVycm9yPy4oJzAwOScsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA5J10odHlwZSkpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hcmtlclN5bWJvbHNbdHlwZV07XG4gICAgfSwgW3R5cGVdKTtcbiAgICByZXR1cm4gc3ltYm9sO1xufVxuXG5jb25zdCBNYXJrZXIgPSAoeyBpZCwgdHlwZSwgY29sb3IsIHdpZHRoID0gMTIuNSwgaGVpZ2h0ID0gMTIuNSwgbWFya2VyVW5pdHMgPSAnc3Ryb2tlV2lkdGgnLCBzdHJva2VXaWR0aCwgb3JpZW50ID0gJ2F1dG8tc3RhcnQtcmV2ZXJzZScsIH0pID0+IHtcbiAgICBjb25zdCBTeW1ib2wgPSB1c2VNYXJrZXJTeW1ib2wodHlwZSk7XG4gICAgaWYgKCFTeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoanN4KFwibWFya2VyXCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2Fycm93aGVhZFwiLCBpZDogaWQsIG1hcmtlcldpZHRoOiBgJHt3aWR0aH1gLCBtYXJrZXJIZWlnaHQ6IGAke2hlaWdodH1gLCB2aWV3Qm94OiBcIi0xMCAtMTAgMjAgMjBcIiwgbWFya2VyVW5pdHM6IG1hcmtlclVuaXRzLCBvcmllbnQ6IG9yaWVudCwgcmVmWDogXCIwXCIsIHJlZlk6IFwiMFwiLCBjaGlsZHJlbjoganN4KFN5bWJvbCwgeyBjb2xvcjogY29sb3IsIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCB9KSB9KSk7XG59O1xuLypcbiAqIHdoZW4geW91IGhhdmUgbXVsdGlwbGUgZmxvd3Mgb24gYSBwYWdlIGFuZCB5b3UgaGlkZSB0aGUgZmlyc3Qgb25lLCB0aGUgb3RoZXIgb25lcyBoYXZlIG5vIG1hcmtlcnMgYW55bW9yZVxuICogd2hlbiB0aGV5IGRvIGhhdmUgbWFya2VycyB3aXRoIHRoZSBzYW1lIGlkcy4gVG8gcHJldmVudCB0aGlzIHRoZSB1c2VyIGNhbiBwYXNzIGEgdW5pcXVlIGlkIHRvIHRoZSByZWFjdCBmbG93IHdyYXBwZXJcbiAqIHRoYXQgd2UgY2FuIHRoZW4gdXNlIGZvciBjcmVhdGluZyBvdXIgdW5pcXVlIG1hcmtlciBpZHNcbiAqL1xuY29uc3QgTWFya2VyRGVmaW5pdGlvbnMgPSAoeyBkZWZhdWx0Q29sb3IsIHJmSWQgfSkgPT4ge1xuICAgIGNvbnN0IGVkZ2VzID0gdXNlU3RvcmUoKHMpID0+IHMuZWRnZXMpO1xuICAgIGNvbnN0IGRlZmF1bHRFZGdlT3B0aW9ucyA9IHVzZVN0b3JlKChzKSA9PiBzLmRlZmF1bHRFZGdlT3B0aW9ucyk7XG4gICAgY29uc3QgbWFya2VycyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBtYXJrZXJzID0gY3JlYXRlTWFya2VySWRzKGVkZ2VzLCB7XG4gICAgICAgICAgICBpZDogcmZJZCxcbiAgICAgICAgICAgIGRlZmF1bHRDb2xvcixcbiAgICAgICAgICAgIGRlZmF1bHRNYXJrZXJTdGFydDogZGVmYXVsdEVkZ2VPcHRpb25zPy5tYXJrZXJTdGFydCxcbiAgICAgICAgICAgIGRlZmF1bHRNYXJrZXJFbmQ6IGRlZmF1bHRFZGdlT3B0aW9ucz8ubWFya2VyRW5kLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1hcmtlcnM7XG4gICAgfSwgW2VkZ2VzLCBkZWZhdWx0RWRnZU9wdGlvbnMsIHJmSWQsIGRlZmF1bHRDb2xvcl0pO1xuICAgIGlmICghbWFya2Vycy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoanN4KFwic3ZnXCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX21hcmtlclwiLCBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiLCBjaGlsZHJlbjoganN4KFwiZGVmc1wiLCB7IGNoaWxkcmVuOiBtYXJrZXJzLm1hcCgobWFya2VyKSA9PiAoanN4KE1hcmtlciwgeyBpZDogbWFya2VyLmlkLCB0eXBlOiBtYXJrZXIudHlwZSwgY29sb3I6IG1hcmtlci5jb2xvciwgd2lkdGg6IG1hcmtlci53aWR0aCwgaGVpZ2h0OiBtYXJrZXIuaGVpZ2h0LCBtYXJrZXJVbml0czogbWFya2VyLm1hcmtlclVuaXRzLCBzdHJva2VXaWR0aDogbWFya2VyLnN0cm9rZVdpZHRoLCBvcmllbnQ6IG1hcmtlci5vcmllbnQgfSwgbWFya2VyLmlkKSkpIH0pIH0pKTtcbn07XG5NYXJrZXJEZWZpbml0aW9ucy5kaXNwbGF5TmFtZSA9ICdNYXJrZXJEZWZpbml0aW9ucyc7XG52YXIgTWFya2VyRGVmaW5pdGlvbnMkMSA9IG1lbW8oTWFya2VyRGVmaW5pdGlvbnMpO1xuXG5mdW5jdGlvbiBFZGdlVGV4dENvbXBvbmVudCh7IHgsIHksIGxhYmVsLCBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZyA9IHRydWUsIGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmcgPSBbMiwgNF0sIGxhYmVsQmdCb3JkZXJSYWRpdXMgPSAyLCBjaGlsZHJlbiwgY2xhc3NOYW1lLCAuLi5yZXN0IH0pIHtcbiAgICBjb25zdCBbZWRnZVRleHRCYm94LCBzZXRFZGdlVGV4dEJib3hdID0gdXNlU3RhdGUoeyB4OiAxLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pO1xuICAgIGNvbnN0IGVkZ2VUZXh0Q2xhc3NlcyA9IGNjKFsncmVhY3QtZmxvd19fZWRnZS10ZXh0d3JhcHBlcicsIGNsYXNzTmFtZV0pO1xuICAgIGNvbnN0IGVkZ2VUZXh0UmVmID0gdXNlUmVmKG51bGwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChlZGdlVGV4dFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0QmJveCA9IGVkZ2VUZXh0UmVmLmN1cnJlbnQuZ2V0QkJveCgpO1xuICAgICAgICAgICAgc2V0RWRnZVRleHRCYm94KHtcbiAgICAgICAgICAgICAgICB4OiB0ZXh0QmJveC54LFxuICAgICAgICAgICAgICAgIHk6IHRleHRCYm94LnksXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRleHRCYm94LndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGV4dEJib3guaGVpZ2h0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbbGFiZWxdKTtcbiAgICBpZiAoIWxhYmVsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeHMoXCJnXCIsIHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7eCAtIGVkZ2VUZXh0QmJveC53aWR0aCAvIDJ9ICR7eSAtIGVkZ2VUZXh0QmJveC5oZWlnaHQgLyAyfSlgLCBjbGFzc05hbWU6IGVkZ2VUZXh0Q2xhc3NlcywgdmlzaWJpbGl0eTogZWRnZVRleHRCYm94LndpZHRoID8gJ3Zpc2libGUnIDogJ2hpZGRlbicsIC4uLnJlc3QsIGNoaWxkcmVuOiBbbGFiZWxTaG93QmcgJiYgKGpzeChcInJlY3RcIiwgeyB3aWR0aDogZWRnZVRleHRCYm94LndpZHRoICsgMiAqIGxhYmVsQmdQYWRkaW5nWzBdLCB4OiAtbGFiZWxCZ1BhZGRpbmdbMF0sIHk6IC1sYWJlbEJnUGFkZGluZ1sxXSwgaGVpZ2h0OiBlZGdlVGV4dEJib3guaGVpZ2h0ICsgMiAqIGxhYmVsQmdQYWRkaW5nWzFdLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fZWRnZS10ZXh0YmdcIiwgc3R5bGU6IGxhYmVsQmdTdHlsZSwgcng6IGxhYmVsQmdCb3JkZXJSYWRpdXMsIHJ5OiBsYWJlbEJnQm9yZGVyUmFkaXVzIH0pKSwganN4KFwidGV4dFwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19lZGdlLXRleHRcIiwgeTogZWRnZVRleHRCYm94LmhlaWdodCAvIDIsIGR5OiBcIjAuM2VtXCIsIHJlZjogZWRnZVRleHRSZWYsIHN0eWxlOiBsYWJlbFN0eWxlLCBjaGlsZHJlbjogbGFiZWwgfSksIGNoaWxkcmVuXSB9KSk7XG59XG5FZGdlVGV4dENvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdFZGdlVGV4dCc7XG4vKipcbiAqIFlvdSBjYW4gdXNlIHRoZSBgPEVkZ2VUZXh0IC8+YCBjb21wb25lbnQgYXMgYSBoZWxwZXIgY29tcG9uZW50IHRvIGRpc3BsYXkgdGV4dFxuICogd2l0aGluIHlvdXIgY3VzdG9tIGVkZ2VzLlxuICpcbiAqIEBwdWJsaWNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKiBpbXBvcnQgeyBFZGdlVGV4dCB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqIGV4cG9ydCBmdW5jdGlvbiBDdXN0b21FZGdlTGFiZWwoeyBsYWJlbCB9KSB7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPEVkZ2VUZXh0XG4gKiAgICAgICB4PXsxMDB9XG4gKiAgICAgICB5PXsxMDB9XG4gKiAgICAgICBsYWJlbD17bGFiZWx9XG4gKiAgICAgICBsYWJlbFN0eWxlPXt7IGZpbGw6ICd3aGl0ZScgfX1cbiAqICAgICAgIGxhYmVsU2hvd0JnXG4gKiAgICAgICBsYWJlbEJnU3R5bGU9e3sgZmlsbDogJ3JlZCcgfX1cbiAqICAgICAgIGxhYmVsQmdQYWRkaW5nPXtbMiwgNF19XG4gKiAgICAgICBsYWJlbEJnQm9yZGVyUmFkaXVzPXsyfVxuICogICAgIC8+XG4gKiAgICk7XG4gKiB9XG4gKmBgYFxuICovXG5jb25zdCBFZGdlVGV4dCA9IG1lbW8oRWRnZVRleHRDb21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSBgPEJhc2VFZGdlIC8+YCBjb21wb25lbnQgZ2V0cyB1c2VkIGludGVybmFsbHkgZm9yIGFsbCB0aGUgZWRnZXMuIEl0IGNhbiBiZVxuICogdXNlZCBpbnNpZGUgYSBjdXN0b20gZWRnZSBhbmQgaGFuZGxlcyB0aGUgaW52aXNpYmxlIGhlbHBlciBlZGdlIGFuZCB0aGUgZWRnZSBsYWJlbFxuICogZm9yIHlvdS5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKmltcG9ydCB7IEJhc2VFZGdlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZnVuY3Rpb24gQ3VzdG9tRWRnZSh7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIC4uLnByb3BzIH0pIHtcbiAqICBjb25zdCBbZWRnZVBhdGhdID0gZ2V0U3RyYWlnaHRQYXRoKHtcbiAqICAgIHNvdXJjZVgsXG4gKiAgICBzb3VyY2VZLFxuICogICAgdGFyZ2V0WCxcbiAqICAgIHRhcmdldFksXG4gKiAgfSk7XG4gKlxuICogIHJldHVybiA8QmFzZUVkZ2UgcGF0aD17ZWRnZVBhdGh9IHsuLi5wcm9wc30gLz47XG4gKn1cbiAqYGBgXG4gKlxuICogQHJlbWFya3MgSWYgeW91IHdhbnQgdG8gdXNlIGFuIGVkZ2UgbWFya2VyIHdpdGggdGhlIFtgPEJhc2VFZGdlIC8+YF0oL2FwaS1yZWZlcmVuY2UvY29tcG9uZW50cy9iYXNlLWVkZ2UpIGNvbXBvbmVudCxcbiAqIHlvdSBjYW4gcGFzcyB0aGUgYG1hcmtlclN0YXJ0YCBvciBgbWFya2VyRW5kYCBwcm9wcyBwYXNzZWQgdG8geW91ciBjdXN0b20gZWRnZVxuICogdGhyb3VnaCB0byB0aGUgW2A8QmFzZUVkZ2UgLz5gXSgvYXBpLXJlZmVyZW5jZS9jb21wb25lbnRzL2Jhc2UtZWRnZSkgY29tcG9uZW50LlxuICogWW91IGNhbiBzZWUgYWxsIHRoZSBwcm9wcyBwYXNzZWQgdG8gYSBjdXN0b20gZWRnZSBieSBsb29raW5nIGF0IHRoZSBbYEVkZ2VQcm9wc2BdKC9hcGktcmVmZXJlbmNlL3R5cGVzL2VkZ2UtcHJvcHMpIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIEJhc2VFZGdlKHsgcGF0aCwgbGFiZWxYLCBsYWJlbFksIGxhYmVsLCBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1cywgaW50ZXJhY3Rpb25XaWR0aCA9IDIwLCAuLi5wcm9wcyB9KSB7XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4KFwicGF0aFwiLCB7IC4uLnByb3BzLCBkOiBwYXRoLCBmaWxsOiBcIm5vbmVcIiwgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX2VkZ2UtcGF0aCcsIHByb3BzLmNsYXNzTmFtZV0pIH0pLCBpbnRlcmFjdGlvbldpZHRoID8gKGpzeChcInBhdGhcIiwgeyBkOiBwYXRoLCBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlT3BhY2l0eTogMCwgc3Ryb2tlV2lkdGg6IGludGVyYWN0aW9uV2lkdGgsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19lZGdlLWludGVyYWN0aW9uXCIgfSkpIDogbnVsbCwgbGFiZWwgJiYgaXNOdW1lcmljKGxhYmVsWCkgJiYgaXNOdW1lcmljKGxhYmVsWSkgPyAoanN4KEVkZ2VUZXh0LCB7IHg6IGxhYmVsWCwgeTogbGFiZWxZLCBsYWJlbDogbGFiZWwsIGxhYmVsU3R5bGU6IGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnOiBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlOiBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nOiBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1czogbGFiZWxCZ0JvcmRlclJhZGl1cyB9KSkgOiBudWxsXSB9KSk7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRyb2woeyBwb3MsIHgxLCB5MSwgeDIsIHkyIH0pIHtcbiAgICBpZiAocG9zID09PSBQb3NpdGlvbi5MZWZ0IHx8IHBvcyA9PT0gUG9zaXRpb24uUmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIFswLjUgKiAoeDEgKyB4MiksIHkxXTtcbiAgICB9XG4gICAgcmV0dXJuIFt4MSwgMC41ICogKHkxICsgeTIpXTtcbn1cbi8qKlxuICogVGhlIGBnZXRTaW1wbGVCZXppZXJQYXRoYCB1dGlsIHJldHVybnMgZXZlcnl0aGluZyB5b3UgbmVlZCB0byByZW5kZXIgYSBzaW1wbGVcbiAqIGJlemllciBlZGdlIGJldHdlZW4gdHdvIG5vZGVzLlxuICogQHB1YmxpY1xuICogQHJldHVybnNcbiAqIC0gYHBhdGhgOiB0aGUgcGF0aCB0byB1c2UgaW4gYW4gU1ZHIGA8cGF0aD5gIGVsZW1lbnQuXG4gKiAtIGBsYWJlbFhgOiB0aGUgYHhgIHBvc2l0aW9uIHlvdSBjYW4gdXNlIHRvIHJlbmRlciBhIGxhYmVsIGZvciB0aGlzIGVkZ2UuXG4gKiAtIGBsYWJlbFlgOiB0aGUgYHlgIHBvc2l0aW9uIHlvdSBjYW4gdXNlIHRvIHJlbmRlciBhIGxhYmVsIGZvciB0aGlzIGVkZ2UuXG4gKiAtIGBvZmZzZXRYYDogdGhlIGFic29sdXRlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgc291cmNlIGB4YCBwb3NpdGlvbiBhbmQgdGhlIGB4YCBwb3NpdGlvbiBvZiB0aGVcbiAqIG1pZGRsZSBvZiB0aGlzIHBhdGguXG4gKiAtIGBvZmZzZXRZYDogdGhlIGFic29sdXRlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgc291cmNlIGB5YCBwb3NpdGlvbiBhbmQgdGhlIGB5YCBwb3NpdGlvbiBvZiB0aGVcbiAqIG1pZGRsZSBvZiB0aGlzIHBhdGguXG4gKi9cbmZ1bmN0aW9uIGdldFNpbXBsZUJlemllclBhdGgoeyBzb3VyY2VYLCBzb3VyY2VZLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgdGFyZ2V0WCwgdGFyZ2V0WSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIH0pIHtcbiAgICBjb25zdCBbc291cmNlQ29udHJvbFgsIHNvdXJjZUNvbnRyb2xZXSA9IGdldENvbnRyb2woe1xuICAgICAgICBwb3M6IHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICB4MTogc291cmNlWCxcbiAgICAgICAgeTE6IHNvdXJjZVksXG4gICAgICAgIHgyOiB0YXJnZXRYLFxuICAgICAgICB5MjogdGFyZ2V0WSxcbiAgICB9KTtcbiAgICBjb25zdCBbdGFyZ2V0Q29udHJvbFgsIHRhcmdldENvbnRyb2xZXSA9IGdldENvbnRyb2woe1xuICAgICAgICBwb3M6IHRhcmdldFBvc2l0aW9uLFxuICAgICAgICB4MTogdGFyZ2V0WCxcbiAgICAgICAgeTE6IHRhcmdldFksXG4gICAgICAgIHgyOiBzb3VyY2VYLFxuICAgICAgICB5Mjogc291cmNlWSxcbiAgICB9KTtcbiAgICBjb25zdCBbbGFiZWxYLCBsYWJlbFksIG9mZnNldFgsIG9mZnNldFldID0gZ2V0QmV6aWVyRWRnZUNlbnRlcih7XG4gICAgICAgIHNvdXJjZVgsXG4gICAgICAgIHNvdXJjZVksXG4gICAgICAgIHRhcmdldFgsXG4gICAgICAgIHRhcmdldFksXG4gICAgICAgIHNvdXJjZUNvbnRyb2xYLFxuICAgICAgICBzb3VyY2VDb250cm9sWSxcbiAgICAgICAgdGFyZ2V0Q29udHJvbFgsXG4gICAgICAgIHRhcmdldENvbnRyb2xZLFxuICAgIH0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIGBNJHtzb3VyY2VYfSwke3NvdXJjZVl9IEMke3NvdXJjZUNvbnRyb2xYfSwke3NvdXJjZUNvbnRyb2xZfSAke3RhcmdldENvbnRyb2xYfSwke3RhcmdldENvbnRyb2xZfSAke3RhcmdldFh9LCR7dGFyZ2V0WX1gLFxuICAgICAgICBsYWJlbFgsXG4gICAgICAgIGxhYmVsWSxcbiAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WSxcbiAgICBdO1xufVxuZnVuY3Rpb24gY3JlYXRlU2ltcGxlQmV6aWVyRWRnZShwYXJhbXMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGlzcGxheS1uYW1lXG4gICAgcmV0dXJuIG1lbW8oKHsgaWQsIHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbiwgbGFiZWwsIGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZSwgbWFya2VyRW5kLCBtYXJrZXJTdGFydCwgaW50ZXJhY3Rpb25XaWR0aCwgfSkgPT4ge1xuICAgICAgICBjb25zdCBbcGF0aCwgbGFiZWxYLCBsYWJlbFldID0gZ2V0U2ltcGxlQmV6aWVyUGF0aCh7XG4gICAgICAgICAgICBzb3VyY2VYLFxuICAgICAgICAgICAgc291cmNlWSxcbiAgICAgICAgICAgIHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICAgICAgdGFyZ2V0WCxcbiAgICAgICAgICAgIHRhcmdldFksXG4gICAgICAgICAgICB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IF9pZCA9IHBhcmFtcy5pc0ludGVybmFsID8gdW5kZWZpbmVkIDogaWQ7XG4gICAgICAgIHJldHVybiAoanN4KEJhc2VFZGdlLCB7IGlkOiBfaWQsIHBhdGg6IHBhdGgsIGxhYmVsWDogbGFiZWxYLCBsYWJlbFk6IGxhYmVsWSwgbGFiZWw6IGxhYmVsLCBsYWJlbFN0eWxlOiBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZzogbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZTogbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXM6IGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlOiBzdHlsZSwgbWFya2VyRW5kOiBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0OiBtYXJrZXJTdGFydCwgaW50ZXJhY3Rpb25XaWR0aDogaW50ZXJhY3Rpb25XaWR0aCB9KSk7XG4gICAgfSk7XG59XG5jb25zdCBTaW1wbGVCZXppZXJFZGdlID0gY3JlYXRlU2ltcGxlQmV6aWVyRWRnZSh7IGlzSW50ZXJuYWw6IGZhbHNlIH0pO1xuY29uc3QgU2ltcGxlQmV6aWVyRWRnZUludGVybmFsID0gY3JlYXRlU2ltcGxlQmV6aWVyRWRnZSh7IGlzSW50ZXJuYWw6IHRydWUgfSk7XG5TaW1wbGVCZXppZXJFZGdlLmRpc3BsYXlOYW1lID0gJ1NpbXBsZUJlemllckVkZ2UnO1xuU2ltcGxlQmV6aWVyRWRnZUludGVybmFsLmRpc3BsYXlOYW1lID0gJ1NpbXBsZUJlemllckVkZ2VJbnRlcm5hbCc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVNtb290aFN0ZXBFZGdlKHBhcmFtcykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9kaXNwbGF5LW5hbWVcbiAgICByZXR1cm4gbWVtbygoeyBpZCwgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgbGFiZWwsIGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0LCBwYXRoT3B0aW9ucywgaW50ZXJhY3Rpb25XaWR0aCwgfSkgPT4ge1xuICAgICAgICBjb25zdCBbcGF0aCwgbGFiZWxYLCBsYWJlbFldID0gZ2V0U21vb3RoU3RlcFBhdGgoe1xuICAgICAgICAgICAgc291cmNlWCxcbiAgICAgICAgICAgIHNvdXJjZVksXG4gICAgICAgICAgICBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgICAgIHRhcmdldFgsXG4gICAgICAgICAgICB0YXJnZXRZLFxuICAgICAgICAgICAgdGFyZ2V0UG9zaXRpb24sXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IHBhdGhPcHRpb25zPy5ib3JkZXJSYWRpdXMsXG4gICAgICAgICAgICBvZmZzZXQ6IHBhdGhPcHRpb25zPy5vZmZzZXQsXG4gICAgICAgICAgICBzdGVwUG9zaXRpb246IHBhdGhPcHRpb25zPy5zdGVwUG9zaXRpb24sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBfaWQgPSBwYXJhbXMuaXNJbnRlcm5hbCA/IHVuZGVmaW5lZCA6IGlkO1xuICAgICAgICByZXR1cm4gKGpzeChCYXNlRWRnZSwgeyBpZDogX2lkLCBwYXRoOiBwYXRoLCBsYWJlbFg6IGxhYmVsWCwgbGFiZWxZOiBsYWJlbFksIGxhYmVsOiBsYWJlbCwgbGFiZWxTdHlsZTogbGFiZWxTdHlsZSwgbGFiZWxTaG93Qmc6IGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmc6IGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzOiBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZTogc3R5bGUsIG1hcmtlckVuZDogbWFya2VyRW5kLCBtYXJrZXJTdGFydDogbWFya2VyU3RhcnQsIGludGVyYWN0aW9uV2lkdGg6IGludGVyYWN0aW9uV2lkdGggfSkpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBDb21wb25lbnQgdGhhdCBjYW4gYmUgdXNlZCBpbnNpZGUgYSBjdXN0b20gZWRnZSB0byByZW5kZXIgYSBzbW9vdGggc3RlcCBlZGdlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHN4XG4gKiBpbXBvcnQgeyBTbW9vdGhTdGVwRWRnZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqIGZ1bmN0aW9uIEN1c3RvbUVkZ2UoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24gfSkge1xuICogICByZXR1cm4gKFxuICogICAgIDxTbW9vdGhTdGVwRWRnZVxuICogICAgICAgc291cmNlWD17c291cmNlWH1cbiAqICAgICAgIHNvdXJjZVk9e3NvdXJjZVl9XG4gKiAgICAgICB0YXJnZXRYPXt0YXJnZXRYfVxuICogICAgICAgdGFyZ2V0WT17dGFyZ2V0WX1cbiAqICAgICAgIHNvdXJjZVBvc2l0aW9uPXtzb3VyY2VQb3NpdGlvbn1cbiAqICAgICAgIHRhcmdldFBvc2l0aW9uPXt0YXJnZXRQb3NpdGlvbn1cbiAqICAgICAvPlxuICogICApO1xuICogfVxuICogYGBgXG4gKi9cbmNvbnN0IFNtb290aFN0ZXBFZGdlID0gY3JlYXRlU21vb3RoU3RlcEVkZ2UoeyBpc0ludGVybmFsOiBmYWxzZSB9KTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFNtb290aFN0ZXBFZGdlSW50ZXJuYWwgPSBjcmVhdGVTbW9vdGhTdGVwRWRnZSh7IGlzSW50ZXJuYWw6IHRydWUgfSk7XG5TbW9vdGhTdGVwRWRnZS5kaXNwbGF5TmFtZSA9ICdTbW9vdGhTdGVwRWRnZSc7XG5TbW9vdGhTdGVwRWRnZUludGVybmFsLmRpc3BsYXlOYW1lID0gJ1Ntb290aFN0ZXBFZGdlSW50ZXJuYWwnO1xuXG5mdW5jdGlvbiBjcmVhdGVTdGVwRWRnZShwYXJhbXMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGlzcGxheS1uYW1lXG4gICAgcmV0dXJuIG1lbW8oKHsgaWQsIC4uLnByb3BzIH0pID0+IHtcbiAgICAgICAgY29uc3QgX2lkID0gcGFyYW1zLmlzSW50ZXJuYWwgPyB1bmRlZmluZWQgOiBpZDtcbiAgICAgICAgcmV0dXJuIChqc3goU21vb3RoU3RlcEVkZ2UsIHsgLi4ucHJvcHMsIGlkOiBfaWQsIHBhdGhPcHRpb25zOiB1c2VNZW1vKCgpID0+ICh7IGJvcmRlclJhZGl1czogMCwgb2Zmc2V0OiBwcm9wcy5wYXRoT3B0aW9ucz8ub2Zmc2V0IH0pLCBbcHJvcHMucGF0aE9wdGlvbnM/Lm9mZnNldF0pIH0pKTtcbiAgICB9KTtcbn1cbi8qKlxuICogQ29tcG9uZW50IHRoYXQgY2FuIGJlIHVzZWQgaW5zaWRlIGEgY3VzdG9tIGVkZ2UgdG8gcmVuZGVyIGEgc3RlcCBlZGdlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHN4XG4gKiBpbXBvcnQgeyBTdGVwRWRnZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqIGZ1bmN0aW9uIEN1c3RvbUVkZ2UoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24gfSkge1xuICogICByZXR1cm4gKFxuICogICAgIDxTdGVwRWRnZVxuICogICAgICAgc291cmNlWD17c291cmNlWH1cbiAqICAgICAgIHNvdXJjZVk9e3NvdXJjZVl9XG4gKiAgICAgICB0YXJnZXRYPXt0YXJnZXRYfVxuICogICAgICAgdGFyZ2V0WT17dGFyZ2V0WX1cbiAqICAgICAgIHNvdXJjZVBvc2l0aW9uPXtzb3VyY2VQb3NpdGlvbn1cbiAqICAgICAgIHRhcmdldFBvc2l0aW9uPXt0YXJnZXRQb3NpdGlvbn1cbiAqICAgICAvPlxuICogICApO1xuICogfVxuICogYGBgXG4gKi9cbmNvbnN0IFN0ZXBFZGdlID0gY3JlYXRlU3RlcEVkZ2UoeyBpc0ludGVybmFsOiBmYWxzZSB9KTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFN0ZXBFZGdlSW50ZXJuYWwgPSBjcmVhdGVTdGVwRWRnZSh7IGlzSW50ZXJuYWw6IHRydWUgfSk7XG5TdGVwRWRnZS5kaXNwbGF5TmFtZSA9ICdTdGVwRWRnZSc7XG5TdGVwRWRnZUludGVybmFsLmRpc3BsYXlOYW1lID0gJ1N0ZXBFZGdlSW50ZXJuYWwnO1xuXG5mdW5jdGlvbiBjcmVhdGVTdHJhaWdodEVkZ2UocGFyYW1zKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2Rpc3BsYXktbmFtZVxuICAgIHJldHVybiBtZW1vKCh7IGlkLCBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBsYWJlbCwgbGFiZWxTdHlsZSwgbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlLCBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0LCBpbnRlcmFjdGlvbldpZHRoLCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWV0gPSBnZXRTdHJhaWdodFBhdGgoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZIH0pO1xuICAgICAgICBjb25zdCBfaWQgPSBwYXJhbXMuaXNJbnRlcm5hbCA/IHVuZGVmaW5lZCA6IGlkO1xuICAgICAgICByZXR1cm4gKGpzeChCYXNlRWRnZSwgeyBpZDogX2lkLCBwYXRoOiBwYXRoLCBsYWJlbFg6IGxhYmVsWCwgbGFiZWxZOiBsYWJlbFksIGxhYmVsOiBsYWJlbCwgbGFiZWxTdHlsZTogbGFiZWxTdHlsZSwgbGFiZWxTaG93Qmc6IGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmc6IGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzOiBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZTogc3R5bGUsIG1hcmtlckVuZDogbWFya2VyRW5kLCBtYXJrZXJTdGFydDogbWFya2VyU3RhcnQsIGludGVyYWN0aW9uV2lkdGg6IGludGVyYWN0aW9uV2lkdGggfSkpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBDb21wb25lbnQgdGhhdCBjYW4gYmUgdXNlZCBpbnNpZGUgYSBjdXN0b20gZWRnZSB0byByZW5kZXIgYSBzdHJhaWdodCBsaW5lLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHN4XG4gKiBpbXBvcnQgeyBTdHJhaWdodEVkZ2UgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKiBmdW5jdGlvbiBDdXN0b21FZGdlKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSB9KSB7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPFN0cmFpZ2h0RWRnZVxuICogICAgICAgc291cmNlWD17c291cmNlWH1cbiAqICAgICAgIHNvdXJjZVk9e3NvdXJjZVl9XG4gKiAgICAgICB0YXJnZXRYPXt0YXJnZXRYfVxuICogICAgICAgdGFyZ2V0WT17dGFyZ2V0WX1cbiAqICAgICAvPlxuICogICApO1xuICogfVxuICogYGBgXG4gKi9cbmNvbnN0IFN0cmFpZ2h0RWRnZSA9IGNyZWF0ZVN0cmFpZ2h0RWRnZSh7IGlzSW50ZXJuYWw6IGZhbHNlIH0pO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgU3RyYWlnaHRFZGdlSW50ZXJuYWwgPSBjcmVhdGVTdHJhaWdodEVkZ2UoeyBpc0ludGVybmFsOiB0cnVlIH0pO1xuU3RyYWlnaHRFZGdlLmRpc3BsYXlOYW1lID0gJ1N0cmFpZ2h0RWRnZSc7XG5TdHJhaWdodEVkZ2VJbnRlcm5hbC5kaXNwbGF5TmFtZSA9ICdTdHJhaWdodEVkZ2VJbnRlcm5hbCc7XG5cbmZ1bmN0aW9uIGNyZWF0ZUJlemllckVkZ2UocGFyYW1zKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2Rpc3BsYXktbmFtZVxuICAgIHJldHVybiBtZW1vKCh7IGlkLCBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIGxhYmVsLCBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGUsIG1hcmtlckVuZCwgbWFya2VyU3RhcnQsIHBhdGhPcHRpb25zLCBpbnRlcmFjdGlvbldpZHRoLCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWV0gPSBnZXRCZXppZXJQYXRoKHtcbiAgICAgICAgICAgIHNvdXJjZVgsXG4gICAgICAgICAgICBzb3VyY2VZLFxuICAgICAgICAgICAgc291cmNlUG9zaXRpb24sXG4gICAgICAgICAgICB0YXJnZXRYLFxuICAgICAgICAgICAgdGFyZ2V0WSxcbiAgICAgICAgICAgIHRhcmdldFBvc2l0aW9uLFxuICAgICAgICAgICAgY3VydmF0dXJlOiBwYXRoT3B0aW9ucz8uY3VydmF0dXJlLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgX2lkID0gcGFyYW1zLmlzSW50ZXJuYWwgPyB1bmRlZmluZWQgOiBpZDtcbiAgICAgICAgcmV0dXJuIChqc3goQmFzZUVkZ2UsIHsgaWQ6IF9pZCwgcGF0aDogcGF0aCwgbGFiZWxYOiBsYWJlbFgsIGxhYmVsWTogbGFiZWxZLCBsYWJlbDogbGFiZWwsIGxhYmVsU3R5bGU6IGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnOiBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlOiBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nOiBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1czogbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGU6IHN0eWxlLCBtYXJrZXJFbmQ6IG1hcmtlckVuZCwgbWFya2VyU3RhcnQ6IG1hcmtlclN0YXJ0LCBpbnRlcmFjdGlvbldpZHRoOiBpbnRlcmFjdGlvbldpZHRoIH0pKTtcbiAgICB9KTtcbn1cbi8qKlxuICogQ29tcG9uZW50IHRoYXQgY2FuIGJlIHVzZWQgaW5zaWRlIGEgY3VzdG9tIGVkZ2UgdG8gcmVuZGVyIGEgYmV6aWVyIGN1cnZlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHN4XG4gKiBpbXBvcnQgeyBCZXppZXJFZGdlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICogZnVuY3Rpb24gQ3VzdG9tRWRnZSh7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbiB9KSB7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPEJlemllckVkZ2VcbiAqICAgICAgIHNvdXJjZVg9e3NvdXJjZVh9XG4gKiAgICAgICBzb3VyY2VZPXtzb3VyY2VZfVxuICogICAgICAgdGFyZ2V0WD17dGFyZ2V0WH1cbiAqICAgICAgIHRhcmdldFk9e3RhcmdldFl9XG4gKiAgICAgICBzb3VyY2VQb3NpdGlvbj17c291cmNlUG9zaXRpb259XG4gKiAgICAgICB0YXJnZXRQb3NpdGlvbj17dGFyZ2V0UG9zaXRpb259XG4gKiAgICAgLz5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5jb25zdCBCZXppZXJFZGdlID0gY3JlYXRlQmV6aWVyRWRnZSh7IGlzSW50ZXJuYWw6IGZhbHNlIH0pO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgQmV6aWVyRWRnZUludGVybmFsID0gY3JlYXRlQmV6aWVyRWRnZSh7IGlzSW50ZXJuYWw6IHRydWUgfSk7XG5CZXppZXJFZGdlLmRpc3BsYXlOYW1lID0gJ0JlemllckVkZ2UnO1xuQmV6aWVyRWRnZUludGVybmFsLmRpc3BsYXlOYW1lID0gJ0JlemllckVkZ2VJbnRlcm5hbCc7XG5cbmNvbnN0IGJ1aWx0aW5FZGdlVHlwZXMgPSB7XG4gICAgZGVmYXVsdDogQmV6aWVyRWRnZUludGVybmFsLFxuICAgIHN0cmFpZ2h0OiBTdHJhaWdodEVkZ2VJbnRlcm5hbCxcbiAgICBzdGVwOiBTdGVwRWRnZUludGVybmFsLFxuICAgIHNtb290aHN0ZXA6IFNtb290aFN0ZXBFZGdlSW50ZXJuYWwsXG4gICAgc2ltcGxlYmV6aWVyOiBTaW1wbGVCZXppZXJFZGdlSW50ZXJuYWwsXG59O1xuY29uc3QgbnVsbFBvc2l0aW9uID0ge1xuICAgIHNvdXJjZVg6IG51bGwsXG4gICAgc291cmNlWTogbnVsbCxcbiAgICB0YXJnZXRYOiBudWxsLFxuICAgIHRhcmdldFk6IG51bGwsXG4gICAgc291cmNlUG9zaXRpb246IG51bGwsXG4gICAgdGFyZ2V0UG9zaXRpb246IG51bGwsXG59O1xuXG5jb25zdCBzaGlmdFggPSAoeCwgc2hpZnQsIHBvc2l0aW9uKSA9PiB7XG4gICAgaWYgKHBvc2l0aW9uID09PSBQb3NpdGlvbi5MZWZ0KVxuICAgICAgICByZXR1cm4geCAtIHNoaWZ0O1xuICAgIGlmIChwb3NpdGlvbiA9PT0gUG9zaXRpb24uUmlnaHQpXG4gICAgICAgIHJldHVybiB4ICsgc2hpZnQ7XG4gICAgcmV0dXJuIHg7XG59O1xuY29uc3Qgc2hpZnRZID0gKHksIHNoaWZ0LCBwb3NpdGlvbikgPT4ge1xuICAgIGlmIChwb3NpdGlvbiA9PT0gUG9zaXRpb24uVG9wKVxuICAgICAgICByZXR1cm4geSAtIHNoaWZ0O1xuICAgIGlmIChwb3NpdGlvbiA9PT0gUG9zaXRpb24uQm90dG9tKVxuICAgICAgICByZXR1cm4geSArIHNoaWZ0O1xuICAgIHJldHVybiB5O1xufTtcbmNvbnN0IEVkZ2VVcGRhdGVyQ2xhc3NOYW1lID0gJ3JlYWN0LWZsb3dfX2VkZ2V1cGRhdGVyJztcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIEVkZ2VBbmNob3IoeyBwb3NpdGlvbiwgY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzID0gMTAsIG9uTW91c2VEb3duLCBvbk1vdXNlRW50ZXIsIG9uTW91c2VPdXQsIHR5cGUsIH0pIHtcbiAgICByZXR1cm4gKGpzeChcImNpcmNsZVwiLCB7IG9uTW91c2VEb3duOiBvbk1vdXNlRG93biwgb25Nb3VzZUVudGVyOiBvbk1vdXNlRW50ZXIsIG9uTW91c2VPdXQ6IG9uTW91c2VPdXQsIGNsYXNzTmFtZTogY2MoW0VkZ2VVcGRhdGVyQ2xhc3NOYW1lLCBgJHtFZGdlVXBkYXRlckNsYXNzTmFtZX0tJHt0eXBlfWBdKSwgY3g6IHNoaWZ0WChjZW50ZXJYLCByYWRpdXMsIHBvc2l0aW9uKSwgY3k6IHNoaWZ0WShjZW50ZXJZLCByYWRpdXMsIHBvc2l0aW9uKSwgcjogcmFkaXVzLCBzdHJva2U6IFwidHJhbnNwYXJlbnRcIiwgZmlsbDogXCJ0cmFuc3BhcmVudFwiIH0pKTtcbn1cblxuZnVuY3Rpb24gRWRnZVVwZGF0ZUFuY2hvcnMoeyBpc1JlY29ubmVjdGFibGUsIHJlY29ubmVjdFJhZGl1cywgZWRnZSwgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uLCBvblJlY29ubmVjdCwgb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQsIHNldFJlY29ubmVjdGluZywgc2V0VXBkYXRlSG92ZXIsIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgaGFuZGxlRWRnZVVwZGF0ZXIgPSAoZXZlbnQsIG9wcG9zaXRlSGFuZGxlKSA9PiB7XG4gICAgICAgIC8vIGF2b2lkIHRyaWdnZXJpbmcgZWRnZSB1cGRhdGVyIGlmIG1vdXNlIGJ0biBpcyBub3QgbGVmdFxuICAgICAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBhdXRvUGFuT25Db25uZWN0LCBkb21Ob2RlLCBpc1ZhbGlkQ29ubmVjdGlvbiwgY29ubmVjdGlvbk1vZGUsIGNvbm5lY3Rpb25SYWRpdXMsIGxpYiwgb25Db25uZWN0U3RhcnQsIG9uQ29ubmVjdEVuZCwgY2FuY2VsQ29ubmVjdGlvbiwgbm9kZUxvb2t1cCwgcmZJZDogZmxvd0lkLCBwYW5CeSwgdXBkYXRlQ29ubmVjdGlvbiwgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IGlzVGFyZ2V0ID0gb3Bwb3NpdGVIYW5kbGUudHlwZSA9PT0gJ3RhcmdldCc7XG4gICAgICAgIGNvbnN0IF9vblJlY29ubmVjdEVuZCA9IChldnQsIGNvbm5lY3Rpb25TdGF0ZSkgPT4ge1xuICAgICAgICAgICAgc2V0UmVjb25uZWN0aW5nKGZhbHNlKTtcbiAgICAgICAgICAgIG9uUmVjb25uZWN0RW5kPy4oZXZ0LCBlZGdlLCBvcHBvc2l0ZUhhbmRsZS50eXBlLCBjb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvbkNvbm5lY3RFZGdlID0gKGNvbm5lY3Rpb24pID0+IG9uUmVjb25uZWN0Py4oZWRnZSwgY29ubmVjdGlvbik7XG4gICAgICAgIGNvbnN0IF9vbkNvbm5lY3RTdGFydCA9IChfZXZlbnQsIHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgc2V0UmVjb25uZWN0aW5nKHRydWUpO1xuICAgICAgICAgICAgb25SZWNvbm5lY3RTdGFydD8uKGV2ZW50LCBlZGdlLCBvcHBvc2l0ZUhhbmRsZS50eXBlKTtcbiAgICAgICAgICAgIG9uQ29ubmVjdFN0YXJ0Py4oX2V2ZW50LCBwYXJhbXMpO1xuICAgICAgICB9O1xuICAgICAgICBYWUhhbmRsZS5vblBvaW50ZXJEb3duKGV2ZW50Lm5hdGl2ZUV2ZW50LCB7XG4gICAgICAgICAgICBhdXRvUGFuT25Db25uZWN0LFxuICAgICAgICAgICAgY29ubmVjdGlvbk1vZGUsXG4gICAgICAgICAgICBjb25uZWN0aW9uUmFkaXVzLFxuICAgICAgICAgICAgZG9tTm9kZSxcbiAgICAgICAgICAgIGhhbmRsZUlkOiBvcHBvc2l0ZUhhbmRsZS5pZCxcbiAgICAgICAgICAgIG5vZGVJZDogb3Bwb3NpdGVIYW5kbGUubm9kZUlkLFxuICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgICAgIGlzVGFyZ2V0LFxuICAgICAgICAgICAgZWRnZVVwZGF0ZXJUeXBlOiBvcHBvc2l0ZUhhbmRsZS50eXBlLFxuICAgICAgICAgICAgbGliLFxuICAgICAgICAgICAgZmxvd0lkLFxuICAgICAgICAgICAgY2FuY2VsQ29ubmVjdGlvbixcbiAgICAgICAgICAgIHBhbkJ5LFxuICAgICAgICAgICAgaXNWYWxpZENvbm5lY3Rpb24sXG4gICAgICAgICAgICBvbkNvbm5lY3Q6IG9uQ29ubmVjdEVkZ2UsXG4gICAgICAgICAgICBvbkNvbm5lY3RTdGFydDogX29uQ29ubmVjdFN0YXJ0LFxuICAgICAgICAgICAgb25Db25uZWN0RW5kLFxuICAgICAgICAgICAgb25SZWNvbm5lY3RFbmQ6IF9vblJlY29ubmVjdEVuZCxcbiAgICAgICAgICAgIHVwZGF0ZUNvbm5lY3Rpb24sXG4gICAgICAgICAgICBnZXRUcmFuc2Zvcm06ICgpID0+IHN0b3JlLmdldFN0YXRlKCkudHJhbnNmb3JtLFxuICAgICAgICAgICAgZ2V0RnJvbUhhbmRsZTogKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS5jb25uZWN0aW9uLmZyb21IYW5kbGUsXG4gICAgICAgICAgICBkcmFnVGhyZXNob2xkOiBzdG9yZS5nZXRTdGF0ZSgpLmNvbm5lY3Rpb25EcmFnVGhyZXNob2xkLFxuICAgICAgICAgICAgaGFuZGxlRG9tTm9kZTogZXZlbnQuY3VycmVudFRhcmdldCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBvblJlY29ubmVjdFNvdXJjZU1vdXNlRG93biA9IChldmVudCkgPT4gaGFuZGxlRWRnZVVwZGF0ZXIoZXZlbnQsIHsgbm9kZUlkOiBlZGdlLnRhcmdldCwgaWQ6IGVkZ2UudGFyZ2V0SGFuZGxlID8/IG51bGwsIHR5cGU6ICd0YXJnZXQnIH0pO1xuICAgIGNvbnN0IG9uUmVjb25uZWN0VGFyZ2V0TW91c2VEb3duID0gKGV2ZW50KSA9PiBoYW5kbGVFZGdlVXBkYXRlcihldmVudCwgeyBub2RlSWQ6IGVkZ2Uuc291cmNlLCBpZDogZWRnZS5zb3VyY2VIYW5kbGUgPz8gbnVsbCwgdHlwZTogJ3NvdXJjZScgfSk7XG4gICAgY29uc3Qgb25SZWNvbm5lY3RNb3VzZUVudGVyID0gKCkgPT4gc2V0VXBkYXRlSG92ZXIodHJ1ZSk7XG4gICAgY29uc3Qgb25SZWNvbm5lY3RNb3VzZU91dCA9ICgpID0+IHNldFVwZGF0ZUhvdmVyKGZhbHNlKTtcbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFsoaXNSZWNvbm5lY3RhYmxlID09PSB0cnVlIHx8IGlzUmVjb25uZWN0YWJsZSA9PT0gJ3NvdXJjZScpICYmIChqc3goRWRnZUFuY2hvciwgeyBwb3NpdGlvbjogc291cmNlUG9zaXRpb24sIGNlbnRlclg6IHNvdXJjZVgsIGNlbnRlclk6IHNvdXJjZVksIHJhZGl1czogcmVjb25uZWN0UmFkaXVzLCBvbk1vdXNlRG93bjogb25SZWNvbm5lY3RTb3VyY2VNb3VzZURvd24sIG9uTW91c2VFbnRlcjogb25SZWNvbm5lY3RNb3VzZUVudGVyLCBvbk1vdXNlT3V0OiBvblJlY29ubmVjdE1vdXNlT3V0LCB0eXBlOiBcInNvdXJjZVwiIH0pKSwgKGlzUmVjb25uZWN0YWJsZSA9PT0gdHJ1ZSB8fCBpc1JlY29ubmVjdGFibGUgPT09ICd0YXJnZXQnKSAmJiAoanN4KEVkZ2VBbmNob3IsIHsgcG9zaXRpb246IHRhcmdldFBvc2l0aW9uLCBjZW50ZXJYOiB0YXJnZXRYLCBjZW50ZXJZOiB0YXJnZXRZLCByYWRpdXM6IHJlY29ubmVjdFJhZGl1cywgb25Nb3VzZURvd246IG9uUmVjb25uZWN0VGFyZ2V0TW91c2VEb3duLCBvbk1vdXNlRW50ZXI6IG9uUmVjb25uZWN0TW91c2VFbnRlciwgb25Nb3VzZU91dDogb25SZWNvbm5lY3RNb3VzZU91dCwgdHlwZTogXCJ0YXJnZXRcIiB9KSldIH0pKTtcbn1cblxuZnVuY3Rpb24gRWRnZVdyYXBwZXIoeyBpZCwgZWRnZXNGb2N1c2FibGUsIGVkZ2VzUmVjb25uZWN0YWJsZSwgZWxlbWVudHNTZWxlY3RhYmxlLCBvbkNsaWNrLCBvbkRvdWJsZUNsaWNrLCBvbkNvbnRleHRNZW51LCBvbk1vdXNlRW50ZXIsIG9uTW91c2VNb3ZlLCBvbk1vdXNlTGVhdmUsIHJlY29ubmVjdFJhZGl1cywgb25SZWNvbm5lY3QsIG9uUmVjb25uZWN0U3RhcnQsIG9uUmVjb25uZWN0RW5kLCByZklkLCBlZGdlVHlwZXMsIG5vUGFuQ2xhc3NOYW1lLCBvbkVycm9yLCBkaXNhYmxlS2V5Ym9hcmRBMTF5LCB9KSB7XG4gICAgbGV0IGVkZ2UgPSB1c2VTdG9yZSgocykgPT4gcy5lZGdlTG9va3VwLmdldChpZCkpO1xuICAgIGNvbnN0IGRlZmF1bHRFZGdlT3B0aW9ucyA9IHVzZVN0b3JlKChzKSA9PiBzLmRlZmF1bHRFZGdlT3B0aW9ucyk7XG4gICAgZWRnZSA9IGRlZmF1bHRFZGdlT3B0aW9ucyA/IHsgLi4uZGVmYXVsdEVkZ2VPcHRpb25zLCAuLi5lZGdlIH0gOiBlZGdlO1xuICAgIGxldCBlZGdlVHlwZSA9IGVkZ2UudHlwZSB8fCAnZGVmYXVsdCc7XG4gICAgbGV0IEVkZ2VDb21wb25lbnQgPSBlZGdlVHlwZXM/LltlZGdlVHlwZV0gfHwgYnVpbHRpbkVkZ2VUeXBlc1tlZGdlVHlwZV07XG4gICAgaWYgKEVkZ2VDb21wb25lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvbkVycm9yPy4oJzAxMScsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDExJ10oZWRnZVR5cGUpKTtcbiAgICAgICAgZWRnZVR5cGUgPSAnZGVmYXVsdCc7XG4gICAgICAgIEVkZ2VDb21wb25lbnQgPSBlZGdlVHlwZXM/LlsnZGVmYXVsdCddIHx8IGJ1aWx0aW5FZGdlVHlwZXMuZGVmYXVsdDtcbiAgICB9XG4gICAgY29uc3QgaXNGb2N1c2FibGUgPSAhIShlZGdlLmZvY3VzYWJsZSB8fCAoZWRnZXNGb2N1c2FibGUgJiYgdHlwZW9mIGVkZ2UuZm9jdXNhYmxlID09PSAndW5kZWZpbmVkJykpO1xuICAgIGNvbnN0IGlzUmVjb25uZWN0YWJsZSA9IHR5cGVvZiBvblJlY29ubmVjdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgKGVkZ2UucmVjb25uZWN0YWJsZSB8fCAoZWRnZXNSZWNvbm5lY3RhYmxlICYmIHR5cGVvZiBlZGdlLnJlY29ubmVjdGFibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgY29uc3QgaXNTZWxlY3RhYmxlID0gISEoZWRnZS5zZWxlY3RhYmxlIHx8IChlbGVtZW50c1NlbGVjdGFibGUgJiYgdHlwZW9mIGVkZ2Uuc2VsZWN0YWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICBjb25zdCBlZGdlUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IFt1cGRhdGVIb3Zlciwgc2V0VXBkYXRlSG92ZXJdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtyZWNvbm5lY3RpbmcsIHNldFJlY29ubmVjdGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHsgekluZGV4LCBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24gfSA9IHVzZVN0b3JlKHVzZUNhbGxiYWNrKChzdG9yZSkgPT4ge1xuICAgICAgICBjb25zdCBzb3VyY2VOb2RlID0gc3RvcmUubm9kZUxvb2t1cC5nZXQoZWRnZS5zb3VyY2UpO1xuICAgICAgICBjb25zdCB0YXJnZXROb2RlID0gc3RvcmUubm9kZUxvb2t1cC5nZXQoZWRnZS50YXJnZXQpO1xuICAgICAgICBpZiAoIXNvdXJjZU5vZGUgfHwgIXRhcmdldE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgekluZGV4OiBlZGdlLnpJbmRleCxcbiAgICAgICAgICAgICAgICAuLi5udWxsUG9zaXRpb24sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVkZ2VQb3NpdGlvbiA9IGdldEVkZ2VQb3NpdGlvbih7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHNvdXJjZU5vZGUsXG4gICAgICAgICAgICB0YXJnZXROb2RlLFxuICAgICAgICAgICAgc291cmNlSGFuZGxlOiBlZGdlLnNvdXJjZUhhbmRsZSB8fCBudWxsLFxuICAgICAgICAgICAgdGFyZ2V0SGFuZGxlOiBlZGdlLnRhcmdldEhhbmRsZSB8fCBudWxsLFxuICAgICAgICAgICAgY29ubmVjdGlvbk1vZGU6IHN0b3JlLmNvbm5lY3Rpb25Nb2RlLFxuICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHpJbmRleCA9IGdldEVsZXZhdGVkRWRnZVpJbmRleCh7XG4gICAgICAgICAgICBzZWxlY3RlZDogZWRnZS5zZWxlY3RlZCxcbiAgICAgICAgICAgIHpJbmRleDogZWRnZS56SW5kZXgsXG4gICAgICAgICAgICBzb3VyY2VOb2RlLFxuICAgICAgICAgICAgdGFyZ2V0Tm9kZSxcbiAgICAgICAgICAgIGVsZXZhdGVPblNlbGVjdDogc3RvcmUuZWxldmF0ZUVkZ2VzT25TZWxlY3QsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgekluZGV4LFxuICAgICAgICAgICAgLi4uKGVkZ2VQb3NpdGlvbiB8fCBudWxsUG9zaXRpb24pLFxuICAgICAgICB9O1xuICAgIH0sIFtlZGdlLnNvdXJjZSwgZWRnZS50YXJnZXQsIGVkZ2Uuc291cmNlSGFuZGxlLCBlZGdlLnRhcmdldEhhbmRsZSwgZWRnZS5zZWxlY3RlZCwgZWRnZS56SW5kZXhdKSwgc2hhbGxvdyk7XG4gICAgY29uc3QgbWFya2VyU3RhcnRVcmwgPSB1c2VNZW1vKCgpID0+IChlZGdlLm1hcmtlclN0YXJ0ID8gYHVybCgnIyR7Z2V0TWFya2VySWQoZWRnZS5tYXJrZXJTdGFydCwgcmZJZCl9JylgIDogdW5kZWZpbmVkKSwgW2VkZ2UubWFya2VyU3RhcnQsIHJmSWRdKTtcbiAgICBjb25zdCBtYXJrZXJFbmRVcmwgPSB1c2VNZW1vKCgpID0+IChlZGdlLm1hcmtlckVuZCA/IGB1cmwoJyMke2dldE1hcmtlcklkKGVkZ2UubWFya2VyRW5kLCByZklkKX0nKWAgOiB1bmRlZmluZWQpLCBbZWRnZS5tYXJrZXJFbmQsIHJmSWRdKTtcbiAgICBpZiAoZWRnZS5oaWRkZW4gfHwgc291cmNlWCA9PT0gbnVsbCB8fCBzb3VyY2VZID09PSBudWxsIHx8IHRhcmdldFggPT09IG51bGwgfHwgdGFyZ2V0WSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgb25FZGdlQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgeyBhZGRTZWxlY3RlZEVkZ2VzLCB1bnNlbGVjdE5vZGVzQW5kRWRnZXMsIG11bHRpU2VsZWN0aW9uQWN0aXZlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoaXNTZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG5vZGVzU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIGlmIChlZGdlLnNlbGVjdGVkICYmIG11bHRpU2VsZWN0aW9uQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzKHsgbm9kZXM6IFtdLCBlZGdlczogW2VkZ2VdIH0pO1xuICAgICAgICAgICAgICAgIGVkZ2VSZWYuY3VycmVudD8uYmx1cigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkU2VsZWN0ZWRFZGdlcyhbaWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob25DbGljaykge1xuICAgICAgICAgICAgb25DbGljayhldmVudCwgZWRnZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG9uRWRnZURvdWJsZUNsaWNrID0gb25Eb3VibGVDbGlja1xuICAgICAgICA/IChldmVudCkgPT4ge1xuICAgICAgICAgICAgb25Eb3VibGVDbGljayhldmVudCwgeyAuLi5lZGdlIH0pO1xuICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uRWRnZUNvbnRleHRNZW51ID0gb25Db250ZXh0TWVudVxuICAgICAgICA/IChldmVudCkgPT4ge1xuICAgICAgICAgICAgb25Db250ZXh0TWVudShldmVudCwgeyAuLi5lZGdlIH0pO1xuICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uRWRnZU1vdXNlRW50ZXIgPSBvbk1vdXNlRW50ZXJcbiAgICAgICAgPyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIG9uTW91c2VFbnRlcihldmVudCwgeyAuLi5lZGdlIH0pO1xuICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uRWRnZU1vdXNlTW92ZSA9IG9uTW91c2VNb3ZlXG4gICAgICAgID8gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBvbk1vdXNlTW92ZShldmVudCwgeyAuLi5lZGdlIH0pO1xuICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uRWRnZU1vdXNlTGVhdmUgPSBvbk1vdXNlTGVhdmVcbiAgICAgICAgPyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIG9uTW91c2VMZWF2ZShldmVudCwgeyAuLi5lZGdlIH0pO1xuICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoIWRpc2FibGVLZXlib2FyZEExMXkgJiYgZWxlbWVudFNlbGVjdGlvbktleXMuaW5jbHVkZXMoZXZlbnQua2V5KSAmJiBpc1NlbGVjdGFibGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzLCBhZGRTZWxlY3RlZEVkZ2VzIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgdW5zZWxlY3QgPSBldmVudC5rZXkgPT09ICdFc2NhcGUnO1xuICAgICAgICAgICAgaWYgKHVuc2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgZWRnZVJlZi5jdXJyZW50Py5ibHVyKCk7XG4gICAgICAgICAgICAgICAgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzKHsgZWRnZXM6IFtlZGdlXSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZFNlbGVjdGVkRWRnZXMoW2lkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiAoanN4KFwic3ZnXCIsIHsgc3R5bGU6IHsgekluZGV4IH0sIGNoaWxkcmVuOiBqc3hzKFwiZ1wiLCB7IGNsYXNzTmFtZTogY2MoW1xuICAgICAgICAgICAgICAgICdyZWFjdC1mbG93X19lZGdlJyxcbiAgICAgICAgICAgICAgICBgcmVhY3QtZmxvd19fZWRnZS0ke2VkZ2VUeXBlfWAsXG4gICAgICAgICAgICAgICAgZWRnZS5jbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgbm9QYW5DbGFzc05hbWUsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZDogZWRnZS5zZWxlY3RlZCxcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZWQ6IGVkZ2UuYW5pbWF0ZWQsXG4gICAgICAgICAgICAgICAgICAgIGluYWN0aXZlOiAhaXNTZWxlY3RhYmxlICYmICFvbkNsaWNrLFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGluZzogdXBkYXRlSG92ZXIsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGFibGU6IGlzU2VsZWN0YWJsZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSksIG9uQ2xpY2s6IG9uRWRnZUNsaWNrLCBvbkRvdWJsZUNsaWNrOiBvbkVkZ2VEb3VibGVDbGljaywgb25Db250ZXh0TWVudTogb25FZGdlQ29udGV4dE1lbnUsIG9uTW91c2VFbnRlcjogb25FZGdlTW91c2VFbnRlciwgb25Nb3VzZU1vdmU6IG9uRWRnZU1vdXNlTW92ZSwgb25Nb3VzZUxlYXZlOiBvbkVkZ2VNb3VzZUxlYXZlLCBvbktleURvd246IGlzRm9jdXNhYmxlID8gb25LZXlEb3duIDogdW5kZWZpbmVkLCB0YWJJbmRleDogaXNGb2N1c2FibGUgPyAwIDogdW5kZWZpbmVkLCByb2xlOiBlZGdlLmFyaWFSb2xlID8/IChpc0ZvY3VzYWJsZSA/ICdncm91cCcgOiAnaW1nJyksIFwiYXJpYS1yb2xlZGVzY3JpcHRpb25cIjogXCJlZGdlXCIsIFwiZGF0YS1pZFwiOiBpZCwgXCJkYXRhLXRlc3RpZFwiOiBgcmZfX2VkZ2UtJHtpZH1gLCBcImFyaWEtbGFiZWxcIjogZWRnZS5hcmlhTGFiZWwgPT09IG51bGwgPyB1bmRlZmluZWQgOiBlZGdlLmFyaWFMYWJlbCB8fCBgRWRnZSBmcm9tICR7ZWRnZS5zb3VyY2V9IHRvICR7ZWRnZS50YXJnZXR9YCwgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IGlzRm9jdXNhYmxlID8gYCR7QVJJQV9FREdFX0RFU0NfS0VZfS0ke3JmSWR9YCA6IHVuZGVmaW5lZCwgcmVmOiBlZGdlUmVmLCAuLi5lZGdlLmRvbUF0dHJpYnV0ZXMsIGNoaWxkcmVuOiBbIXJlY29ubmVjdGluZyAmJiAoanN4KEVkZ2VDb21wb25lbnQsIHsgaWQ6IGlkLCBzb3VyY2U6IGVkZ2Uuc291cmNlLCB0YXJnZXQ6IGVkZ2UudGFyZ2V0LCB0eXBlOiBlZGdlLnR5cGUsIHNlbGVjdGVkOiBlZGdlLnNlbGVjdGVkLCBhbmltYXRlZDogZWRnZS5hbmltYXRlZCwgc2VsZWN0YWJsZTogaXNTZWxlY3RhYmxlLCBkZWxldGFibGU6IGVkZ2UuZGVsZXRhYmxlID8/IHRydWUsIGxhYmVsOiBlZGdlLmxhYmVsLCBsYWJlbFN0eWxlOiBlZGdlLmxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnOiBlZGdlLmxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGVkZ2UubGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogZWRnZS5sYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1czogZWRnZS5sYWJlbEJnQm9yZGVyUmFkaXVzLCBzb3VyY2VYOiBzb3VyY2VYLCBzb3VyY2VZOiBzb3VyY2VZLCB0YXJnZXRYOiB0YXJnZXRYLCB0YXJnZXRZOiB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbjogc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbiwgZGF0YTogZWRnZS5kYXRhLCBzdHlsZTogZWRnZS5zdHlsZSwgc291cmNlSGFuZGxlSWQ6IGVkZ2Uuc291cmNlSGFuZGxlLCB0YXJnZXRIYW5kbGVJZDogZWRnZS50YXJnZXRIYW5kbGUsIG1hcmtlclN0YXJ0OiBtYXJrZXJTdGFydFVybCwgbWFya2VyRW5kOiBtYXJrZXJFbmRVcmwsIHBhdGhPcHRpb25zOiAncGF0aE9wdGlvbnMnIGluIGVkZ2UgPyBlZGdlLnBhdGhPcHRpb25zIDogdW5kZWZpbmVkLCBpbnRlcmFjdGlvbldpZHRoOiBlZGdlLmludGVyYWN0aW9uV2lkdGggfSkpLCBpc1JlY29ubmVjdGFibGUgJiYgKGpzeChFZGdlVXBkYXRlQW5jaG9ycywgeyBlZGdlOiBlZGdlLCBpc1JlY29ubmVjdGFibGU6IGlzUmVjb25uZWN0YWJsZSwgcmVjb25uZWN0UmFkaXVzOiByZWNvbm5lY3RSYWRpdXMsIG9uUmVjb25uZWN0OiBvblJlY29ubmVjdCwgb25SZWNvbm5lY3RTdGFydDogb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQ6IG9uUmVjb25uZWN0RW5kLCBzb3VyY2VYOiBzb3VyY2VYLCBzb3VyY2VZOiBzb3VyY2VZLCB0YXJnZXRYOiB0YXJnZXRYLCB0YXJnZXRZOiB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbjogc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbiwgc2V0VXBkYXRlSG92ZXI6IHNldFVwZGF0ZUhvdmVyLCBzZXRSZWNvbm5lY3Rpbmc6IHNldFJlY29ubmVjdGluZyB9KSldIH0pIH0pKTtcbn1cbnZhciBFZGdlV3JhcHBlciQxID0gbWVtbyhFZGdlV3JhcHBlcik7XG5cbmNvbnN0IHNlbGVjdG9yJGEgPSAocykgPT4gKHtcbiAgICBlZGdlc0ZvY3VzYWJsZTogcy5lZGdlc0ZvY3VzYWJsZSxcbiAgICBlZGdlc1JlY29ubmVjdGFibGU6IHMuZWRnZXNSZWNvbm5lY3RhYmxlLFxuICAgIGVsZW1lbnRzU2VsZWN0YWJsZTogcy5lbGVtZW50c1NlbGVjdGFibGUsXG4gICAgY29ubmVjdGlvbk1vZGU6IHMuY29ubmVjdGlvbk1vZGUsXG4gICAgb25FcnJvcjogcy5vbkVycm9yLFxufSk7XG5mdW5jdGlvbiBFZGdlUmVuZGVyZXJDb21wb25lbnQoeyBkZWZhdWx0TWFya2VyQ29sb3IsIG9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMsIHJmSWQsIGVkZ2VUeXBlcywgbm9QYW5DbGFzc05hbWUsIG9uUmVjb25uZWN0LCBvbkVkZ2VDb250ZXh0TWVudSwgb25FZGdlTW91c2VFbnRlciwgb25FZGdlTW91c2VNb3ZlLCBvbkVkZ2VNb3VzZUxlYXZlLCBvbkVkZ2VDbGljaywgcmVjb25uZWN0UmFkaXVzLCBvbkVkZ2VEb3VibGVDbGljaywgb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQsIGRpc2FibGVLZXlib2FyZEExMXksIH0pIHtcbiAgICBjb25zdCB7IGVkZ2VzRm9jdXNhYmxlLCBlZGdlc1JlY29ubmVjdGFibGUsIGVsZW1lbnRzU2VsZWN0YWJsZSwgb25FcnJvciB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkYSwgc2hhbGxvdyk7XG4gICAgY29uc3QgZWRnZUlkcyA9IHVzZVZpc2libGVFZGdlSWRzKG9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMpO1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19lZGdlc1wiLCBjaGlsZHJlbjogW2pzeChNYXJrZXJEZWZpbml0aW9ucyQxLCB7IGRlZmF1bHRDb2xvcjogZGVmYXVsdE1hcmtlckNvbG9yLCByZklkOiByZklkIH0pLCBlZGdlSWRzLm1hcCgoaWQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGpzeChFZGdlV3JhcHBlciQxLCB7IGlkOiBpZCwgZWRnZXNGb2N1c2FibGU6IGVkZ2VzRm9jdXNhYmxlLCBlZGdlc1JlY29ubmVjdGFibGU6IGVkZ2VzUmVjb25uZWN0YWJsZSwgZWxlbWVudHNTZWxlY3RhYmxlOiBlbGVtZW50c1NlbGVjdGFibGUsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgb25SZWNvbm5lY3Q6IG9uUmVjb25uZWN0LCBvbkNvbnRleHRNZW51OiBvbkVkZ2VDb250ZXh0TWVudSwgb25Nb3VzZUVudGVyOiBvbkVkZ2VNb3VzZUVudGVyLCBvbk1vdXNlTW92ZTogb25FZGdlTW91c2VNb3ZlLCBvbk1vdXNlTGVhdmU6IG9uRWRnZU1vdXNlTGVhdmUsIG9uQ2xpY2s6IG9uRWRnZUNsaWNrLCByZWNvbm5lY3RSYWRpdXM6IHJlY29ubmVjdFJhZGl1cywgb25Eb3VibGVDbGljazogb25FZGdlRG91YmxlQ2xpY2ssIG9uUmVjb25uZWN0U3RhcnQ6IG9uUmVjb25uZWN0U3RhcnQsIG9uUmVjb25uZWN0RW5kOiBvblJlY29ubmVjdEVuZCwgcmZJZDogcmZJZCwgb25FcnJvcjogb25FcnJvciwgZWRnZVR5cGVzOiBlZGdlVHlwZXMsIGRpc2FibGVLZXlib2FyZEExMXk6IGRpc2FibGVLZXlib2FyZEExMXkgfSwgaWQpKTtcbiAgICAgICAgICAgIH0pXSB9KSk7XG59XG5FZGdlUmVuZGVyZXJDb21wb25lbnQuZGlzcGxheU5hbWUgPSAnRWRnZVJlbmRlcmVyJztcbmNvbnN0IEVkZ2VSZW5kZXJlciA9IG1lbW8oRWRnZVJlbmRlcmVyQ29tcG9uZW50KTtcblxuY29uc3Qgc2VsZWN0b3IkOSA9IChzKSA9PiBgdHJhbnNsYXRlKCR7cy50cmFuc2Zvcm1bMF19cHgsJHtzLnRyYW5zZm9ybVsxXX1weCkgc2NhbGUoJHtzLnRyYW5zZm9ybVsyXX0pYDtcbmZ1bmN0aW9uIFZpZXdwb3J0KHsgY2hpbGRyZW4gfSkge1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHVzZVN0b3JlKHNlbGVjdG9yJDkpO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX3ZpZXdwb3J0IHh5Zmxvd19fdmlld3BvcnQgcmVhY3QtZmxvd19fY29udGFpbmVyXCIsIHN0eWxlOiB7IHRyYW5zZm9ybSB9LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufVxuXG4vKipcbiAqIEhvb2sgZm9yIGNhbGxpbmcgb25Jbml0IGhhbmRsZXIuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZU9uSW5pdEhhbmRsZXIob25Jbml0KSB7XG4gICAgY29uc3QgcmZJbnN0YW5jZSA9IHVzZVJlYWN0RmxvdygpO1xuICAgIGNvbnN0IGlzSW5pdGlhbGl6ZWQgPSB1c2VSZWYoZmFsc2UpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghaXNJbml0aWFsaXplZC5jdXJyZW50ICYmIHJmSW5zdGFuY2Uudmlld3BvcnRJbml0aWFsaXplZCAmJiBvbkluaXQpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gb25Jbml0KHJmSW5zdGFuY2UpLCAxKTtcbiAgICAgICAgICAgIGlzSW5pdGlhbGl6ZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LCBbb25Jbml0LCByZkluc3RhbmNlLnZpZXdwb3J0SW5pdGlhbGl6ZWRdKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkOCA9IChzdGF0ZSkgPT4gc3RhdGUucGFuWm9vbT8uc3luY1ZpZXdwb3J0O1xuLyoqXG4gKiBIb29rIGZvciBzeW5jaW5nIHRoZSB2aWV3cG9ydCB3aXRoIHRoZSBwYW56b29tIGluc3RhbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHZpZXdwb3J0XG4gKi9cbmZ1bmN0aW9uIHVzZVZpZXdwb3J0U3luYyh2aWV3cG9ydCkge1xuICAgIGNvbnN0IHN5bmNWaWV3cG9ydCA9IHVzZVN0b3JlKHNlbGVjdG9yJDgpO1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAodmlld3BvcnQpIHtcbiAgICAgICAgICAgIHN5bmNWaWV3cG9ydD8uKHZpZXdwb3J0KTtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgdHJhbnNmb3JtOiBbdmlld3BvcnQueCwgdmlld3BvcnQueSwgdmlld3BvcnQuem9vbV0gfSk7XG4gICAgICAgIH1cbiAgICB9LCBbdmlld3BvcnQsIHN5bmNWaWV3cG9ydF0pO1xuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBzdG9yZVNlbGVjdG9yJDEocykge1xuICAgIHJldHVybiBzLmNvbm5lY3Rpb24uaW5Qcm9ncmVzc1xuICAgICAgICA/IHsgLi4ucy5jb25uZWN0aW9uLCB0bzogcG9pbnRUb1JlbmRlcmVyUG9pbnQocy5jb25uZWN0aW9uLnRvLCBzLnRyYW5zZm9ybSkgfVxuICAgICAgICA6IHsgLi4ucy5jb25uZWN0aW9uIH07XG59XG5mdW5jdGlvbiBnZXRTZWxlY3Rvcihjb25uZWN0aW9uU2VsZWN0b3IpIHtcbiAgICBpZiAoY29ubmVjdGlvblNlbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IGNvbWJpbmVkU2VsZWN0b3IgPSAocykgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHN0b3JlU2VsZWN0b3IkMShzKTtcbiAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uU2VsZWN0b3IoY29ubmVjdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjb21iaW5lZFNlbGVjdG9yO1xuICAgIH1cbiAgICByZXR1cm4gc3RvcmVTZWxlY3RvciQxO1xufVxuLyoqXG4gKiBUaGUgYHVzZUNvbm5lY3Rpb25gIGhvb2sgcmV0dXJucyB0aGUgY3VycmVudCBjb25uZWN0aW9uIHdoZW4gdGhlcmUgaXMgYW4gYWN0aXZlXG4gKiBjb25uZWN0aW9uIGludGVyYWN0aW9uLiBJZiBubyBjb25uZWN0aW9uIGludGVyYWN0aW9uIGlzIGFjdGl2ZSwgaXQgcmV0dXJucyBudWxsXG4gKiBmb3IgZXZlcnkgcHJvcGVydHkuIEEgdHlwaWNhbCB1c2UgY2FzZSBmb3IgdGhpcyBob29rIGlzIHRvIGNvbG9yaXplIGhhbmRsZXNcbiAqIGJhc2VkIG9uIGEgY2VydGFpbiBjb25kaXRpb24gKGUuZy4gaWYgdGhlIGNvbm5lY3Rpb24gaXMgdmFsaWQgb3Igbm90KS5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gY29ubmVjdGlvblNlbGVjdG9yIC0gQW4gb3B0aW9uYWwgc2VsZWN0b3IgZnVuY3Rpb24gdXNlZCB0byBleHRyYWN0IGEgc2xpY2Ugb2YgdGhlXG4gKiBgQ29ubmVjdGlvblN0YXRlYCBkYXRhLiBVc2luZyBhIHNlbGVjdG9yIGNhbiBwcmV2ZW50IGNvbXBvbmVudCByZS1yZW5kZXJzIHdoZXJlIGRhdGEgeW91IGRvbid0XG4gKiBvdGhlcndpc2UgY2FyZSBhYm91dCBtaWdodCBjaGFuZ2UuIElmIGEgc2VsZWN0b3IgaXMgbm90IHByb3ZpZGVkLCB0aGUgZW50aXJlIGBDb25uZWN0aW9uU3RhdGVgXG4gKiBvYmplY3QgaXMgcmV0dXJuZWQgdW5jaGFuZ2VkLlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c3hcbiAqaW1wb3J0IHsgdXNlQ29ubmVjdGlvbiB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZnVuY3Rpb24gQXBwKCkge1xuICogIGNvbnN0IGNvbm5lY3Rpb24gPSB1c2VDb25uZWN0aW9uKCk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8ZGl2PiB7Y29ubmVjdGlvbiA/IGBTb21lb25lIGlzIHRyeWluZyB0byBtYWtlIGEgY29ubmVjdGlvbiBmcm9tICR7Y29ubmVjdGlvbi5mcm9tTm9kZX0gdG8gdGhpcyBvbmUuYCA6ICdUaGVyZSBhcmUgY3VycmVudGx5IG5vIGluY29taW5nIGNvbm5lY3Rpb25zISd9XG4gKlxuICogICA8L2Rpdj5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEByZXR1cm5zIENvbm5lY3Rpb25TdGF0ZVxuICovXG5mdW5jdGlvbiB1c2VDb25uZWN0aW9uKGNvbm5lY3Rpb25TZWxlY3Rvcikge1xuICAgIGNvbnN0IGNvbWJpbmVkU2VsZWN0b3IgPSBnZXRTZWxlY3Rvcihjb25uZWN0aW9uU2VsZWN0b3IpO1xuICAgIHJldHVybiB1c2VTdG9yZShjb21iaW5lZFNlbGVjdG9yLCBzaGFsbG93KTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkNyA9IChzKSA9PiAoe1xuICAgIG5vZGVzQ29ubmVjdGFibGU6IHMubm9kZXNDb25uZWN0YWJsZSxcbiAgICBpc1ZhbGlkOiBzLmNvbm5lY3Rpb24uaXNWYWxpZCxcbiAgICBpblByb2dyZXNzOiBzLmNvbm5lY3Rpb24uaW5Qcm9ncmVzcyxcbiAgICB3aWR0aDogcy53aWR0aCxcbiAgICBoZWlnaHQ6IHMuaGVpZ2h0LFxufSk7XG5mdW5jdGlvbiBDb25uZWN0aW9uTGluZVdyYXBwZXIoeyBjb250YWluZXJTdHlsZSwgc3R5bGUsIHR5cGUsIGNvbXBvbmVudCwgfSkge1xuICAgIGNvbnN0IHsgbm9kZXNDb25uZWN0YWJsZSwgd2lkdGgsIGhlaWdodCwgaXNWYWxpZCwgaW5Qcm9ncmVzcyB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkNywgc2hhbGxvdyk7XG4gICAgY29uc3QgcmVuZGVyQ29ubmVjdGlvbiA9ICEhKHdpZHRoICYmIG5vZGVzQ29ubmVjdGFibGUgJiYgaW5Qcm9ncmVzcyk7XG4gICAgaWYgKCFyZW5kZXJDb25uZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChcInN2Z1wiLCB7IHN0eWxlOiBjb250YWluZXJTdHlsZSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2Nvbm5lY3Rpb25saW5lIHJlYWN0LWZsb3dfX2NvbnRhaW5lclwiLCBjaGlsZHJlbjoganN4KFwiZ1wiLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19jb25uZWN0aW9uJywgZ2V0Q29ubmVjdGlvblN0YXR1cyhpc1ZhbGlkKV0pLCBjaGlsZHJlbjoganN4KENvbm5lY3Rpb25MaW5lLCB7IHN0eWxlOiBzdHlsZSwgdHlwZTogdHlwZSwgQ3VzdG9tQ29tcG9uZW50OiBjb21wb25lbnQsIGlzVmFsaWQ6IGlzVmFsaWQgfSkgfSkgfSkpO1xufVxuY29uc3QgQ29ubmVjdGlvbkxpbmUgPSAoeyBzdHlsZSwgdHlwZSA9IENvbm5lY3Rpb25MaW5lVHlwZS5CZXppZXIsIEN1c3RvbUNvbXBvbmVudCwgaXNWYWxpZCwgfSkgPT4ge1xuICAgIGNvbnN0IHsgaW5Qcm9ncmVzcywgZnJvbSwgZnJvbU5vZGUsIGZyb21IYW5kbGUsIGZyb21Qb3NpdGlvbiwgdG8sIHRvTm9kZSwgdG9IYW5kbGUsIHRvUG9zaXRpb24gfSA9IHVzZUNvbm5lY3Rpb24oKTtcbiAgICBpZiAoIWluUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoQ3VzdG9tQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiAoanN4KEN1c3RvbUNvbXBvbmVudCwgeyBjb25uZWN0aW9uTGluZVR5cGU6IHR5cGUsIGNvbm5lY3Rpb25MaW5lU3R5bGU6IHN0eWxlLCBmcm9tTm9kZTogZnJvbU5vZGUsIGZyb21IYW5kbGU6IGZyb21IYW5kbGUsIGZyb21YOiBmcm9tLngsIGZyb21ZOiBmcm9tLnksIHRvWDogdG8ueCwgdG9ZOiB0by55LCBmcm9tUG9zaXRpb246IGZyb21Qb3NpdGlvbiwgdG9Qb3NpdGlvbjogdG9Qb3NpdGlvbiwgY29ubmVjdGlvblN0YXR1czogZ2V0Q29ubmVjdGlvblN0YXR1cyhpc1ZhbGlkKSwgdG9Ob2RlOiB0b05vZGUsIHRvSGFuZGxlOiB0b0hhbmRsZSB9KSk7XG4gICAgfVxuICAgIGxldCBwYXRoID0gJyc7XG4gICAgY29uc3QgcGF0aFBhcmFtcyA9IHtcbiAgICAgICAgc291cmNlWDogZnJvbS54LFxuICAgICAgICBzb3VyY2VZOiBmcm9tLnksXG4gICAgICAgIHNvdXJjZVBvc2l0aW9uOiBmcm9tUG9zaXRpb24sXG4gICAgICAgIHRhcmdldFg6IHRvLngsXG4gICAgICAgIHRhcmdldFk6IHRvLnksXG4gICAgICAgIHRhcmdldFBvc2l0aW9uOiB0b1Bvc2l0aW9uLFxuICAgIH07XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgQ29ubmVjdGlvbkxpbmVUeXBlLkJlemllcjpcbiAgICAgICAgICAgIFtwYXRoXSA9IGdldEJlemllclBhdGgocGF0aFBhcmFtcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDb25uZWN0aW9uTGluZVR5cGUuU2ltcGxlQmV6aWVyOlxuICAgICAgICAgICAgW3BhdGhdID0gZ2V0U2ltcGxlQmV6aWVyUGF0aChwYXRoUGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENvbm5lY3Rpb25MaW5lVHlwZS5TdGVwOlxuICAgICAgICAgICAgW3BhdGhdID0gZ2V0U21vb3RoU3RlcFBhdGgoe1xuICAgICAgICAgICAgICAgIC4uLnBhdGhQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDb25uZWN0aW9uTGluZVR5cGUuU21vb3RoU3RlcDpcbiAgICAgICAgICAgIFtwYXRoXSA9IGdldFNtb290aFN0ZXBQYXRoKHBhdGhQYXJhbXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBbcGF0aF0gPSBnZXRTdHJhaWdodFBhdGgocGF0aFBhcmFtcyk7XG4gICAgfVxuICAgIHJldHVybiBqc3goXCJwYXRoXCIsIHsgZDogcGF0aCwgZmlsbDogXCJub25lXCIsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19jb25uZWN0aW9uLXBhdGhcIiwgc3R5bGU6IHN0eWxlIH0pO1xufTtcbkNvbm5lY3Rpb25MaW5lLmRpc3BsYXlOYW1lID0gJ0Nvbm5lY3Rpb25MaW5lJztcblxuY29uc3QgZW1wdHlUeXBlcyA9IHt9O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIHVzZU5vZGVPckVkZ2VUeXBlc1dhcm5pbmcobm9kZU9yRWRnZVR5cGVzID0gZW1wdHlUeXBlcykge1xuICAgIGNvbnN0IHR5cGVzUmVmID0gdXNlUmVmKG5vZGVPckVkZ2VUeXBlcyk7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgY29uc3QgdXNlZEtleXMgPSBuZXcgU2V0KFsuLi5PYmplY3Qua2V5cyh0eXBlc1JlZi5jdXJyZW50KSwgLi4uT2JqZWN0LmtleXMobm9kZU9yRWRnZVR5cGVzKV0pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdXNlZEtleXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZXNSZWYuY3VycmVudFtrZXldICE9PSBub2RlT3JFZGdlVHlwZXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uRXJyb3I/LignMDAyJywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDInXSgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHlwZXNSZWYuY3VycmVudCA9IG5vZGVPckVkZ2VUeXBlcztcbiAgICAgICAgfVxuICAgIH0sIFtub2RlT3JFZGdlVHlwZXNdKTtcbn1cblxuZnVuY3Rpb24gdXNlU3R5bGVzTG9hZGVkV2FybmluZygpIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgY2hlY2tlZCA9IHVzZVJlZihmYWxzZSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICBpZiAoIWNoZWNrZWQuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhbmUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucmVhY3QtZmxvd19fcGFuZScpO1xuICAgICAgICAgICAgICAgIGlmIChwYW5lICYmICEod2luZG93LmdldENvbXB1dGVkU3R5bGUocGFuZSkuekluZGV4ID09PSAnMScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLmdldFN0YXRlKCkub25FcnJvcj8uKCcwMTMnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAxMyddKCdyZWFjdCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hlY2tlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gR3JhcGhWaWV3Q29tcG9uZW50KHsgbm9kZVR5cGVzLCBlZGdlVHlwZXMsIG9uSW5pdCwgb25Ob2RlQ2xpY2ssIG9uRWRnZUNsaWNrLCBvbk5vZGVEb3VibGVDbGljaywgb25FZGdlRG91YmxlQ2xpY2ssIG9uTm9kZU1vdXNlRW50ZXIsIG9uTm9kZU1vdXNlTW92ZSwgb25Ob2RlTW91c2VMZWF2ZSwgb25Ob2RlQ29udGV4dE1lbnUsIG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kLCBjb25uZWN0aW9uTGluZVR5cGUsIGNvbm5lY3Rpb25MaW5lU3R5bGUsIGNvbm5lY3Rpb25MaW5lQ29tcG9uZW50LCBjb25uZWN0aW9uTGluZUNvbnRhaW5lclN0eWxlLCBzZWxlY3Rpb25LZXlDb2RlLCBzZWxlY3Rpb25PbkRyYWcsIHNlbGVjdGlvbk1vZGUsIG11bHRpU2VsZWN0aW9uS2V5Q29kZSwgcGFuQWN0aXZhdGlvbktleUNvZGUsIHpvb21BY3RpdmF0aW9uS2V5Q29kZSwgZGVsZXRlS2V5Q29kZSwgb25seVJlbmRlclZpc2libGVFbGVtZW50cywgZWxlbWVudHNTZWxlY3RhYmxlLCBkZWZhdWx0Vmlld3BvcnQsIHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbSwgbWF4Wm9vbSwgcHJldmVudFNjcm9sbGluZywgZGVmYXVsdE1hcmtlckNvbG9yLCB6b29tT25TY3JvbGwsIHpvb21PblBpbmNoLCBwYW5PblNjcm9sbCwgcGFuT25TY3JvbGxTcGVlZCwgcGFuT25TY3JvbGxNb2RlLCB6b29tT25Eb3VibGVDbGljaywgcGFuT25EcmFnLCBvblBhbmVDbGljaywgb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlLCBvblBhbmVNb3VzZUxlYXZlLCBvblBhbmVTY3JvbGwsIG9uUGFuZUNvbnRleHRNZW51LCBwYW5lQ2xpY2tEaXN0YW5jZSwgbm9kZUNsaWNrRGlzdGFuY2UsIG9uRWRnZUNvbnRleHRNZW51LCBvbkVkZ2VNb3VzZUVudGVyLCBvbkVkZ2VNb3VzZU1vdmUsIG9uRWRnZU1vdXNlTGVhdmUsIHJlY29ubmVjdFJhZGl1cywgb25SZWNvbm5lY3QsIG9uUmVjb25uZWN0U3RhcnQsIG9uUmVjb25uZWN0RW5kLCBub0RyYWdDbGFzc05hbWUsIG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5LCBub2RlRXh0ZW50LCByZklkLCB2aWV3cG9ydCwgb25WaWV3cG9ydENoYW5nZSwgfSkge1xuICAgIHVzZU5vZGVPckVkZ2VUeXBlc1dhcm5pbmcobm9kZVR5cGVzKTtcbiAgICB1c2VOb2RlT3JFZGdlVHlwZXNXYXJuaW5nKGVkZ2VUeXBlcyk7XG4gICAgdXNlU3R5bGVzTG9hZGVkV2FybmluZygpO1xuICAgIHVzZU9uSW5pdEhhbmRsZXIob25Jbml0KTtcbiAgICB1c2VWaWV3cG9ydFN5bmModmlld3BvcnQpO1xuICAgIHJldHVybiAoanN4KEZsb3dSZW5kZXJlciwgeyBvblBhbmVDbGljazogb25QYW5lQ2xpY2ssIG9uUGFuZU1vdXNlRW50ZXI6IG9uUGFuZU1vdXNlRW50ZXIsIG9uUGFuZU1vdXNlTW92ZTogb25QYW5lTW91c2VNb3ZlLCBvblBhbmVNb3VzZUxlYXZlOiBvblBhbmVNb3VzZUxlYXZlLCBvblBhbmVDb250ZXh0TWVudTogb25QYW5lQ29udGV4dE1lbnUsIG9uUGFuZVNjcm9sbDogb25QYW5lU2Nyb2xsLCBwYW5lQ2xpY2tEaXN0YW5jZTogcGFuZUNsaWNrRGlzdGFuY2UsIGRlbGV0ZUtleUNvZGU6IGRlbGV0ZUtleUNvZGUsIHNlbGVjdGlvbktleUNvZGU6IHNlbGVjdGlvbktleUNvZGUsIHNlbGVjdGlvbk9uRHJhZzogc2VsZWN0aW9uT25EcmFnLCBzZWxlY3Rpb25Nb2RlOiBzZWxlY3Rpb25Nb2RlLCBvblNlbGVjdGlvblN0YXJ0OiBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZDogb25TZWxlY3Rpb25FbmQsIG11bHRpU2VsZWN0aW9uS2V5Q29kZTogbXVsdGlTZWxlY3Rpb25LZXlDb2RlLCBwYW5BY3RpdmF0aW9uS2V5Q29kZTogcGFuQWN0aXZhdGlvbktleUNvZGUsIHpvb21BY3RpdmF0aW9uS2V5Q29kZTogem9vbUFjdGl2YXRpb25LZXlDb2RlLCBlbGVtZW50c1NlbGVjdGFibGU6IGVsZW1lbnRzU2VsZWN0YWJsZSwgem9vbU9uU2Nyb2xsOiB6b29tT25TY3JvbGwsIHpvb21PblBpbmNoOiB6b29tT25QaW5jaCwgem9vbU9uRG91YmxlQ2xpY2s6IHpvb21PbkRvdWJsZUNsaWNrLCBwYW5PblNjcm9sbDogcGFuT25TY3JvbGwsIHBhbk9uU2Nyb2xsU3BlZWQ6IHBhbk9uU2Nyb2xsU3BlZWQsIHBhbk9uU2Nyb2xsTW9kZTogcGFuT25TY3JvbGxNb2RlLCBwYW5PbkRyYWc6IHBhbk9uRHJhZywgZGVmYXVsdFZpZXdwb3J0OiBkZWZhdWx0Vmlld3BvcnQsIHRyYW5zbGF0ZUV4dGVudDogdHJhbnNsYXRlRXh0ZW50LCBtaW5ab29tOiBtaW5ab29tLCBtYXhab29tOiBtYXhab29tLCBvblNlbGVjdGlvbkNvbnRleHRNZW51OiBvblNlbGVjdGlvbkNvbnRleHRNZW51LCBwcmV2ZW50U2Nyb2xsaW5nOiBwcmV2ZW50U2Nyb2xsaW5nLCBub0RyYWdDbGFzc05hbWU6IG5vRHJhZ0NsYXNzTmFtZSwgbm9XaGVlbENsYXNzTmFtZTogbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5LCBvblZpZXdwb3J0Q2hhbmdlOiBvblZpZXdwb3J0Q2hhbmdlLCBpc0NvbnRyb2xsZWRWaWV3cG9ydDogISF2aWV3cG9ydCwgY2hpbGRyZW46IGpzeHMoVmlld3BvcnQsIHsgY2hpbGRyZW46IFtqc3goRWRnZVJlbmRlcmVyLCB7IGVkZ2VUeXBlczogZWRnZVR5cGVzLCBvbkVkZ2VDbGljazogb25FZGdlQ2xpY2ssIG9uRWRnZURvdWJsZUNsaWNrOiBvbkVkZ2VEb3VibGVDbGljaywgb25SZWNvbm5lY3Q6IG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0OiBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZDogb25SZWNvbm5lY3RFbmQsIG9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHM6IG9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMsIG9uRWRnZUNvbnRleHRNZW51OiBvbkVkZ2VDb250ZXh0TWVudSwgb25FZGdlTW91c2VFbnRlcjogb25FZGdlTW91c2VFbnRlciwgb25FZGdlTW91c2VNb3ZlOiBvbkVkZ2VNb3VzZU1vdmUsIG9uRWRnZU1vdXNlTGVhdmU6IG9uRWRnZU1vdXNlTGVhdmUsIHJlY29ubmVjdFJhZGl1czogcmVjb25uZWN0UmFkaXVzLCBkZWZhdWx0TWFya2VyQ29sb3I6IGRlZmF1bHRNYXJrZXJDb2xvciwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5LCByZklkOiByZklkIH0pLCBqc3goQ29ubmVjdGlvbkxpbmVXcmFwcGVyLCB7IHN0eWxlOiBjb25uZWN0aW9uTGluZVN0eWxlLCB0eXBlOiBjb25uZWN0aW9uTGluZVR5cGUsIGNvbXBvbmVudDogY29ubmVjdGlvbkxpbmVDb21wb25lbnQsIGNvbnRhaW5lclN0eWxlOiBjb25uZWN0aW9uTGluZUNvbnRhaW5lclN0eWxlIH0pLCBqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fZWRnZWxhYmVsLXJlbmRlcmVyXCIgfSksIGpzeChOb2RlUmVuZGVyZXIsIHsgbm9kZVR5cGVzOiBub2RlVHlwZXMsIG9uTm9kZUNsaWNrOiBvbk5vZGVDbGljaywgb25Ob2RlRG91YmxlQ2xpY2s6IG9uTm9kZURvdWJsZUNsaWNrLCBvbk5vZGVNb3VzZUVudGVyOiBvbk5vZGVNb3VzZUVudGVyLCBvbk5vZGVNb3VzZU1vdmU6IG9uTm9kZU1vdXNlTW92ZSwgb25Ob2RlTW91c2VMZWF2ZTogb25Ob2RlTW91c2VMZWF2ZSwgb25Ob2RlQ29udGV4dE1lbnU6IG9uTm9kZUNvbnRleHRNZW51LCBub2RlQ2xpY2tEaXN0YW5jZTogbm9kZUNsaWNrRGlzdGFuY2UsIG9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHM6IG9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgbm9EcmFnQ2xhc3NOYW1lOiBub0RyYWdDbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXk6IGRpc2FibGVLZXlib2FyZEExMXksIG5vZGVFeHRlbnQ6IG5vZGVFeHRlbnQsIHJmSWQ6IHJmSWQgfSksIGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X192aWV3cG9ydC1wb3J0YWxcIiB9KV0gfSkgfSkpO1xufVxuR3JhcGhWaWV3Q29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ0dyYXBoVmlldyc7XG5jb25zdCBHcmFwaFZpZXcgPSBtZW1vKEdyYXBoVmlld0NvbXBvbmVudCk7XG5cbmNvbnN0IGdldEluaXRpYWxTdGF0ZSA9ICh7IG5vZGVzLCBlZGdlcywgZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXMsIHdpZHRoLCBoZWlnaHQsIGZpdFZpZXcsIGZpdFZpZXdPcHRpb25zLCBtaW5ab29tID0gMC41LCBtYXhab29tID0gMiwgbm9kZU9yaWdpbiwgbm9kZUV4dGVudCwgfSA9IHt9KSA9PiB7XG4gICAgY29uc3Qgbm9kZUxvb2t1cCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBwYXJlbnRMb29rdXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgY29ubmVjdGlvbkxvb2t1cCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBlZGdlTG9va3VwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHN0b3JlRWRnZXMgPSBkZWZhdWx0RWRnZXMgPz8gZWRnZXMgPz8gW107XG4gICAgY29uc3Qgc3RvcmVOb2RlcyA9IGRlZmF1bHROb2RlcyA/PyBub2RlcyA/PyBbXTtcbiAgICBjb25zdCBzdG9yZU5vZGVPcmlnaW4gPSBub2RlT3JpZ2luID8/IFswLCAwXTtcbiAgICBjb25zdCBzdG9yZU5vZGVFeHRlbnQgPSBub2RlRXh0ZW50ID8/IGluZmluaXRlRXh0ZW50O1xuICAgIHVwZGF0ZUNvbm5lY3Rpb25Mb29rdXAoY29ubmVjdGlvbkxvb2t1cCwgZWRnZUxvb2t1cCwgc3RvcmVFZGdlcyk7XG4gICAgY29uc3Qgbm9kZXNJbml0aWFsaXplZCA9IGFkb3B0VXNlck5vZGVzKHN0b3JlTm9kZXMsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwge1xuICAgICAgICBub2RlT3JpZ2luOiBzdG9yZU5vZGVPcmlnaW4sXG4gICAgICAgIG5vZGVFeHRlbnQ6IHN0b3JlTm9kZUV4dGVudCxcbiAgICAgICAgZWxldmF0ZU5vZGVzT25TZWxlY3Q6IGZhbHNlLFxuICAgIH0pO1xuICAgIGxldCB0cmFuc2Zvcm0gPSBbMCwgMCwgMV07XG4gICAgaWYgKGZpdFZpZXcgJiYgd2lkdGggJiYgaGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IGdldEludGVybmFsTm9kZXNCb3VuZHMobm9kZUxvb2t1cCwge1xuICAgICAgICAgICAgZmlsdGVyOiAobm9kZSkgPT4gISEoKG5vZGUud2lkdGggfHwgbm9kZS5pbml0aWFsV2lkdGgpICYmIChub2RlLmhlaWdodCB8fCBub2RlLmluaXRpYWxIZWlnaHQpKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgeCwgeSwgem9vbSB9ID0gZ2V0Vmlld3BvcnRGb3JCb3VuZHMoYm91bmRzLCB3aWR0aCwgaGVpZ2h0LCBtaW5ab29tLCBtYXhab29tLCBmaXRWaWV3T3B0aW9ucz8ucGFkZGluZyA/PyAwLjEpO1xuICAgICAgICB0cmFuc2Zvcm0gPSBbeCwgeSwgem9vbV07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJmSWQ6ICcxJyxcbiAgICAgICAgd2lkdGg6IHdpZHRoID8/IDAsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0ID8/IDAsXG4gICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgbm9kZXM6IHN0b3JlTm9kZXMsXG4gICAgICAgIG5vZGVzSW5pdGlhbGl6ZWQsXG4gICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgIHBhcmVudExvb2t1cCxcbiAgICAgICAgZWRnZXM6IHN0b3JlRWRnZXMsXG4gICAgICAgIGVkZ2VMb29rdXAsXG4gICAgICAgIGNvbm5lY3Rpb25Mb29rdXAsXG4gICAgICAgIG9uTm9kZXNDaGFuZ2U6IG51bGwsXG4gICAgICAgIG9uRWRnZXNDaGFuZ2U6IG51bGwsXG4gICAgICAgIGhhc0RlZmF1bHROb2RlczogZGVmYXVsdE5vZGVzICE9PSB1bmRlZmluZWQsXG4gICAgICAgIGhhc0RlZmF1bHRFZGdlczogZGVmYXVsdEVkZ2VzICE9PSB1bmRlZmluZWQsXG4gICAgICAgIHBhblpvb206IG51bGwsXG4gICAgICAgIG1pblpvb20sXG4gICAgICAgIG1heFpvb20sXG4gICAgICAgIHRyYW5zbGF0ZUV4dGVudDogaW5maW5pdGVFeHRlbnQsXG4gICAgICAgIG5vZGVFeHRlbnQ6IHN0b3JlTm9kZUV4dGVudCxcbiAgICAgICAgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlLFxuICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSxcbiAgICAgICAgdXNlclNlbGVjdGlvblJlY3Q6IG51bGwsXG4gICAgICAgIGNvbm5lY3Rpb25Nb2RlOiBDb25uZWN0aW9uTW9kZS5TdHJpY3QsXG4gICAgICAgIGRvbU5vZGU6IG51bGwsXG4gICAgICAgIHBhbmVEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgIG5vUGFuQ2xhc3NOYW1lOiAnbm9wYW4nLFxuICAgICAgICBub2RlT3JpZ2luOiBzdG9yZU5vZGVPcmlnaW4sXG4gICAgICAgIG5vZGVEcmFnVGhyZXNob2xkOiAxLFxuICAgICAgICBjb25uZWN0aW9uRHJhZ1RocmVzaG9sZDogMSxcbiAgICAgICAgc25hcEdyaWQ6IFsxNSwgMTVdLFxuICAgICAgICBzbmFwVG9HcmlkOiBmYWxzZSxcbiAgICAgICAgbm9kZXNEcmFnZ2FibGU6IHRydWUsXG4gICAgICAgIG5vZGVzQ29ubmVjdGFibGU6IHRydWUsXG4gICAgICAgIG5vZGVzRm9jdXNhYmxlOiB0cnVlLFxuICAgICAgICBlZGdlc0ZvY3VzYWJsZTogdHJ1ZSxcbiAgICAgICAgZWRnZXNSZWNvbm5lY3RhYmxlOiB0cnVlLFxuICAgICAgICBlbGVtZW50c1NlbGVjdGFibGU6IHRydWUsXG4gICAgICAgIGVsZXZhdGVOb2Rlc09uU2VsZWN0OiB0cnVlLFxuICAgICAgICBlbGV2YXRlRWRnZXNPblNlbGVjdDogZmFsc2UsXG4gICAgICAgIHNlbGVjdE5vZGVzT25EcmFnOiB0cnVlLFxuICAgICAgICBtdWx0aVNlbGVjdGlvbkFjdGl2ZTogZmFsc2UsXG4gICAgICAgIGZpdFZpZXdRdWV1ZWQ6IGZpdFZpZXcgPz8gZmFsc2UsXG4gICAgICAgIGZpdFZpZXdPcHRpb25zLFxuICAgICAgICBmaXRWaWV3UmVzb2x2ZXI6IG51bGwsXG4gICAgICAgIGNvbm5lY3Rpb246IHsgLi4uaW5pdGlhbENvbm5lY3Rpb24gfSxcbiAgICAgICAgY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGU6IG51bGwsXG4gICAgICAgIGNvbm5lY3RPbkNsaWNrOiB0cnVlLFxuICAgICAgICBhcmlhTGl2ZU1lc3NhZ2U6ICcnLFxuICAgICAgICBhdXRvUGFuT25Db25uZWN0OiB0cnVlLFxuICAgICAgICBhdXRvUGFuT25Ob2RlRHJhZzogdHJ1ZSxcbiAgICAgICAgYXV0b1Bhbk9uTm9kZUZvY3VzOiB0cnVlLFxuICAgICAgICBhdXRvUGFuU3BlZWQ6IDE1LFxuICAgICAgICBjb25uZWN0aW9uUmFkaXVzOiAyMCxcbiAgICAgICAgb25FcnJvcjogZGV2V2FybixcbiAgICAgICAgaXNWYWxpZENvbm5lY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgICAgb25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVyczogW10sXG4gICAgICAgIGxpYjogJ3JlYWN0JyxcbiAgICAgICAgZGVidWc6IGZhbHNlLFxuICAgICAgICBhcmlhTGFiZWxDb25maWc6IGRlZmF1bHRBcmlhTGFiZWxDb25maWcsXG4gICAgfTtcbn07XG5cbmNvbnN0IGNyZWF0ZVN0b3JlID0gKHsgbm9kZXMsIGVkZ2VzLCBkZWZhdWx0Tm9kZXMsIGRlZmF1bHRFZGdlcywgd2lkdGgsIGhlaWdodCwgZml0VmlldywgZml0Vmlld09wdGlvbnMsIG1pblpvb20sIG1heFpvb20sIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQsIH0pID0+IGNyZWF0ZVdpdGhFcXVhbGl0eUZuKChzZXQsIGdldCkgPT4ge1xuICAgIGFzeW5jIGZ1bmN0aW9uIHJlc29sdmVGaXRWaWV3KCkge1xuICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIHBhblpvb20sIGZpdFZpZXdPcHRpb25zLCBmaXRWaWV3UmVzb2x2ZXIsIHdpZHRoLCBoZWlnaHQsIG1pblpvb20sIG1heFpvb20gfSA9IGdldCgpO1xuICAgICAgICBpZiAoIXBhblpvb20pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBmaXRWaWV3cG9ydCh7XG4gICAgICAgICAgICBub2Rlczogbm9kZUxvb2t1cCxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgcGFuWm9vbSxcbiAgICAgICAgICAgIG1pblpvb20sXG4gICAgICAgICAgICBtYXhab29tLFxuICAgICAgICB9LCBmaXRWaWV3T3B0aW9ucyk7XG4gICAgICAgIGZpdFZpZXdSZXNvbHZlcj8ucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHdhaXQgZm9yIHRoZSBmaXRWaWV3cG9ydCB0byByZXNvbHZlIGJlZm9yZSBkZWxldGluZyB0aGUgcmVzb2x2ZXIsXG4gICAgICAgICAqIHdlIHdhbnQgdG8gcmV1c2UgdGhlIG9sZCByZXNvbHZlciBpZiB0aGUgdXNlciBjYWxscyBmaXRWaWV3IGFnYWluIGluIHRoZSBtZWFuIHRpbWVcbiAgICAgICAgICovXG4gICAgICAgIHNldCh7IGZpdFZpZXdSZXNvbHZlcjogbnVsbCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZ2V0SW5pdGlhbFN0YXRlKHtcbiAgICAgICAgICAgIG5vZGVzLFxuICAgICAgICAgICAgZWRnZXMsXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIGZpdFZpZXcsXG4gICAgICAgICAgICBmaXRWaWV3T3B0aW9ucyxcbiAgICAgICAgICAgIG1pblpvb20sXG4gICAgICAgICAgICBtYXhab29tLFxuICAgICAgICAgICAgbm9kZU9yaWdpbixcbiAgICAgICAgICAgIG5vZGVFeHRlbnQsXG4gICAgICAgICAgICBkZWZhdWx0Tm9kZXMsXG4gICAgICAgICAgICBkZWZhdWx0RWRnZXMsXG4gICAgICAgIH0pLFxuICAgICAgICBzZXROb2RlczogKG5vZGVzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgbm9kZU9yaWdpbiwgZWxldmF0ZU5vZGVzT25TZWxlY3QsIGZpdFZpZXdRdWV1ZWQgfSA9IGdldCgpO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIHNldE5vZGVzKCkgaXMgY2FsbGVkIGV4Y2x1c2l2ZWx5IGluIHJlc3BvbnNlIHRvIHVzZXIgYWN0aW9uczpcbiAgICAgICAgICAgICAqIC0gZWl0aGVyIHdoZW4gdGhlIGA8UmVhY3RGbG93IG5vZGVzPmAgcHJvcCBpcyB1cGRhdGVkIGluIHRoZSBjb250cm9sbGVkIFJlYWN0RmxvdyBzZXR1cCxcbiAgICAgICAgICAgICAqIC0gb3Igd2hlbiB0aGUgdXNlciBjYWxscyBzb21ldGhpbmcgbGlrZSBgcmVhY3RGbG93SW5zdGFuY2Uuc2V0Tm9kZXMoKWAgaW4gYW4gdW5jb250cm9sbGVkIFJlYWN0RmxvdyBzZXR1cC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBXaGVuIHRoaXMgaGFwcGVucywgd2UgdGFrZSB0aGUgbm90ZSBvYmplY3RzIHBhc3NlZCBieSB0aGUgdXNlciBhbmQgZXh0ZW5kIHRoZW0gd2l0aCBmaWVsZHNcbiAgICAgICAgICAgICAqIHJlbGV2YW50IGZvciBpbnRlcm5hbCBSZWFjdCBGbG93IG9wZXJhdGlvbnMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IG5vZGVzSW5pdGlhbGl6ZWQgPSBhZG9wdFVzZXJOb2Rlcyhub2Rlcywgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCB7XG4gICAgICAgICAgICAgICAgbm9kZU9yaWdpbixcbiAgICAgICAgICAgICAgICBub2RlRXh0ZW50LFxuICAgICAgICAgICAgICAgIGVsZXZhdGVOb2Rlc09uU2VsZWN0LFxuICAgICAgICAgICAgICAgIGNoZWNrRXF1YWxpdHk6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChmaXRWaWV3UXVldWVkICYmIG5vZGVzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlRml0VmlldygpO1xuICAgICAgICAgICAgICAgIHNldCh7IG5vZGVzLCBub2Rlc0luaXRpYWxpemVkLCBmaXRWaWV3UXVldWVkOiBmYWxzZSwgZml0Vmlld09wdGlvbnM6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldCh7IG5vZGVzLCBub2Rlc0luaXRpYWxpemVkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXRFZGdlczogKGVkZ2VzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGNvbm5lY3Rpb25Mb29rdXAsIGVkZ2VMb29rdXAgfSA9IGdldCgpO1xuICAgICAgICAgICAgdXBkYXRlQ29ubmVjdGlvbkxvb2t1cChjb25uZWN0aW9uTG9va3VwLCBlZGdlTG9va3VwLCBlZGdlcyk7XG4gICAgICAgICAgICBzZXQoeyBlZGdlcyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0RGVmYXVsdE5vZGVzQW5kRWRnZXM6IChub2RlcywgZWRnZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChub2Rlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2V0Tm9kZXMgfSA9IGdldCgpO1xuICAgICAgICAgICAgICAgIHNldE5vZGVzKG5vZGVzKTtcbiAgICAgICAgICAgICAgICBzZXQoeyBoYXNEZWZhdWx0Tm9kZXM6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWRnZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNldEVkZ2VzIH0gPSBnZXQoKTtcbiAgICAgICAgICAgICAgICBzZXRFZGdlcyhlZGdlcyk7XG4gICAgICAgICAgICAgICAgc2V0KHsgaGFzRGVmYXVsdEVkZ2VzOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKlxuICAgICAgICAgKiBFdmVyeSBub2RlIGdldHMgcmVnaXN0ZXJkIGF0IGEgUmVzaXplT2JzZXJ2ZXIuIFdoZW5ldmVyIGEgbm9kZVxuICAgICAgICAgKiBjaGFuZ2VzIGl0cyBkaW1lbnNpb25zLCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB0byBtZWFzdXJlIHRoZVxuICAgICAgICAgKiBuZXcgZGltZW5zaW9ucyBhbmQgdXBkYXRlIHRoZSBub2Rlcy5cbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZU5vZGVJbnRlcm5hbHM6ICh1cGRhdGVzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHRyaWdnZXJOb2RlQ2hhbmdlcywgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBkb21Ob2RlLCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCBkZWJ1ZywgZml0Vmlld1F1ZXVlZCB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBjb25zdCB7IGNoYW5nZXMsIHVwZGF0ZWRJbnRlcm5hbHMgfSA9IHVwZGF0ZU5vZGVJbnRlcm5hbHModXBkYXRlcywgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBkb21Ob2RlLCBub2RlT3JpZ2luLCBub2RlRXh0ZW50KTtcbiAgICAgICAgICAgIGlmICghdXBkYXRlZEludGVybmFscykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZUFic29sdXRlUG9zaXRpb25zKG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgeyBub2RlT3JpZ2luLCBub2RlRXh0ZW50IH0pO1xuICAgICAgICAgICAgaWYgKGZpdFZpZXdRdWV1ZWQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlRml0VmlldygpO1xuICAgICAgICAgICAgICAgIHNldCh7IGZpdFZpZXdRdWV1ZWQ6IGZhbHNlLCBmaXRWaWV3T3B0aW9uczogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgYWx3YXlzIHdhbnQgdG8gdHJpZ2dlciB1c2VTdG9yZSBjYWxscyB3aGVuZXZlciB1cGRhdGVOb2RlSW50ZXJuYWxzIGlzIGNhbGxlZFxuICAgICAgICAgICAgICAgIHNldCh7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhbmdlcz8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUmVhY3QgRmxvdzogdHJpZ2dlciBub2RlIGNoYW5nZXMnLCBjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzPy4oY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZU5vZGVQb3NpdGlvbnM6IChub2RlRHJhZ0l0ZW1zLCBkcmFnZ2luZyA9IGZhbHNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRFeHBhbmRDaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCB0cmlnZ2VyTm9kZUNoYW5nZXMgfSA9IGdldCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaWQsIGRyYWdJdGVtXSBvZiBub2RlRHJhZ0l0ZW1zKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgYXJlIHVzaW5nIHRoZSBub2RlbG9va3VwIHRvIGJlIHN1cmUgdG8gdXNlIHRoZSBjdXJyZW50IGV4cGFuZFBhcmVudCBhbmQgcGFyZW50SWQgdmFsdWVcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cGFuZFBhcmVudCA9ICEhKG5vZGU/LmV4cGFuZFBhcmVudCAmJiBub2RlPy5wYXJlbnRJZCAmJiBkcmFnSXRlbT8ucG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwb3NpdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHBhbmRQYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IE1hdGgubWF4KDAsIGRyYWdJdGVtLnBvc2l0aW9uLngpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IE1hdGgubWF4KDAsIGRyYWdJdGVtLnBvc2l0aW9uLnkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBkcmFnSXRlbS5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dpbmcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwYW5kUGFyZW50ICYmIG5vZGUucGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RXhwYW5kQ2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiBub2RlLnBhcmVudElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmRyYWdJdGVtLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBkcmFnSXRlbS5tZWFzdXJlZC53aWR0aCA/PyAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogZHJhZ0l0ZW0ubWVhc3VyZWQuaGVpZ2h0ID8/IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKGNoYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyZW50RXhwYW5kQ2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGFyZW50TG9va3VwLCBub2RlT3JpZ2luIH0gPSBnZXQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRFeHBhbmRDaGFuZ2VzID0gaGFuZGxlRXhwYW5kUGFyZW50KHBhcmVudEV4cGFuZENoaWxkcmVuLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG5vZGVPcmlnaW4pO1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCguLi5wYXJlbnRFeHBhbmRDaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWdnZXJOb2RlQ2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzOiAoY2hhbmdlcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvbk5vZGVzQ2hhbmdlLCBzZXROb2Rlcywgbm9kZXMsIGhhc0RlZmF1bHROb2RlcywgZGVidWcgfSA9IGdldCgpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZXM/Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChoYXNEZWZhdWx0Tm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZE5vZGVzID0gYXBwbHlOb2RlQ2hhbmdlcyhjaGFuZ2VzLCBub2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgIHNldE5vZGVzKHVwZGF0ZWROb2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUmVhY3QgRmxvdzogdHJpZ2dlciBub2RlIGNoYW5nZXMnLCBjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb25Ob2Rlc0NoYW5nZT8uKGNoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0cmlnZ2VyRWRnZUNoYW5nZXM6IChjaGFuZ2VzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG9uRWRnZXNDaGFuZ2UsIHNldEVkZ2VzLCBlZGdlcywgaGFzRGVmYXVsdEVkZ2VzLCBkZWJ1ZyB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0RlZmF1bHRFZGdlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkRWRnZXMgPSBhcHBseUVkZ2VDaGFuZ2VzKGNoYW5nZXMsIGVkZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0RWRnZXModXBkYXRlZEVkZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWFjdCBGbG93OiB0cmlnZ2VyIGVkZ2UgY2hhbmdlcycsIGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvbkVkZ2VzQ2hhbmdlPy4oY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFkZFNlbGVjdGVkTm9kZXM6IChzZWxlY3RlZE5vZGVJZHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbXVsdGlTZWxlY3Rpb25BY3RpdmUsIGVkZ2VMb29rdXAsIG5vZGVMb29rdXAsIHRyaWdnZXJOb2RlQ2hhbmdlcywgdHJpZ2dlckVkZ2VDaGFuZ2VzIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGlmIChtdWx0aVNlbGVjdGlvbkFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVDaGFuZ2VzID0gc2VsZWN0ZWROb2RlSWRzLm1hcCgobm9kZUlkKSA9PiBjcmVhdGVTZWxlY3Rpb25DaGFuZ2Uobm9kZUlkLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKG5vZGVDaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMoZ2V0U2VsZWN0aW9uQ2hhbmdlcyhub2RlTG9va3VwLCBuZXcgU2V0KFsuLi5zZWxlY3RlZE5vZGVJZHNdKSwgdHJ1ZSkpO1xuICAgICAgICAgICAgdHJpZ2dlckVkZ2VDaGFuZ2VzKGdldFNlbGVjdGlvbkNoYW5nZXMoZWRnZUxvb2t1cCkpO1xuICAgICAgICB9LFxuICAgICAgICBhZGRTZWxlY3RlZEVkZ2VzOiAoc2VsZWN0ZWRFZGdlSWRzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG11bHRpU2VsZWN0aW9uQWN0aXZlLCBlZGdlTG9va3VwLCBub2RlTG9va3VwLCB0cmlnZ2VyTm9kZUNoYW5nZXMsIHRyaWdnZXJFZGdlQ2hhbmdlcyB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBpZiAobXVsdGlTZWxlY3Rpb25BY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VkRWRnZXMgPSBzZWxlY3RlZEVkZ2VJZHMubWFwKChlZGdlSWQpID0+IGNyZWF0ZVNlbGVjdGlvbkNoYW5nZShlZGdlSWQsIHRydWUpKTtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRWRnZUNoYW5nZXMoY2hhbmdlZEVkZ2VzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyRWRnZUNoYW5nZXMoZ2V0U2VsZWN0aW9uQ2hhbmdlcyhlZGdlTG9va3VwLCBuZXcgU2V0KFsuLi5zZWxlY3RlZEVkZ2VJZHNdKSkpO1xuICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKGdldFNlbGVjdGlvbkNoYW5nZXMobm9kZUxvb2t1cCwgbmV3IFNldCgpLCB0cnVlKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVuc2VsZWN0Tm9kZXNBbmRFZGdlczogKHsgbm9kZXMsIGVkZ2VzIH0gPSB7fSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBlZGdlczogc3RvcmVFZGdlcywgbm9kZXM6IHN0b3JlTm9kZXMsIG5vZGVMb29rdXAsIHRyaWdnZXJOb2RlQ2hhbmdlcywgdHJpZ2dlckVkZ2VDaGFuZ2VzIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzVG9VbnNlbGVjdCA9IG5vZGVzID8gbm9kZXMgOiBzdG9yZU5vZGVzO1xuICAgICAgICAgICAgY29uc3QgZWRnZXNUb1Vuc2VsZWN0ID0gZWRnZXMgPyBlZGdlcyA6IHN0b3JlRWRnZXM7XG4gICAgICAgICAgICBjb25zdCBub2RlQ2hhbmdlcyA9IG5vZGVzVG9VbnNlbGVjdC5tYXAoKG4pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlcm5hbE5vZGUgPSBub2RlTG9va3VwLmdldChuLmlkKTtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAqIHdlIG5lZWQgdG8gdW5zZWxlY3QgdGhlIGludGVybmFsIG5vZGUgdGhhdCB3YXMgc2VsZWN0ZWQgcHJldmlvdXNseSBiZWZvcmUgd2VcbiAgICAgICAgICAgICAgICAgICAgICogc2VuZCB0aGUgY2hhbmdlIHRvIHRoZSB1c2VyIHRvIHByZXZlbnQgaXQgdG8gYmUgc2VsZWN0ZWQgd2hpbGUgZHJhZ2dpbmcgdGhlIG5ldyBub2RlXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbE5vZGUuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVNlbGVjdGlvbkNoYW5nZShuLmlkLCBmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGVkZ2VDaGFuZ2VzID0gZWRnZXNUb1Vuc2VsZWN0Lm1hcCgoZWRnZSkgPT4gY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKGVkZ2UuaWQsIGZhbHNlKSk7XG4gICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMobm9kZUNoYW5nZXMpO1xuICAgICAgICAgICAgdHJpZ2dlckVkZ2VDaGFuZ2VzKGVkZ2VDaGFuZ2VzKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0TWluWm9vbTogKG1pblpvb20pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGFuWm9vbSwgbWF4Wm9vbSB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBwYW5ab29tPy5zZXRTY2FsZUV4dGVudChbbWluWm9vbSwgbWF4Wm9vbV0pO1xuICAgICAgICAgICAgc2V0KHsgbWluWm9vbSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0TWF4Wm9vbTogKG1heFpvb20pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGFuWm9vbSwgbWluWm9vbSB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBwYW5ab29tPy5zZXRTY2FsZUV4dGVudChbbWluWm9vbSwgbWF4Wm9vbV0pO1xuICAgICAgICAgICAgc2V0KHsgbWF4Wm9vbSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0VHJhbnNsYXRlRXh0ZW50OiAodHJhbnNsYXRlRXh0ZW50KSA9PiB7XG4gICAgICAgICAgICBnZXQoKS5wYW5ab29tPy5zZXRUcmFuc2xhdGVFeHRlbnQodHJhbnNsYXRlRXh0ZW50KTtcbiAgICAgICAgICAgIHNldCh7IHRyYW5zbGF0ZUV4dGVudCB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0UGFuZUNsaWNrRGlzdGFuY2U6IChjbGlja0Rpc3RhbmNlKSA9PiB7XG4gICAgICAgICAgICBnZXQoKS5wYW5ab29tPy5zZXRDbGlja0Rpc3RhbmNlKGNsaWNrRGlzdGFuY2UpO1xuICAgICAgICB9LFxuICAgICAgICByZXNldFNlbGVjdGVkRWxlbWVudHM6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZWRnZXMsIG5vZGVzLCB0cmlnZ2VyTm9kZUNoYW5nZXMsIHRyaWdnZXJFZGdlQ2hhbmdlcywgZWxlbWVudHNTZWxlY3RhYmxlIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGlmICghZWxlbWVudHNTZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm9kZUNoYW5nZXMgPSBub2Rlcy5yZWR1Y2UoKHJlcywgbm9kZSkgPT4gKG5vZGUuc2VsZWN0ZWQgPyBbLi4ucmVzLCBjcmVhdGVTZWxlY3Rpb25DaGFuZ2Uobm9kZS5pZCwgZmFsc2UpXSA6IHJlcyksIFtdKTtcbiAgICAgICAgICAgIGNvbnN0IGVkZ2VDaGFuZ2VzID0gZWRnZXMucmVkdWNlKChyZXMsIGVkZ2UpID0+IChlZGdlLnNlbGVjdGVkID8gWy4uLnJlcywgY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKGVkZ2UuaWQsIGZhbHNlKV0gOiByZXMpLCBbXSk7XG4gICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMobm9kZUNoYW5nZXMpO1xuICAgICAgICAgICAgdHJpZ2dlckVkZ2VDaGFuZ2VzKGVkZ2VDaGFuZ2VzKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0Tm9kZUV4dGVudDogKG5leHROb2RlRXh0ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG5vZGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG5vZGVPcmlnaW4sIGVsZXZhdGVOb2Rlc09uU2VsZWN0LCBub2RlRXh0ZW50IH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGlmIChuZXh0Tm9kZUV4dGVudFswXVswXSA9PT0gbm9kZUV4dGVudFswXVswXSAmJlxuICAgICAgICAgICAgICAgIG5leHROb2RlRXh0ZW50WzBdWzFdID09PSBub2RlRXh0ZW50WzBdWzFdICYmXG4gICAgICAgICAgICAgICAgbmV4dE5vZGVFeHRlbnRbMV1bMF0gPT09IG5vZGVFeHRlbnRbMV1bMF0gJiZcbiAgICAgICAgICAgICAgICBuZXh0Tm9kZUV4dGVudFsxXVsxXSA9PT0gbm9kZUV4dGVudFsxXVsxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkb3B0VXNlck5vZGVzKG5vZGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIHtcbiAgICAgICAgICAgICAgICBub2RlT3JpZ2luLFxuICAgICAgICAgICAgICAgIG5vZGVFeHRlbnQ6IG5leHROb2RlRXh0ZW50LFxuICAgICAgICAgICAgICAgIGVsZXZhdGVOb2Rlc09uU2VsZWN0LFxuICAgICAgICAgICAgICAgIGNoZWNrRXF1YWxpdHk6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXQoeyBub2RlRXh0ZW50OiBuZXh0Tm9kZUV4dGVudCB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFuQnk6IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm0sIHdpZHRoLCBoZWlnaHQsIHBhblpvb20sIHRyYW5zbGF0ZUV4dGVudCB9ID0gZ2V0KCk7XG4gICAgICAgICAgICByZXR1cm4gcGFuQnkoeyBkZWx0YSwgcGFuWm9vbSwgdHJhbnNmb3JtLCB0cmFuc2xhdGVFeHRlbnQsIHdpZHRoLCBoZWlnaHQgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldENlbnRlcjogYXN5bmMgKHgsIHksIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgbWF4Wm9vbSwgcGFuWm9vbSB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBpZiAoIXBhblpvb20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5leHRab29tID0gdHlwZW9mIG9wdGlvbnM/Lnpvb20gIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy56b29tIDogbWF4Wm9vbTtcbiAgICAgICAgICAgIGF3YWl0IHBhblpvb20uc2V0Vmlld3BvcnQoe1xuICAgICAgICAgICAgICAgIHg6IHdpZHRoIC8gMiAtIHggKiBuZXh0Wm9vbSxcbiAgICAgICAgICAgICAgICB5OiBoZWlnaHQgLyAyIC0geSAqIG5leHRab29tLFxuICAgICAgICAgICAgICAgIHpvb206IG5leHRab29tLFxuICAgICAgICAgICAgfSwgeyBkdXJhdGlvbjogb3B0aW9ucz8uZHVyYXRpb24sIGVhc2U6IG9wdGlvbnM/LmVhc2UsIGludGVycG9sYXRlOiBvcHRpb25zPy5pbnRlcnBvbGF0ZSB9KTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNhbmNlbENvbm5lY3Rpb246ICgpID0+IHtcbiAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbjogeyAuLi5pbml0aWFsQ29ubmVjdGlvbiB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZUNvbm5lY3Rpb246IChjb25uZWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBzZXQoeyBjb25uZWN0aW9uIH0pO1xuICAgICAgICB9LFxuICAgICAgICByZXNldDogKCkgPT4gc2V0KHsgLi4uZ2V0SW5pdGlhbFN0YXRlKCkgfSksXG4gICAgfTtcbn0sIE9iamVjdC5pcyk7XG5cbi8qKlxuICogVGhlIGA8UmVhY3RGbG93UHJvdmlkZXIgLz5gIGNvbXBvbmVudCBpcyBhIFtjb250ZXh0IHByb3ZpZGVyXShodHRwczovL3JlYWN0LmRldi9sZWFybi9wYXNzaW5nLWRhdGEtZGVlcGx5LXdpdGgtY29udGV4dCMpXG4gKiB0aGF0IG1ha2VzIGl0IHBvc3NpYmxlIHRvIGFjY2VzcyBhIGZsb3cncyBpbnRlcm5hbCBzdGF0ZSBvdXRzaWRlIG9mIHRoZVxuICogW2A8UmVhY3RGbG93IC8+YF0oL2FwaS1yZWZlcmVuY2UvcmVhY3QtZmxvdykgY29tcG9uZW50LiBNYW55IG9mIHRoZSBob29rcyB3ZVxuICogcHJvdmlkZSByZWx5IG9uIHRoaXMgY29tcG9uZW50IHRvIHdvcmsuXG4gKiBAcHVibGljXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICppbXBvcnQgeyBSZWFjdEZsb3csIFJlYWN0Rmxvd1Byb3ZpZGVyLCB1c2VOb2RlcyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnXG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93UHJvdmlkZXI+XG4gKiAgICAgIDxSZWFjdEZsb3cgbm9kZXM9ey4uLn0gZWRnZXM9ey4uLn0gLz5cbiAqICAgICAgPFNpZGViYXIgLz5cbiAqICAgIDwvUmVhY3RGbG93UHJvdmlkZXI+XG4gKiAgKTtcbiAqfVxuICpcbiAqZnVuY3Rpb24gU2lkZWJhcigpIHtcbiAqICAvLyBUaGlzIGhvb2sgd2lsbCBvbmx5IHdvcmsgaWYgdGhlIGNvbXBvbmVudCBpdCdzIHVzZWQgaW4gaXMgYSBjaGlsZCBvZiBhXG4gKiAgLy8gPFJlYWN0Rmxvd1Byb3ZpZGVyIC8+LlxuICogIGNvbnN0IG5vZGVzID0gdXNlTm9kZXMoKVxuICpcbiAqICByZXR1cm4gPGFzaWRlPmRvIHNvbWV0aGluZyB3aXRoIG5vZGVzPC9hc2lkZT47XG4gKn1cbiAqYGBgXG4gKlxuICogQHJlbWFya3MgSWYgeW91J3JlIHVzaW5nIGEgcm91dGVyIGFuZCB3YW50IHlvdXIgZmxvdydzIHN0YXRlIHRvIHBlcnNpc3QgYWNyb3NzIHJvdXRlcyxcbiAqIGl0J3Mgdml0YWwgdGhhdCB5b3UgcGxhY2UgdGhlIGA8UmVhY3RGbG93UHJvdmlkZXIgLz5gIGNvbXBvbmVudCBfb3V0c2lkZV8gb2ZcbiAqIHlvdXIgcm91dGVyLiBJZiB5b3UgaGF2ZSBtdWx0aXBsZSBmbG93cyBvbiB0aGUgc2FtZSBwYWdlIHlvdSB3aWxsIG5lZWQgdG8gdXNlIGEgc2VwYXJhdGVcbiAqIGA8UmVhY3RGbG93UHJvdmlkZXIgLz5gIGZvciBlYWNoIGZsb3cuXG4gKi9cbmZ1bmN0aW9uIFJlYWN0Rmxvd1Byb3ZpZGVyKHsgaW5pdGlhbE5vZGVzOiBub2RlcywgaW5pdGlhbEVkZ2VzOiBlZGdlcywgZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXMsIGluaXRpYWxXaWR0aDogd2lkdGgsIGluaXRpYWxIZWlnaHQ6IGhlaWdodCwgaW5pdGlhbE1pblpvb206IG1pblpvb20sIGluaXRpYWxNYXhab29tOiBtYXhab29tLCBpbml0aWFsRml0Vmlld09wdGlvbnM6IGZpdFZpZXdPcHRpb25zLCBmaXRWaWV3LCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCBjaGlsZHJlbiwgfSkge1xuICAgIGNvbnN0IFtzdG9yZV0gPSB1c2VTdGF0ZSgoKSA9PiBjcmVhdGVTdG9yZSh7XG4gICAgICAgIG5vZGVzLFxuICAgICAgICBlZGdlcyxcbiAgICAgICAgZGVmYXVsdE5vZGVzLFxuICAgICAgICBkZWZhdWx0RWRnZXMsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGZpdFZpZXcsXG4gICAgICAgIG1pblpvb20sXG4gICAgICAgIG1heFpvb20sXG4gICAgICAgIGZpdFZpZXdPcHRpb25zLFxuICAgICAgICBub2RlT3JpZ2luLFxuICAgICAgICBub2RlRXh0ZW50LFxuICAgIH0pKTtcbiAgICByZXR1cm4gKGpzeChQcm92aWRlciQxLCB7IHZhbHVlOiBzdG9yZSwgY2hpbGRyZW46IGpzeChCYXRjaFByb3ZpZGVyLCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KSB9KSk7XG59XG5cbmZ1bmN0aW9uIFdyYXBwZXIoeyBjaGlsZHJlbiwgbm9kZXMsIGVkZ2VzLCBkZWZhdWx0Tm9kZXMsIGRlZmF1bHRFZGdlcywgd2lkdGgsIGhlaWdodCwgZml0VmlldywgZml0Vmlld09wdGlvbnMsIG1pblpvb20sIG1heFpvb20sIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQsIH0pIHtcbiAgICBjb25zdCBpc1dyYXBwZWQgPSB1c2VDb250ZXh0KFN0b3JlQ29udGV4dCk7XG4gICAgaWYgKGlzV3JhcHBlZCkge1xuICAgICAgICAvKlxuICAgICAgICAgKiB3ZSBuZWVkIHRvIHdyYXAgaXQgd2l0aCBhIGZyYWdtZW50IGJlY2F1c2UgaXQncyBub3QgYWxsb3dlZCBmb3IgY2hpbGRyZW4gdG8gYmUgYSBSZWFjdE5vZGVcbiAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL0RlZmluaXRlbHlUeXBlZC9EZWZpbml0ZWx5VHlwZWQvaXNzdWVzLzE4MDUxXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4ganN4KEZyYWdtZW50LCB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goUmVhY3RGbG93UHJvdmlkZXIsIHsgaW5pdGlhbE5vZGVzOiBub2RlcywgaW5pdGlhbEVkZ2VzOiBlZGdlcywgZGVmYXVsdE5vZGVzOiBkZWZhdWx0Tm9kZXMsIGRlZmF1bHRFZGdlczogZGVmYXVsdEVkZ2VzLCBpbml0aWFsV2lkdGg6IHdpZHRoLCBpbml0aWFsSGVpZ2h0OiBoZWlnaHQsIGZpdFZpZXc6IGZpdFZpZXcsIGluaXRpYWxGaXRWaWV3T3B0aW9uczogZml0Vmlld09wdGlvbnMsIGluaXRpYWxNaW5ab29tOiBtaW5ab29tLCBpbml0aWFsTWF4Wm9vbTogbWF4Wm9vbSwgbm9kZU9yaWdpbjogbm9kZU9yaWdpbiwgbm9kZUV4dGVudDogbm9kZUV4dGVudCwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn1cblxuY29uc3Qgd3JhcHBlclN0eWxlID0ge1xuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIHpJbmRleDogMCxcbn07XG5mdW5jdGlvbiBSZWFjdEZsb3coeyBub2RlcywgZWRnZXMsIGRlZmF1bHROb2RlcywgZGVmYXVsdEVkZ2VzLCBjbGFzc05hbWUsIG5vZGVUeXBlcywgZWRnZVR5cGVzLCBvbk5vZGVDbGljaywgb25FZGdlQ2xpY2ssIG9uSW5pdCwgb25Nb3ZlLCBvbk1vdmVTdGFydCwgb25Nb3ZlRW5kLCBvbkNvbm5lY3QsIG9uQ29ubmVjdFN0YXJ0LCBvbkNvbm5lY3RFbmQsIG9uQ2xpY2tDb25uZWN0U3RhcnQsIG9uQ2xpY2tDb25uZWN0RW5kLCBvbk5vZGVNb3VzZUVudGVyLCBvbk5vZGVNb3VzZU1vdmUsIG9uTm9kZU1vdXNlTGVhdmUsIG9uTm9kZUNvbnRleHRNZW51LCBvbk5vZGVEb3VibGVDbGljaywgb25Ob2RlRHJhZ1N0YXJ0LCBvbk5vZGVEcmFnLCBvbk5vZGVEcmFnU3RvcCwgb25Ob2Rlc0RlbGV0ZSwgb25FZGdlc0RlbGV0ZSwgb25EZWxldGUsIG9uU2VsZWN0aW9uQ2hhbmdlLCBvblNlbGVjdGlvbkRyYWdTdGFydCwgb25TZWxlY3Rpb25EcmFnLCBvblNlbGVjdGlvbkRyYWdTdG9wLCBvblNlbGVjdGlvbkNvbnRleHRNZW51LCBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZCwgb25CZWZvcmVEZWxldGUsIGNvbm5lY3Rpb25Nb2RlLCBjb25uZWN0aW9uTGluZVR5cGUgPSBDb25uZWN0aW9uTGluZVR5cGUuQmV6aWVyLCBjb25uZWN0aW9uTGluZVN0eWxlLCBjb25uZWN0aW9uTGluZUNvbXBvbmVudCwgY29ubmVjdGlvbkxpbmVDb250YWluZXJTdHlsZSwgZGVsZXRlS2V5Q29kZSA9ICdCYWNrc3BhY2UnLCBzZWxlY3Rpb25LZXlDb2RlID0gJ1NoaWZ0Jywgc2VsZWN0aW9uT25EcmFnID0gZmFsc2UsIHNlbGVjdGlvbk1vZGUgPSBTZWxlY3Rpb25Nb2RlLkZ1bGwsIHBhbkFjdGl2YXRpb25LZXlDb2RlID0gJ1NwYWNlJywgbXVsdGlTZWxlY3Rpb25LZXlDb2RlID0gaXNNYWNPcygpID8gJ01ldGEnIDogJ0NvbnRyb2wnLCB6b29tQWN0aXZhdGlvbktleUNvZGUgPSBpc01hY09zKCkgPyAnTWV0YScgOiAnQ29udHJvbCcsIHNuYXBUb0dyaWQsIHNuYXBHcmlkLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzID0gZmFsc2UsIHNlbGVjdE5vZGVzT25EcmFnLCBub2Rlc0RyYWdnYWJsZSwgYXV0b1Bhbk9uTm9kZUZvY3VzLCBub2Rlc0Nvbm5lY3RhYmxlLCBub2Rlc0ZvY3VzYWJsZSwgbm9kZU9yaWdpbiA9IGRlZmF1bHROb2RlT3JpZ2luLCBlZGdlc0ZvY3VzYWJsZSwgZWRnZXNSZWNvbm5lY3RhYmxlLCBlbGVtZW50c1NlbGVjdGFibGUgPSB0cnVlLCBkZWZhdWx0Vmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCQxID0gZGVmYXVsdFZpZXdwb3J0LCBtaW5ab29tID0gMC41LCBtYXhab29tID0gMiwgdHJhbnNsYXRlRXh0ZW50ID0gaW5maW5pdGVFeHRlbnQsIHByZXZlbnRTY3JvbGxpbmcgPSB0cnVlLCBub2RlRXh0ZW50LCBkZWZhdWx0TWFya2VyQ29sb3IgPSAnI2IxYjFiNycsIHpvb21PblNjcm9sbCA9IHRydWUsIHpvb21PblBpbmNoID0gdHJ1ZSwgcGFuT25TY3JvbGwgPSBmYWxzZSwgcGFuT25TY3JvbGxTcGVlZCA9IDAuNSwgcGFuT25TY3JvbGxNb2RlID0gUGFuT25TY3JvbGxNb2RlLkZyZWUsIHpvb21PbkRvdWJsZUNsaWNrID0gdHJ1ZSwgcGFuT25EcmFnID0gdHJ1ZSwgb25QYW5lQ2xpY2ssIG9uUGFuZU1vdXNlRW50ZXIsIG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZSwgb25QYW5lU2Nyb2xsLCBvblBhbmVDb250ZXh0TWVudSwgcGFuZUNsaWNrRGlzdGFuY2UgPSAwLCBub2RlQ2xpY2tEaXN0YW5jZSA9IDAsIGNoaWxkcmVuLCBvblJlY29ubmVjdCwgb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQsIG9uRWRnZUNvbnRleHRNZW51LCBvbkVkZ2VEb3VibGVDbGljaywgb25FZGdlTW91c2VFbnRlciwgb25FZGdlTW91c2VNb3ZlLCBvbkVkZ2VNb3VzZUxlYXZlLCByZWNvbm5lY3RSYWRpdXMgPSAxMCwgb25Ob2Rlc0NoYW5nZSwgb25FZGdlc0NoYW5nZSwgbm9EcmFnQ2xhc3NOYW1lID0gJ25vZHJhZycsIG5vV2hlZWxDbGFzc05hbWUgPSAnbm93aGVlbCcsIG5vUGFuQ2xhc3NOYW1lID0gJ25vcGFuJywgZml0VmlldywgZml0Vmlld09wdGlvbnMsIGNvbm5lY3RPbkNsaWNrLCBhdHRyaWJ1dGlvblBvc2l0aW9uLCBwcm9PcHRpb25zLCBkZWZhdWx0RWRnZU9wdGlvbnMsIGVsZXZhdGVOb2Rlc09uU2VsZWN0LCBlbGV2YXRlRWRnZXNPblNlbGVjdCwgZGlzYWJsZUtleWJvYXJkQTExeSA9IGZhbHNlLCBhdXRvUGFuT25Db25uZWN0LCBhdXRvUGFuT25Ob2RlRHJhZywgYXV0b1BhblNwZWVkLCBjb25uZWN0aW9uUmFkaXVzLCBpc1ZhbGlkQ29ubmVjdGlvbiwgb25FcnJvciwgc3R5bGUsIGlkLCBub2RlRHJhZ1RocmVzaG9sZCwgY29ubmVjdGlvbkRyYWdUaHJlc2hvbGQsIHZpZXdwb3J0LCBvblZpZXdwb3J0Q2hhbmdlLCB3aWR0aCwgaGVpZ2h0LCBjb2xvck1vZGUgPSAnbGlnaHQnLCBkZWJ1Zywgb25TY3JvbGwsIGFyaWFMYWJlbENvbmZpZywgLi4ucmVzdCB9LCByZWYpIHtcbiAgICBjb25zdCByZklkID0gaWQgfHwgJzEnO1xuICAgIGNvbnN0IGNvbG9yTW9kZUNsYXNzTmFtZSA9IHVzZUNvbG9yTW9kZUNsYXNzKGNvbG9yTW9kZSk7XG4gICAgLy8gVW5kbyBzY3JvbGwgZXZlbnRzLCBwcmV2ZW50aW5nIHZpZXdwb3J0IGZyb20gc2hpZnRpbmcgd2hlbiBub2RlcyBvdXRzaWRlIG9mIGl0IGFyZSBmb2N1c2VkXG4gICAgY29uc3Qgd3JhcHBlck9uU2Nyb2xsID0gdXNlQ2FsbGJhY2soKGUpID0+IHtcbiAgICAgICAgZS5jdXJyZW50VGFyZ2V0LnNjcm9sbFRvKHsgdG9wOiAwLCBsZWZ0OiAwLCBiZWhhdmlvcjogJ2luc3RhbnQnIH0pO1xuICAgICAgICBvblNjcm9sbD8uKGUpO1xuICAgIH0sIFtvblNjcm9sbF0pO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgXCJkYXRhLXRlc3RpZFwiOiBcInJmX193cmFwcGVyXCIsIC4uLnJlc3QsIG9uU2Nyb2xsOiB3cmFwcGVyT25TY3JvbGwsIHN0eWxlOiB7IC4uLnN0eWxlLCAuLi53cmFwcGVyU3R5bGUgfSwgcmVmOiByZWYsIGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93JywgY2xhc3NOYW1lLCBjb2xvck1vZGVDbGFzc05hbWVdKSwgaWQ6IGlkLCByb2xlOiBcImFwcGxpY2F0aW9uXCIsIGNoaWxkcmVuOiBqc3hzKFdyYXBwZXIsIHsgbm9kZXM6IG5vZGVzLCBlZGdlczogZWRnZXMsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIGZpdFZpZXc6IGZpdFZpZXcsIGZpdFZpZXdPcHRpb25zOiBmaXRWaWV3T3B0aW9ucywgbWluWm9vbTogbWluWm9vbSwgbWF4Wm9vbTogbWF4Wm9vbSwgbm9kZU9yaWdpbjogbm9kZU9yaWdpbiwgbm9kZUV4dGVudDogbm9kZUV4dGVudCwgY2hpbGRyZW46IFtqc3goR3JhcGhWaWV3LCB7IG9uSW5pdDogb25Jbml0LCBvbk5vZGVDbGljazogb25Ob2RlQ2xpY2ssIG9uRWRnZUNsaWNrOiBvbkVkZ2VDbGljaywgb25Ob2RlTW91c2VFbnRlcjogb25Ob2RlTW91c2VFbnRlciwgb25Ob2RlTW91c2VNb3ZlOiBvbk5vZGVNb3VzZU1vdmUsIG9uTm9kZU1vdXNlTGVhdmU6IG9uTm9kZU1vdXNlTGVhdmUsIG9uTm9kZUNvbnRleHRNZW51OiBvbk5vZGVDb250ZXh0TWVudSwgb25Ob2RlRG91YmxlQ2xpY2s6IG9uTm9kZURvdWJsZUNsaWNrLCBub2RlVHlwZXM6IG5vZGVUeXBlcywgZWRnZVR5cGVzOiBlZGdlVHlwZXMsIGNvbm5lY3Rpb25MaW5lVHlwZTogY29ubmVjdGlvbkxpbmVUeXBlLCBjb25uZWN0aW9uTGluZVN0eWxlOiBjb25uZWN0aW9uTGluZVN0eWxlLCBjb25uZWN0aW9uTGluZUNvbXBvbmVudDogY29ubmVjdGlvbkxpbmVDb21wb25lbnQsIGNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGU6IGNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGUsIHNlbGVjdGlvbktleUNvZGU6IHNlbGVjdGlvbktleUNvZGUsIHNlbGVjdGlvbk9uRHJhZzogc2VsZWN0aW9uT25EcmFnLCBzZWxlY3Rpb25Nb2RlOiBzZWxlY3Rpb25Nb2RlLCBkZWxldGVLZXlDb2RlOiBkZWxldGVLZXlDb2RlLCBtdWx0aVNlbGVjdGlvbktleUNvZGU6IG11bHRpU2VsZWN0aW9uS2V5Q29kZSwgcGFuQWN0aXZhdGlvbktleUNvZGU6IHBhbkFjdGl2YXRpb25LZXlDb2RlLCB6b29tQWN0aXZhdGlvbktleUNvZGU6IHpvb21BY3RpdmF0aW9uS2V5Q29kZSwgb25seVJlbmRlclZpc2libGVFbGVtZW50czogb25seVJlbmRlclZpc2libGVFbGVtZW50cywgZGVmYXVsdFZpZXdwb3J0OiBkZWZhdWx0Vmlld3BvcnQkMSwgdHJhbnNsYXRlRXh0ZW50OiB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb206IG1pblpvb20sIG1heFpvb206IG1heFpvb20sIHByZXZlbnRTY3JvbGxpbmc6IHByZXZlbnRTY3JvbGxpbmcsIHpvb21PblNjcm9sbDogem9vbU9uU2Nyb2xsLCB6b29tT25QaW5jaDogem9vbU9uUGluY2gsIHpvb21PbkRvdWJsZUNsaWNrOiB6b29tT25Eb3VibGVDbGljaywgcGFuT25TY3JvbGw6IHBhbk9uU2Nyb2xsLCBwYW5PblNjcm9sbFNwZWVkOiBwYW5PblNjcm9sbFNwZWVkLCBwYW5PblNjcm9sbE1vZGU6IHBhbk9uU2Nyb2xsTW9kZSwgcGFuT25EcmFnOiBwYW5PbkRyYWcsIG9uUGFuZUNsaWNrOiBvblBhbmVDbGljaywgb25QYW5lTW91c2VFbnRlcjogb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlOiBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmU6IG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZVNjcm9sbDogb25QYW5lU2Nyb2xsLCBvblBhbmVDb250ZXh0TWVudTogb25QYW5lQ29udGV4dE1lbnUsIHBhbmVDbGlja0Rpc3RhbmNlOiBwYW5lQ2xpY2tEaXN0YW5jZSwgbm9kZUNsaWNrRGlzdGFuY2U6IG5vZGVDbGlja0Rpc3RhbmNlLCBvblNlbGVjdGlvbkNvbnRleHRNZW51OiBvblNlbGVjdGlvbkNvbnRleHRNZW51LCBvblNlbGVjdGlvblN0YXJ0OiBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZDogb25TZWxlY3Rpb25FbmQsIG9uUmVjb25uZWN0OiBvblJlY29ubmVjdCwgb25SZWNvbm5lY3RTdGFydDogb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQ6IG9uUmVjb25uZWN0RW5kLCBvbkVkZ2VDb250ZXh0TWVudTogb25FZGdlQ29udGV4dE1lbnUsIG9uRWRnZURvdWJsZUNsaWNrOiBvbkVkZ2VEb3VibGVDbGljaywgb25FZGdlTW91c2VFbnRlcjogb25FZGdlTW91c2VFbnRlciwgb25FZGdlTW91c2VNb3ZlOiBvbkVkZ2VNb3VzZU1vdmUsIG9uRWRnZU1vdXNlTGVhdmU6IG9uRWRnZU1vdXNlTGVhdmUsIHJlY29ubmVjdFJhZGl1czogcmVjb25uZWN0UmFkaXVzLCBkZWZhdWx0TWFya2VyQ29sb3I6IGRlZmF1bHRNYXJrZXJDb2xvciwgbm9EcmFnQ2xhc3NOYW1lOiBub0RyYWdDbGFzc05hbWUsIG5vV2hlZWxDbGFzc05hbWU6IG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgcmZJZDogcmZJZCwgZGlzYWJsZUtleWJvYXJkQTExeTogZGlzYWJsZUtleWJvYXJkQTExeSwgbm9kZUV4dGVudDogbm9kZUV4dGVudCwgdmlld3BvcnQ6IHZpZXdwb3J0LCBvblZpZXdwb3J0Q2hhbmdlOiBvblZpZXdwb3J0Q2hhbmdlIH0pLCBqc3goU3RvcmVVcGRhdGVyLCB7IG5vZGVzOiBub2RlcywgZWRnZXM6IGVkZ2VzLCBkZWZhdWx0Tm9kZXM6IGRlZmF1bHROb2RlcywgZGVmYXVsdEVkZ2VzOiBkZWZhdWx0RWRnZXMsIG9uQ29ubmVjdDogb25Db25uZWN0LCBvbkNvbm5lY3RTdGFydDogb25Db25uZWN0U3RhcnQsIG9uQ29ubmVjdEVuZDogb25Db25uZWN0RW5kLCBvbkNsaWNrQ29ubmVjdFN0YXJ0OiBvbkNsaWNrQ29ubmVjdFN0YXJ0LCBvbkNsaWNrQ29ubmVjdEVuZDogb25DbGlja0Nvbm5lY3RFbmQsIG5vZGVzRHJhZ2dhYmxlOiBub2Rlc0RyYWdnYWJsZSwgYXV0b1Bhbk9uTm9kZUZvY3VzOiBhdXRvUGFuT25Ob2RlRm9jdXMsIG5vZGVzQ29ubmVjdGFibGU6IG5vZGVzQ29ubmVjdGFibGUsIG5vZGVzRm9jdXNhYmxlOiBub2Rlc0ZvY3VzYWJsZSwgZWRnZXNGb2N1c2FibGU6IGVkZ2VzRm9jdXNhYmxlLCBlZGdlc1JlY29ubmVjdGFibGU6IGVkZ2VzUmVjb25uZWN0YWJsZSwgZWxlbWVudHNTZWxlY3RhYmxlOiBlbGVtZW50c1NlbGVjdGFibGUsIGVsZXZhdGVOb2Rlc09uU2VsZWN0OiBlbGV2YXRlTm9kZXNPblNlbGVjdCwgZWxldmF0ZUVkZ2VzT25TZWxlY3Q6IGVsZXZhdGVFZGdlc09uU2VsZWN0LCBtaW5ab29tOiBtaW5ab29tLCBtYXhab29tOiBtYXhab29tLCBub2RlRXh0ZW50OiBub2RlRXh0ZW50LCBvbk5vZGVzQ2hhbmdlOiBvbk5vZGVzQ2hhbmdlLCBvbkVkZ2VzQ2hhbmdlOiBvbkVkZ2VzQ2hhbmdlLCBzbmFwVG9HcmlkOiBzbmFwVG9HcmlkLCBzbmFwR3JpZDogc25hcEdyaWQsIGNvbm5lY3Rpb25Nb2RlOiBjb25uZWN0aW9uTW9kZSwgdHJhbnNsYXRlRXh0ZW50OiB0cmFuc2xhdGVFeHRlbnQsIGNvbm5lY3RPbkNsaWNrOiBjb25uZWN0T25DbGljaywgZGVmYXVsdEVkZ2VPcHRpb25zOiBkZWZhdWx0RWRnZU9wdGlvbnMsIGZpdFZpZXc6IGZpdFZpZXcsIGZpdFZpZXdPcHRpb25zOiBmaXRWaWV3T3B0aW9ucywgb25Ob2Rlc0RlbGV0ZTogb25Ob2Rlc0RlbGV0ZSwgb25FZGdlc0RlbGV0ZTogb25FZGdlc0RlbGV0ZSwgb25EZWxldGU6IG9uRGVsZXRlLCBvbk5vZGVEcmFnU3RhcnQ6IG9uTm9kZURyYWdTdGFydCwgb25Ob2RlRHJhZzogb25Ob2RlRHJhZywgb25Ob2RlRHJhZ1N0b3A6IG9uTm9kZURyYWdTdG9wLCBvblNlbGVjdGlvbkRyYWc6IG9uU2VsZWN0aW9uRHJhZywgb25TZWxlY3Rpb25EcmFnU3RhcnQ6IG9uU2VsZWN0aW9uRHJhZ1N0YXJ0LCBvblNlbGVjdGlvbkRyYWdTdG9wOiBvblNlbGVjdGlvbkRyYWdTdG9wLCBvbk1vdmU6IG9uTW92ZSwgb25Nb3ZlU3RhcnQ6IG9uTW92ZVN0YXJ0LCBvbk1vdmVFbmQ6IG9uTW92ZUVuZCwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBub2RlT3JpZ2luOiBub2RlT3JpZ2luLCByZklkOiByZklkLCBhdXRvUGFuT25Db25uZWN0OiBhdXRvUGFuT25Db25uZWN0LCBhdXRvUGFuT25Ob2RlRHJhZzogYXV0b1Bhbk9uTm9kZURyYWcsIGF1dG9QYW5TcGVlZDogYXV0b1BhblNwZWVkLCBvbkVycm9yOiBvbkVycm9yLCBjb25uZWN0aW9uUmFkaXVzOiBjb25uZWN0aW9uUmFkaXVzLCBpc1ZhbGlkQ29ubmVjdGlvbjogaXNWYWxpZENvbm5lY3Rpb24sIHNlbGVjdE5vZGVzT25EcmFnOiBzZWxlY3ROb2Rlc09uRHJhZywgbm9kZURyYWdUaHJlc2hvbGQ6IG5vZGVEcmFnVGhyZXNob2xkLCBjb25uZWN0aW9uRHJhZ1RocmVzaG9sZDogY29ubmVjdGlvbkRyYWdUaHJlc2hvbGQsIG9uQmVmb3JlRGVsZXRlOiBvbkJlZm9yZURlbGV0ZSwgcGFuZUNsaWNrRGlzdGFuY2U6IHBhbmVDbGlja0Rpc3RhbmNlLCBkZWJ1ZzogZGVidWcsIGFyaWFMYWJlbENvbmZpZzogYXJpYUxhYmVsQ29uZmlnIH0pLCBqc3goU2VsZWN0aW9uTGlzdGVuZXIsIHsgb25TZWxlY3Rpb25DaGFuZ2U6IG9uU2VsZWN0aW9uQ2hhbmdlIH0pLCBjaGlsZHJlbiwganN4KEF0dHJpYnV0aW9uLCB7IHByb09wdGlvbnM6IHByb09wdGlvbnMsIHBvc2l0aW9uOiBhdHRyaWJ1dGlvblBvc2l0aW9uIH0pLCBqc3goQTExeURlc2NyaXB0aW9ucywgeyByZklkOiByZklkLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5IH0pXSB9KSB9KSk7XG59XG4vKipcbiAqIFRoZSBgPFJlYWN0RmxvdyAvPmAgY29tcG9uZW50IGlzIHRoZSBoZWFydCBvZiB5b3VyIFJlYWN0IEZsb3cgYXBwbGljYXRpb24uXG4gKiBJdCByZW5kZXJzIHlvdXIgbm9kZXMgYW5kIGVkZ2VzIGFuZCBoYW5kbGVzIHVzZXIgaW50ZXJhY3Rpb25cbiAqXG4gKiBAcHVibGljXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICppbXBvcnQgeyBSZWFjdEZsb3cgfSBmcm9tICdAeHlmbG93L3JlYWN0J1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmxvdygpIHtcbiAqICByZXR1cm4gKDxSZWFjdEZsb3dcbiAqICAgIG5vZGVzPXsuLi59XG4gKiAgICBlZGdlcz17Li4ufVxuICogICAgb25Ob2Rlc0NoYW5nZT17Li4ufVxuICogICAgLi4uXG4gKiAgLz4pO1xuICp9XG4gKmBgYFxuICovXG52YXIgaW5kZXggPSBmaXhlZEZvcndhcmRSZWYoUmVhY3RGbG93KTtcblxuY29uc3Qgc2VsZWN0b3IkNiA9IChzKSA9PiBzLmRvbU5vZGU/LnF1ZXJ5U2VsZWN0b3IoJy5yZWFjdC1mbG93X19lZGdlbGFiZWwtcmVuZGVyZXInKTtcbi8qKlxuICogRWRnZXMgYXJlIFNWRy1iYXNlZC4gSWYgeW91IHdhbnQgdG8gcmVuZGVyIG1vcmUgY29tcGxleCBsYWJlbHMgeW91IGNhbiB1c2UgdGhlXG4gKiBgPEVkZ2VMYWJlbFJlbmRlcmVyIC8+YCBjb21wb25lbnQgdG8gYWNjZXNzIGEgZGl2IGJhc2VkIHJlbmRlcmVyLiBUaGlzIGNvbXBvbmVudFxuICogaXMgYSBwb3J0YWwgdGhhdCByZW5kZXJzIHRoZSBsYWJlbCBpbiBhIGA8ZGl2IC8+YCB0aGF0IGlzIHBvc2l0aW9uZWQgb24gdG9wIG9mXG4gKiB0aGUgZWRnZXMuIFlvdSBjYW4gc2VlIGFuIGV4YW1wbGUgdXNhZ2Ugb2YgdGhlIGNvbXBvbmVudCBpbiB0aGVcbiAqIFtlZGdlIGxhYmVsIHJlbmRlcmVyIGV4YW1wbGVdKC9leGFtcGxlcy9lZGdlcy9lZGdlLWxhYmVsLXJlbmRlcmVyKS5cbiAqIEBwdWJsaWNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKiBpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuICogaW1wb3J0IHsgZ2V0QmV6aWVyUGF0aCwgRWRnZUxhYmVsUmVuZGVyZXIsIEJhc2VFZGdlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICogZXhwb3J0IGZ1bmN0aW9uIEN1c3RvbUVkZ2UoeyBpZCwgZGF0YSwgLi4ucHJvcHMgfSkge1xuICogICBjb25zdCBbZWRnZVBhdGgsIGxhYmVsWCwgbGFiZWxZXSA9IGdldEJlemllclBhdGgocHJvcHMpO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8PlxuICogICAgICAgPEJhc2VFZGdlIGlkPXtpZH0gcGF0aD17ZWRnZVBhdGh9IC8+XG4gKiAgICAgICA8RWRnZUxhYmVsUmVuZGVyZXI+XG4gKiAgICAgICAgIDxkaXZcbiAqICAgICAgICAgICBzdHlsZT17e1xuICogICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gKiAgICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoLTUwJSwgLTUwJSkgdHJhbnNsYXRlKCR7bGFiZWxYfXB4LCR7bGFiZWxZfXB4KWAsXG4gKiAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAnI2ZmY2MwMCcsXG4gKiAgICAgICAgICAgICBwYWRkaW5nOiAxMCxcbiAqICAgICAgICAgfX1cbiAqICAgICAgICAgICBjbGFzc05hbWU9XCJub2RyYWcgbm9wYW5cIlxuICogICAgICAgICA+XG4gKiAgICAgICAgICB7ZGF0YS5sYWJlbH1cbiAqICAgICAgICAgPC9kaXY+XG4gKiAgICAgICA8L0VkZ2VMYWJlbFJlbmRlcmVyPlxuICogICAgIDwvPlxuICogICApO1xuICogfTtcbiAqIGBgYFxuICpcbiAqIEByZW1hcmtzIFRoZSBgPEVkZ2VMYWJlbFJlbmRlcmVyIC8+YCBoYXMgbm8gcG9pbnRlciBldmVudHMgYnkgZGVmYXVsdC4gSWYgeW91IHdhbnQgdG9cbiAqIGFkZCBtb3VzZSBpbnRlcmFjdGlvbnMgeW91IG5lZWQgdG8gc2V0IHRoZSBzdHlsZSBgcG9pbnRlckV2ZW50czogYWxsYCBhbmQgYWRkXG4gKiB0aGUgYG5vcGFuYCBjbGFzcyBvbiB0aGUgbGFiZWwgb3IgdGhlIGVsZW1lbnQgeW91IHdhbnQgdG8gaW50ZXJhY3Qgd2l0aC5cbiAqL1xuZnVuY3Rpb24gRWRnZUxhYmVsUmVuZGVyZXIoeyBjaGlsZHJlbiB9KSB7XG4gICAgY29uc3QgZWRnZUxhYmVsUmVuZGVyZXIgPSB1c2VTdG9yZShzZWxlY3RvciQ2KTtcbiAgICBpZiAoIWVkZ2VMYWJlbFJlbmRlcmVyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBlZGdlTGFiZWxSZW5kZXJlcik7XG59XG5cbmNvbnN0IHNlbGVjdG9yJDUgPSAocykgPT4gcy5kb21Ob2RlPy5xdWVyeVNlbGVjdG9yKCcucmVhY3QtZmxvd19fdmlld3BvcnQtcG9ydGFsJyk7XG4vKipcbiAqIFRoZSBgPFZpZXdwb3J0UG9ydGFsIC8+YCBjb21wb25lbnQgY2FuIGJlIHVzZWQgdG8gYWRkIGNvbXBvbmVudHMgdG8gdGhlIHNhbWUgdmlld3BvcnRcbiAqIG9mIHRoZSBmbG93IHdoZXJlIG5vZGVzIGFuZCBlZGdlcyBhcmUgcmVuZGVyZWQuIFRoaXMgaXMgdXNlZnVsIHdoZW4geW91IHdhbnQgdG8gcmVuZGVyXG4gKiB5b3VyIG93biBjb21wb25lbnRzIHRoYXQgYXJlIGFkaGVyZSB0byB0aGUgc2FtZSBjb29yZGluYXRlIHN5c3RlbSBhcyB0aGUgbm9kZXMgJiBlZGdlc1xuICogYW5kIGFyZSBhbHNvIGFmZmVjdGVkIGJ5IHpvb21pbmcgYW5kIHBhbm5pbmdcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganN4XG4gKmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG4gKmltcG9ydCB7IFZpZXdwb3J0UG9ydGFsIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gKiAgcmV0dXJuIChcbiAqICAgIDxWaWV3cG9ydFBvcnRhbD5cbiAqICAgICAgPGRpdlxuICogICAgICAgIHN0eWxlPXt7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgxMDBweCwgMTAwcHgpJywgcG9zaXRpb246ICdhYnNvbHV0ZScgfX1cbiAqICAgICAgPlxuICogICAgICAgIFRoaXMgZGl2IGlzIHBvc2l0aW9uZWQgYXQgWzEwMCwgMTAwXSBvbiB0aGUgZmxvdy5cbiAqICAgICAgPC9kaXY+XG4gKiAgICA8L1ZpZXdwb3J0UG9ydGFsPlxuICogICk7XG4gKn1cbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIFZpZXdwb3J0UG9ydGFsKHsgY2hpbGRyZW4gfSkge1xuICAgIGNvbnN0IHZpZXdQb3J0YWxEaXYgPSB1c2VTdG9yZShzZWxlY3RvciQ1KTtcbiAgICBpZiAoIXZpZXdQb3J0YWxEaXYpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIHZpZXdQb3J0YWxEaXYpO1xufVxuXG4vKipcbiAqIFdoZW4geW91IHByb2dyYW1tYXRpY2FsbHkgYWRkIG9yIHJlbW92ZSBoYW5kbGVzIHRvIGEgbm9kZSBvciB1cGRhdGUgYSBub2RlJ3NcbiAqIGhhbmRsZSBwb3NpdGlvbiwgeW91IG5lZWQgdG8gbGV0IFJlYWN0IEZsb3cga25vdyBhYm91dCBpdCB1c2luZyB0aGlzIGhvb2suIFRoaXNcbiAqIHdpbGwgdXBkYXRlIHRoZSBpbnRlcm5hbCBkaW1lbnNpb25zIG9mIHRoZSBub2RlIGFuZCBwcm9wZXJseSByZXBvc2l0aW9uIGhhbmRsZXNcbiAqIG9uIHRoZSBjYW52YXMgaWYgbmVjZXNzYXJ5LlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIHRlbGwgUmVhY3QgRmxvdyB0byB1cGRhdGUgdGhlIGludGVybmFsIHN0YXRlIG9mIG9uZSBvciBtb3JlIG5vZGVzXG4gKiB0aGF0IHlvdSBoYXZlIGNoYW5nZWQgcHJvZ3JhbW1hdGljYWxseS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgSGFuZGxlLCB1c2VVcGRhdGVOb2RlSW50ZXJuYWxzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBSYW5kb21IYW5kbGVOb2RlKHsgaWQgfSkge1xuICogIGNvbnN0IHVwZGF0ZU5vZGVJbnRlcm5hbHMgPSB1c2VVcGRhdGVOb2RlSW50ZXJuYWxzKCk7XG4gKiAgY29uc3QgW2hhbmRsZUNvdW50LCBzZXRIYW5kbGVDb3VudF0gPSB1c2VTdGF0ZSgwKTtcbiAqICBjb25zdCByYW5kb21pemVIYW5kbGVDb3VudCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAqICAgc2V0SGFuZGxlQ291bnQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTApKTtcbiAqICAgIHVwZGF0ZU5vZGVJbnRlcm5hbHMoaWQpO1xuICogIH0sIFtpZCwgdXBkYXRlTm9kZUludGVybmFsc10pO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPD5cbiAqICAgICAge0FycmF5LmZyb20oeyBsZW5ndGg6IGhhbmRsZUNvdW50IH0pLm1hcCgoXywgaW5kZXgpID0+IChcbiAqICAgICAgICA8SGFuZGxlXG4gKiAgICAgICAgICBrZXk9e2luZGV4fVxuICogICAgICAgICAgdHlwZT1cInRhcmdldFwiXG4gKiAgICAgICAgICBwb3NpdGlvbj1cImxlZnRcIlxuICogICAgICAgICAgaWQ9e2BoYW5kbGUtJHtpbmRleH1gfVxuICogICAgICAgIC8+XG4gKiAgICAgICkpfVxuICpcbiAqICAgICAgPGRpdj5cbiAqICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e3JhbmRvbWl6ZUhhbmRsZUNvdW50fT5SYW5kb21pemUgaGFuZGxlIGNvdW50PC9idXR0b24+XG4gKiAgICAgICAgPHA+VGhlcmUgYXJlIHtoYW5kbGVDb3VudH0gaGFuZGxlcyBvbiB0aGlzIG5vZGUuPC9wPlxuICogICAgICA8L2Rpdj5cbiAqICAgIDwvPlxuICogICk7XG4gKn1cbiAqYGBgXG4gKiBAcmVtYXJrcyBUaGlzIGhvb2sgY2FuIG9ubHkgYmUgdXNlZCBpbiBhIGNvbXBvbmVudCB0aGF0IGlzIGEgY2hpbGQgb2YgYVxuICp7QGxpbmsgUmVhY3RGbG93UHJvdmlkZXJ9IG9yIGEge0BsaW5rIFJlYWN0Rmxvd30gY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiB1c2VVcGRhdGVOb2RlSW50ZXJuYWxzKCkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soKGlkKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZG9tTm9kZSwgdXBkYXRlTm9kZUludGVybmFscyB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3QgdXBkYXRlSWRzID0gQXJyYXkuaXNBcnJheShpZCkgPyBpZCA6IFtpZF07XG4gICAgICAgIGNvbnN0IHVwZGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHVwZGF0ZUlkcy5mb3JFYWNoKCh1cGRhdGVJZCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9kZUVsZW1lbnQgPSBkb21Ob2RlPy5xdWVyeVNlbGVjdG9yKGAucmVhY3QtZmxvd19fbm9kZVtkYXRhLWlkPVwiJHt1cGRhdGVJZH1cIl1gKTtcbiAgICAgICAgICAgIGlmIChub2RlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZXMuc2V0KHVwZGF0ZUlkLCB7IGlkOiB1cGRhdGVJZCwgbm9kZUVsZW1lbnQsIGZvcmNlOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHVwZGF0ZU5vZGVJbnRlcm5hbHModXBkYXRlcywgeyB0cmlnZ2VyRml0VmlldzogZmFsc2UgfSkpO1xuICAgIH0sIFtdKTtcbn1cblxuY29uc3Qgbm9kZXNTZWxlY3RvciA9IChzdGF0ZSkgPT4gc3RhdGUubm9kZXM7XG4vKipcbiAqIFRoaXMgaG9vayByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBjdXJyZW50IG5vZGVzLiBDb21wb25lbnRzIHRoYXQgdXNlIHRoaXMgaG9va1xuICogd2lsbCByZS1yZW5kZXIgKip3aGVuZXZlciBhbnkgbm9kZSBjaGFuZ2VzKiosIGluY2x1ZGluZyB3aGVuIGEgbm9kZSBpcyBzZWxlY3RlZFxuICogb3IgbW92ZWQuXG4gKlxuICogQHB1YmxpY1xuICogQHJldHVybnMgQW4gYXJyYXkgb2YgYWxsIG5vZGVzIGN1cnJlbnRseSBpbiB0aGUgZmxvdy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKmltcG9ydCB7IHVzZU5vZGVzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAqICBjb25zdCBub2RlcyA9IHVzZU5vZGVzKCk7XG4gKlxuICogIHJldHVybiA8ZGl2PlRoZXJlIGFyZSBjdXJyZW50bHkge25vZGVzLmxlbmd0aH0gbm9kZXMhPC9kaXY+O1xuICp9XG4gKmBgYFxuICovXG5mdW5jdGlvbiB1c2VOb2RlcygpIHtcbiAgICBjb25zdCBub2RlcyA9IHVzZVN0b3JlKG5vZGVzU2VsZWN0b3IsIHNoYWxsb3cpO1xuICAgIHJldHVybiBub2Rlcztcbn1cblxuY29uc3QgZWRnZXNTZWxlY3RvciA9IChzdGF0ZSkgPT4gc3RhdGUuZWRnZXM7XG4vKipcbiAqIFRoaXMgaG9vayByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBjdXJyZW50IGVkZ2VzLiBDb21wb25lbnRzIHRoYXQgdXNlIHRoaXMgaG9va1xuICogd2lsbCByZS1yZW5kZXIgKip3aGVuZXZlciBhbnkgZWRnZSBjaGFuZ2VzKiouXG4gKlxuICogQHB1YmxpY1xuICogQHJldHVybnMgQW4gYXJyYXkgb2YgYWxsIGVkZ2VzIGN1cnJlbnRseSBpbiB0aGUgZmxvdy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKmltcG9ydCB7IHVzZUVkZ2VzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gKiAgY29uc3QgZWRnZXMgPSB1c2VFZGdlcygpO1xuICpcbiAqICByZXR1cm4gPGRpdj5UaGVyZSBhcmUgY3VycmVudGx5IHtlZGdlcy5sZW5ndGh9IGVkZ2VzITwvZGl2PjtcbiAqfVxuICpgYGBcbiAqL1xuZnVuY3Rpb24gdXNlRWRnZXMoKSB7XG4gICAgY29uc3QgZWRnZXMgPSB1c2VTdG9yZShlZGdlc1NlbGVjdG9yLCBzaGFsbG93KTtcbiAgICByZXR1cm4gZWRnZXM7XG59XG5cbmNvbnN0IHZpZXdwb3J0U2VsZWN0b3IgPSAoc3RhdGUpID0+ICh7XG4gICAgeDogc3RhdGUudHJhbnNmb3JtWzBdLFxuICAgIHk6IHN0YXRlLnRyYW5zZm9ybVsxXSxcbiAgICB6b29tOiBzdGF0ZS50cmFuc2Zvcm1bMl0sXG59KTtcbi8qKlxuICogVGhlIGB1c2VWaWV3cG9ydGAgaG9vayBpcyBhIGNvbnZlbmllbnQgd2F5IHRvIHJlYWQgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlXG4gKiB7QGxpbmsgVmlld3BvcnR9IGluIGEgY29tcG9uZW50LiBDb21wb25lbnRzIHRoYXQgdXNlIHRoaXMgaG9va1xuICogd2lsbCByZS1yZW5kZXIgKip3aGVuZXZlciB0aGUgdmlld3BvcnQgY2hhbmdlcyoqLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHZpZXdwb3J0LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICpgYGBqc3hcbiAqaW1wb3J0IHsgdXNlVmlld3BvcnQgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFZpZXdwb3J0RGlzcGxheSgpIHtcbiAqICBjb25zdCB7IHgsIHksIHpvb20gfSA9IHVzZVZpZXdwb3J0KCk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8ZGl2PlxuICogICAgICA8cD5cbiAqICAgICAgICBUaGUgdmlld3BvcnQgaXMgY3VycmVudGx5IGF0ICh7eH0sIHt5fSkgYW5kIHpvb21lZCB0byB7em9vbX0uXG4gKiAgICAgIDwvcD5cbiAqICAgIDwvZGl2PlxuICogICk7XG4gKn1cbiAqYGBgXG4gKlxuICogQHJlbWFya3MgVGhpcyBob29rIGNhbiBvbmx5IGJlIHVzZWQgaW4gYSBjb21wb25lbnQgdGhhdCBpcyBhIGNoaWxkIG9mIGFcbiAqe0BsaW5rIFJlYWN0Rmxvd1Byb3ZpZGVyfSBvciBhIHtAbGluayBSZWFjdEZsb3d9IGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gdXNlVmlld3BvcnQoKSB7XG4gICAgY29uc3Qgdmlld3BvcnQgPSB1c2VTdG9yZSh2aWV3cG9ydFNlbGVjdG9yLCBzaGFsbG93KTtcbiAgICByZXR1cm4gdmlld3BvcnQ7XG59XG5cbi8qKlxuICogVGhpcyBob29rIG1ha2VzIGl0IGVhc3kgdG8gcHJvdG90eXBlIGEgY29udHJvbGxlZCBmbG93IHdoZXJlIHlvdSBtYW5hZ2UgdGhlXG4gKiBzdGF0ZSBvZiBub2RlcyBhbmQgZWRnZXMgb3V0c2lkZSB0aGUgYFJlYWN0Rmxvd0luc3RhbmNlYC4gWW91IGNhbiB0aGluayBvZiBpdFxuICogbGlrZSBSZWFjdCdzIGB1c2VTdGF0ZWAgaG9vayB3aXRoIGFuIGFkZGl0aW9uYWwgaGVscGVyIGNhbGxiYWNrLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zXG4gKiAtIGBub2Rlc2A6IFRoZSBjdXJyZW50IGFycmF5IG9mIG5vZGVzLiBZb3UgbWlnaHQgcGFzcyB0aGlzIGRpcmVjdGx5IHRvIHRoZSBgbm9kZXNgIHByb3Agb2YgeW91clxuICogYDxSZWFjdEZsb3cgLz5gIGNvbXBvbmVudCwgb3IgeW91IG1heSB3YW50IHRvIG1hbmlwdWxhdGUgaXQgZmlyc3QgdG8gcGVyZm9ybSBzb21lIGxheW91dGluZyxcbiAqIGZvciBleGFtcGxlLlxuICogLSBgc2V0Tm9kZXNgOiBBIGZ1bmN0aW9uIHRoYXQgeW91IGNhbiB1c2UgdG8gdXBkYXRlIHRoZSBub2Rlcy4gWW91IGNhbiBwYXNzIGl0IGEgbmV3IGFycmF5IG9mXG4gKiBub2RlcyBvciBhIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIGN1cnJlbnQgYXJyYXkgb2Ygbm9kZXMgYW5kIHJldHVybnMgYSBuZXcgYXJyYXkgb2Ygbm9kZXMuXG4gKiBUaGlzIGlzIHRoZSBzYW1lIGFzIHRoZSBzZWNvbmQgZWxlbWVudCBvZiB0aGUgdHVwbGUgcmV0dXJuZWQgYnkgUmVhY3QncyBgdXNlU3RhdGVgIGhvb2suXG4gKiAtIGBvbk5vZGVzQ2hhbmdlYDogQSBoYW5keSBjYWxsYmFjayB0aGF0IGNhbiB0YWtlIGFuIGFycmF5IG9mIGBOb2RlQ2hhbmdlc2AgYW5kIHVwZGF0ZSB0aGUgbm9kZXNcbiAqIHN0YXRlIGFjY29yZGluZ2x5LiBZb3UnbGwgdHlwaWNhbGx5IHBhc3MgdGhpcyBkaXJlY3RseSB0byB0aGUgYG9uTm9kZXNDaGFuZ2VgIHByb3Agb2YgeW91clxuICogYDxSZWFjdEZsb3cgLz5gIGNvbXBvbmVudC5cbiAqIEBleGFtcGxlXG4gKlxuICpgYGB0c3hcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCB1c2VOb2Rlc1N0YXRlLCB1c2VFZGdlc1N0YXRlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpjb25zdCBpbml0aWFsTm9kZXMgPSBbXTtcbiAqY29uc3QgaW5pdGlhbEVkZ2VzID0gW107XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gKiAgY29uc3QgW25vZGVzLCBzZXROb2Rlcywgb25Ob2Rlc0NoYW5nZV0gPSB1c2VOb2Rlc1N0YXRlKGluaXRpYWxOb2Rlcyk7XG4gKiAgY29uc3QgW2VkZ2VzLCBzZXRFZGdlcywgb25FZGdlc0NoYW5nZV0gPSB1c2VFZGdlc1N0YXRlKGluaXRpYWxFZGdlcyk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93XG4gKiAgICAgIG5vZGVzPXtub2Rlc31cbiAqICAgICAgZWRnZXM9e2VkZ2VzfVxuICogICAgICBvbk5vZGVzQ2hhbmdlPXtvbk5vZGVzQ2hhbmdlfVxuICogICAgICBvbkVkZ2VzQ2hhbmdlPXtvbkVkZ2VzQ2hhbmdlfVxuICogICAgLz5cbiAqICApO1xuICp9XG4gKmBgYFxuICpcbiAqIEByZW1hcmtzIFRoaXMgaG9vayB3YXMgY3JlYXRlZCB0byBtYWtlIHByb3RvdHlwaW5nIGVhc2llciBhbmQgb3VyIGRvY3VtZW50YXRpb25cbiAqIGV4YW1wbGVzIGNsZWFyZXIuIEFsdGhvdWdoIGl0IGlzIE9LIHRvIHVzZSB0aGlzIGhvb2sgaW4gcHJvZHVjdGlvbiwgaW5cbiAqIHByYWN0aWNlIHlvdSBtYXkgd2FudCB0byB1c2UgYSBtb3JlIHNvcGhpc3RpY2F0ZWQgc3RhdGUgbWFuYWdlbWVudCBzb2x1dGlvblxuICogbGlrZSBadXN0YW5kIHtAbGluayBodHRwczovL3JlYWN0Zmxvdy5kZXYvZG9jcy9ndWlkZXMvc3RhdGUtbWFuYWdlbWVudC99IGluc3RlYWQuXG4gKlxuICovXG5mdW5jdGlvbiB1c2VOb2Rlc1N0YXRlKGluaXRpYWxOb2Rlcykge1xuICAgIGNvbnN0IFtub2Rlcywgc2V0Tm9kZXNdID0gdXNlU3RhdGUoaW5pdGlhbE5vZGVzKTtcbiAgICBjb25zdCBvbk5vZGVzQ2hhbmdlID0gdXNlQ2FsbGJhY2soKGNoYW5nZXMpID0+IHNldE5vZGVzKChuZHMpID0+IGFwcGx5Tm9kZUNoYW5nZXMoY2hhbmdlcywgbmRzKSksIFtdKTtcbiAgICByZXR1cm4gW25vZGVzLCBzZXROb2Rlcywgb25Ob2Rlc0NoYW5nZV07XG59XG4vKipcbiAqIFRoaXMgaG9vayBtYWtlcyBpdCBlYXN5IHRvIHByb3RvdHlwZSBhIGNvbnRyb2xsZWQgZmxvdyB3aGVyZSB5b3UgbWFuYWdlIHRoZVxuICogc3RhdGUgb2Ygbm9kZXMgYW5kIGVkZ2VzIG91dHNpZGUgdGhlIGBSZWFjdEZsb3dJbnN0YW5jZWAuIFlvdSBjYW4gdGhpbmsgb2YgaXRcbiAqIGxpa2UgUmVhY3QncyBgdXNlU3RhdGVgIGhvb2sgd2l0aCBhbiBhZGRpdGlvbmFsIGhlbHBlciBjYWxsYmFjay5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmV0dXJuc1xuICogLSBgZWRnZXNgOiBUaGUgY3VycmVudCBhcnJheSBvZiBlZGdlcy4gWW91IG1pZ2h0IHBhc3MgdGhpcyBkaXJlY3RseSB0byB0aGUgYGVkZ2VzYCBwcm9wIG9mIHlvdXJcbiAqIGA8UmVhY3RGbG93IC8+YCBjb21wb25lbnQsIG9yIHlvdSBtYXkgd2FudCB0byBtYW5pcHVsYXRlIGl0IGZpcnN0IHRvIHBlcmZvcm0gc29tZSBsYXlvdXRpbmcsXG4gKiBmb3IgZXhhbXBsZS5cbiAqXG4gKiAtIGBzZXRFZGdlc2A6IEEgZnVuY3Rpb24gdGhhdCB5b3UgY2FuIHVzZSB0byB1cGRhdGUgdGhlIGVkZ2VzLiBZb3UgY2FuIHBhc3MgaXQgYSBuZXcgYXJyYXkgb2ZcbiAqIGVkZ2VzIG9yIGEgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUgY3VycmVudCBhcnJheSBvZiBlZGdlcyBhbmQgcmV0dXJucyBhIG5ldyBhcnJheSBvZiBlZGdlcy5cbiAqIFRoaXMgaXMgdGhlIHNhbWUgYXMgdGhlIHNlY29uZCBlbGVtZW50IG9mIHRoZSB0dXBsZSByZXR1cm5lZCBieSBSZWFjdCdzIGB1c2VTdGF0ZWAgaG9vay5cbiAqXG4gKiAtIGBvbkVkZ2VzQ2hhbmdlYDogQSBoYW5keSBjYWxsYmFjayB0aGF0IGNhbiB0YWtlIGFuIGFycmF5IG9mIGBFZGdlQ2hhbmdlc2AgYW5kIHVwZGF0ZSB0aGUgZWRnZXNcbiAqIHN0YXRlIGFjY29yZGluZ2x5LiBZb3UnbGwgdHlwaWNhbGx5IHBhc3MgdGhpcyBkaXJlY3RseSB0byB0aGUgYG9uRWRnZXNDaGFuZ2VgIHByb3Agb2YgeW91clxuICogYDxSZWFjdEZsb3cgLz5gIGNvbXBvbmVudC5cbiAqIEBleGFtcGxlXG4gKlxuICpgYGB0c3hcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCB1c2VOb2Rlc1N0YXRlLCB1c2VFZGdlc1N0YXRlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpjb25zdCBpbml0aWFsTm9kZXMgPSBbXTtcbiAqY29uc3QgaW5pdGlhbEVkZ2VzID0gW107XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gKiAgY29uc3QgW25vZGVzLCBzZXROb2Rlcywgb25Ob2Rlc0NoYW5nZV0gPSB1c2VOb2Rlc1N0YXRlKGluaXRpYWxOb2Rlcyk7XG4gKiAgY29uc3QgW2VkZ2VzLCBzZXRFZGdlcywgb25FZGdlc0NoYW5nZV0gPSB1c2VFZGdlc1N0YXRlKGluaXRpYWxFZGdlcyk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93XG4gKiAgICAgIG5vZGVzPXtub2Rlc31cbiAqICAgICAgZWRnZXM9e2VkZ2VzfVxuICogICAgICBvbk5vZGVzQ2hhbmdlPXtvbk5vZGVzQ2hhbmdlfVxuICogICAgICBvbkVkZ2VzQ2hhbmdlPXtvbkVkZ2VzQ2hhbmdlfVxuICogICAgLz5cbiAqICApO1xuICp9XG4gKmBgYFxuICpcbiAqIEByZW1hcmtzIFRoaXMgaG9vayB3YXMgY3JlYXRlZCB0byBtYWtlIHByb3RvdHlwaW5nIGVhc2llciBhbmQgb3VyIGRvY3VtZW50YXRpb25cbiAqIGV4YW1wbGVzIGNsZWFyZXIuIEFsdGhvdWdoIGl0IGlzIE9LIHRvIHVzZSB0aGlzIGhvb2sgaW4gcHJvZHVjdGlvbiwgaW5cbiAqIHByYWN0aWNlIHlvdSBtYXkgd2FudCB0byB1c2UgYSBtb3JlIHNvcGhpc3RpY2F0ZWQgc3RhdGUgbWFuYWdlbWVudCBzb2x1dGlvblxuICogbGlrZSBadXN0YW5kIHtAbGluayBodHRwczovL3JlYWN0Zmxvdy5kZXYvZG9jcy9ndWlkZXMvc3RhdGUtbWFuYWdlbWVudC99IGluc3RlYWQuXG4gKlxuICovXG5mdW5jdGlvbiB1c2VFZGdlc1N0YXRlKGluaXRpYWxFZGdlcykge1xuICAgIGNvbnN0IFtlZGdlcywgc2V0RWRnZXNdID0gdXNlU3RhdGUoaW5pdGlhbEVkZ2VzKTtcbiAgICBjb25zdCBvbkVkZ2VzQ2hhbmdlID0gdXNlQ2FsbGJhY2soKGNoYW5nZXMpID0+IHNldEVkZ2VzKChlZHMpID0+IGFwcGx5RWRnZUNoYW5nZXMoY2hhbmdlcywgZWRzKSksIFtdKTtcbiAgICByZXR1cm4gW2VkZ2VzLCBzZXRFZGdlcywgb25FZGdlc0NoYW5nZV07XG59XG5cbi8qKlxuICogVGhlIGB1c2VPblZpZXdwb3J0Q2hhbmdlYCBob29rIGxldHMgeW91IGxpc3RlbiBmb3IgY2hhbmdlcyB0byB0aGUgdmlld3BvcnQgc3VjaFxuICogYXMgcGFubmluZyBhbmQgem9vbWluZy4gWW91IGNhbiBwcm92aWRlIGEgY2FsbGJhY2sgZm9yIGVhY2ggcGhhc2Ugb2YgYSB2aWV3cG9ydFxuICogY2hhbmdlOiBgb25TdGFydGAsIGBvbkNoYW5nZWAsIGFuZCBgb25FbmRgLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG4gKmltcG9ydCB7IHVzZU9uVmlld3BvcnRDaGFuZ2UgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmZ1bmN0aW9uIFZpZXdwb3J0Q2hhbmdlTG9nZ2VyKCkge1xuICogIHVzZU9uVmlld3BvcnRDaGFuZ2Uoe1xuICogICAgb25TdGFydDogKHZpZXdwb3J0OiBWaWV3cG9ydCkgPT4gY29uc29sZS5sb2coJ3N0YXJ0Jywgdmlld3BvcnQpLFxuICogICAgb25DaGFuZ2U6ICh2aWV3cG9ydDogVmlld3BvcnQpID0+IGNvbnNvbGUubG9nKCdjaGFuZ2UnLCB2aWV3cG9ydCksXG4gKiAgICBvbkVuZDogKHZpZXdwb3J0OiBWaWV3cG9ydCkgPT4gY29uc29sZS5sb2coJ2VuZCcsIHZpZXdwb3J0KSxcbiAqICB9KTtcbiAqXG4gKiAgcmV0dXJuIG51bGw7XG4gKn1cbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZU9uVmlld3BvcnRDaGFuZ2UoeyBvblN0YXJ0LCBvbkNoYW5nZSwgb25FbmQgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG9uVmlld3BvcnRDaGFuZ2VTdGFydDogb25TdGFydCB9KTtcbiAgICB9LCBbb25TdGFydF0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgb25WaWV3cG9ydENoYW5nZTogb25DaGFuZ2UgfSk7XG4gICAgfSwgW29uQ2hhbmdlXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBvblZpZXdwb3J0Q2hhbmdlRW5kOiBvbkVuZCB9KTtcbiAgICB9LCBbb25FbmRdKTtcbn1cblxuLyoqXG4gKiBUaGlzIGhvb2sgbGV0cyB5b3UgbGlzdGVuIGZvciBjaGFuZ2VzIHRvIGJvdGggbm9kZSBhbmQgZWRnZSBzZWxlY3Rpb24uIEFzIHRoZVxuICpuYW1lIGltcGxpZXMsIHRoZSBjYWxsYmFjayB5b3UgcHJvdmlkZSB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgc2VsZWN0aW9uIG9mXG4gKl9laXRoZXJfIG5vZGVzIG9yIGVkZ2VzIGNoYW5nZXMuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICppbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCB1c2VPblNlbGVjdGlvbkNoYW5nZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZnVuY3Rpb24gU2VsZWN0aW9uRGlzcGxheSgpIHtcbiAqICBjb25zdCBbc2VsZWN0ZWROb2Rlcywgc2V0U2VsZWN0ZWROb2Rlc10gPSB1c2VTdGF0ZShbXSk7XG4gKiAgY29uc3QgW3NlbGVjdGVkRWRnZXMsIHNldFNlbGVjdGVkRWRnZXNdID0gdXNlU3RhdGUoW10pO1xuICpcbiAqICAvLyB0aGUgcGFzc2VkIGhhbmRsZXIgaGFzIHRvIGJlIG1lbW9pemVkLCBvdGhlcndpc2UgdGhlIGhvb2sgd2lsbCBub3Qgd29yayBjb3JyZWN0bHlcbiAqICBjb25zdCBvbkNoYW5nZSA9IHVzZUNhbGxiYWNrKCh7IG5vZGVzLCBlZGdlcyB9KSA9PiB7XG4gKiAgICBzZXRTZWxlY3RlZE5vZGVzKG5vZGVzLm1hcCgobm9kZSkgPT4gbm9kZS5pZCkpO1xuICogICAgc2V0U2VsZWN0ZWRFZGdlcyhlZGdlcy5tYXAoKGVkZ2UpID0+IGVkZ2UuaWQpKTtcbiAqICB9LCBbXSk7XG4gKlxuICogIHVzZU9uU2VsZWN0aW9uQ2hhbmdlKHtcbiAqICAgIG9uQ2hhbmdlLFxuICogIH0pO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPGRpdj5cbiAqICAgICAgPHA+U2VsZWN0ZWQgbm9kZXM6IHtzZWxlY3RlZE5vZGVzLmpvaW4oJywgJyl9PC9wPlxuICogICAgICA8cD5TZWxlY3RlZCBlZGdlczoge3NlbGVjdGVkRWRnZXMuam9pbignLCAnKX08L3A+XG4gKiAgICA8L2Rpdj5cbiAqICApO1xuICp9XG4gKmBgYFxuICpcbiAqIEByZW1hcmtzIFlvdSBuZWVkIHRvIG1lbW9pemUgdGhlIHBhc3NlZCBgb25DaGFuZ2VgIGhhbmRsZXIsIG90aGVyd2lzZSB0aGUgaG9vayB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseS5cbiAqL1xuZnVuY3Rpb24gdXNlT25TZWxlY3Rpb25DaGFuZ2UoeyBvbkNoYW5nZSwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBuZXh0T25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVycyA9IFsuLi5zdG9yZS5nZXRTdGF0ZSgpLm9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMsIG9uQ2hhbmdlXTtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBvblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzOiBuZXh0T25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVycyB9KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRIYW5kbGVycyA9IHN0b3JlLmdldFN0YXRlKCkub25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVycy5maWx0ZXIoKGZuKSA9PiBmbiAhPT0gb25DaGFuZ2UpO1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBvblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzOiBuZXh0SGFuZGxlcnMgfSk7XG4gICAgICAgIH07XG4gICAgfSwgW29uQ2hhbmdlXSk7XG59XG5cbmNvbnN0IHNlbGVjdG9yJDQgPSAob3B0aW9ucykgPT4gKHMpID0+IHtcbiAgICBpZiAoIW9wdGlvbnMuaW5jbHVkZUhpZGRlbk5vZGVzKSB7XG4gICAgICAgIHJldHVybiBzLm5vZGVzSW5pdGlhbGl6ZWQ7XG4gICAgfVxuICAgIGlmIChzLm5vZGVMb29rdXAuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3QgWywgeyBpbnRlcm5hbHMgfV0gb2Ygcy5ub2RlTG9va3VwKSB7XG4gICAgICAgIGlmIChpbnRlcm5hbHMuaGFuZGxlQm91bmRzID09PSB1bmRlZmluZWQgfHwgIW5vZGVIYXNEaW1lbnNpb25zKGludGVybmFscy51c2VyTm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbiAqIFRoaXMgaG9vayB0ZWxscyB5b3Ugd2hldGhlciBhbGwgdGhlIG5vZGVzIGluIGEgZmxvdyBoYXZlIGJlZW4gbWVhc3VyZWQgYW5kIGdpdmVuXG4gKmEgd2lkdGggYW5kIGhlaWdodC4gV2hlbiB5b3UgYWRkIGEgbm9kZSB0byB0aGUgZmxvdywgdGhpcyBob29rIHdpbGwgcmV0dXJuXG4gKmBmYWxzZWAgYW5kIHRoZW4gYHRydWVgIGFnYWluIG9uY2UgdGhlIG5vZGUgaGFzIGJlZW4gbWVhc3VyZWQuXG4gKlxuICogQHB1YmxpY1xuICogQHJldHVybnMgV2hldGhlciBvciBub3QgdGhlIG5vZGVzIGhhdmUgYmVlbiBpbml0aWFsaXplZCBieSB0aGUgYDxSZWFjdEZsb3cgLz5gIGNvbXBvbmVudCBhbmRcbiAqIGdpdmVuIGEgd2lkdGggYW5kIGhlaWdodC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKmltcG9ydCB7IHVzZVJlYWN0RmxvdywgdXNlTm9kZXNJbml0aWFsaXplZCB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICppbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuICpcbiAqY29uc3Qgb3B0aW9ucyA9IHtcbiAqICBpbmNsdWRlSGlkZGVuTm9kZXM6IGZhbHNlLFxuICp9O1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlTGF5b3V0KCkge1xuICogIGNvbnN0IHsgZ2V0Tm9kZXMgfSA9IHVzZVJlYWN0RmxvdygpO1xuICogIGNvbnN0IG5vZGVzSW5pdGlhbGl6ZWQgPSB1c2VOb2Rlc0luaXRpYWxpemVkKG9wdGlvbnMpO1xuICogIGNvbnN0IFtsYXlvdXRlZE5vZGVzLCBzZXRMYXlvdXRlZE5vZGVzXSA9IHVzZVN0YXRlKGdldE5vZGVzKCkpO1xuICpcbiAqICB1c2VFZmZlY3QoKCkgPT4ge1xuICogICAgaWYgKG5vZGVzSW5pdGlhbGl6ZWQpIHtcbiAqICAgICAgc2V0TGF5b3V0ZWROb2Rlcyh5b3VyTGF5b3V0aW5nRnVuY3Rpb24oZ2V0Tm9kZXMoKSkpO1xuICogICAgfVxuICogIH0sIFtub2Rlc0luaXRpYWxpemVkXSk7XG4gKlxuICogIHJldHVybiBsYXlvdXRlZE5vZGVzO1xuICp9XG4gKmBgYFxuICovXG5mdW5jdGlvbiB1c2VOb2Rlc0luaXRpYWxpemVkKG9wdGlvbnMgPSB7XG4gICAgaW5jbHVkZUhpZGRlbk5vZGVzOiBmYWxzZSxcbn0pIHtcbiAgICBjb25zdCBpbml0aWFsaXplZCA9IHVzZVN0b3JlKHNlbGVjdG9yJDQob3B0aW9ucykpO1xuICAgIHJldHVybiBpbml0aWFsaXplZDtcbn1cblxuLyoqXG4gKiBIb29rIHRvIGNoZWNrIGlmIGEgPEhhbmRsZSAvPiBpcyBjb25uZWN0ZWQgdG8gYW5vdGhlciA8SGFuZGxlIC8+IGFuZCBnZXQgdGhlIGNvbm5lY3Rpb25zLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBkZXByZWNhdGVkIFVzZSBgdXNlTm9kZUNvbm5lY3Rpb25zYCBpbnN0ZWFkLlxuICogQHJldHVybnMgQW4gYXJyYXkgd2l0aCBoYW5kbGUgY29ubmVjdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIHVzZUhhbmRsZUNvbm5lY3Rpb25zKHsgdHlwZSwgaWQsIG5vZGVJZCwgb25Db25uZWN0LCBvbkRpc2Nvbm5lY3QsIH0pIHtcbiAgICBjb25zb2xlLndhcm4oJ1tERVBSRUNBVEVEXSBgdXNlSGFuZGxlQ29ubmVjdGlvbnNgIGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQgdXNlIGB1c2VOb2RlQ29ubmVjdGlvbnNgIGh0dHBzOi8vcmVhY3RmbG93LmRldi9hcGktcmVmZXJlbmNlL2hvb2tzL3VzZU5vZGVDb25uZWN0aW9ucycpO1xuICAgIGNvbnN0IF9ub2RlSWQgPSB1c2VOb2RlSWQoKTtcbiAgICBjb25zdCBjdXJyZW50Tm9kZUlkID0gbm9kZUlkID8/IF9ub2RlSWQ7XG4gICAgY29uc3QgcHJldkNvbm5lY3Rpb25zID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gdXNlU3RvcmUoKHN0YXRlKSA9PiBzdGF0ZS5jb25uZWN0aW9uTG9va3VwLmdldChgJHtjdXJyZW50Tm9kZUlkfS0ke3R5cGV9JHtpZCA/IGAtJHtpZH1gIDogJyd9YCksIGFyZUNvbm5lY3Rpb25NYXBzRXF1YWwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIEB0b2RvIGRpY3VzcyBpZiBvbkNvbm5lY3Qvb25EaXNjb25uZWN0IHNob3VsZCBiZSBjYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IG1vdW50cy91bm1vdW50c1xuICAgICAgICBpZiAocHJldkNvbm5lY3Rpb25zLmN1cnJlbnQgJiYgcHJldkNvbm5lY3Rpb25zLmN1cnJlbnQgIT09IGNvbm5lY3Rpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBfY29ubmVjdGlvbnMgPSBjb25uZWN0aW9ucyA/PyBuZXcgTWFwKCk7XG4gICAgICAgICAgICBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlKHByZXZDb25uZWN0aW9ucy5jdXJyZW50LCBfY29ubmVjdGlvbnMsIG9uRGlzY29ubmVjdCk7XG4gICAgICAgICAgICBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlKF9jb25uZWN0aW9ucywgcHJldkNvbm5lY3Rpb25zLmN1cnJlbnQsIG9uQ29ubmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJldkNvbm5lY3Rpb25zLmN1cnJlbnQgPSBjb25uZWN0aW9ucyA/PyBuZXcgTWFwKCk7XG4gICAgfSwgW2Nvbm5lY3Rpb25zLCBvbkNvbm5lY3QsIG9uRGlzY29ubmVjdF0pO1xuICAgIHJldHVybiB1c2VNZW1vKCgpID0+IEFycmF5LmZyb20oY29ubmVjdGlvbnM/LnZhbHVlcygpID8/IFtdKSwgW2Nvbm5lY3Rpb25zXSk7XG59XG5cbmNvbnN0IGVycm9yMDE0ID0gZXJyb3JNZXNzYWdlc1snZXJyb3IwMTQnXSgpO1xuLyoqXG4gKiBUaGlzIGhvb2sgcmV0dXJucyBhbiBhcnJheSBvZiBjb25uZWN0aW9ucyBvbiBhIHNwZWNpZmljIG5vZGUsIGhhbmRsZSB0eXBlICgnc291cmNlJywgJ3RhcmdldCcpIG9yIGhhbmRsZSBJRC5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyBBbiBhcnJheSB3aXRoIGNvbm5lY3Rpb25zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgdXNlTm9kZUNvbm5lY3Rpb25zIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gKiAgY29uc3QgY29ubmVjdGlvbnMgPSB1c2VOb2RlQ29ubmVjdGlvbnMoe1xuICogICAgaGFuZGxlVHlwZTogJ3RhcmdldCcsXG4gKiAgICBoYW5kbGVJZDogJ215LWhhbmRsZScsXG4gKiAgfSk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8ZGl2PlRoZXJlIGFyZSBjdXJyZW50bHkge2Nvbm5lY3Rpb25zLmxlbmd0aH0gaW5jb21pbmcgY29ubmVjdGlvbnMhPC9kaXY+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqL1xuZnVuY3Rpb24gdXNlTm9kZUNvbm5lY3Rpb25zKHsgaWQsIGhhbmRsZVR5cGUsIGhhbmRsZUlkLCBvbkNvbm5lY3QsIG9uRGlzY29ubmVjdCwgfSA9IHt9KSB7XG4gICAgY29uc3Qgbm9kZUlkID0gdXNlTm9kZUlkKCk7XG4gICAgY29uc3QgY3VycmVudE5vZGVJZCA9IGlkID8/IG5vZGVJZDtcbiAgICBpZiAoIWN1cnJlbnROb2RlSWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yMDE0KTtcbiAgICB9XG4gICAgY29uc3QgcHJldkNvbm5lY3Rpb25zID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gdXNlU3RvcmUoKHN0YXRlKSA9PiBzdGF0ZS5jb25uZWN0aW9uTG9va3VwLmdldChgJHtjdXJyZW50Tm9kZUlkfSR7aGFuZGxlVHlwZSA/IChoYW5kbGVJZCA/IGAtJHtoYW5kbGVUeXBlfS0ke2hhbmRsZUlkfWAgOiBgLSR7aGFuZGxlVHlwZX1gKSA6ICcnfWApLCBhcmVDb25uZWN0aW9uTWFwc0VxdWFsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvLyBAdG9kbyBkaXNjdXNzIGlmIG9uQ29ubmVjdC9vbkRpc2Nvbm5lY3Qgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgbW91bnRzL3VubW91bnRzXG4gICAgICAgIGlmIChwcmV2Q29ubmVjdGlvbnMuY3VycmVudCAmJiBwcmV2Q29ubmVjdGlvbnMuY3VycmVudCAhPT0gY29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IF9jb25uZWN0aW9ucyA9IGNvbm5lY3Rpb25zID8/IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGhhbmRsZUNvbm5lY3Rpb25DaGFuZ2UocHJldkNvbm5lY3Rpb25zLmN1cnJlbnQsIF9jb25uZWN0aW9ucywgb25EaXNjb25uZWN0KTtcbiAgICAgICAgICAgIGhhbmRsZUNvbm5lY3Rpb25DaGFuZ2UoX2Nvbm5lY3Rpb25zLCBwcmV2Q29ubmVjdGlvbnMuY3VycmVudCwgb25Db25uZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2Q29ubmVjdGlvbnMuY3VycmVudCA9IGNvbm5lY3Rpb25zID8/IG5ldyBNYXAoKTtcbiAgICB9LCBbY29ubmVjdGlvbnMsIG9uQ29ubmVjdCwgb25EaXNjb25uZWN0XSk7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gQXJyYXkuZnJvbShjb25uZWN0aW9ucz8udmFsdWVzKCkgPz8gW10pLCBbY29ubmVjdGlvbnNdKTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIHVzZU5vZGVzRGF0YShub2RlSWRzKSB7XG4gICAgY29uc3Qgbm9kZXNEYXRhID0gdXNlU3RvcmUodXNlQ2FsbGJhY2soKHMpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IFtdO1xuICAgICAgICBjb25zdCBpc0FycmF5T2ZJZHMgPSBBcnJheS5pc0FycmF5KG5vZGVJZHMpO1xuICAgICAgICBjb25zdCBfbm9kZUlkcyA9IGlzQXJyYXlPZklkcyA/IG5vZGVJZHMgOiBbbm9kZUlkc107XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZUlkIG9mIF9ub2RlSWRzKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gcy5ub2RlTG9va3VwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogbm9kZS50eXBlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBub2RlLmRhdGEsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQXJyYXlPZklkcyA/IGRhdGEgOiBkYXRhWzBdID8/IG51bGw7XG4gICAgfSwgW25vZGVJZHNdKSwgc2hhbGxvd05vZGVEYXRhKTtcbiAgICByZXR1cm4gbm9kZXNEYXRhO1xufVxuXG4vKipcbiAqIFRoaXMgaG9vayByZXR1cm5zIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBhIHNwZWNpZmljIG5vZGUuXG4gKiBDb21wb25lbnRzIHRoYXQgdXNlIHRoaXMgaG9vayB3aWxsIHJlLXJlbmRlciAqKndoZW5ldmVyIHRoZSBub2RlIGNoYW5nZXMqKixcbiAqIGluY2x1ZGluZyB3aGVuIGEgbm9kZSBpcyBzZWxlY3RlZCBvciBtb3ZlZC5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gaWQgLSBUaGUgSUQgb2YgYSBub2RlIHlvdSB3YW50IHRvIG9ic2VydmUuXG4gKiBAcmV0dXJucyBUaGUgYEludGVybmFsTm9kZWAgb2JqZWN0IGZvciB0aGUgbm9kZSB3aXRoIHRoZSBnaXZlbiBJRC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKmltcG9ydCB7IHVzZUludGVybmFsTm9kZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICogIGNvbnN0IGludGVybmFsTm9kZSA9IHVzZUludGVybmFsTm9kZSgnbm9kZS0xJyk7XG4gKiAgY29uc3QgYWJzb2x1dGVQb3NpdGlvbiA9IGludGVybmFsTm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxkaXY+XG4gKiAgICAgIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgbm9kZSBpcyBhdDpcbiAqICAgICAgPHA+eDoge2Fic29sdXRlUG9zaXRpb24ueH08L3A+XG4gKiAgICAgIDxwPnk6IHthYnNvbHV0ZVBvc2l0aW9uLnl9PC9wPlxuICogICAgPC9kaXY+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqL1xuZnVuY3Rpb24gdXNlSW50ZXJuYWxOb2RlKGlkKSB7XG4gICAgY29uc3Qgbm9kZSA9IHVzZVN0b3JlKHVzZUNhbGxiYWNrKChzKSA9PiBzLm5vZGVMb29rdXAuZ2V0KGlkKSwgW2lkXSksIHNoYWxsb3cpO1xuICAgIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBMaW5lUGF0dGVybih7IGRpbWVuc2lvbnMsIGxpbmVXaWR0aCwgdmFyaWFudCwgY2xhc3NOYW1lIH0pIHtcbiAgICByZXR1cm4gKGpzeChcInBhdGhcIiwgeyBzdHJva2VXaWR0aDogbGluZVdpZHRoLCBkOiBgTSR7ZGltZW5zaW9uc1swXSAvIDJ9IDAgViR7ZGltZW5zaW9uc1sxXX0gTTAgJHtkaW1lbnNpb25zWzFdIC8gMn0gSCR7ZGltZW5zaW9uc1swXX1gLCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fYmFja2dyb3VuZC1wYXR0ZXJuJywgdmFyaWFudCwgY2xhc3NOYW1lXSkgfSkpO1xufVxuZnVuY3Rpb24gRG90UGF0dGVybih7IHJhZGl1cywgY2xhc3NOYW1lIH0pIHtcbiAgICByZXR1cm4gKGpzeChcImNpcmNsZVwiLCB7IGN4OiByYWRpdXMsIGN5OiByYWRpdXMsIHI6IHJhZGl1cywgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX2JhY2tncm91bmQtcGF0dGVybicsICdkb3RzJywgY2xhc3NOYW1lXSkgfSkpO1xufVxuXG4vKipcbiAqIFRoZSB0aHJlZSB2YXJpYW50cyBhcmUgZXhwb3J0ZWQgYXMgYW4gZW51bSBmb3IgY29udmVuaWVuY2UuIFlvdSBjYW4gZWl0aGVyIGltcG9ydFxuICogdGhlIGVudW0gYW5kIHVzZSBpdCBsaWtlIGBCYWNrZ3JvdW5kVmFyaWFudC5MaW5lc2Agb3IgeW91IGNhbiB1c2UgdGhlIHJhdyBzdHJpbmdcbiAqIHZhbHVlIGRpcmVjdGx5LlxuICogQHB1YmxpY1xuICovXG52YXIgQmFja2dyb3VuZFZhcmlhbnQ7XG4oZnVuY3Rpb24gKEJhY2tncm91bmRWYXJpYW50KSB7XG4gICAgQmFja2dyb3VuZFZhcmlhbnRbXCJMaW5lc1wiXSA9IFwibGluZXNcIjtcbiAgICBCYWNrZ3JvdW5kVmFyaWFudFtcIkRvdHNcIl0gPSBcImRvdHNcIjtcbiAgICBCYWNrZ3JvdW5kVmFyaWFudFtcIkNyb3NzXCJdID0gXCJjcm9zc1wiO1xufSkoQmFja2dyb3VuZFZhcmlhbnQgfHwgKEJhY2tncm91bmRWYXJpYW50ID0ge30pKTtcblxuY29uc3QgZGVmYXVsdFNpemUgPSB7XG4gICAgW0JhY2tncm91bmRWYXJpYW50LkRvdHNdOiAxLFxuICAgIFtCYWNrZ3JvdW5kVmFyaWFudC5MaW5lc106IDEsXG4gICAgW0JhY2tncm91bmRWYXJpYW50LkNyb3NzXTogNixcbn07XG5jb25zdCBzZWxlY3RvciQzID0gKHMpID0+ICh7IHRyYW5zZm9ybTogcy50cmFuc2Zvcm0sIHBhdHRlcm5JZDogYHBhdHRlcm4tJHtzLnJmSWR9YCB9KTtcbmZ1bmN0aW9uIEJhY2tncm91bmRDb21wb25lbnQoeyBpZCwgdmFyaWFudCA9IEJhY2tncm91bmRWYXJpYW50LkRvdHMsIFxuLy8gb25seSB1c2VkIGZvciBkb3RzIGFuZCBjcm9zc1xuZ2FwID0gMjAsIFxuLy8gb25seSB1c2VkIGZvciBsaW5lcyBhbmQgY3Jvc3NcbnNpemUsIGxpbmVXaWR0aCA9IDEsIG9mZnNldCA9IDAsIGNvbG9yLCBiZ0NvbG9yLCBzdHlsZSwgY2xhc3NOYW1lLCBwYXR0ZXJuQ2xhc3NOYW1lLCB9KSB7XG4gICAgY29uc3QgcmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHsgdHJhbnNmb3JtLCBwYXR0ZXJuSWQgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJDMsIHNoYWxsb3cpO1xuICAgIGNvbnN0IHBhdHRlcm5TaXplID0gc2l6ZSB8fCBkZWZhdWx0U2l6ZVt2YXJpYW50XTtcbiAgICBjb25zdCBpc0RvdHMgPSB2YXJpYW50ID09PSBCYWNrZ3JvdW5kVmFyaWFudC5Eb3RzO1xuICAgIGNvbnN0IGlzQ3Jvc3MgPSB2YXJpYW50ID09PSBCYWNrZ3JvdW5kVmFyaWFudC5Dcm9zcztcbiAgICBjb25zdCBnYXBYWSA9IEFycmF5LmlzQXJyYXkoZ2FwKSA/IGdhcCA6IFtnYXAsIGdhcF07XG4gICAgY29uc3Qgc2NhbGVkR2FwID0gW2dhcFhZWzBdICogdHJhbnNmb3JtWzJdIHx8IDEsIGdhcFhZWzFdICogdHJhbnNmb3JtWzJdIHx8IDFdO1xuICAgIGNvbnN0IHNjYWxlZFNpemUgPSBwYXR0ZXJuU2l6ZSAqIHRyYW5zZm9ybVsyXTtcbiAgICBjb25zdCBvZmZzZXRYWSA9IEFycmF5LmlzQXJyYXkob2Zmc2V0KSA/IG9mZnNldCA6IFtvZmZzZXQsIG9mZnNldF07XG4gICAgY29uc3QgcGF0dGVybkRpbWVuc2lvbnMgPSBpc0Nyb3NzID8gW3NjYWxlZFNpemUsIHNjYWxlZFNpemVdIDogc2NhbGVkR2FwO1xuICAgIGNvbnN0IHNjYWxlZE9mZnNldCA9IFtcbiAgICAgICAgb2Zmc2V0WFlbMF0gKiB0cmFuc2Zvcm1bMl0gfHwgMSArIHBhdHRlcm5EaW1lbnNpb25zWzBdIC8gMixcbiAgICAgICAgb2Zmc2V0WFlbMV0gKiB0cmFuc2Zvcm1bMl0gfHwgMSArIHBhdHRlcm5EaW1lbnNpb25zWzFdIC8gMixcbiAgICBdO1xuICAgIGNvbnN0IF9wYXR0ZXJuSWQgPSBgJHtwYXR0ZXJuSWR9JHtpZCA/IGlkIDogJyd9YDtcbiAgICByZXR1cm4gKGpzeHMoXCJzdmdcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fYmFja2dyb3VuZCcsIGNsYXNzTmFtZV0pLCBzdHlsZToge1xuICAgICAgICAgICAgLi4uc3R5bGUsXG4gICAgICAgICAgICAuLi5jb250YWluZXJTdHlsZSxcbiAgICAgICAgICAgICctLXh5LWJhY2tncm91bmQtY29sb3ItcHJvcHMnOiBiZ0NvbG9yLFxuICAgICAgICAgICAgJy0teHktYmFja2dyb3VuZC1wYXR0ZXJuLWNvbG9yLXByb3BzJzogY29sb3IsXG4gICAgICAgIH0sIHJlZjogcmVmLCBcImRhdGEtdGVzdGlkXCI6IFwicmZfX2JhY2tncm91bmRcIiwgY2hpbGRyZW46IFtqc3goXCJwYXR0ZXJuXCIsIHsgaWQ6IF9wYXR0ZXJuSWQsIHg6IHRyYW5zZm9ybVswXSAlIHNjYWxlZEdhcFswXSwgeTogdHJhbnNmb3JtWzFdICUgc2NhbGVkR2FwWzFdLCB3aWR0aDogc2NhbGVkR2FwWzBdLCBoZWlnaHQ6IHNjYWxlZEdhcFsxXSwgcGF0dGVyblVuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCIsIHBhdHRlcm5UcmFuc2Zvcm06IGB0cmFuc2xhdGUoLSR7c2NhbGVkT2Zmc2V0WzBdfSwtJHtzY2FsZWRPZmZzZXRbMV19KWAsIGNoaWxkcmVuOiBpc0RvdHMgPyAoanN4KERvdFBhdHRlcm4sIHsgcmFkaXVzOiBzY2FsZWRTaXplIC8gMiwgY2xhc3NOYW1lOiBwYXR0ZXJuQ2xhc3NOYW1lIH0pKSA6IChqc3goTGluZVBhdHRlcm4sIHsgZGltZW5zaW9uczogcGF0dGVybkRpbWVuc2lvbnMsIGxpbmVXaWR0aDogbGluZVdpZHRoLCB2YXJpYW50OiB2YXJpYW50LCBjbGFzc05hbWU6IHBhdHRlcm5DbGFzc05hbWUgfSkpIH0pLCBqc3goXCJyZWN0XCIsIHsgeDogXCIwXCIsIHk6IFwiMFwiLCB3aWR0aDogXCIxMDAlXCIsIGhlaWdodDogXCIxMDAlXCIsIGZpbGw6IGB1cmwoIyR7X3BhdHRlcm5JZH0pYCB9KV0gfSkpO1xufVxuQmFja2dyb3VuZENvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdCYWNrZ3JvdW5kJztcbi8qKlxuICogVGhlIGA8QmFja2dyb3VuZCAvPmAgY29tcG9uZW50IG1ha2VzIGl0IGNvbnZlbmllbnQgdG8gcmVuZGVyIGRpZmZlcmVudCB0eXBlcyBvZiBiYWNrZ3JvdW5kcyBjb21tb24gaW4gbm9kZS1iYXNlZCBVSXMuIEl0IGNvbWVzIHdpdGggdGhyZWUgdmFyaWFudHM6IGxpbmVzLCBkb3RzIGFuZCBjcm9zcy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIEEgc2ltcGxlIGV4YW1wbGUgb2YgaG93IHRvIHVzZSB0aGUgQmFja2dyb3VuZCBjb21wb25lbnQuXG4gKlxuICogYGBgdHN4XG4gKiBpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbiAqIGltcG9ydCB7IFJlYWN0RmxvdywgQmFja2dyb3VuZCwgQmFja2dyb3VuZFZhcmlhbnQgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogICByZXR1cm4gKFxuICogICAgIDxSZWFjdEZsb3cgZGVmYXVsdE5vZGVzPXtbLi4uXX0gZGVmYXVsdEVkZ2VzPXtbLi4uXX0+XG4gKiAgICAgICA8QmFja2dyb3VuZCBjb2xvcj1cIiNjY2NcIiB2YXJpYW50PXtCYWNrZ3JvdW5kVmFyaWFudC5Eb3RzfSAvPlxuICogICAgIDwvUmVhY3RGbG93PlxuICogICApO1xuICogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBJbiB0aGlzIGV4YW1wbGUgeW91IGNhbiBzZWUgaG93IHRvIGNvbWJpbmUgbXVsdGlwbGUgYmFja2dyb3VuZHNcbiAqXG4gKiBgYGB0c3hcbiAqIGltcG9ydCB7IFJlYWN0RmxvdywgQmFja2dyb3VuZCwgQmFja2dyb3VuZFZhcmlhbnQgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqIGltcG9ydCAnQHh5Zmxvdy9yZWFjdC9kaXN0L3N0eWxlLmNzcyc7XG4gKlxuICogZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmxvdygpIHtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8UmVhY3RGbG93IGRlZmF1bHROb2Rlcz17Wy4uLl19IGRlZmF1bHRFZGdlcz17Wy4uLl19PlxuICogICAgICAgPEJhY2tncm91bmRcbiAqICAgICAgICAgaWQ9XCIxXCJcbiAqICAgICAgICAgZ2FwPXsxMH1cbiAqICAgICAgICAgY29sb3I9XCIjZjFmMWYxXCJcbiAqICAgICAgICAgdmFyaWFudD17QmFja2dyb3VuZFZhcmlhbnQuTGluZXN9XG4gKiAgICAgICAvPlxuICogICAgICAgPEJhY2tncm91bmRcbiAqICAgICAgICAgaWQ9XCIyXCJcbiAqICAgICAgICAgZ2FwPXsxMDB9XG4gKiAgICAgICAgIGNvbG9yPVwiI2NjY1wiXG4gKiAgICAgICAgIHZhcmlhbnQ9e0JhY2tncm91bmRWYXJpYW50LkxpbmVzfVxuICogICAgICAgLz5cbiAqICAgICA8L1JlYWN0Rmxvdz5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEByZW1hcmtzXG4gKlxuICogV2hlbiBjb21iaW5pbmcgbXVsdGlwbGUgPEJhY2tncm91bmQgLz4gY29tcG9uZW50cyBpdOKAmXMgaW1wb3J0YW50IHRvIGdpdmUgZWFjaCBvZiB0aGVtIGEgdW5pcXVlIGlkIHByb3AhXG4gKlxuICovXG5jb25zdCBCYWNrZ3JvdW5kID0gbWVtbyhCYWNrZ3JvdW5kQ29tcG9uZW50KTtcblxuZnVuY3Rpb24gUGx1c0ljb24oKSB7XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAzMiAzMlwiLCBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7IGQ6IFwiTTMyIDE4LjEzM0gxOC4xMzNWMzJoLTQuMjY2VjE4LjEzM0gwdi00LjI2NmgxMy44NjdWMGg0LjI2NnYxMy44NjdIMzJ6XCIgfSkgfSkpO1xufVxuXG5mdW5jdGlvbiBNaW51c0ljb24oKSB7XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAzMiA1XCIsIGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHsgZDogXCJNMCAwaDMydjQuMkgwelwiIH0pIH0pKTtcbn1cblxuZnVuY3Rpb24gRml0Vmlld0ljb24oKSB7XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAzMiAzMFwiLCBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7IGQ6IFwiTTMuNjkyIDQuNjNjMC0uNTMuNC0uOTM4LjkzOS0uOTM4aDUuMjE1VjBINC43MDhDMi4xMyAwIDAgMi4wNTQgMCA0LjYzdjUuMjE2aDMuNjkyVjQuNjMxek0yNy4zNTQgMGgtNS4ydjMuNjkyaDUuMTdjLjUzIDAgLjk4NC40Ljk4NC45Mzl2NS4yMTVIMzJWNC42MzFBNC42MjQgNC42MjQgMCAwMDI3LjM1NCAwem0uOTU0IDI0LjgzYzAgLjUzMi0uNC45NC0uOTM5Ljk0aC01LjIxNXYzLjc2OGg1LjIxNWMyLjU3NyAwIDQuNjMxLTIuMTMgNC42MzEtNC43MDd2LTUuMTM5aC0zLjY5MnY1LjEzOXptLTIzLjY3Ny45NGMtLjUzMSAwLS45MzktLjQtLjkzOS0uOTR2LTUuMTM4SDB2NS4xMzljMCAyLjU3NyAyLjEzIDQuNzA3IDQuNzA4IDQuNzA3aDUuMTM4VjI1Ljc3SDQuNjMxelwiIH0pIH0pKTtcbn1cblxuZnVuY3Rpb24gTG9ja0ljb24oKSB7XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAyNSAzMlwiLCBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7IGQ6IFwiTTIxLjMzMyAxMC42NjdIMTkuODFWNy42MTlDMTkuODEgMy40MjkgMTYuMzggMCAxMi4xOSAwIDggMCA0LjU3MSAzLjQyOSA0LjU3MSA3LjYxOXYzLjA0OEgzLjA0OEEzLjA1NiAzLjA1NiAwIDAwMCAxMy43MTR2MTUuMjM4QTMuMDU2IDMuMDU2IDAgMDAzLjA0OCAzMmgxOC4yODVhMy4wNTYgMy4wNTYgMCAwMDMuMDQ4LTMuMDQ4VjEzLjcxNGEzLjA1NiAzLjA1NiAwIDAwLTMuMDQ4LTMuMDQ3ek0xMi4xOSAyNC41MzNhMy4wNTYgMy4wNTYgMCAwMS0zLjA0Ny0zLjA0NyAzLjA1NiAzLjA1NiAwIDAxMy4wNDctMy4wNDggMy4wNTYgMy4wNTYgMCAwMTMuMDQ4IDMuMDQ4IDMuMDU2IDMuMDU2IDAgMDEtMy4wNDggMy4wNDd6bTQuNzI0LTEzLjg2Nkg3LjQ2N1Y3LjYxOWMwLTIuNTkgMi4xMzMtNC43MjQgNC43MjMtNC43MjQgMi41OTEgMCA0LjcyNCAyLjEzMyA0LjcyNCA0LjcyNHYzLjA0OHpcIiB9KSB9KSk7XG59XG5cbmZ1bmN0aW9uIFVubG9ja0ljb24oKSB7XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAyNSAzMlwiLCBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7IGQ6IFwiTTIxLjMzMyAxMC42NjdIMTkuODFWNy42MTlDMTkuODEgMy40MjkgMTYuMzggMCAxMi4xOSAwYy00LjExNCAxLjgyOC0xLjM3IDIuMTMzLjMwNSAyLjQzOCAxLjY3Ni4zMDUgNC40MiAyLjU5IDQuNDIgNS4xODF2My4wNDhIMy4wNDdBMy4wNTYgMy4wNTYgMCAwMDAgMTMuNzE0djE1LjIzOEEzLjA1NiAzLjA1NiAwIDAwMy4wNDggMzJoMTguMjg1YTMuMDU2IDMuMDU2IDAgMDAzLjA0OC0zLjA0OFYxMy43MTRhMy4wNTYgMy4wNTYgMCAwMC0zLjA0OC0zLjA0N3pNMTIuMTkgMjQuNTMzYTMuMDU2IDMuMDU2IDAgMDEtMy4wNDctMy4wNDcgMy4wNTYgMy4wNTYgMCAwMTMuMDQ3LTMuMDQ4IDMuMDU2IDMuMDU2IDAgMDEzLjA0OCAzLjA0OCAzLjA1NiAzLjA1NiAwIDAxLTMuMDQ4IDMuMDQ3elwiIH0pIH0pKTtcbn1cblxuLyoqXG4gKiBZb3UgY2FuIGFkZCBidXR0b25zIHRvIHRoZSBjb250cm9sIHBhbmVsIGJ5IHVzaW5nIHRoZSBgPENvbnRyb2xCdXR0b24gLz5gIGNvbXBvbmVudFxuICogYW5kIHBhc3MgaXQgYXMgYSBjaGlsZCB0byB0aGUgW2A8Q29udHJvbHMgLz5gXSgvYXBpLXJlZmVyZW5jZS9jb21wb25lbnRzL2NvbnRyb2xzKSBjb21wb25lbnQuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqYGBganN4XG4gKmltcG9ydCB7IE1hZ2ljV2FuZCB9IGZyb20gJ0ByYWRpeC11aS9yZWFjdC1pY29ucydcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCBDb250cm9scywgQ29udHJvbEJ1dHRvbiB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnXG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93IG5vZGVzPXtbLi4uXX0gZWRnZXM9e1suLi5dfT5cbiAqICAgICAgPENvbnRyb2xzPlxuICogICAgICAgIDxDb250cm9sQnV0dG9uIG9uQ2xpY2s9eygpID0+IGFsZXJ0KCdTb21ldGhpbmcgbWFnaWNhbCBqdXN0IGhhcHBlbmVkLiDinKgnKX0+XG4gKiAgICAgICAgICA8TWFnaWNXYW5kIC8+XG4gKiAgICAgICAgPC9Db250cm9sQnV0dG9uPlxuICogICAgICA8L0NvbnRyb2xzPlxuICogICAgPC9SZWFjdEZsb3c+XG4gKiAgKVxuICp9XG4gKmBgYFxuICovXG5mdW5jdGlvbiBDb250cm9sQnV0dG9uKHsgY2hpbGRyZW4sIGNsYXNzTmFtZSwgLi4ucmVzdCB9KSB7XG4gICAgcmV0dXJuIChqc3goXCJidXR0b25cIiwgeyB0eXBlOiBcImJ1dHRvblwiLCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fY29udHJvbHMtYnV0dG9uJywgY2xhc3NOYW1lXSksIC4uLnJlc3QsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59XG5cbmNvbnN0IHNlbGVjdG9yJDIgPSAocykgPT4gKHtcbiAgICBpc0ludGVyYWN0aXZlOiBzLm5vZGVzRHJhZ2dhYmxlIHx8IHMubm9kZXNDb25uZWN0YWJsZSB8fCBzLmVsZW1lbnRzU2VsZWN0YWJsZSxcbiAgICBtaW5ab29tUmVhY2hlZDogcy50cmFuc2Zvcm1bMl0gPD0gcy5taW5ab29tLFxuICAgIG1heFpvb21SZWFjaGVkOiBzLnRyYW5zZm9ybVsyXSA+PSBzLm1heFpvb20sXG4gICAgYXJpYUxhYmVsQ29uZmlnOiBzLmFyaWFMYWJlbENvbmZpZyxcbn0pO1xuZnVuY3Rpb24gQ29udHJvbHNDb21wb25lbnQoeyBzdHlsZSwgc2hvd1pvb20gPSB0cnVlLCBzaG93Rml0VmlldyA9IHRydWUsIHNob3dJbnRlcmFjdGl2ZSA9IHRydWUsIGZpdFZpZXdPcHRpb25zLCBvblpvb21Jbiwgb25ab29tT3V0LCBvbkZpdFZpZXcsIG9uSW50ZXJhY3RpdmVDaGFuZ2UsIGNsYXNzTmFtZSwgY2hpbGRyZW4sIHBvc2l0aW9uID0gJ2JvdHRvbS1sZWZ0Jywgb3JpZW50YXRpb24gPSAndmVydGljYWwnLCAnYXJpYS1sYWJlbCc6IGFyaWFMYWJlbCwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCB7IGlzSW50ZXJhY3RpdmUsIG1pblpvb21SZWFjaGVkLCBtYXhab29tUmVhY2hlZCwgYXJpYUxhYmVsQ29uZmlnIH0gPSB1c2VTdG9yZShzZWxlY3RvciQyLCBzaGFsbG93KTtcbiAgICBjb25zdCB7IHpvb21Jbiwgem9vbU91dCwgZml0VmlldyB9ID0gdXNlUmVhY3RGbG93KCk7XG4gICAgY29uc3Qgb25ab29tSW5IYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICB6b29tSW4oKTtcbiAgICAgICAgb25ab29tSW4/LigpO1xuICAgIH07XG4gICAgY29uc3Qgb25ab29tT3V0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgem9vbU91dCgpO1xuICAgICAgICBvblpvb21PdXQ/LigpO1xuICAgIH07XG4gICAgY29uc3Qgb25GaXRWaWV3SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgZml0VmlldyhmaXRWaWV3T3B0aW9ucyk7XG4gICAgICAgIG9uRml0Vmlldz8uKCk7XG4gICAgfTtcbiAgICBjb25zdCBvblRvZ2dsZUludGVyYWN0aXZpdHkgPSAoKSA9PiB7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgIG5vZGVzRHJhZ2dhYmxlOiAhaXNJbnRlcmFjdGl2ZSxcbiAgICAgICAgICAgIG5vZGVzQ29ubmVjdGFibGU6ICFpc0ludGVyYWN0aXZlLFxuICAgICAgICAgICAgZWxlbWVudHNTZWxlY3RhYmxlOiAhaXNJbnRlcmFjdGl2ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIG9uSW50ZXJhY3RpdmVDaGFuZ2U/LighaXNJbnRlcmFjdGl2ZSk7XG4gICAgfTtcbiAgICBjb25zdCBvcmllbnRhdGlvbkNsYXNzID0gb3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/ICdob3Jpem9udGFsJyA6ICd2ZXJ0aWNhbCc7XG4gICAgcmV0dXJuIChqc3hzKFBhbmVsLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19jb250cm9scycsIG9yaWVudGF0aW9uQ2xhc3MsIGNsYXNzTmFtZV0pLCBwb3NpdGlvbjogcG9zaXRpb24sIHN0eWxlOiBzdHlsZSwgXCJkYXRhLXRlc3RpZFwiOiBcInJmX19jb250cm9sc1wiLCBcImFyaWEtbGFiZWxcIjogYXJpYUxhYmVsID8/IGFyaWFMYWJlbENvbmZpZ1snY29udHJvbHMuYXJpYUxhYmVsJ10sIGNoaWxkcmVuOiBbc2hvd1pvb20gJiYgKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goQ29udHJvbEJ1dHRvbiwgeyBvbkNsaWNrOiBvblpvb21JbkhhbmRsZXIsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19jb250cm9scy16b29taW5cIiwgdGl0bGU6IGFyaWFMYWJlbENvbmZpZ1snY29udHJvbHMuem9vbUluLmFyaWFMYWJlbCddLCBcImFyaWEtbGFiZWxcIjogYXJpYUxhYmVsQ29uZmlnWydjb250cm9scy56b29tSW4uYXJpYUxhYmVsJ10sIGRpc2FibGVkOiBtYXhab29tUmVhY2hlZCwgY2hpbGRyZW46IGpzeChQbHVzSWNvbiwge30pIH0pLCBqc3goQ29udHJvbEJ1dHRvbiwgeyBvbkNsaWNrOiBvblpvb21PdXRIYW5kbGVyLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fY29udHJvbHMtem9vbW91dFwiLCB0aXRsZTogYXJpYUxhYmVsQ29uZmlnWydjb250cm9scy56b29tT3V0LmFyaWFMYWJlbCddLCBcImFyaWEtbGFiZWxcIjogYXJpYUxhYmVsQ29uZmlnWydjb250cm9scy56b29tT3V0LmFyaWFMYWJlbCddLCBkaXNhYmxlZDogbWluWm9vbVJlYWNoZWQsIGNoaWxkcmVuOiBqc3goTWludXNJY29uLCB7fSkgfSldIH0pKSwgc2hvd0ZpdFZpZXcgJiYgKGpzeChDb250cm9sQnV0dG9uLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19jb250cm9scy1maXR2aWV3XCIsIG9uQ2xpY2s6IG9uRml0Vmlld0hhbmRsZXIsIHRpdGxlOiBhcmlhTGFiZWxDb25maWdbJ2NvbnRyb2xzLmZpdFZpZXcuYXJpYUxhYmVsJ10sIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWxDb25maWdbJ2NvbnRyb2xzLmZpdFZpZXcuYXJpYUxhYmVsJ10sIGNoaWxkcmVuOiBqc3goRml0Vmlld0ljb24sIHt9KSB9KSksIHNob3dJbnRlcmFjdGl2ZSAmJiAoanN4KENvbnRyb2xCdXR0b24sIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2NvbnRyb2xzLWludGVyYWN0aXZlXCIsIG9uQ2xpY2s6IG9uVG9nZ2xlSW50ZXJhY3Rpdml0eSwgdGl0bGU6IGFyaWFMYWJlbENvbmZpZ1snY29udHJvbHMuaW50ZXJhY3RpdmUuYXJpYUxhYmVsJ10sIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWxDb25maWdbJ2NvbnRyb2xzLmludGVyYWN0aXZlLmFyaWFMYWJlbCddLCBjaGlsZHJlbjogaXNJbnRlcmFjdGl2ZSA/IGpzeChVbmxvY2tJY29uLCB7fSkgOiBqc3goTG9ja0ljb24sIHt9KSB9KSksIGNoaWxkcmVuXSB9KSk7XG59XG5Db250cm9sc0NvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdDb250cm9scyc7XG4vKipcbiAqIFRoZSBgPENvbnRyb2xzIC8+YCBjb21wb25lbnQgcmVuZGVycyBhIHNtYWxsIHBhbmVsIHRoYXQgY29udGFpbnMgY29udmVuaWVudFxuICogYnV0dG9ucyB0byB6b29tIGluLCB6b29tIG91dCwgZml0IHRoZSB2aWV3LCBhbmQgbG9jayB0aGUgdmlld3BvcnQuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqYGBgdHN4XG4gKmltcG9ydCB7IFJlYWN0RmxvdywgQ29udHJvbHMgfSBmcm9tICdAeHlmbG93L3JlYWN0J1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmxvdygpIHtcbiAqICByZXR1cm4gKFxuICogICAgPFJlYWN0RmxvdyBub2Rlcz17Wy4uLl19IGVkZ2VzPXtbLi4uXX0+XG4gKiAgICAgIDxDb250cm9scyAvPlxuICogICAgPC9SZWFjdEZsb3c+XG4gKiAgKVxuICp9XG4gKmBgYFxuICpcbiAqIEByZW1hcmtzIFRvIGV4dGVuZCBvciBjdXN0b21pc2UgdGhlIGNvbnRyb2xzLCB5b3UgY2FuIHVzZSB0aGUgW2A8Q29udHJvbEJ1dHRvbiAvPmBdKC9hcGktcmVmZXJlbmNlL2NvbXBvbmVudHMvY29udHJvbC1idXR0b24pIGNvbXBvbmVudFxuICpcbiAqL1xuY29uc3QgQ29udHJvbHMgPSBtZW1vKENvbnRyb2xzQ29tcG9uZW50KTtcblxuZnVuY3Rpb24gTWluaU1hcE5vZGVDb21wb25lbnQoeyBpZCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgc3R5bGUsIGNvbG9yLCBzdHJva2VDb2xvciwgc3Ryb2tlV2lkdGgsIGNsYXNzTmFtZSwgYm9yZGVyUmFkaXVzLCBzaGFwZVJlbmRlcmluZywgc2VsZWN0ZWQsIG9uQ2xpY2ssIH0pIHtcbiAgICBjb25zdCB7IGJhY2tncm91bmQsIGJhY2tncm91bmRDb2xvciB9ID0gc3R5bGUgfHwge307XG4gICAgY29uc3QgZmlsbCA9IChjb2xvciB8fCBiYWNrZ3JvdW5kIHx8IGJhY2tncm91bmRDb2xvcik7XG4gICAgcmV0dXJuIChqc3goXCJyZWN0XCIsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX21pbmltYXAtbm9kZScsIHsgc2VsZWN0ZWQgfSwgY2xhc3NOYW1lXSksIHg6IHgsIHk6IHksIHJ4OiBib3JkZXJSYWRpdXMsIHJ5OiBib3JkZXJSYWRpdXMsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIHN0eWxlOiB7XG4gICAgICAgICAgICBmaWxsLFxuICAgICAgICAgICAgc3Ryb2tlOiBzdHJva2VDb2xvcixcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICB9LCBzaGFwZVJlbmRlcmluZzogc2hhcGVSZW5kZXJpbmcsIG9uQ2xpY2s6IG9uQ2xpY2sgPyAoZXZlbnQpID0+IG9uQ2xpY2soZXZlbnQsIGlkKSA6IHVuZGVmaW5lZCB9KSk7XG59XG5jb25zdCBNaW5pTWFwTm9kZSA9IG1lbW8oTWluaU1hcE5vZGVDb21wb25lbnQpO1xuXG5jb25zdCBzZWxlY3Rvck5vZGVJZHMgPSAocykgPT4gcy5ub2Rlcy5tYXAoKG5vZGUpID0+IG5vZGUuaWQpO1xuY29uc3QgZ2V0QXR0ckZ1bmN0aW9uID0gKGZ1bmMpID0+IGZ1bmMgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGZ1bmMgOiAoKSA9PiBmdW5jO1xuZnVuY3Rpb24gTWluaU1hcE5vZGVzKHsgbm9kZVN0cm9rZUNvbG9yLCBub2RlQ29sb3IsIG5vZGVDbGFzc05hbWUgPSAnJywgbm9kZUJvcmRlclJhZGl1cyA9IDUsIG5vZGVTdHJva2VXaWR0aCwgXG4vKlxuICogV2UgbmVlZCB0byByZW5hbWUgdGhlIHByb3AgdG8gYmUgYENhcGl0YWxDYXNlYCBzbyB0aGF0IEpTWCB3aWxsIHJlbmRlciBpdCBhc1xuICogYSBjb21wb25lbnQgcHJvcGVybHkuXG4gKi9cbm5vZGVDb21wb25lbnQ6IE5vZGVDb21wb25lbnQgPSBNaW5pTWFwTm9kZSwgb25DbGljaywgfSkge1xuICAgIGNvbnN0IG5vZGVJZHMgPSB1c2VTdG9yZShzZWxlY3Rvck5vZGVJZHMsIHNoYWxsb3cpO1xuICAgIGNvbnN0IG5vZGVDb2xvckZ1bmMgPSBnZXRBdHRyRnVuY3Rpb24obm9kZUNvbG9yKTtcbiAgICBjb25zdCBub2RlU3Ryb2tlQ29sb3JGdW5jID0gZ2V0QXR0ckZ1bmN0aW9uKG5vZGVTdHJva2VDb2xvcik7XG4gICAgY29uc3Qgbm9kZUNsYXNzTmFtZUZ1bmMgPSBnZXRBdHRyRnVuY3Rpb24obm9kZUNsYXNzTmFtZSk7XG4gICAgY29uc3Qgc2hhcGVSZW5kZXJpbmcgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhIXdpbmRvdy5jaHJvbWUgPyAnY3Jpc3BFZGdlcycgOiAnZ2VvbWV0cmljUHJlY2lzaW9uJztcbiAgICByZXR1cm4gKGpzeChGcmFnbWVudCwgeyBjaGlsZHJlbjogbm9kZUlkcy5tYXAoKG5vZGVJZCkgPT4gKFxuICAgICAgICAvKlxuICAgICAgICAgKiBUaGUgc3BsaXQgb2YgcmVzcG9uc2liaWxpdGllcyBiZXR3ZWVuIE1pbmlNYXBOb2RlcyBhbmRcbiAgICAgICAgICogTm9kZUNvbXBvbmVudFdyYXBwZXIgbWF5IGFwcGVhciB3ZWlyZC4gSG93ZXZlciwgaXTigJlzIGRlc2lnbmVkIHRvXG4gICAgICAgICAqIG1pbmltaXplIHRoZSBjb3N0IG9mIHVwZGF0ZXMgd2hlbiBpbmRpdmlkdWFsIG5vZGVzIGNoYW5nZS5cbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgZGV0YWlscywgc2VlIGEgc2ltaWxhciBjb21taXQgaW4gYE5vZGVSZW5kZXJlci9pbmRleC50c3hgLlxuICAgICAgICAgKi9cbiAgICAgICAganN4KE5vZGVDb21wb25lbnRXcmFwcGVyLCB7IGlkOiBub2RlSWQsIG5vZGVDb2xvckZ1bmM6IG5vZGVDb2xvckZ1bmMsIG5vZGVTdHJva2VDb2xvckZ1bmM6IG5vZGVTdHJva2VDb2xvckZ1bmMsIG5vZGVDbGFzc05hbWVGdW5jOiBub2RlQ2xhc3NOYW1lRnVuYywgbm9kZUJvcmRlclJhZGl1czogbm9kZUJvcmRlclJhZGl1cywgbm9kZVN0cm9rZVdpZHRoOiBub2RlU3Ryb2tlV2lkdGgsIE5vZGVDb21wb25lbnQ6IE5vZGVDb21wb25lbnQsIG9uQ2xpY2s6IG9uQ2xpY2ssIHNoYXBlUmVuZGVyaW5nOiBzaGFwZVJlbmRlcmluZyB9LCBub2RlSWQpKSkgfSkpO1xufVxuZnVuY3Rpb24gTm9kZUNvbXBvbmVudFdyYXBwZXJJbm5lcih7IGlkLCBub2RlQ29sb3JGdW5jLCBub2RlU3Ryb2tlQ29sb3JGdW5jLCBub2RlQ2xhc3NOYW1lRnVuYywgbm9kZUJvcmRlclJhZGl1cywgbm9kZVN0cm9rZVdpZHRoLCBzaGFwZVJlbmRlcmluZywgTm9kZUNvbXBvbmVudCwgb25DbGljaywgfSkge1xuICAgIGNvbnN0IHsgbm9kZSwgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gdXNlU3RvcmUoKHMpID0+IHtcbiAgICAgICAgY29uc3QgeyBpbnRlcm5hbHMgfSA9IHMubm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgICAgICBjb25zdCBub2RlID0gaW50ZXJuYWxzLnVzZXJOb2RlO1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IGludGVybmFscy5wb3NpdGlvbkFic29sdXRlO1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGdldE5vZGVEaW1lbnNpb25zKG5vZGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5LFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgIH07XG4gICAgfSwgc2hhbGxvdyk7XG4gICAgaWYgKCFub2RlIHx8IG5vZGUuaGlkZGVuIHx8ICFub2RlSGFzRGltZW5zaW9ucyhub2RlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goTm9kZUNvbXBvbmVudCwgeyB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCBzdHlsZTogbm9kZS5zdHlsZSwgc2VsZWN0ZWQ6ICEhbm9kZS5zZWxlY3RlZCwgY2xhc3NOYW1lOiBub2RlQ2xhc3NOYW1lRnVuYyhub2RlKSwgY29sb3I6IG5vZGVDb2xvckZ1bmMobm9kZSksIGJvcmRlclJhZGl1czogbm9kZUJvcmRlclJhZGl1cywgc3Ryb2tlQ29sb3I6IG5vZGVTdHJva2VDb2xvckZ1bmMobm9kZSksIHN0cm9rZVdpZHRoOiBub2RlU3Ryb2tlV2lkdGgsIHNoYXBlUmVuZGVyaW5nOiBzaGFwZVJlbmRlcmluZywgb25DbGljazogb25DbGljaywgaWQ6IG5vZGUuaWQgfSkpO1xufVxuY29uc3QgTm9kZUNvbXBvbmVudFdyYXBwZXIgPSBtZW1vKE5vZGVDb21wb25lbnRXcmFwcGVySW5uZXIpO1xudmFyIE1pbmlNYXBOb2RlcyQxID0gbWVtbyhNaW5pTWFwTm9kZXMpO1xuXG5jb25zdCBkZWZhdWx0V2lkdGggPSAyMDA7XG5jb25zdCBkZWZhdWx0SGVpZ2h0ID0gMTUwO1xuY29uc3QgZmlsdGVySGlkZGVuID0gKG5vZGUpID0+ICFub2RlLmhpZGRlbjtcbmNvbnN0IHNlbGVjdG9yJDEgPSAocykgPT4ge1xuICAgIGNvbnN0IHZpZXdCQiA9IHtcbiAgICAgICAgeDogLXMudHJhbnNmb3JtWzBdIC8gcy50cmFuc2Zvcm1bMl0sXG4gICAgICAgIHk6IC1zLnRyYW5zZm9ybVsxXSAvIHMudHJhbnNmb3JtWzJdLFxuICAgICAgICB3aWR0aDogcy53aWR0aCAvIHMudHJhbnNmb3JtWzJdLFxuICAgICAgICBoZWlnaHQ6IHMuaGVpZ2h0IC8gcy50cmFuc2Zvcm1bMl0sXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICB2aWV3QkIsXG4gICAgICAgIGJvdW5kaW5nUmVjdDogcy5ub2RlTG9va3VwLnNpemUgPiAwXG4gICAgICAgICAgICA/IGdldEJvdW5kc09mUmVjdHMoZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyhzLm5vZGVMb29rdXAsIHsgZmlsdGVyOiBmaWx0ZXJIaWRkZW4gfSksIHZpZXdCQilcbiAgICAgICAgICAgIDogdmlld0JCLFxuICAgICAgICByZklkOiBzLnJmSWQsXG4gICAgICAgIHBhblpvb206IHMucGFuWm9vbSxcbiAgICAgICAgdHJhbnNsYXRlRXh0ZW50OiBzLnRyYW5zbGF0ZUV4dGVudCxcbiAgICAgICAgZmxvd1dpZHRoOiBzLndpZHRoLFxuICAgICAgICBmbG93SGVpZ2h0OiBzLmhlaWdodCxcbiAgICAgICAgYXJpYUxhYmVsQ29uZmlnOiBzLmFyaWFMYWJlbENvbmZpZyxcbiAgICB9O1xufTtcbmNvbnN0IEFSSUFfTEFCRUxfS0VZID0gJ3JlYWN0LWZsb3dfX21pbmltYXAtZGVzYyc7XG5mdW5jdGlvbiBNaW5pTWFwQ29tcG9uZW50KHsgc3R5bGUsIGNsYXNzTmFtZSwgbm9kZVN0cm9rZUNvbG9yLCBub2RlQ29sb3IsIG5vZGVDbGFzc05hbWUgPSAnJywgbm9kZUJvcmRlclJhZGl1cyA9IDUsIG5vZGVTdHJva2VXaWR0aCwgXG4vKlxuICogV2UgbmVlZCB0byByZW5hbWUgdGhlIHByb3AgdG8gYmUgYENhcGl0YWxDYXNlYCBzbyB0aGF0IEpTWCB3aWxsIHJlbmRlciBpdCBhc1xuICogYSBjb21wb25lbnQgcHJvcGVybHkuXG4gKi9cbm5vZGVDb21wb25lbnQsIGJnQ29sb3IsIG1hc2tDb2xvciwgbWFza1N0cm9rZUNvbG9yLCBtYXNrU3Ryb2tlV2lkdGgsIHBvc2l0aW9uID0gJ2JvdHRvbS1yaWdodCcsIG9uQ2xpY2ssIG9uTm9kZUNsaWNrLCBwYW5uYWJsZSA9IGZhbHNlLCB6b29tYWJsZSA9IGZhbHNlLCBhcmlhTGFiZWwsIGludmVyc2VQYW4sIHpvb21TdGVwID0gMSwgb2Zmc2V0U2NhbGUgPSA1LCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHN2ZyA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCB7IGJvdW5kaW5nUmVjdCwgdmlld0JCLCByZklkLCBwYW5ab29tLCB0cmFuc2xhdGVFeHRlbnQsIGZsb3dXaWR0aCwgZmxvd0hlaWdodCwgYXJpYUxhYmVsQ29uZmlnIH0gPSB1c2VTdG9yZShzZWxlY3RvciQxLCBzaGFsbG93KTtcbiAgICBjb25zdCBlbGVtZW50V2lkdGggPSBzdHlsZT8ud2lkdGggPz8gZGVmYXVsdFdpZHRoO1xuICAgIGNvbnN0IGVsZW1lbnRIZWlnaHQgPSBzdHlsZT8uaGVpZ2h0ID8/IGRlZmF1bHRIZWlnaHQ7XG4gICAgY29uc3Qgc2NhbGVkV2lkdGggPSBib3VuZGluZ1JlY3Qud2lkdGggLyBlbGVtZW50V2lkdGg7XG4gICAgY29uc3Qgc2NhbGVkSGVpZ2h0ID0gYm91bmRpbmdSZWN0LmhlaWdodCAvIGVsZW1lbnRIZWlnaHQ7XG4gICAgY29uc3Qgdmlld1NjYWxlID0gTWF0aC5tYXgoc2NhbGVkV2lkdGgsIHNjYWxlZEhlaWdodCk7XG4gICAgY29uc3Qgdmlld1dpZHRoID0gdmlld1NjYWxlICogZWxlbWVudFdpZHRoO1xuICAgIGNvbnN0IHZpZXdIZWlnaHQgPSB2aWV3U2NhbGUgKiBlbGVtZW50SGVpZ2h0O1xuICAgIGNvbnN0IG9mZnNldCA9IG9mZnNldFNjYWxlICogdmlld1NjYWxlO1xuICAgIGNvbnN0IHggPSBib3VuZGluZ1JlY3QueCAtICh2aWV3V2lkdGggLSBib3VuZGluZ1JlY3Qud2lkdGgpIC8gMiAtIG9mZnNldDtcbiAgICBjb25zdCB5ID0gYm91bmRpbmdSZWN0LnkgLSAodmlld0hlaWdodCAtIGJvdW5kaW5nUmVjdC5oZWlnaHQpIC8gMiAtIG9mZnNldDtcbiAgICBjb25zdCB3aWR0aCA9IHZpZXdXaWR0aCArIG9mZnNldCAqIDI7XG4gICAgY29uc3QgaGVpZ2h0ID0gdmlld0hlaWdodCArIG9mZnNldCAqIDI7XG4gICAgY29uc3QgbGFiZWxsZWRCeSA9IGAke0FSSUFfTEFCRUxfS0VZfS0ke3JmSWR9YDtcbiAgICBjb25zdCB2aWV3U2NhbGVSZWYgPSB1c2VSZWYoMCk7XG4gICAgY29uc3QgbWluaW1hcEluc3RhbmNlID0gdXNlUmVmKCk7XG4gICAgdmlld1NjYWxlUmVmLmN1cnJlbnQgPSB2aWV3U2NhbGU7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHN2Zy5jdXJyZW50ICYmIHBhblpvb20pIHtcbiAgICAgICAgICAgIG1pbmltYXBJbnN0YW5jZS5jdXJyZW50ID0gWFlNaW5pbWFwKHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlOiBzdmcuY3VycmVudCxcbiAgICAgICAgICAgICAgICBwYW5ab29tLFxuICAgICAgICAgICAgICAgIGdldFRyYW5zZm9ybTogKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS50cmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgZ2V0Vmlld1NjYWxlOiAoKSA9PiB2aWV3U2NhbGVSZWYuY3VycmVudCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBtaW5pbWFwSW5zdGFuY2UuY3VycmVudD8uZGVzdHJveSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtwYW5ab29tXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgbWluaW1hcEluc3RhbmNlLmN1cnJlbnQ/LnVwZGF0ZSh7XG4gICAgICAgICAgICB0cmFuc2xhdGVFeHRlbnQsXG4gICAgICAgICAgICB3aWR0aDogZmxvd1dpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBmbG93SGVpZ2h0LFxuICAgICAgICAgICAgaW52ZXJzZVBhbixcbiAgICAgICAgICAgIHBhbm5hYmxlLFxuICAgICAgICAgICAgem9vbVN0ZXAsXG4gICAgICAgICAgICB6b29tYWJsZSxcbiAgICAgICAgfSk7XG4gICAgfSwgW3Bhbm5hYmxlLCB6b29tYWJsZSwgaW52ZXJzZVBhbiwgem9vbVN0ZXAsIHRyYW5zbGF0ZUV4dGVudCwgZmxvd1dpZHRoLCBmbG93SGVpZ2h0XSk7XG4gICAgY29uc3Qgb25TdmdDbGljayA9IG9uQ2xpY2tcbiAgICAgICAgPyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFt4LCB5XSA9IG1pbmltYXBJbnN0YW5jZS5jdXJyZW50Py5wb2ludGVyKGV2ZW50KSB8fCBbMCwgMF07XG4gICAgICAgICAgICBvbkNsaWNrKGV2ZW50LCB7IHgsIHkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25TdmdOb2RlQ2xpY2sgPSBvbk5vZGVDbGlja1xuICAgICAgICA/IHVzZUNhbGxiYWNrKChldmVudCwgbm9kZUlkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gc3RvcmUuZ2V0U3RhdGUoKS5ub2RlTG9va3VwLmdldChub2RlSWQpLmludGVybmFscy51c2VyTm9kZTtcbiAgICAgICAgICAgIG9uTm9kZUNsaWNrKGV2ZW50LCBub2RlKTtcbiAgICAgICAgfSwgW10pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IF9hcmlhTGFiZWwgPSBhcmlhTGFiZWwgPz8gYXJpYUxhYmVsQ29uZmlnWydtaW5pbWFwLmFyaWFMYWJlbCddO1xuICAgIHJldHVybiAoanN4KFBhbmVsLCB7IHBvc2l0aW9uOiBwb3NpdGlvbiwgc3R5bGU6IHtcbiAgICAgICAgICAgIC4uLnN0eWxlLFxuICAgICAgICAgICAgJy0teHktbWluaW1hcC1iYWNrZ3JvdW5kLWNvbG9yLXByb3BzJzogdHlwZW9mIGJnQ29sb3IgPT09ICdzdHJpbmcnID8gYmdDb2xvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICctLXh5LW1pbmltYXAtbWFzay1iYWNrZ3JvdW5kLWNvbG9yLXByb3BzJzogdHlwZW9mIG1hc2tDb2xvciA9PT0gJ3N0cmluZycgPyBtYXNrQ29sb3IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnLS14eS1taW5pbWFwLW1hc2stc3Ryb2tlLWNvbG9yLXByb3BzJzogdHlwZW9mIG1hc2tTdHJva2VDb2xvciA9PT0gJ3N0cmluZycgPyBtYXNrU3Ryb2tlQ29sb3IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnLS14eS1taW5pbWFwLW1hc2stc3Ryb2tlLXdpZHRoLXByb3BzJzogdHlwZW9mIG1hc2tTdHJva2VXaWR0aCA9PT0gJ251bWJlcicgPyBtYXNrU3Ryb2tlV2lkdGggKiB2aWV3U2NhbGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnLS14eS1taW5pbWFwLW5vZGUtYmFja2dyb3VuZC1jb2xvci1wcm9wcyc6IHR5cGVvZiBub2RlQ29sb3IgPT09ICdzdHJpbmcnID8gbm9kZUNvbG9yIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJy0teHktbWluaW1hcC1ub2RlLXN0cm9rZS1jb2xvci1wcm9wcyc6IHR5cGVvZiBub2RlU3Ryb2tlQ29sb3IgPT09ICdzdHJpbmcnID8gbm9kZVN0cm9rZUNvbG9yIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJy0teHktbWluaW1hcC1ub2RlLXN0cm9rZS13aWR0aC1wcm9wcyc6IHR5cGVvZiBub2RlU3Ryb2tlV2lkdGggPT09ICdudW1iZXInID8gbm9kZVN0cm9rZVdpZHRoIDogdW5kZWZpbmVkLFxuICAgICAgICB9LCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fbWluaW1hcCcsIGNsYXNzTmFtZV0pLCBcImRhdGEtdGVzdGlkXCI6IFwicmZfX21pbmltYXBcIiwgY2hpbGRyZW46IGpzeHMoXCJzdmdcIiwgeyB3aWR0aDogZWxlbWVudFdpZHRoLCBoZWlnaHQ6IGVsZW1lbnRIZWlnaHQsIHZpZXdCb3g6IGAke3h9ICR7eX0gJHt3aWR0aH0gJHtoZWlnaHR9YCwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX21pbmltYXAtc3ZnXCIsIHJvbGU6IFwiaW1nXCIsIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGxhYmVsbGVkQnksIHJlZjogc3ZnLCBvbkNsaWNrOiBvblN2Z0NsaWNrLCBjaGlsZHJlbjogW19hcmlhTGFiZWwgJiYganN4KFwidGl0bGVcIiwgeyBpZDogbGFiZWxsZWRCeSwgY2hpbGRyZW46IF9hcmlhTGFiZWwgfSksIGpzeChNaW5pTWFwTm9kZXMkMSwgeyBvbkNsaWNrOiBvblN2Z05vZGVDbGljaywgbm9kZUNvbG9yOiBub2RlQ29sb3IsIG5vZGVTdHJva2VDb2xvcjogbm9kZVN0cm9rZUNvbG9yLCBub2RlQm9yZGVyUmFkaXVzOiBub2RlQm9yZGVyUmFkaXVzLCBub2RlQ2xhc3NOYW1lOiBub2RlQ2xhc3NOYW1lLCBub2RlU3Ryb2tlV2lkdGg6IG5vZGVTdHJva2VXaWR0aCwgbm9kZUNvbXBvbmVudDogbm9kZUNvbXBvbmVudCB9KSwganN4KFwicGF0aFwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19taW5pbWFwLW1hc2tcIiwgZDogYE0ke3ggLSBvZmZzZXR9LCR7eSAtIG9mZnNldH1oJHt3aWR0aCArIG9mZnNldCAqIDJ9diR7aGVpZ2h0ICsgb2Zmc2V0ICogMn1oJHstd2lkdGggLSBvZmZzZXQgKiAyfXpcbiAgICAgICAgTSR7dmlld0JCLnh9LCR7dmlld0JCLnl9aCR7dmlld0JCLndpZHRofXYke3ZpZXdCQi5oZWlnaHR9aCR7LXZpZXdCQi53aWR0aH16YCwgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLCBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIiB9KV0gfSkgfSkpO1xufVxuTWluaU1hcENvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdNaW5pTWFwJztcbi8qKlxuICogVGhlIGA8TWluaU1hcCAvPmAgY29tcG9uZW50IGNhbiBiZSB1c2VkIHRvIHJlbmRlciBhbiBvdmVydmlldyBvZiB5b3VyIGZsb3cuIEl0XG4gKiByZW5kZXJzIGVhY2ggbm9kZSBhcyBhbiBTVkcgZWxlbWVudCBhbmQgdmlzdWFsaXplcyB3aGVyZSB0aGUgY3VycmVudCB2aWV3cG9ydCBpc1xuICogaW4gcmVsYXRpb24gdG8gdGhlIHJlc3Qgb2YgdGhlIGZsb3cuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCBNaW5pTWFwIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93IG5vZGVzPXtbLi4uXV19IGVkZ2VzPXtbLi4uXV19PlxuICogICAgICA8TWluaU1hcCBub2RlU3Ryb2tlV2lkdGg9ezN9IC8+XG4gKiAgICA8L1JlYWN0Rmxvdz5cbiAqICApO1xuICp9XG4gKmBgYFxuICovXG5jb25zdCBNaW5pTWFwID0gbWVtbyhNaW5pTWFwQ29tcG9uZW50KTtcblxuY29uc3Qgc2NhbGVTZWxlY3RvciA9IChjYWxjdWxhdGVTY2FsZSkgPT4gKHN0b3JlKSA9PiBjYWxjdWxhdGVTY2FsZSA/IGAke01hdGgubWF4KDEgLyBzdG9yZS50cmFuc2Zvcm1bMl0sIDEpfWAgOiB1bmRlZmluZWQ7XG5jb25zdCBkZWZhdWx0UG9zaXRpb25zID0ge1xuICAgIFtSZXNpemVDb250cm9sVmFyaWFudC5MaW5lXTogJ3JpZ2h0JyxcbiAgICBbUmVzaXplQ29udHJvbFZhcmlhbnQuSGFuZGxlXTogJ2JvdHRvbS1yaWdodCcsXG59O1xuZnVuY3Rpb24gUmVzaXplQ29udHJvbCh7IG5vZGVJZCwgcG9zaXRpb24sIHZhcmlhbnQgPSBSZXNpemVDb250cm9sVmFyaWFudC5IYW5kbGUsIGNsYXNzTmFtZSwgc3R5bGUgPSB1bmRlZmluZWQsIGNoaWxkcmVuLCBjb2xvciwgbWluV2lkdGggPSAxMCwgbWluSGVpZ2h0ID0gMTAsIG1heFdpZHRoID0gTnVtYmVyLk1BWF9WQUxVRSwgbWF4SGVpZ2h0ID0gTnVtYmVyLk1BWF9WQUxVRSwga2VlcEFzcGVjdFJhdGlvID0gZmFsc2UsIHJlc2l6ZURpcmVjdGlvbiwgYXV0b1NjYWxlID0gdHJ1ZSwgc2hvdWxkUmVzaXplLCBvblJlc2l6ZVN0YXJ0LCBvblJlc2l6ZSwgb25SZXNpemVFbmQsIH0pIHtcbiAgICBjb25zdCBjb250ZXh0Tm9kZUlkID0gdXNlTm9kZUlkKCk7XG4gICAgY29uc3QgaWQgPSB0eXBlb2Ygbm9kZUlkID09PSAnc3RyaW5nJyA/IG5vZGVJZCA6IGNvbnRleHROb2RlSWQ7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHJlc2l6ZUNvbnRyb2xSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgaXNIYW5kbGVDb250cm9sID0gdmFyaWFudCA9PT0gUmVzaXplQ29udHJvbFZhcmlhbnQuSGFuZGxlO1xuICAgIGNvbnN0IHNjYWxlID0gdXNlU3RvcmUodXNlQ2FsbGJhY2soc2NhbGVTZWxlY3Rvcihpc0hhbmRsZUNvbnRyb2wgJiYgYXV0b1NjYWxlKSwgW2lzSGFuZGxlQ29udHJvbCwgYXV0b1NjYWxlXSksIHNoYWxsb3cpO1xuICAgIGNvbnN0IHJlc2l6ZXIgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgY29udHJvbFBvc2l0aW9uID0gcG9zaXRpb24gPz8gZGVmYXVsdFBvc2l0aW9uc1t2YXJpYW50XTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXJlc2l6ZUNvbnRyb2xSZWYuY3VycmVudCB8fCAhaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc2l6ZXIuY3VycmVudCkge1xuICAgICAgICAgICAgcmVzaXplci5jdXJyZW50ID0gWFlSZXNpemVyKHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlOiByZXNpemVDb250cm9sUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgbm9kZUlkOiBpZCxcbiAgICAgICAgICAgICAgICBnZXRTdG9yZUl0ZW1zOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgbm9kZU9yaWdpbiwgZG9tTm9kZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzbmFwR3JpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNuYXBUb0dyaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlT3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFuZURvbU5vZGU6IGRvbU5vZGUsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogKGNoYW5nZSwgY2hpbGRDaGFuZ2VzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdHJpZ2dlck5vZGVDaGFuZ2VzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG5vZGVPcmlnaW4gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFBvc2l0aW9uID0geyB4OiBjaGFuZ2UueCwgeTogY2hhbmdlLnkgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5leHBhbmRQYXJlbnQgJiYgbm9kZS5wYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luID0gbm9kZS5vcmlnaW4gPz8gbm9kZU9yaWdpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gY2hhbmdlLndpZHRoID8/IG5vZGUubWVhc3VyZWQud2lkdGggPz8gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGNoYW5nZS5oZWlnaHQgPz8gbm9kZS5tZWFzdXJlZC5oZWlnaHQgPz8gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBub2RlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiBub2RlLnBhcmVudElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZXZhbHVhdGVBYnNvbHV0ZVBvc2l0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGNoYW5nZS54ID8/IG5vZGUucG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNoYW5nZS55ID8/IG5vZGUucG9zaXRpb24ueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgeyB3aWR0aCwgaGVpZ2h0IH0sIG5vZGUucGFyZW50SWQsIG5vZGVMb29rdXAsIG9yaWdpbiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRFeHBhbmRDaGFuZ2VzID0gaGFuZGxlRXhwYW5kUGFyZW50KFtjaGlsZF0sIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgbm9kZU9yaWdpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goLi4ucGFyZW50RXhwYW5kQ2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogd2hlbiB0aGUgcGFyZW50IHdhcyBleHBhbmRlZCBieSB0aGUgY2hpbGQgbm9kZSwgaXRzIHBvc2l0aW9uIHdpbGwgYmUgY2xhbXBlZCBhdFxuICAgICAgICAgICAgICAgICAgICAgICAgICogMCwwIHdoZW4gbm9kZSBvcmlnaW4gaXMgMCwwIGFuZCB0byB3aWR0aCwgaGVpZ2h0IGlmIGl0J3MgMSwxXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRQb3NpdGlvbi54ID0gY2hhbmdlLnggPyBNYXRoLm1heChvcmlnaW5bMF0gKiB3aWR0aCwgY2hhbmdlLngpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFBvc2l0aW9uLnkgPSBjaGFuZ2UueSA/IE1hdGgubWF4KG9yaWdpblsxXSAqIGhlaWdodCwgY2hhbmdlLnkpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0UG9zaXRpb24ueCAhPT0gdW5kZWZpbmVkICYmIG5leHRQb3NpdGlvbi55ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwb3NpdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHsgLi4ubmV4dFBvc2l0aW9uIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHBvc2l0aW9uQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLndpZHRoICE9PSB1bmRlZmluZWQgJiYgY2hhbmdlLmhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXRBdHRyaWJ1dGVzID0gIXJlc2l6ZURpcmVjdGlvbiA/IHRydWUgOiByZXNpemVEaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbkNoYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGltZW5zaW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzaXppbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjaGFuZ2Uud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogY2hhbmdlLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaChkaW1lbnNpb25DaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGRDaGFuZ2Ugb2YgY2hpbGRDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbkNoYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jaGlsZENoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaChwb3NpdGlvbkNoYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25FbmQ6ICh7IHdpZHRoLCBoZWlnaHQgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaW1lbnNpb25DaGFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGltZW5zaW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNpemluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS50cmlnZ2VyTm9kZUNoYW5nZXMoW2RpbWVuc2lvbkNoYW5nZV0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXNpemVyLmN1cnJlbnQudXBkYXRlKHtcbiAgICAgICAgICAgIGNvbnRyb2xQb3NpdGlvbixcbiAgICAgICAgICAgIGJvdW5kYXJpZXM6IHtcbiAgICAgICAgICAgICAgICBtaW5XaWR0aCxcbiAgICAgICAgICAgICAgICBtaW5IZWlnaHQsXG4gICAgICAgICAgICAgICAgbWF4V2lkdGgsXG4gICAgICAgICAgICAgICAgbWF4SGVpZ2h0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtlZXBBc3BlY3RSYXRpbyxcbiAgICAgICAgICAgIHJlc2l6ZURpcmVjdGlvbixcbiAgICAgICAgICAgIG9uUmVzaXplU3RhcnQsXG4gICAgICAgICAgICBvblJlc2l6ZSxcbiAgICAgICAgICAgIG9uUmVzaXplRW5kLFxuICAgICAgICAgICAgc2hvdWxkUmVzaXplLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJlc2l6ZXIuY3VycmVudD8uZGVzdHJveSgpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgY29udHJvbFBvc2l0aW9uLFxuICAgICAgICBtaW5XaWR0aCxcbiAgICAgICAgbWluSGVpZ2h0LFxuICAgICAgICBtYXhXaWR0aCxcbiAgICAgICAgbWF4SGVpZ2h0LFxuICAgICAgICBrZWVwQXNwZWN0UmF0aW8sXG4gICAgICAgIG9uUmVzaXplU3RhcnQsXG4gICAgICAgIG9uUmVzaXplLFxuICAgICAgICBvblJlc2l6ZUVuZCxcbiAgICAgICAgc2hvdWxkUmVzaXplLFxuICAgIF0pO1xuICAgIGNvbnN0IHBvc2l0aW9uQ2xhc3NOYW1lcyA9IGNvbnRyb2xQb3NpdGlvbi5zcGxpdCgnLScpO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX3Jlc2l6ZS1jb250cm9sJywgJ25vZHJhZycsIC4uLnBvc2l0aW9uQ2xhc3NOYW1lcywgdmFyaWFudCwgY2xhc3NOYW1lXSksIHJlZjogcmVzaXplQ29udHJvbFJlZiwgc3R5bGU6IHtcbiAgICAgICAgICAgIC4uLnN0eWxlLFxuICAgICAgICAgICAgc2NhbGUsXG4gICAgICAgICAgICAuLi4oY29sb3IgJiYgeyBbaXNIYW5kbGVDb250cm9sID8gJ2JhY2tncm91bmRDb2xvcicgOiAnYm9yZGVyQ29sb3InXTogY29sb3IgfSksXG4gICAgICAgIH0sIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59XG4vKipcbiAqIFRvIGNyZWF0ZSB5b3VyIG93biByZXNpemluZyBVSSwgeW91IGNhbiB1c2UgdGhlIGBOb2RlUmVzaXplQ29udHJvbGAgY29tcG9uZW50IHdoZXJlIHlvdSBjYW4gcGFzcyBjaGlsZHJlbiAoc3VjaCBhcyBpY29ucykuXG4gKiBAcHVibGljXG4gKlxuICovXG5jb25zdCBOb2RlUmVzaXplQ29udHJvbCA9IG1lbW8oUmVzaXplQ29udHJvbCk7XG5cbi8qKlxuICogVGhlIGA8Tm9kZVJlc2l6ZXIgLz5gIGNvbXBvbmVudCBjYW4gYmUgdXNlZCB0byBhZGQgYSByZXNpemUgZnVuY3Rpb25hbGl0eSB0byB5b3VyXG4gKiBub2Rlcy4gSXQgcmVuZGVycyBkcmFnZ2FibGUgY29udHJvbHMgYXJvdW5kIHRoZSBub2RlIHRvIHJlc2l6ZSBpbiBhbGwgZGlyZWN0aW9ucy5cbiAqIEBwdWJsaWNcbiAqXG4gKiBAZXhhbXBsZVxuICpgYGBqc3hcbiAqaW1wb3J0IHsgbWVtbyB9IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgSGFuZGxlLCBQb3NpdGlvbiwgTm9kZVJlc2l6ZXIgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmZ1bmN0aW9uIFJlc2l6YWJsZU5vZGUoeyBkYXRhIH0pIHtcbiAqICByZXR1cm4gKFxuICogICAgPD5cbiAqICAgICAgPE5vZGVSZXNpemVyIG1pbldpZHRoPXsxMDB9IG1pbkhlaWdodD17MzB9IC8+XG4gKiAgICAgIDxIYW5kbGUgdHlwZT1cInRhcmdldFwiIHBvc2l0aW9uPXtQb3NpdGlvbi5MZWZ0fSAvPlxuICogICAgICA8ZGl2IHN0eWxlPXt7IHBhZGRpbmc6IDEwIH19PntkYXRhLmxhYmVsfTwvZGl2PlxuICogICAgICA8SGFuZGxlIHR5cGU9XCJzb3VyY2VcIiBwb3NpdGlvbj17UG9zaXRpb24uUmlnaHR9IC8+XG4gKiAgICA8Lz5cbiAqICApO1xuICp9O1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgbWVtbyhSZXNpemFibGVOb2RlKTtcbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIE5vZGVSZXNpemVyKHsgbm9kZUlkLCBpc1Zpc2libGUgPSB0cnVlLCBoYW5kbGVDbGFzc05hbWUsIGhhbmRsZVN0eWxlLCBsaW5lQ2xhc3NOYW1lLCBsaW5lU3R5bGUsIGNvbG9yLCBtaW5XaWR0aCA9IDEwLCBtaW5IZWlnaHQgPSAxMCwgbWF4V2lkdGggPSBOdW1iZXIuTUFYX1ZBTFVFLCBtYXhIZWlnaHQgPSBOdW1iZXIuTUFYX1ZBTFVFLCBrZWVwQXNwZWN0UmF0aW8gPSBmYWxzZSwgYXV0b1NjYWxlID0gdHJ1ZSwgc2hvdWxkUmVzaXplLCBvblJlc2l6ZVN0YXJ0LCBvblJlc2l6ZSwgb25SZXNpemVFbmQsIH0pIHtcbiAgICBpZiAoIWlzVmlzaWJsZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbWFlfUkVTSVpFUl9MSU5FX1BPU0lUSU9OUy5tYXAoKHBvc2l0aW9uKSA9PiAoanN4KE5vZGVSZXNpemVDb250cm9sLCB7IGNsYXNzTmFtZTogbGluZUNsYXNzTmFtZSwgc3R5bGU6IGxpbmVTdHlsZSwgbm9kZUlkOiBub2RlSWQsIHBvc2l0aW9uOiBwb3NpdGlvbiwgdmFyaWFudDogUmVzaXplQ29udHJvbFZhcmlhbnQuTGluZSwgY29sb3I6IGNvbG9yLCBtaW5XaWR0aDogbWluV2lkdGgsIG1pbkhlaWdodDogbWluSGVpZ2h0LCBtYXhXaWR0aDogbWF4V2lkdGgsIG1heEhlaWdodDogbWF4SGVpZ2h0LCBvblJlc2l6ZVN0YXJ0OiBvblJlc2l6ZVN0YXJ0LCBrZWVwQXNwZWN0UmF0aW86IGtlZXBBc3BlY3RSYXRpbywgYXV0b1NjYWxlOiBhdXRvU2NhbGUsIHNob3VsZFJlc2l6ZTogc2hvdWxkUmVzaXplLCBvblJlc2l6ZTogb25SZXNpemUsIG9uUmVzaXplRW5kOiBvblJlc2l6ZUVuZCB9LCBwb3NpdGlvbikpKSwgWFlfUkVTSVpFUl9IQU5ETEVfUE9TSVRJT05TLm1hcCgocG9zaXRpb24pID0+IChqc3goTm9kZVJlc2l6ZUNvbnRyb2wsIHsgY2xhc3NOYW1lOiBoYW5kbGVDbGFzc05hbWUsIHN0eWxlOiBoYW5kbGVTdHlsZSwgbm9kZUlkOiBub2RlSWQsIHBvc2l0aW9uOiBwb3NpdGlvbiwgY29sb3I6IGNvbG9yLCBtaW5XaWR0aDogbWluV2lkdGgsIG1pbkhlaWdodDogbWluSGVpZ2h0LCBtYXhXaWR0aDogbWF4V2lkdGgsIG1heEhlaWdodDogbWF4SGVpZ2h0LCBvblJlc2l6ZVN0YXJ0OiBvblJlc2l6ZVN0YXJ0LCBrZWVwQXNwZWN0UmF0aW86IGtlZXBBc3BlY3RSYXRpbywgYXV0b1NjYWxlOiBhdXRvU2NhbGUsIHNob3VsZFJlc2l6ZTogc2hvdWxkUmVzaXplLCBvblJlc2l6ZTogb25SZXNpemUsIG9uUmVzaXplRW5kOiBvblJlc2l6ZUVuZCB9LCBwb3NpdGlvbikpKV0gfSkpO1xufVxuXG5jb25zdCBzZWxlY3RvciA9IChzdGF0ZSkgPT4gc3RhdGUuZG9tTm9kZT8ucXVlcnlTZWxlY3RvcignLnJlYWN0LWZsb3dfX3JlbmRlcmVyJyk7XG5mdW5jdGlvbiBOb2RlVG9vbGJhclBvcnRhbCh7IGNoaWxkcmVuIH0pIHtcbiAgICBjb25zdCB3cmFwcGVyUmVmID0gdXNlU3RvcmUoc2VsZWN0b3IpO1xuICAgIGlmICghd3JhcHBlclJlZikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgd3JhcHBlclJlZik7XG59XG5cbmNvbnN0IG5vZGVFcXVhbGl0eUZuID0gKGEsIGIpID0+IGE/LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnggIT09IGI/LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnggfHxcbiAgICBhPy5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55ICE9PSBiPy5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55IHx8XG4gICAgYT8ubWVhc3VyZWQud2lkdGggIT09IGI/Lm1lYXN1cmVkLndpZHRoIHx8XG4gICAgYT8ubWVhc3VyZWQuaGVpZ2h0ICE9PSBiPy5tZWFzdXJlZC5oZWlnaHQgfHxcbiAgICBhPy5zZWxlY3RlZCAhPT0gYj8uc2VsZWN0ZWQgfHxcbiAgICBhPy5pbnRlcm5hbHMueiAhPT0gYj8uaW50ZXJuYWxzLno7XG5jb25zdCBub2Rlc0VxdWFsaXR5Rm4gPSAoYSwgYikgPT4ge1xuICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2tleSwgbm9kZV0gb2YgYSkge1xuICAgICAgICBpZiAobm9kZUVxdWFsaXR5Rm4obm9kZSwgYi5nZXQoa2V5KSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5jb25zdCBzdG9yZVNlbGVjdG9yID0gKHN0YXRlKSA9PiAoe1xuICAgIHg6IHN0YXRlLnRyYW5zZm9ybVswXSxcbiAgICB5OiBzdGF0ZS50cmFuc2Zvcm1bMV0sXG4gICAgem9vbTogc3RhdGUudHJhbnNmb3JtWzJdLFxuICAgIHNlbGVjdGVkTm9kZXNDb3VudDogc3RhdGUubm9kZXMuZmlsdGVyKChub2RlKSA9PiBub2RlLnNlbGVjdGVkKS5sZW5ndGgsXG59KTtcbi8qKlxuICogVGhpcyBjb21wb25lbnQgY2FuIHJlbmRlciBhIHRvb2xiYXIgb3IgdG9vbHRpcCB0byBvbmUgc2lkZSBvZiBhIGN1c3RvbSBub2RlLiBUaGlzXG4gKiB0b29sYmFyIGRvZXNuJ3Qgc2NhbGUgd2l0aCB0aGUgdmlld3BvcnQgc28gdGhhdCB0aGUgY29udGVudCBpcyBhbHdheXMgdmlzaWJsZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKmltcG9ydCB7IG1lbW8gfSBmcm9tICdyZWFjdCc7XG4gKmltcG9ydCB7IEhhbmRsZSwgUG9zaXRpb24sIE5vZGVUb29sYmFyIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpmdW5jdGlvbiBDdXN0b21Ob2RlKHsgZGF0YSB9KSB7XG4gKiAgcmV0dXJuIChcbiAqICAgIDw+XG4gKiAgICAgIDxOb2RlVG9vbGJhciBpc1Zpc2libGU9e2RhdGEudG9vbGJhclZpc2libGV9IHBvc2l0aW9uPXtkYXRhLnRvb2xiYXJQb3NpdGlvbn0+XG4gKiAgICAgICAgPGJ1dHRvbj5kZWxldGU8L2J1dHRvbj5cbiAqICAgICAgICA8YnV0dG9uPmNvcHk8L2J1dHRvbj5cbiAqICAgICAgICA8YnV0dG9uPmV4cGFuZDwvYnV0dG9uPlxuICogICAgICA8L05vZGVUb29sYmFyPlxuICpcbiAqICAgICAgPGRpdiBzdHlsZT17eyBwYWRkaW5nOiAnMTBweCAyMHB4JyB9fT5cbiAqICAgICAgICB7ZGF0YS5sYWJlbH1cbiAqICAgICAgPC9kaXY+XG4gKlxuICogICAgICA8SGFuZGxlIHR5cGU9XCJ0YXJnZXRcIiBwb3NpdGlvbj17UG9zaXRpb24uTGVmdH0gLz5cbiAqICAgICAgPEhhbmRsZSB0eXBlPVwic291cmNlXCIgcG9zaXRpb249e1Bvc2l0aW9uLlJpZ2h0fSAvPlxuICogICAgPC8+XG4gKiAgKTtcbiAqfTtcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IG1lbW8oQ3VzdG9tTm9kZSk7XG4gKmBgYFxuICogQHJlbWFya3MgQnkgZGVmYXVsdCwgdGhlIHRvb2xiYXIgaXMgb25seSB2aXNpYmxlIHdoZW4gYSBub2RlIGlzIHNlbGVjdGVkLiBJZiBtdWx0aXBsZVxuICogbm9kZXMgYXJlIHNlbGVjdGVkIGl0IHdpbGwgbm90IGJlIHZpc2libGUgdG8gcHJldmVudCBvdmVybGFwcGluZyB0b29sYmFycyBvclxuICogY2x1dHRlci4gWW91IGNhbiBvdmVycmlkZSB0aGlzIGJlaGF2aW9yIGJ5IHNldHRpbmcgdGhlIGBpc1Zpc2libGVgIHByb3AgdG8gYHRydWVgLlxuICovXG5mdW5jdGlvbiBOb2RlVG9vbGJhcih7IG5vZGVJZCwgY2hpbGRyZW4sIGNsYXNzTmFtZSwgc3R5bGUsIGlzVmlzaWJsZSwgcG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIG9mZnNldCA9IDEwLCBhbGlnbiA9ICdjZW50ZXInLCAuLi5yZXN0IH0pIHtcbiAgICBjb25zdCBjb250ZXh0Tm9kZUlkID0gdXNlTm9kZUlkKCk7XG4gICAgY29uc3Qgbm9kZXNTZWxlY3RvciA9IHVzZUNhbGxiYWNrKChzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBub2RlSWRzID0gQXJyYXkuaXNBcnJheShub2RlSWQpID8gbm9kZUlkIDogW25vZGVJZCB8fCBjb250ZXh0Tm9kZUlkIHx8ICcnXTtcbiAgICAgICAgY29uc3QgaW50ZXJuYWxOb2RlcyA9IG5vZGVJZHMucmVkdWNlKChyZXMsIGlkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gc3RhdGUubm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXMuc2V0KG5vZGUuaWQsIG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSwgbmV3IE1hcCgpKTtcbiAgICAgICAgcmV0dXJuIGludGVybmFsTm9kZXM7XG4gICAgfSwgW25vZGVJZCwgY29udGV4dE5vZGVJZF0pO1xuICAgIGNvbnN0IG5vZGVzID0gdXNlU3RvcmUobm9kZXNTZWxlY3Rvciwgbm9kZXNFcXVhbGl0eUZuKTtcbiAgICBjb25zdCB7IHgsIHksIHpvb20sIHNlbGVjdGVkTm9kZXNDb3VudCB9ID0gdXNlU3RvcmUoc3RvcmVTZWxlY3Rvciwgc2hhbGxvdyk7XG4gICAgLy8gaWYgaXNWaXNpYmxlIGlzIG5vdCBzZXQsIHdlIHNob3cgdGhlIHRvb2xiYXIgb25seSBpZiBpdHMgbm9kZSBpcyBzZWxlY3RlZCBhbmQgbm8gb3RoZXIgbm9kZSBpcyBzZWxlY3RlZFxuICAgIGNvbnN0IGlzQWN0aXZlID0gdHlwZW9mIGlzVmlzaWJsZSA9PT0gJ2Jvb2xlYW4nXG4gICAgICAgID8gaXNWaXNpYmxlXG4gICAgICAgIDogbm9kZXMuc2l6ZSA9PT0gMSAmJiBub2Rlcy52YWx1ZXMoKS5uZXh0KCkudmFsdWU/LnNlbGVjdGVkICYmIHNlbGVjdGVkTm9kZXNDb3VudCA9PT0gMTtcbiAgICBpZiAoIWlzQWN0aXZlIHx8ICFub2Rlcy5zaXplKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBub2RlUmVjdCA9IGdldEludGVybmFsTm9kZXNCb3VuZHMobm9kZXMpO1xuICAgIGNvbnN0IG5vZGVzQXJyYXkgPSBBcnJheS5mcm9tKG5vZGVzLnZhbHVlcygpKTtcbiAgICBjb25zdCB6SW5kZXggPSBNYXRoLm1heCguLi5ub2Rlc0FycmF5Lm1hcCgobm9kZSkgPT4gbm9kZS5pbnRlcm5hbHMueiArIDEpKTtcbiAgICBjb25zdCB3cmFwcGVyU3R5bGUgPSB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB0cmFuc2Zvcm06IGdldE5vZGVUb29sYmFyVHJhbnNmb3JtKG5vZGVSZWN0LCB7IHgsIHksIHpvb20gfSwgcG9zaXRpb24sIG9mZnNldCwgYWxpZ24pLFxuICAgICAgICB6SW5kZXgsXG4gICAgICAgIC4uLnN0eWxlLFxuICAgIH07XG4gICAgcmV0dXJuIChqc3goTm9kZVRvb2xiYXJQb3J0YWwsIHsgY2hpbGRyZW46IGpzeChcImRpdlwiLCB7IHN0eWxlOiB3cmFwcGVyU3R5bGUsIGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19ub2RlLXRvb2xiYXInLCBjbGFzc05hbWVdKSwgLi4ucmVzdCwgXCJkYXRhLWlkXCI6IG5vZGVzQXJyYXkucmVkdWNlKChhY2MsIG5vZGUpID0+IGAke2FjY30ke25vZGUuaWR9IGAsICcnKS50cmltKCksIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSB9KSk7XG59XG5cbmNvbnN0IHpvb21TZWxlY3RvciA9IChzdGF0ZSkgPT4gc3RhdGUudHJhbnNmb3JtWzJdO1xuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCBjYW4gcmVuZGVyIGEgdG9vbGJhciBvciB0b29sdGlwIHRvIG9uZSBzaWRlIG9mIGEgY3VzdG9tIGVkZ2UuIFRoaXNcbiAqIHRvb2xiYXIgZG9lc24ndCBzY2FsZSB3aXRoIHRoZSB2aWV3cG9ydCBzbyB0aGF0IHRoZSBjb250ZW50IHN0YXlzIHRoZSBzYW1lIHNpemUuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICogaW1wb3J0IHsgRWRnZVRvb2xiYXIsIEJhc2VFZGdlLCBnZXRCZXppZXJQYXRoLCB0eXBlIEVkZ2VQcm9wcyB9IGZyb20gXCJAeHlmbG93L3JlYWN0XCI7XG4gKlxuICogZXhwb3J0IGZ1bmN0aW9uIEN1c3RvbUVkZ2UoeyBpZCwgZGF0YSwgLi4ucHJvcHMgfTogRWRnZVByb3BzKSB7XG4gKiAgIGNvbnN0IFtlZGdlUGF0aCwgY2VudGVyWCwgY2VudGVyWV0gPSBnZXRCZXppZXJQYXRoKHByb3BzKTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPD5cbiAqICAgICAgIDxCYXNlRWRnZSBpZD17aWR9IHBhdGg9e2VkZ2VQYXRofSAvPlxuICogICAgICAgPEVkZ2VUb29sYmFyIGVkZ2VJZD17aWR9IHg9e2NlbnRlclh9IHk9e2NlbnRlcll9IGlzVmlzaWJsZT5cbiAqICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBjb25zb2xlLmxvZygnZWRnZScsIGlkLCAnY2xpY2snKX19PkNsaWNrIG1lPC9idXR0b24+XG4gKiAgICAgICA8L0VkZ2VUb29sYmFyPlxuICogICAgIDwvPlxuICogICApO1xuICogfVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIEVkZ2VUb29sYmFyKHsgZWRnZUlkLCB4LCB5LCBjaGlsZHJlbiwgY2xhc3NOYW1lLCBzdHlsZSwgaXNWaXNpYmxlLCBhbGlnblggPSAnY2VudGVyJywgYWxpZ25ZID0gJ2NlbnRlcicsIC4uLnJlc3QgfSkge1xuICAgIGNvbnN0IGVkZ2VTZWxlY3RvciA9IHVzZUNhbGxiYWNrKChzdGF0ZSkgPT4gc3RhdGUuZWRnZUxvb2t1cC5nZXQoZWRnZUlkKSwgW2VkZ2VJZF0pO1xuICAgIGNvbnN0IGVkZ2UgPSB1c2VTdG9yZShlZGdlU2VsZWN0b3IsIHNoYWxsb3cpO1xuICAgIGNvbnN0IGlzQWN0aXZlID0gdHlwZW9mIGlzVmlzaWJsZSA9PT0gJ2Jvb2xlYW4nID8gaXNWaXNpYmxlIDogZWRnZT8uc2VsZWN0ZWQ7XG4gICAgY29uc3Qgem9vbSA9IHVzZVN0b3JlKHpvb21TZWxlY3Rvcik7XG4gICAgaWYgKCFpc0FjdGl2ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgekluZGV4ID0gKGVkZ2U/LnpJbmRleCA/PyAwKSArIDE7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gZ2V0RWRnZVRvb2xiYXJUcmFuc2Zvcm0oeCwgeSwgem9vbSwgYWxpZ25YLCBhbGlnblkpO1xuICAgIHJldHVybiAoanN4KEVkZ2VMYWJlbFJlbmRlcmVyLCB7IGNoaWxkcmVuOiBqc3goXCJkaXZcIiwgeyBzdHlsZToge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICB6SW5kZXgsXG4gICAgICAgICAgICAgICAgcG9pbnRlckV2ZW50czogJ2FsbCcsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiAnMCAwJyxcbiAgICAgICAgICAgICAgICAuLi5zdHlsZSxcbiAgICAgICAgICAgIH0sIGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19lZGdlLXRvb2xiYXInLCBjbGFzc05hbWVdKSwgXCJkYXRhLWlkXCI6IGVkZ2U/LmlkID8/ICcnLCAuLi5yZXN0LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkgfSkpO1xufVxuXG5leHBvcnQgeyBCYWNrZ3JvdW5kLCBCYWNrZ3JvdW5kVmFyaWFudCwgQmFzZUVkZ2UsIEJlemllckVkZ2UsIENvbnRyb2xCdXR0b24sIENvbnRyb2xzLCBFZGdlTGFiZWxSZW5kZXJlciwgRWRnZVRleHQsIEVkZ2VUb29sYmFyLCBIYW5kbGUsIE1pbmlNYXAsIE1pbmlNYXBOb2RlLCBOb2RlUmVzaXplQ29udHJvbCwgTm9kZVJlc2l6ZXIsIE5vZGVUb29sYmFyLCBQYW5lbCwgaW5kZXggYXMgUmVhY3RGbG93LCBSZWFjdEZsb3dQcm92aWRlciwgU2ltcGxlQmV6aWVyRWRnZSwgU21vb3RoU3RlcEVkZ2UsIFN0ZXBFZGdlLCBTdHJhaWdodEVkZ2UsIFZpZXdwb3J0UG9ydGFsLCBhcHBseUVkZ2VDaGFuZ2VzLCBhcHBseU5vZGVDaGFuZ2VzLCBnZXRTaW1wbGVCZXppZXJQYXRoLCBpc0VkZ2UsIGlzTm9kZSwgdXNlQ29ubmVjdGlvbiwgdXNlRWRnZXMsIHVzZUVkZ2VzU3RhdGUsIHVzZUhhbmRsZUNvbm5lY3Rpb25zLCB1c2VJbnRlcm5hbE5vZGUsIHVzZUtleVByZXNzLCB1c2VOb2RlQ29ubmVjdGlvbnMsIHVzZU5vZGVJZCwgdXNlTm9kZXMsIHVzZU5vZGVzRGF0YSwgdXNlTm9kZXNJbml0aWFsaXplZCwgdXNlTm9kZXNTdGF0ZSwgdXNlT25TZWxlY3Rpb25DaGFuZ2UsIHVzZU9uVmlld3BvcnRDaGFuZ2UsIHVzZVJlYWN0RmxvdywgdXNlU3RvcmUsIHVzZVN0b3JlQXBpLCB1c2VVcGRhdGVOb2RlSW50ZXJuYWxzLCB1c2VWaWV3cG9ydCB9O1xuIl0sIm5hbWVzIjpbImpzeHMiLCJGcmFnbWVudCIsImpzeCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlTWVtbyIsImZvcndhcmRSZWYiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUxheW91dEVmZmVjdCIsInVzZUNhbGxiYWNrIiwibWVtbyIsImNjIiwiZXJyb3JNZXNzYWdlcyIsIm1lcmdlQXJpYUxhYmVsQ29uZmlnIiwiaW5maW5pdGVFeHRlbnQiLCJpc0lucHV0RE9NTm9kZSIsImdldFZpZXdwb3J0Rm9yQm91bmRzIiwicG9pbnRUb1JlbmRlcmVyUG9pbnQiLCJyZW5kZXJlclBvaW50VG9Qb2ludCIsImlzTm9kZUJhc2UiLCJpc0VkZ2VCYXNlIiwiZ2V0RWxlbWVudHNUb1JlbW92ZSIsImlzUmVjdE9iamVjdCIsIm5vZGVUb1JlY3QiLCJnZXRPdmVybGFwcGluZ0FyZWEiLCJnZXROb2Rlc0JvdW5kcyIsIndpdGhSZXNvbHZlcnMiLCJldmFsdWF0ZUFic29sdXRlUG9zaXRpb24iLCJnZXREaW1lbnNpb25zIiwiWFlQYW5ab29tIiwiUGFuT25TY3JvbGxNb2RlIiwiU2VsZWN0aW9uTW9kZSIsImdldEV2ZW50UG9zaXRpb24iLCJnZXROb2Rlc0luc2lkZSIsImFyZVNldHNFcXVhbCIsIlhZRHJhZyIsInNuYXBQb3NpdGlvbiIsImNhbGN1bGF0ZU5vZGVQb3NpdGlvbiIsIlBvc2l0aW9uIiwiQ29ubmVjdGlvbk1vZGUiLCJpc01vdXNlRXZlbnQiLCJYWUhhbmRsZSIsImdldEhvc3RGb3JFbGVtZW50IiwiYWRkRWRnZSIsImdldEludGVybmFsTm9kZXNCb3VuZHMiLCJpc051bWVyaWMiLCJub2RlSGFzRGltZW5zaW9ucyIsImdldE5vZGVEaW1lbnNpb25zIiwiZWxlbWVudFNlbGVjdGlvbktleXMiLCJpc0VkZ2VWaXNpYmxlIiwiTWFya2VyVHlwZSIsImNyZWF0ZU1hcmtlcklkcyIsImdldEJlemllckVkZ2VDZW50ZXIiLCJnZXRTbW9vdGhTdGVwUGF0aCIsImdldFN0cmFpZ2h0UGF0aCIsImdldEJlemllclBhdGgiLCJnZXRFZGdlUG9zaXRpb24iLCJnZXRFbGV2YXRlZEVkZ2VaSW5kZXgiLCJnZXRNYXJrZXJJZCIsImdldENvbm5lY3Rpb25TdGF0dXMiLCJDb25uZWN0aW9uTGluZVR5cGUiLCJ1cGRhdGVDb25uZWN0aW9uTG9va3VwIiwiYWRvcHRVc2VyTm9kZXMiLCJpbml0aWFsQ29ubmVjdGlvbiIsImRldldhcm4iLCJkZWZhdWx0QXJpYUxhYmVsQ29uZmlnIiwidXBkYXRlTm9kZUludGVybmFscyIsInVwZGF0ZUFic29sdXRlUG9zaXRpb25zIiwiaGFuZGxlRXhwYW5kUGFyZW50IiwicGFuQnkiLCJmaXRWaWV3cG9ydCIsImlzTWFjT3MiLCJhcmVDb25uZWN0aW9uTWFwc0VxdWFsIiwiaGFuZGxlQ29ubmVjdGlvbkNoYW5nZSIsInNoYWxsb3dOb2RlRGF0YSIsIlhZTWluaW1hcCIsImdldEJvdW5kc09mUmVjdHMiLCJSZXNpemVDb250cm9sVmFyaWFudCIsIlhZUmVzaXplciIsIlhZX1JFU0laRVJfTElORV9QT1NJVElPTlMiLCJYWV9SRVNJWkVSX0hBTkRMRV9QT1NJVElPTlMiLCJnZXROb2RlVG9vbGJhclRyYW5zZm9ybSIsImdldEVkZ2VUb29sYmFyVHJhbnNmb3JtIiwiZ2V0Q29ubmVjdGVkRWRnZXMiLCJnZXRFZGdlQ2VudGVyIiwiZ2V0SW5jb21lcnMiLCJnZXRPdXRnb2VycyIsInJlY29ubmVjdEVkZ2UiLCJ1c2VTdG9yZVdpdGhFcXVhbGl0eUZuIiwiY3JlYXRlV2l0aEVxdWFsaXR5Rm4iLCJzaGFsbG93IiwiY3JlYXRlUG9ydGFsIiwiU3RvcmVDb250ZXh0IiwiUHJvdmlkZXIkMSIsIlByb3ZpZGVyIiwienVzdGFuZEVycm9yTWVzc2FnZSIsInVzZVN0b3JlIiwic2VsZWN0b3IiLCJlcXVhbGl0eUZuIiwic3RvcmUiLCJFcnJvciIsInVzZVN0b3JlQXBpIiwiZ2V0U3RhdGUiLCJzZXRTdGF0ZSIsInN1YnNjcmliZSIsInN0eWxlIiwiZGlzcGxheSIsImFyaWFMaXZlU3R5bGUiLCJwb3NpdGlvbiIsIndpZHRoIiwiaGVpZ2h0IiwibWFyZ2luIiwiYm9yZGVyIiwicGFkZGluZyIsIm92ZXJmbG93IiwiY2xpcCIsImNsaXBQYXRoIiwiQVJJQV9OT0RFX0RFU0NfS0VZIiwiQVJJQV9FREdFX0RFU0NfS0VZIiwiQVJJQV9MSVZFX01FU1NBR0UiLCJhcmlhTGl2ZVNlbGVjdG9yIiwicyIsImFyaWFMaXZlTWVzc2FnZSIsImFyaWFMYWJlbENvbmZpZ1NlbGVjdG9yIiwiYXJpYUxhYmVsQ29uZmlnIiwiQXJpYUxpdmVNZXNzYWdlIiwicmZJZCIsImlkIiwiY2hpbGRyZW4iLCJBMTF5RGVzY3JpcHRpb25zIiwiZGlzYWJsZUtleWJvYXJkQTExeSIsIlBhbmVsIiwiY2xhc3NOYW1lIiwicmVzdCIsInJlZiIsInBvc2l0aW9uQ2xhc3NlcyIsInNwbGl0IiwiZGlzcGxheU5hbWUiLCJBdHRyaWJ1dGlvbiIsInByb09wdGlvbnMiLCJoaWRlQXR0cmlidXRpb24iLCJocmVmIiwidGFyZ2V0IiwicmVsIiwic2VsZWN0b3IkbSIsInNlbGVjdGVkTm9kZXMiLCJzZWxlY3RlZEVkZ2VzIiwibm9kZSIsIm5vZGVMb29rdXAiLCJzZWxlY3RlZCIsInB1c2giLCJpbnRlcm5hbHMiLCJ1c2VyTm9kZSIsImVkZ2UiLCJlZGdlTG9va3VwIiwic2VsZWN0SWQiLCJvYmoiLCJhcmVFcXVhbCIsImEiLCJiIiwibWFwIiwiU2VsZWN0aW9uTGlzdGVuZXJJbm5lciIsIm9uU2VsZWN0aW9uQ2hhbmdlIiwicGFyYW1zIiwibm9kZXMiLCJlZGdlcyIsIm9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMiLCJmb3JFYWNoIiwiZm4iLCJjaGFuZ2VTZWxlY3RvciIsIlNlbGVjdGlvbkxpc3RlbmVyIiwic3RvcmVIYXNTZWxlY3Rpb25DaGFuZ2VIYW5kbGVycyIsImRlZmF1bHROb2RlT3JpZ2luIiwiZGVmYXVsdFZpZXdwb3J0IiwieCIsInkiLCJ6b29tIiwicmVhY3RGbG93RmllbGRzVG9UcmFjayIsImZpZWxkc1RvVHJhY2siLCJzZWxlY3RvciRsIiwic2V0Tm9kZXMiLCJzZXRFZGdlcyIsInNldE1pblpvb20iLCJzZXRNYXhab29tIiwic2V0VHJhbnNsYXRlRXh0ZW50Iiwic2V0Tm9kZUV4dGVudCIsInJlc2V0Iiwic2V0RGVmYXVsdE5vZGVzQW5kRWRnZXMiLCJzZXRQYW5lQ2xpY2tEaXN0YW5jZSIsImluaXRQcmV2VmFsdWVzIiwidHJhbnNsYXRlRXh0ZW50Iiwibm9kZU9yaWdpbiIsIm1pblpvb20iLCJtYXhab29tIiwiZWxlbWVudHNTZWxlY3RhYmxlIiwibm9QYW5DbGFzc05hbWUiLCJwYW5lQ2xpY2tEaXN0YW5jZSIsIlN0b3JlVXBkYXRlciIsInByb3BzIiwiZGVmYXVsdE5vZGVzIiwiZGVmYXVsdEVkZ2VzIiwicHJldmlvdXNGaWVsZHMiLCJjdXJyZW50IiwiZmllbGROYW1lIiwiZmllbGRWYWx1ZSIsInByZXZpb3VzRmllbGRWYWx1ZSIsImZpdFZpZXdRdWV1ZWQiLCJmaXRWaWV3T3B0aW9ucyIsImdldE1lZGlhUXVlcnkiLCJ3aW5kb3ciLCJtYXRjaE1lZGlhIiwidXNlQ29sb3JNb2RlQ2xhc3MiLCJjb2xvck1vZGUiLCJjb2xvck1vZGVDbGFzcyIsInNldENvbG9yTW9kZUNsYXNzIiwibWVkaWFRdWVyeSIsInVwZGF0ZUNvbG9yTW9kZUNsYXNzIiwibWF0Y2hlcyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZGVmYXVsdERvYyIsImRvY3VtZW50IiwidXNlS2V5UHJlc3MiLCJrZXlDb2RlIiwib3B0aW9ucyIsImFjdEluc2lkZUlucHV0V2l0aE1vZGlmaWVyIiwia2V5UHJlc3NlZCIsInNldEtleVByZXNzZWQiLCJtb2RpZmllclByZXNzZWQiLCJwcmVzc2VkS2V5cyIsIlNldCIsImtleUNvZGVzIiwia2V5c1RvV2F0Y2giLCJrZXlDb2RlQXJyIiwiQXJyYXkiLCJpc0FycmF5Iiwia2V5cyIsImZpbHRlciIsImtjIiwicmVwbGFjZSIsImtleXNGbGF0IiwicmVkdWNlIiwicmVzIiwiaXRlbSIsImNvbmNhdCIsImRvd25IYW5kbGVyIiwiZXZlbnQiLCJjdHJsS2V5IiwibWV0YUtleSIsInNoaWZ0S2V5IiwiYWx0S2V5IiwicHJldmVudEFjdGlvbiIsImtleU9yQ29kZSIsInVzZUtleU9yQ29kZSIsImNvZGUiLCJhZGQiLCJpc01hdGNoaW5nS2V5IiwiY29tcG9zZWRQYXRoIiwiaXNJbnRlcmFjdGl2ZUVsZW1lbnQiLCJub2RlTmFtZSIsInByZXZlbnREZWZhdWx0IiwidXBIYW5kbGVyIiwiY2xlYXIiLCJkZWxldGUiLCJrZXkiLCJyZXNldEhhbmRsZXIiLCJpc1VwIiwibGVuZ3RoIiwic2l6ZSIsInNvbWUiLCJldmVyeSIsImsiLCJoYXMiLCJldmVudENvZGUiLCJpbmNsdWRlcyIsInVzZVZpZXdwb3J0SGVscGVyIiwiem9vbUluIiwicGFuWm9vbSIsInNjYWxlQnkiLCJkdXJhdGlvbiIsIlByb21pc2UiLCJyZXNvbHZlIiwiem9vbU91dCIsInpvb21UbyIsInpvb21MZXZlbCIsInNjYWxlVG8iLCJnZXRab29tIiwidHJhbnNmb3JtIiwic2V0Vmlld3BvcnQiLCJ2aWV3cG9ydCIsInRYIiwidFkiLCJ0Wm9vbSIsImdldFZpZXdwb3J0Iiwic2V0Q2VudGVyIiwiZml0Qm91bmRzIiwiYm91bmRzIiwiZWFzZSIsImludGVycG9sYXRlIiwic2NyZWVuVG9GbG93UG9zaXRpb24iLCJjbGllbnRQb3NpdGlvbiIsInNuYXBHcmlkIiwic25hcFRvR3JpZCIsImRvbU5vZGUiLCJkb21YIiwiZG9tWSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNvcnJlY3RlZFBvc2l0aW9uIiwiX3NuYXBHcmlkIiwiX3NuYXBUb0dyaWQiLCJmbG93VG9TY3JlZW5Qb3NpdGlvbiIsImZsb3dQb3NpdGlvbiIsInJlbmRlcmVyUG9zaXRpb24iLCJhcHBseUNoYW5nZXMiLCJjaGFuZ2VzIiwiZWxlbWVudHMiLCJ1cGRhdGVkRWxlbWVudHMiLCJjaGFuZ2VzTWFwIiwiTWFwIiwiYWRkSXRlbUNoYW5nZXMiLCJjaGFuZ2UiLCJ0eXBlIiwic2V0IiwiZWxlbWVudENoYW5nZXMiLCJnZXQiLCJlbGVtZW50IiwidXBkYXRlZEVsZW1lbnQiLCJhcHBseUNoYW5nZSIsImluZGV4IiwidW5kZWZpbmVkIiwic3BsaWNlIiwiZHJhZ2dpbmciLCJkaW1lbnNpb25zIiwibWVhc3VyZWQiLCJzZXRBdHRyaWJ1dGVzIiwicmVzaXppbmciLCJhcHBseU5vZGVDaGFuZ2VzIiwiYXBwbHlFZGdlQ2hhbmdlcyIsImNyZWF0ZVNlbGVjdGlvbkNoYW5nZSIsImdldFNlbGVjdGlvbkNoYW5nZXMiLCJpdGVtcyIsInNlbGVjdGVkSWRzIiwibXV0YXRlSXRlbSIsIndpbGxCZVNlbGVjdGVkIiwiZ2V0RWxlbWVudHNEaWZmQ2hhbmdlcyIsImxvb2t1cCIsIml0ZW1zTG9va3VwIiwiZW50cmllcyIsImxvb2t1cEl0ZW0iLCJzdG9yZUl0ZW0iLCJuZXh0Tm9kZSIsImVsZW1lbnRUb1JlbW92ZUNoYW5nZSIsImlzTm9kZSIsImlzRWRnZSIsImZpeGVkRm9yd2FyZFJlZiIsInJlbmRlciIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJ1c2VRdWV1ZSIsInJ1blF1ZXVlIiwic2VyaWFsIiwic2V0U2VyaWFsIiwiQmlnSW50IiwicXVldWUiLCJjcmVhdGVRdWV1ZSIsIm4iLCJxdWV1ZUl0ZW1zIiwiY2IiLCJCYXRjaENvbnRleHQiLCJCYXRjaFByb3ZpZGVyIiwibm9kZVF1ZXVlSGFuZGxlciIsImhhc0RlZmF1bHROb2RlcyIsIm9uTm9kZXNDaGFuZ2UiLCJuZXh0IiwicGF5bG9hZCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm5vZGVRdWV1ZSIsImVkZ2VRdWV1ZUhhbmRsZXIiLCJoYXNEZWZhdWx0RWRnZXMiLCJvbkVkZ2VzQ2hhbmdlIiwiZWRnZVF1ZXVlIiwidmFsdWUiLCJ1c2VCYXRjaENvbnRleHQiLCJiYXRjaENvbnRleHQiLCJzZWxlY3RvciRrIiwidXNlUmVhY3RGbG93Iiwidmlld3BvcnRIZWxwZXIiLCJ2aWV3cG9ydEluaXRpYWxpemVkIiwiZ2VuZXJhbEhlbHBlciIsImdldEludGVybmFsTm9kZSIsImdldE5vZGVSZWN0Iiwibm9kZVRvVXNlIiwicGFyZW50SWQiLCJub2RlV2l0aFBvc2l0aW9uIiwidXBkYXRlTm9kZSIsIm5vZGVVcGRhdGUiLCJwcmV2Tm9kZXMiLCJ1cGRhdGVFZGdlIiwiZWRnZVVwZGF0ZSIsInByZXZFZGdlcyIsIm5leHRFZGdlIiwiZ2V0Tm9kZXMiLCJnZXROb2RlIiwiZ2V0RWRnZXMiLCJlIiwiZ2V0RWRnZSIsImFkZE5vZGVzIiwibmV3Tm9kZXMiLCJhZGRFZGdlcyIsIm5ld0VkZ2VzIiwidG9PYmplY3QiLCJkZWxldGVFbGVtZW50cyIsIm5vZGVzVG9SZW1vdmUiLCJlZGdlc1RvUmVtb3ZlIiwib25Ob2Rlc0RlbGV0ZSIsIm9uRWRnZXNEZWxldGUiLCJ0cmlnZ2VyTm9kZUNoYW5nZXMiLCJ0cmlnZ2VyRWRnZUNoYW5nZXMiLCJvbkRlbGV0ZSIsIm9uQmVmb3JlRGVsZXRlIiwibWF0Y2hpbmdOb2RlcyIsIm1hdGNoaW5nRWRnZXMiLCJoYXNNYXRjaGluZ0VkZ2VzIiwiaGFzTWF0Y2hpbmdOb2RlcyIsImVkZ2VDaGFuZ2VzIiwibm9kZUNoYW5nZXMiLCJkZWxldGVkTm9kZXMiLCJkZWxldGVkRWRnZXMiLCJnZXRJbnRlcnNlY3RpbmdOb2RlcyIsIm5vZGVPclJlY3QiLCJwYXJ0aWFsbHkiLCJpc1JlY3QiLCJub2RlUmVjdCIsImhhc05vZGVzT3B0aW9uIiwiaW50ZXJuYWxOb2RlIiwicG9zaXRpb25BYnNvbHV0ZSIsImN1cnJOb2RlUmVjdCIsIm92ZXJsYXBwaW5nQXJlYSIsInBhcnRpYWxseVZpc2libGUiLCJpc05vZGVJbnRlcnNlY3RpbmciLCJhcmVhIiwidXBkYXRlTm9kZURhdGEiLCJkYXRhVXBkYXRlIiwibmV4dERhdGEiLCJkYXRhIiwidXBkYXRlRWRnZURhdGEiLCJnZXRIYW5kbGVDb25uZWN0aW9ucyIsIm5vZGVJZCIsImZyb20iLCJjb25uZWN0aW9uTG9va3VwIiwidmFsdWVzIiwiZ2V0Tm9kZUNvbm5lY3Rpb25zIiwiaGFuZGxlSWQiLCJmaXRWaWV3IiwiZml0Vmlld1Jlc29sdmVyIiwicHJvbWlzZSIsIndpbiQxIiwidXNlR2xvYmFsS2V5SGFuZGxlciIsImRlbGV0ZUtleUNvZGUiLCJtdWx0aVNlbGVjdGlvbktleUNvZGUiLCJkZWxldGVLZXlQcmVzc2VkIiwibXVsdGlTZWxlY3Rpb25LZXlQcmVzc2VkIiwibm9kZXNTZWxlY3Rpb25BY3RpdmUiLCJtdWx0aVNlbGVjdGlvbkFjdGl2ZSIsInVzZVJlc2l6ZUhhbmRsZXIiLCJ1cGRhdGVEaW1lbnNpb25zIiwiY2hlY2tWaXNpYmlsaXR5Iiwib25FcnJvciIsInJlc2l6ZU9ic2VydmVyIiwiUmVzaXplT2JzZXJ2ZXIiLCJvYnNlcnZlIiwidW5vYnNlcnZlIiwiY29udGFpbmVyU3R5bGUiLCJ0b3AiLCJsZWZ0Iiwic2VsZWN0b3IkaiIsInVzZXJTZWxlY3Rpb25BY3RpdmUiLCJsaWIiLCJjb25uZWN0aW9uSW5Qcm9ncmVzcyIsImNvbm5lY3Rpb24iLCJpblByb2dyZXNzIiwiWm9vbVBhbmUiLCJvblBhbmVDb250ZXh0TWVudSIsInpvb21PblNjcm9sbCIsInpvb21PblBpbmNoIiwicGFuT25TY3JvbGwiLCJwYW5PblNjcm9sbFNwZWVkIiwicGFuT25TY3JvbGxNb2RlIiwiRnJlZSIsInpvb21PbkRvdWJsZUNsaWNrIiwicGFuT25EcmFnIiwiem9vbUFjdGl2YXRpb25LZXlDb2RlIiwicHJldmVudFNjcm9sbGluZyIsIm5vV2hlZWxDbGFzc05hbWUiLCJvblZpZXdwb3J0Q2hhbmdlIiwiaXNDb250cm9sbGVkVmlld3BvcnQiLCJ6b29tUGFuZSIsInpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCIsIm9uVHJhbnNmb3JtQ2hhbmdlIiwib25EcmFnZ2luZ0NoYW5nZSIsInBhbmVEcmFnZ2luZyIsIm9uUGFuWm9vbVN0YXJ0IiwidnAiLCJvblZpZXdwb3J0Q2hhbmdlU3RhcnQiLCJvbk1vdmVTdGFydCIsIm9uUGFuWm9vbSIsIm9uTW92ZSIsIm9uUGFuWm9vbUVuZCIsIm9uVmlld3BvcnRDaGFuZ2VFbmQiLCJvbk1vdmVFbmQiLCJjbG9zZXN0IiwiZGVzdHJveSIsInVwZGF0ZSIsInNlbGVjdG9yJGkiLCJ1c2VyU2VsZWN0aW9uUmVjdCIsIlVzZXJTZWxlY3Rpb24iLCJpc0FjdGl2ZSIsIndyYXBIYW5kbGVyIiwiaGFuZGxlciIsImNvbnRhaW5lclJlZiIsInNlbGVjdG9yJGgiLCJQYW5lIiwiaXNTZWxlY3RpbmciLCJzZWxlY3Rpb25LZXlQcmVzc2VkIiwic2VsZWN0aW9uTW9kZSIsIkZ1bGwiLCJzZWxlY3Rpb25PbkRyYWciLCJvblNlbGVjdGlvblN0YXJ0Iiwib25TZWxlY3Rpb25FbmQiLCJvblBhbmVDbGljayIsIm9uUGFuZVNjcm9sbCIsIm9uUGFuZU1vdXNlRW50ZXIiLCJvblBhbmVNb3VzZU1vdmUiLCJvblBhbmVNb3VzZUxlYXZlIiwiaGFzQWN0aXZlU2VsZWN0aW9uIiwiY29udGFpbmVyIiwiY29udGFpbmVyQm91bmRzIiwic2VsZWN0ZWROb2RlSWRzIiwic2VsZWN0ZWRFZGdlSWRzIiwic2VsZWN0aW9uSW5Qcm9ncmVzcyIsInNlbGVjdGlvblN0YXJ0ZWQiLCJvbkNsaWNrIiwicmVzZXRTZWxlY3RlZEVsZW1lbnRzIiwib25Db250ZXh0TWVudSIsIm9uV2hlZWwiLCJvbkNsaWNrQ2FwdHVyZSIsImlzU2VsZWN0aW9uT25EcmFnQWN0aXZlIiwic3RvcFByb3BhZ2F0aW9uIiwib25Qb2ludGVyRG93bkNhcHR1cmUiLCJpc05vS2V5RXZlbnQiLCJpc1NlbGVjdGlvbkFjdGl2ZSIsImJ1dHRvbiIsImlzUHJpbWFyeSIsInNldFBvaW50ZXJDYXB0dXJlIiwicG9pbnRlcklkIiwibmF0aXZlRXZlbnQiLCJzdGFydFgiLCJzdGFydFkiLCJvblBvaW50ZXJNb3ZlIiwiZGVmYXVsdEVkZ2VPcHRpb25zIiwibW91c2VYIiwibW91c2VZIiwibmV4dFVzZXJTZWxlY3RSZWN0IiwiTWF0aCIsImFicyIsInByZXZTZWxlY3RlZE5vZGVJZHMiLCJwcmV2U2VsZWN0ZWRFZGdlSWRzIiwiUGFydGlhbCIsImVkZ2VzU2VsZWN0YWJsZSIsInNlbGVjdGFibGUiLCJjb25uZWN0aW9ucyIsImVkZ2VJZCIsIm9uUG9pbnRlclVwIiwicmVsZWFzZVBvaW50ZXJDYXB0dXJlIiwiZHJhZ2dhYmxlIiwic2VsZWN0aW9uIiwib25Qb2ludGVyRW50ZXIiLCJvblBvaW50ZXJMZWF2ZSIsImhhbmRsZU5vZGVDbGljayIsInVuc2VsZWN0Iiwibm9kZVJlZiIsImFkZFNlbGVjdGVkTm9kZXMiLCJ1bnNlbGVjdE5vZGVzQW5kRWRnZXMiLCJibHVyIiwidXNlRHJhZyIsImRpc2FibGVkIiwibm9EcmFnQ2xhc3NOYW1lIiwiaGFuZGxlU2VsZWN0b3IiLCJpc1NlbGVjdGFibGUiLCJub2RlQ2xpY2tEaXN0YW5jZSIsInNldERyYWdnaW5nIiwieHlEcmFnIiwiZ2V0U3RvcmVJdGVtcyIsIm9uTm9kZU1vdXNlRG93biIsIm9uRHJhZ1N0YXJ0Iiwib25EcmFnU3RvcCIsInNlbGVjdGVkQW5kRHJhZ2dhYmxlIiwibm9kZXNEcmFnZ2FibGUiLCJ1c2VNb3ZlU2VsZWN0ZWROb2RlcyIsIm1vdmVTZWxlY3RlZE5vZGVzIiwibm9kZUV4dGVudCIsInVwZGF0ZU5vZGVQb3NpdGlvbnMiLCJub2RlVXBkYXRlcyIsImlzU2VsZWN0ZWQiLCJ4VmVsbyIsInlWZWxvIiwieERpZmYiLCJkaXJlY3Rpb24iLCJmYWN0b3IiLCJ5RGlmZiIsIm5leHRQb3NpdGlvbiIsIk5vZGVJZENvbnRleHQiLCJDb25zdW1lciIsInVzZU5vZGVJZCIsInNlbGVjdG9yJGciLCJjb25uZWN0T25DbGljayIsImNvbm5lY3RpbmdTZWxlY3RvciIsInN0YXRlIiwiY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUiLCJjbGlja0hhbmRsZSIsImNvbm5lY3Rpb25Nb2RlIiwiZnJvbUhhbmRsZSIsInRvSGFuZGxlIiwiaXNWYWxpZCIsImNvbm5lY3RpbmdUbyIsImNvbm5lY3RpbmdGcm9tIiwiY2xpY2tDb25uZWN0aW5nIiwiaXNQb3NzaWJsZUVuZEhhbmRsZSIsIlN0cmljdCIsImNvbm5lY3Rpb25JblByb2Nlc3MiLCJjbGlja0Nvbm5lY3Rpb25JblByb2Nlc3MiLCJ2YWxpZCIsIkhhbmRsZUNvbXBvbmVudCIsIlRvcCIsImlzVmFsaWRDb25uZWN0aW9uIiwiaXNDb25uZWN0YWJsZSIsImlzQ29ubmVjdGFibGVTdGFydCIsImlzQ29ubmVjdGFibGVFbmQiLCJvbkNvbm5lY3QiLCJvbk1vdXNlRG93biIsIm9uVG91Y2hTdGFydCIsImlzVGFyZ2V0Iiwib25Db25uZWN0RXh0ZW5kZWQiLCJvbkNvbm5lY3RBY3Rpb24iLCJlZGdlUGFyYW1zIiwib25Qb2ludGVyRG93biIsImlzTW91c2VUcmlnZ2VyZWQiLCJjdXJyZW50U3RvcmUiLCJoYW5kbGVEb21Ob2RlIiwiY3VycmVudFRhcmdldCIsImF1dG9QYW5PbkNvbm5lY3QiLCJjb25uZWN0aW9uUmFkaXVzIiwiZmxvd0lkIiwiY2FuY2VsQ29ubmVjdGlvbiIsIm9uQ29ubmVjdFN0YXJ0Iiwib25Db25uZWN0RW5kIiwidXBkYXRlQ29ubmVjdGlvbiIsImdldFRyYW5zZm9ybSIsImdldEZyb21IYW5kbGUiLCJhdXRvUGFuU3BlZWQiLCJkcmFnVGhyZXNob2xkIiwiY29ubmVjdGlvbkRyYWdUaHJlc2hvbGQiLCJvbkNsaWNrQ29ubmVjdFN0YXJ0Iiwib25DbGlja0Nvbm5lY3RFbmQiLCJpc1ZhbGlkQ29ubmVjdGlvblN0b3JlIiwiY29ubmVjdGlvblN0YXRlIiwiaGFuZGxlVHlwZSIsImRvYyIsImlzVmFsaWRDb25uZWN0aW9uSGFuZGxlciIsImhhbmRsZSIsImZyb21Ob2RlSWQiLCJmcm9tSGFuZGxlSWQiLCJmcm9tVHlwZSIsImNvbm5lY3Rpb25DbG9uZSIsInN0cnVjdHVyZWRDbG9uZSIsInRvUG9zaXRpb24iLCJzb3VyY2UiLCJjb25uZWN0YWJsZSIsImNvbm5lY3RhYmxlc3RhcnQiLCJjb25uZWN0YWJsZWVuZCIsImNsaWNrY29ubmVjdGluZyIsImNvbm5lY3Rpbmdmcm9tIiwiY29ubmVjdGluZ3RvIiwiY29ubmVjdGlvbmluZGljYXRvciIsIkhhbmRsZSIsIklucHV0Tm9kZSIsInNvdXJjZVBvc2l0aW9uIiwiQm90dG9tIiwibGFiZWwiLCJEZWZhdWx0Tm9kZSIsInRhcmdldFBvc2l0aW9uIiwiR3JvdXBOb2RlIiwiT3V0cHV0Tm9kZSIsImFycm93S2V5RGlmZnMiLCJBcnJvd1VwIiwiQXJyb3dEb3duIiwiQXJyb3dMZWZ0IiwiQXJyb3dSaWdodCIsImJ1aWx0aW5Ob2RlVHlwZXMiLCJpbnB1dCIsImRlZmF1bHQiLCJvdXRwdXQiLCJncm91cCIsImdldE5vZGVJbmxpbmVTdHlsZURpbWVuc2lvbnMiLCJoYW5kbGVCb3VuZHMiLCJpbml0aWFsV2lkdGgiLCJpbml0aWFsSGVpZ2h0Iiwic2VsZWN0b3IkZiIsInRyYW5zZm9ybVN0cmluZyIsIk5vZGVzU2VsZWN0aW9uIiwib25TZWxlY3Rpb25Db250ZXh0TWVudSIsImZvY3VzIiwicHJldmVudFNjcm9sbCIsIm9uS2V5RG93biIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInRhYkluZGV4Iiwid2luIiwic2VsZWN0b3IkZSIsIkZsb3dSZW5kZXJlckNvbXBvbmVudCIsInNlbGVjdGlvbktleUNvZGUiLCJwYW5BY3RpdmF0aW9uS2V5Q29kZSIsIl9wYW5PblNjcm9sbCIsIl9wYW5PbkRyYWciLCJwYW5BY3RpdmF0aW9uS2V5UHJlc3NlZCIsIl9zZWxlY3Rpb25PbkRyYWciLCJGbG93UmVuZGVyZXIiLCJzZWxlY3RvciRkIiwib25seVJlbmRlclZpc2libGUiLCJ1c2VWaXNpYmxlTm9kZUlkcyIsIm5vZGVJZHMiLCJzZWxlY3RvciRjIiwidXNlUmVzaXplT2JzZXJ2ZXIiLCJ1cGRhdGVzIiwiZW50cnkiLCJnZXRBdHRyaWJ1dGUiLCJub2RlRWxlbWVudCIsImZvcmNlIiwiZGlzY29ubmVjdCIsInVzZU5vZGVPYnNlcnZlciIsIm5vZGVUeXBlIiwiaGFzRGltZW5zaW9ucyIsIm9ic2VydmVkTm9kZSIsInByZXZTb3VyY2VQb3NpdGlvbiIsInByZXZUYXJnZXRQb3NpdGlvbiIsInByZXZUeXBlIiwiaXNJbml0aWFsaXplZCIsImhpZGRlbiIsInR5cGVDaGFuZ2VkIiwic291cmNlUG9zQ2hhbmdlZCIsInRhcmdldFBvc0NoYW5nZWQiLCJOb2RlV3JhcHBlciIsIm9uTW91c2VFbnRlciIsIm9uTW91c2VNb3ZlIiwib25Nb3VzZUxlYXZlIiwib25Eb3VibGVDbGljayIsIm5vZGVzQ29ubmVjdGFibGUiLCJub2Rlc0ZvY3VzYWJsZSIsIm5vZGVUeXBlcyIsImlzUGFyZW50IiwicGFyZW50TG9va3VwIiwiTm9kZUNvbXBvbmVudCIsImlzRHJhZ2dhYmxlIiwiaXNGb2N1c2FibGUiLCJmb2N1c2FibGUiLCJkcmFnSGFuZGxlIiwibm9kZURpbWVuc2lvbnMiLCJpbmxpbmVEaW1lbnNpb25zIiwiaGFzUG9pbnRlckV2ZW50cyIsIm9uTW91c2VFbnRlckhhbmRsZXIiLCJvbk1vdXNlTW92ZUhhbmRsZXIiLCJvbk1vdXNlTGVhdmVIYW5kbGVyIiwib25Db250ZXh0TWVudUhhbmRsZXIiLCJvbkRvdWJsZUNsaWNrSGFuZGxlciIsIm9uU2VsZWN0Tm9kZUhhbmRsZXIiLCJzZWxlY3ROb2Rlc09uRHJhZyIsIm5vZGVEcmFnVGhyZXNob2xkIiwidG9Mb3dlckNhc2UiLCJvbkZvY3VzIiwiYXV0b1Bhbk9uTm9kZUZvY3VzIiwid2l0aGluVmlld3BvcnQiLCJwYXJlbnQiLCJ6SW5kZXgiLCJ6IiwicG9pbnRlckV2ZW50cyIsInZpc2liaWxpdHkiLCJyb2xlIiwiYXJpYVJvbGUiLCJhcmlhTGFiZWwiLCJkb21BdHRyaWJ1dGVzIiwicG9zaXRpb25BYnNvbHV0ZVgiLCJwb3NpdGlvbkFic29sdXRlWSIsImRlbGV0YWJsZSIsIk5vZGVXcmFwcGVyJDEiLCJzZWxlY3RvciRiIiwiTm9kZVJlbmRlcmVyQ29tcG9uZW50Iiwib25seVJlbmRlclZpc2libGVFbGVtZW50cyIsIm9uTm9kZUNsaWNrIiwib25Ob2RlTW91c2VFbnRlciIsIm9uTm9kZU1vdXNlTW92ZSIsIm9uTm9kZU1vdXNlTGVhdmUiLCJvbk5vZGVDb250ZXh0TWVudSIsIm9uTm9kZURvdWJsZUNsaWNrIiwiTm9kZVJlbmRlcmVyIiwidXNlVmlzaWJsZUVkZ2VJZHMiLCJlZGdlSWRzIiwidmlzaWJsZUVkZ2VJZHMiLCJzb3VyY2VOb2RlIiwidGFyZ2V0Tm9kZSIsIkFycm93U3ltYm9sIiwiY29sb3IiLCJzdHJva2VXaWR0aCIsInN0cm9rZSIsInN0cm9rZUxpbmVjYXAiLCJmaWxsIiwic3Ryb2tlTGluZWpvaW4iLCJwb2ludHMiLCJBcnJvd0Nsb3NlZFN5bWJvbCIsIk1hcmtlclN5bWJvbHMiLCJBcnJvdyIsIkFycm93Q2xvc2VkIiwidXNlTWFya2VyU3ltYm9sIiwic3ltYm9sIiwic3ltYm9sRXhpc3RzIiwiTWFya2VyIiwibWFya2VyVW5pdHMiLCJvcmllbnQiLCJTeW1ib2wiLCJtYXJrZXJXaWR0aCIsIm1hcmtlckhlaWdodCIsInZpZXdCb3giLCJyZWZYIiwicmVmWSIsIk1hcmtlckRlZmluaXRpb25zIiwiZGVmYXVsdENvbG9yIiwibWFya2VycyIsImRlZmF1bHRNYXJrZXJTdGFydCIsIm1hcmtlclN0YXJ0IiwiZGVmYXVsdE1hcmtlckVuZCIsIm1hcmtlckVuZCIsIm1hcmtlciIsIk1hcmtlckRlZmluaXRpb25zJDEiLCJFZGdlVGV4dENvbXBvbmVudCIsImxhYmVsU3R5bGUiLCJsYWJlbFNob3dCZyIsImxhYmVsQmdTdHlsZSIsImxhYmVsQmdQYWRkaW5nIiwibGFiZWxCZ0JvcmRlclJhZGl1cyIsImVkZ2VUZXh0QmJveCIsInNldEVkZ2VUZXh0QmJveCIsImVkZ2VUZXh0Q2xhc3NlcyIsImVkZ2VUZXh0UmVmIiwidGV4dEJib3giLCJnZXRCQm94IiwicngiLCJyeSIsImR5IiwiRWRnZVRleHQiLCJCYXNlRWRnZSIsInBhdGgiLCJsYWJlbFgiLCJsYWJlbFkiLCJpbnRlcmFjdGlvbldpZHRoIiwiZCIsInN0cm9rZU9wYWNpdHkiLCJnZXRDb250cm9sIiwicG9zIiwieDEiLCJ5MSIsIngyIiwieTIiLCJMZWZ0IiwiUmlnaHQiLCJnZXRTaW1wbGVCZXppZXJQYXRoIiwic291cmNlWCIsInNvdXJjZVkiLCJ0YXJnZXRYIiwidGFyZ2V0WSIsInNvdXJjZUNvbnRyb2xYIiwic291cmNlQ29udHJvbFkiLCJ0YXJnZXRDb250cm9sWCIsInRhcmdldENvbnRyb2xZIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJjcmVhdGVTaW1wbGVCZXppZXJFZGdlIiwiX2lkIiwiaXNJbnRlcm5hbCIsIlNpbXBsZUJlemllckVkZ2UiLCJTaW1wbGVCZXppZXJFZGdlSW50ZXJuYWwiLCJjcmVhdGVTbW9vdGhTdGVwRWRnZSIsInBhdGhPcHRpb25zIiwiYm9yZGVyUmFkaXVzIiwib2Zmc2V0Iiwic3RlcFBvc2l0aW9uIiwiU21vb3RoU3RlcEVkZ2UiLCJTbW9vdGhTdGVwRWRnZUludGVybmFsIiwiY3JlYXRlU3RlcEVkZ2UiLCJTdGVwRWRnZSIsIlN0ZXBFZGdlSW50ZXJuYWwiLCJjcmVhdGVTdHJhaWdodEVkZ2UiLCJTdHJhaWdodEVkZ2UiLCJTdHJhaWdodEVkZ2VJbnRlcm5hbCIsImNyZWF0ZUJlemllckVkZ2UiLCJjdXJ2YXR1cmUiLCJCZXppZXJFZGdlIiwiQmV6aWVyRWRnZUludGVybmFsIiwiYnVpbHRpbkVkZ2VUeXBlcyIsInN0cmFpZ2h0Iiwic3RlcCIsInNtb290aHN0ZXAiLCJzaW1wbGViZXppZXIiLCJudWxsUG9zaXRpb24iLCJzaGlmdFgiLCJzaGlmdCIsInNoaWZ0WSIsIkVkZ2VVcGRhdGVyQ2xhc3NOYW1lIiwiRWRnZUFuY2hvciIsImNlbnRlclgiLCJjZW50ZXJZIiwicmFkaXVzIiwib25Nb3VzZU91dCIsImN4IiwiY3kiLCJyIiwiRWRnZVVwZGF0ZUFuY2hvcnMiLCJpc1JlY29ubmVjdGFibGUiLCJyZWNvbm5lY3RSYWRpdXMiLCJvblJlY29ubmVjdCIsIm9uUmVjb25uZWN0U3RhcnQiLCJvblJlY29ubmVjdEVuZCIsInNldFJlY29ubmVjdGluZyIsInNldFVwZGF0ZUhvdmVyIiwiaGFuZGxlRWRnZVVwZGF0ZXIiLCJvcHBvc2l0ZUhhbmRsZSIsIl9vblJlY29ubmVjdEVuZCIsImV2dCIsIm9uQ29ubmVjdEVkZ2UiLCJfb25Db25uZWN0U3RhcnQiLCJfZXZlbnQiLCJlZGdlVXBkYXRlclR5cGUiLCJvblJlY29ubmVjdFNvdXJjZU1vdXNlRG93biIsInRhcmdldEhhbmRsZSIsIm9uUmVjb25uZWN0VGFyZ2V0TW91c2VEb3duIiwic291cmNlSGFuZGxlIiwib25SZWNvbm5lY3RNb3VzZUVudGVyIiwib25SZWNvbm5lY3RNb3VzZU91dCIsIkVkZ2VXcmFwcGVyIiwiZWRnZXNGb2N1c2FibGUiLCJlZGdlc1JlY29ubmVjdGFibGUiLCJlZGdlVHlwZXMiLCJlZGdlVHlwZSIsIkVkZ2VDb21wb25lbnQiLCJyZWNvbm5lY3RhYmxlIiwiZWRnZVJlZiIsInVwZGF0ZUhvdmVyIiwicmVjb25uZWN0aW5nIiwiZWRnZVBvc2l0aW9uIiwiZWxldmF0ZU9uU2VsZWN0IiwiZWxldmF0ZUVkZ2VzT25TZWxlY3QiLCJtYXJrZXJTdGFydFVybCIsIm1hcmtlckVuZFVybCIsIm9uRWRnZUNsaWNrIiwiYWRkU2VsZWN0ZWRFZGdlcyIsIm9uRWRnZURvdWJsZUNsaWNrIiwib25FZGdlQ29udGV4dE1lbnUiLCJvbkVkZ2VNb3VzZUVudGVyIiwib25FZGdlTW91c2VNb3ZlIiwib25FZGdlTW91c2VMZWF2ZSIsImFuaW1hdGVkIiwiaW5hY3RpdmUiLCJ1cGRhdGluZyIsInNvdXJjZUhhbmRsZUlkIiwidGFyZ2V0SGFuZGxlSWQiLCJFZGdlV3JhcHBlciQxIiwic2VsZWN0b3IkYSIsIkVkZ2VSZW5kZXJlckNvbXBvbmVudCIsImRlZmF1bHRNYXJrZXJDb2xvciIsIkVkZ2VSZW5kZXJlciIsInNlbGVjdG9yJDkiLCJWaWV3cG9ydCIsInVzZU9uSW5pdEhhbmRsZXIiLCJvbkluaXQiLCJyZkluc3RhbmNlIiwic2V0VGltZW91dCIsInNlbGVjdG9yJDgiLCJzeW5jVmlld3BvcnQiLCJ1c2VWaWV3cG9ydFN5bmMiLCJzdG9yZVNlbGVjdG9yJDEiLCJ0byIsImdldFNlbGVjdG9yIiwiY29ubmVjdGlvblNlbGVjdG9yIiwiY29tYmluZWRTZWxlY3RvciIsInVzZUNvbm5lY3Rpb24iLCJzZWxlY3RvciQ3IiwiQ29ubmVjdGlvbkxpbmVXcmFwcGVyIiwiY29tcG9uZW50IiwicmVuZGVyQ29ubmVjdGlvbiIsIkNvbm5lY3Rpb25MaW5lIiwiQ3VzdG9tQ29tcG9uZW50IiwiQmV6aWVyIiwiZnJvbU5vZGUiLCJmcm9tUG9zaXRpb24iLCJ0b05vZGUiLCJjb25uZWN0aW9uTGluZVR5cGUiLCJjb25uZWN0aW9uTGluZVN0eWxlIiwiZnJvbVgiLCJmcm9tWSIsInRvWCIsInRvWSIsImNvbm5lY3Rpb25TdGF0dXMiLCJwYXRoUGFyYW1zIiwiU2ltcGxlQmV6aWVyIiwiU3RlcCIsIlNtb290aFN0ZXAiLCJlbXB0eVR5cGVzIiwidXNlTm9kZU9yRWRnZVR5cGVzV2FybmluZyIsIm5vZGVPckVkZ2VUeXBlcyIsInR5cGVzUmVmIiwicHJvY2VzcyIsInVzZWRLZXlzIiwidXNlU3R5bGVzTG9hZGVkV2FybmluZyIsImNoZWNrZWQiLCJwYW5lIiwicXVlcnlTZWxlY3RvciIsImdldENvbXB1dGVkU3R5bGUiLCJHcmFwaFZpZXdDb21wb25lbnQiLCJjb25uZWN0aW9uTGluZUNvbXBvbmVudCIsImNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGUiLCJHcmFwaFZpZXciLCJnZXRJbml0aWFsU3RhdGUiLCJzdG9yZUVkZ2VzIiwic3RvcmVOb2RlcyIsInN0b3JlTm9kZU9yaWdpbiIsInN0b3JlTm9kZUV4dGVudCIsIm5vZGVzSW5pdGlhbGl6ZWQiLCJlbGV2YXRlTm9kZXNPblNlbGVjdCIsImF1dG9QYW5Pbk5vZGVEcmFnIiwiZGVidWciLCJjcmVhdGVTdG9yZSIsInJlc29sdmVGaXRWaWV3IiwiY2hlY2tFcXVhbGl0eSIsInVwZGF0ZWRJbnRlcm5hbHMiLCJjb25zb2xlIiwibG9nIiwibm9kZURyYWdJdGVtcyIsInBhcmVudEV4cGFuZENoaWxkcmVuIiwiZHJhZ0l0ZW0iLCJleHBhbmRQYXJlbnQiLCJtYXgiLCJyZWN0IiwicGFyZW50RXhwYW5kQ2hhbmdlcyIsInVwZGF0ZWROb2RlcyIsInVwZGF0ZWRFZGdlcyIsImNoYW5nZWRFZGdlcyIsIm5vZGVzVG9VbnNlbGVjdCIsImVkZ2VzVG9VbnNlbGVjdCIsInNldFNjYWxlRXh0ZW50IiwiY2xpY2tEaXN0YW5jZSIsInNldENsaWNrRGlzdGFuY2UiLCJuZXh0Tm9kZUV4dGVudCIsImRlbHRhIiwibmV4dFpvb20iLCJpcyIsIlJlYWN0Rmxvd1Byb3ZpZGVyIiwiaW5pdGlhbE5vZGVzIiwiaW5pdGlhbEVkZ2VzIiwiaW5pdGlhbE1pblpvb20iLCJpbml0aWFsTWF4Wm9vbSIsImluaXRpYWxGaXRWaWV3T3B0aW9ucyIsIldyYXBwZXIiLCJpc1dyYXBwZWQiLCJ3cmFwcGVyU3R5bGUiLCJSZWFjdEZsb3ciLCJvbk5vZGVEcmFnU3RhcnQiLCJvbk5vZGVEcmFnIiwib25Ob2RlRHJhZ1N0b3AiLCJvblNlbGVjdGlvbkRyYWdTdGFydCIsIm9uU2VsZWN0aW9uRHJhZyIsIm9uU2VsZWN0aW9uRHJhZ1N0b3AiLCJkZWZhdWx0Vmlld3BvcnQkMSIsImF0dHJpYnV0aW9uUG9zaXRpb24iLCJvblNjcm9sbCIsImNvbG9yTW9kZUNsYXNzTmFtZSIsIndyYXBwZXJPblNjcm9sbCIsInNjcm9sbFRvIiwiYmVoYXZpb3IiLCJzZWxlY3RvciQ2IiwiRWRnZUxhYmVsUmVuZGVyZXIiLCJlZGdlTGFiZWxSZW5kZXJlciIsInNlbGVjdG9yJDUiLCJWaWV3cG9ydFBvcnRhbCIsInZpZXdQb3J0YWxEaXYiLCJ1c2VVcGRhdGVOb2RlSW50ZXJuYWxzIiwidXBkYXRlSWRzIiwidXBkYXRlSWQiLCJ0cmlnZ2VyRml0VmlldyIsIm5vZGVzU2VsZWN0b3IiLCJ1c2VOb2RlcyIsImVkZ2VzU2VsZWN0b3IiLCJ1c2VFZGdlcyIsInZpZXdwb3J0U2VsZWN0b3IiLCJ1c2VWaWV3cG9ydCIsInVzZU5vZGVzU3RhdGUiLCJuZHMiLCJ1c2VFZGdlc1N0YXRlIiwiZWRzIiwidXNlT25WaWV3cG9ydENoYW5nZSIsIm9uU3RhcnQiLCJvbkNoYW5nZSIsIm9uRW5kIiwidXNlT25TZWxlY3Rpb25DaGFuZ2UiLCJuZXh0T25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVycyIsIm5leHRIYW5kbGVycyIsInNlbGVjdG9yJDQiLCJpbmNsdWRlSGlkZGVuTm9kZXMiLCJ1c2VOb2Rlc0luaXRpYWxpemVkIiwiaW5pdGlhbGl6ZWQiLCJ1c2VIYW5kbGVDb25uZWN0aW9ucyIsIm9uRGlzY29ubmVjdCIsIndhcm4iLCJfbm9kZUlkIiwiY3VycmVudE5vZGVJZCIsInByZXZDb25uZWN0aW9ucyIsIl9jb25uZWN0aW9ucyIsImVycm9yMDE0IiwidXNlTm9kZUNvbm5lY3Rpb25zIiwidXNlTm9kZXNEYXRhIiwibm9kZXNEYXRhIiwiaXNBcnJheU9mSWRzIiwiX25vZGVJZHMiLCJ1c2VJbnRlcm5hbE5vZGUiLCJMaW5lUGF0dGVybiIsImxpbmVXaWR0aCIsInZhcmlhbnQiLCJEb3RQYXR0ZXJuIiwiQmFja2dyb3VuZFZhcmlhbnQiLCJkZWZhdWx0U2l6ZSIsIkRvdHMiLCJMaW5lcyIsIkNyb3NzIiwic2VsZWN0b3IkMyIsInBhdHRlcm5JZCIsIkJhY2tncm91bmRDb21wb25lbnQiLCJnYXAiLCJiZ0NvbG9yIiwicGF0dGVybkNsYXNzTmFtZSIsInBhdHRlcm5TaXplIiwiaXNEb3RzIiwiaXNDcm9zcyIsImdhcFhZIiwic2NhbGVkR2FwIiwic2NhbGVkU2l6ZSIsIm9mZnNldFhZIiwicGF0dGVybkRpbWVuc2lvbnMiLCJzY2FsZWRPZmZzZXQiLCJfcGF0dGVybklkIiwicGF0dGVyblVuaXRzIiwicGF0dGVyblRyYW5zZm9ybSIsIkJhY2tncm91bmQiLCJQbHVzSWNvbiIsInhtbG5zIiwiTWludXNJY29uIiwiRml0Vmlld0ljb24iLCJMb2NrSWNvbiIsIlVubG9ja0ljb24iLCJDb250cm9sQnV0dG9uIiwic2VsZWN0b3IkMiIsImlzSW50ZXJhY3RpdmUiLCJtaW5ab29tUmVhY2hlZCIsIm1heFpvb21SZWFjaGVkIiwiQ29udHJvbHNDb21wb25lbnQiLCJzaG93Wm9vbSIsInNob3dGaXRWaWV3Iiwic2hvd0ludGVyYWN0aXZlIiwib25ab29tSW4iLCJvblpvb21PdXQiLCJvbkZpdFZpZXciLCJvbkludGVyYWN0aXZlQ2hhbmdlIiwib3JpZW50YXRpb24iLCJvblpvb21JbkhhbmRsZXIiLCJvblpvb21PdXRIYW5kbGVyIiwib25GaXRWaWV3SGFuZGxlciIsIm9uVG9nZ2xlSW50ZXJhY3Rpdml0eSIsIm9yaWVudGF0aW9uQ2xhc3MiLCJ0aXRsZSIsIkNvbnRyb2xzIiwiTWluaU1hcE5vZGVDb21wb25lbnQiLCJzdHJva2VDb2xvciIsInNoYXBlUmVuZGVyaW5nIiwiYmFja2dyb3VuZCIsImJhY2tncm91bmRDb2xvciIsIk1pbmlNYXBOb2RlIiwic2VsZWN0b3JOb2RlSWRzIiwiZ2V0QXR0ckZ1bmN0aW9uIiwiZnVuYyIsIkZ1bmN0aW9uIiwiTWluaU1hcE5vZGVzIiwibm9kZVN0cm9rZUNvbG9yIiwibm9kZUNvbG9yIiwibm9kZUNsYXNzTmFtZSIsIm5vZGVCb3JkZXJSYWRpdXMiLCJub2RlU3Ryb2tlV2lkdGgiLCJub2RlQ29tcG9uZW50Iiwibm9kZUNvbG9yRnVuYyIsIm5vZGVTdHJva2VDb2xvckZ1bmMiLCJub2RlQ2xhc3NOYW1lRnVuYyIsImNocm9tZSIsIk5vZGVDb21wb25lbnRXcmFwcGVyIiwiTm9kZUNvbXBvbmVudFdyYXBwZXJJbm5lciIsIk1pbmlNYXBOb2RlcyQxIiwiZGVmYXVsdFdpZHRoIiwiZGVmYXVsdEhlaWdodCIsImZpbHRlckhpZGRlbiIsInNlbGVjdG9yJDEiLCJ2aWV3QkIiLCJib3VuZGluZ1JlY3QiLCJmbG93V2lkdGgiLCJmbG93SGVpZ2h0IiwiQVJJQV9MQUJFTF9LRVkiLCJNaW5pTWFwQ29tcG9uZW50IiwibWFza0NvbG9yIiwibWFza1N0cm9rZUNvbG9yIiwibWFza1N0cm9rZVdpZHRoIiwicGFubmFibGUiLCJ6b29tYWJsZSIsImludmVyc2VQYW4iLCJ6b29tU3RlcCIsIm9mZnNldFNjYWxlIiwic3ZnIiwiZWxlbWVudFdpZHRoIiwiZWxlbWVudEhlaWdodCIsInNjYWxlZFdpZHRoIiwic2NhbGVkSGVpZ2h0Iiwidmlld1NjYWxlIiwidmlld1dpZHRoIiwidmlld0hlaWdodCIsImxhYmVsbGVkQnkiLCJ2aWV3U2NhbGVSZWYiLCJtaW5pbWFwSW5zdGFuY2UiLCJnZXRWaWV3U2NhbGUiLCJvblN2Z0NsaWNrIiwicG9pbnRlciIsIm9uU3ZnTm9kZUNsaWNrIiwiX2FyaWFMYWJlbCIsImZpbGxSdWxlIiwiTWluaU1hcCIsInNjYWxlU2VsZWN0b3IiLCJjYWxjdWxhdGVTY2FsZSIsImRlZmF1bHRQb3NpdGlvbnMiLCJMaW5lIiwiUmVzaXplQ29udHJvbCIsIm1pbldpZHRoIiwibWluSGVpZ2h0IiwibWF4V2lkdGgiLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJtYXhIZWlnaHQiLCJrZWVwQXNwZWN0UmF0aW8iLCJyZXNpemVEaXJlY3Rpb24iLCJhdXRvU2NhbGUiLCJzaG91bGRSZXNpemUiLCJvblJlc2l6ZVN0YXJ0Iiwib25SZXNpemUiLCJvblJlc2l6ZUVuZCIsImNvbnRleHROb2RlSWQiLCJyZXNpemVDb250cm9sUmVmIiwiaXNIYW5kbGVDb250cm9sIiwic2NhbGUiLCJyZXNpemVyIiwiY29udHJvbFBvc2l0aW9uIiwicGFuZURvbU5vZGUiLCJjaGlsZENoYW5nZXMiLCJvcmlnaW4iLCJjaGlsZCIsInBvc2l0aW9uQ2hhbmdlIiwiZGltZW5zaW9uQ2hhbmdlIiwiY2hpbGRDaGFuZ2UiLCJib3VuZGFyaWVzIiwicG9zaXRpb25DbGFzc05hbWVzIiwiTm9kZVJlc2l6ZUNvbnRyb2wiLCJOb2RlUmVzaXplciIsImlzVmlzaWJsZSIsImhhbmRsZUNsYXNzTmFtZSIsImhhbmRsZVN0eWxlIiwibGluZUNsYXNzTmFtZSIsImxpbmVTdHlsZSIsIk5vZGVUb29sYmFyUG9ydGFsIiwid3JhcHBlclJlZiIsIm5vZGVFcXVhbGl0eUZuIiwibm9kZXNFcXVhbGl0eUZuIiwic3RvcmVTZWxlY3RvciIsInNlbGVjdGVkTm9kZXNDb3VudCIsIk5vZGVUb29sYmFyIiwiYWxpZ24iLCJpbnRlcm5hbE5vZGVzIiwibm9kZXNBcnJheSIsImFjYyIsInRyaW0iLCJ6b29tU2VsZWN0b3IiLCJFZGdlVG9vbGJhciIsImFsaWduWCIsImFsaWduWSIsImVkZ2VTZWxlY3RvciIsInRyYW5zZm9ybU9yaWdpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xyflow/react/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xyflow/system/dist/esm/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@xyflow/system/dist/esm/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectionLineType: () => (/* binding */ ConnectionLineType),\n/* harmony export */   ConnectionMode: () => (/* binding */ ConnectionMode),\n/* harmony export */   MarkerType: () => (/* binding */ MarkerType),\n/* harmony export */   PanOnScrollMode: () => (/* binding */ PanOnScrollMode),\n/* harmony export */   Position: () => (/* binding */ Position),\n/* harmony export */   ResizeControlVariant: () => (/* binding */ ResizeControlVariant),\n/* harmony export */   SelectionMode: () => (/* binding */ SelectionMode),\n/* harmony export */   XYDrag: () => (/* binding */ XYDrag),\n/* harmony export */   XYHandle: () => (/* binding */ XYHandle),\n/* harmony export */   XYMinimap: () => (/* binding */ XYMinimap),\n/* harmony export */   XYPanZoom: () => (/* binding */ XYPanZoom),\n/* harmony export */   XYResizer: () => (/* binding */ XYResizer),\n/* harmony export */   XY_RESIZER_HANDLE_POSITIONS: () => (/* binding */ XY_RESIZER_HANDLE_POSITIONS),\n/* harmony export */   XY_RESIZER_LINE_POSITIONS: () => (/* binding */ XY_RESIZER_LINE_POSITIONS),\n/* harmony export */   addEdge: () => (/* binding */ addEdge),\n/* harmony export */   adoptUserNodes: () => (/* binding */ adoptUserNodes),\n/* harmony export */   areConnectionMapsEqual: () => (/* binding */ areConnectionMapsEqual),\n/* harmony export */   areSetsEqual: () => (/* binding */ areSetsEqual),\n/* harmony export */   boxToRect: () => (/* binding */ boxToRect),\n/* harmony export */   calcAutoPan: () => (/* binding */ calcAutoPan),\n/* harmony export */   calculateNodePosition: () => (/* binding */ calculateNodePosition),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   clampPosition: () => (/* binding */ clampPosition),\n/* harmony export */   clampPositionToParent: () => (/* binding */ clampPositionToParent),\n/* harmony export */   createMarkerIds: () => (/* binding */ createMarkerIds),\n/* harmony export */   defaultAriaLabelConfig: () => (/* binding */ defaultAriaLabelConfig),\n/* harmony export */   devWarn: () => (/* binding */ devWarn),\n/* harmony export */   elementSelectionKeys: () => (/* binding */ elementSelectionKeys),\n/* harmony export */   errorMessages: () => (/* binding */ errorMessages),\n/* harmony export */   evaluateAbsolutePosition: () => (/* binding */ evaluateAbsolutePosition),\n/* harmony export */   fitViewport: () => (/* binding */ fitViewport),\n/* harmony export */   getBezierEdgeCenter: () => (/* binding */ getBezierEdgeCenter),\n/* harmony export */   getBezierPath: () => (/* binding */ getBezierPath),\n/* harmony export */   getBoundsOfBoxes: () => (/* binding */ getBoundsOfBoxes),\n/* harmony export */   getBoundsOfRects: () => (/* binding */ getBoundsOfRects),\n/* harmony export */   getConnectedEdges: () => (/* binding */ getConnectedEdges),\n/* harmony export */   getConnectionStatus: () => (/* binding */ getConnectionStatus),\n/* harmony export */   getDimensions: () => (/* binding */ getDimensions),\n/* harmony export */   getEdgeCenter: () => (/* binding */ getEdgeCenter),\n/* harmony export */   getEdgePosition: () => (/* binding */ getEdgePosition),\n/* harmony export */   getEdgeToolbarTransform: () => (/* binding */ getEdgeToolbarTransform),\n/* harmony export */   getElementsToRemove: () => (/* binding */ getElementsToRemove),\n/* harmony export */   getElevatedEdgeZIndex: () => (/* binding */ getElevatedEdgeZIndex),\n/* harmony export */   getEventPosition: () => (/* binding */ getEventPosition),\n/* harmony export */   getHandleBounds: () => (/* binding */ getHandleBounds),\n/* harmony export */   getHandlePosition: () => (/* binding */ getHandlePosition),\n/* harmony export */   getHostForElement: () => (/* binding */ getHostForElement),\n/* harmony export */   getIncomers: () => (/* binding */ getIncomers),\n/* harmony export */   getInternalNodesBounds: () => (/* binding */ getInternalNodesBounds),\n/* harmony export */   getMarkerId: () => (/* binding */ getMarkerId),\n/* harmony export */   getNodeDimensions: () => (/* binding */ getNodeDimensions),\n/* harmony export */   getNodePositionWithOrigin: () => (/* binding */ getNodePositionWithOrigin),\n/* harmony export */   getNodeToolbarTransform: () => (/* binding */ getNodeToolbarTransform),\n/* harmony export */   getNodesBounds: () => (/* binding */ getNodesBounds),\n/* harmony export */   getNodesInside: () => (/* binding */ getNodesInside),\n/* harmony export */   getOutgoers: () => (/* binding */ getOutgoers),\n/* harmony export */   getOverlappingArea: () => (/* binding */ getOverlappingArea),\n/* harmony export */   getPointerPosition: () => (/* binding */ getPointerPosition),\n/* harmony export */   getSmoothStepPath: () => (/* binding */ getSmoothStepPath),\n/* harmony export */   getStraightPath: () => (/* binding */ getStraightPath),\n/* harmony export */   getViewportForBounds: () => (/* binding */ getViewportForBounds),\n/* harmony export */   handleConnectionChange: () => (/* binding */ handleConnectionChange),\n/* harmony export */   handleExpandParent: () => (/* binding */ handleExpandParent),\n/* harmony export */   infiniteExtent: () => (/* binding */ infiniteExtent),\n/* harmony export */   initialConnection: () => (/* binding */ initialConnection),\n/* harmony export */   isCoordinateExtent: () => (/* binding */ isCoordinateExtent),\n/* harmony export */   isEdgeBase: () => (/* binding */ isEdgeBase),\n/* harmony export */   isEdgeVisible: () => (/* binding */ isEdgeVisible),\n/* harmony export */   isInputDOMNode: () => (/* binding */ isInputDOMNode),\n/* harmony export */   isInternalNodeBase: () => (/* binding */ isInternalNodeBase),\n/* harmony export */   isMacOs: () => (/* binding */ isMacOs),\n/* harmony export */   isMouseEvent: () => (/* binding */ isMouseEvent),\n/* harmony export */   isNodeBase: () => (/* binding */ isNodeBase),\n/* harmony export */   isNumeric: () => (/* binding */ isNumeric),\n/* harmony export */   isRectObject: () => (/* binding */ isRectObject),\n/* harmony export */   mergeAriaLabelConfig: () => (/* binding */ mergeAriaLabelConfig),\n/* harmony export */   nodeHasDimensions: () => (/* binding */ nodeHasDimensions),\n/* harmony export */   nodeToBox: () => (/* binding */ nodeToBox),\n/* harmony export */   nodeToRect: () => (/* binding */ nodeToRect),\n/* harmony export */   oppositePosition: () => (/* binding */ oppositePosition),\n/* harmony export */   panBy: () => (/* binding */ panBy),\n/* harmony export */   pointToRendererPoint: () => (/* binding */ pointToRendererPoint),\n/* harmony export */   reconnectEdge: () => (/* binding */ reconnectEdge),\n/* harmony export */   rectToBox: () => (/* binding */ rectToBox),\n/* harmony export */   rendererPointToPoint: () => (/* binding */ rendererPointToPoint),\n/* harmony export */   shallowNodeData: () => (/* binding */ shallowNodeData),\n/* harmony export */   snapPosition: () => (/* binding */ snapPosition),\n/* harmony export */   updateAbsolutePositions: () => (/* binding */ updateAbsolutePositions),\n/* harmony export */   updateConnectionLookup: () => (/* binding */ updateConnectionLookup),\n/* harmony export */   updateNodeInternals: () => (/* binding */ updateNodeInternals),\n/* harmony export */   withResolvers: () => (/* binding */ withResolvers)\n/* harmony export */ });\n/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-drag */ \"(ssr)/./node_modules/d3-drag/src/drag.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ \"(ssr)/./node_modules/d3-selection/src/select.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ \"(ssr)/./node_modules/d3-selection/src/pointer.js\");\n/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-zoom */ \"(ssr)/./node_modules/d3-zoom/src/index.js\");\n/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-interpolate */ \"(ssr)/./node_modules/d3-interpolate/src/value.js\");\n/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ \"(ssr)/./node_modules/d3-interpolate/src/zoom.js\");\n\n\n\n\nconst errorMessages = {\n    error001: ()=>\"[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001\",\n    error002: ()=>\"It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.\",\n    error003: (nodeType)=>`Node type \"${nodeType}\" not found. Using fallback type \"default\".`,\n    error004: ()=>\"The React Flow parent container needs a width and a height to render the graph.\",\n    error005: ()=>\"Only child nodes can use a parent extent.\",\n    error006: ()=>\"Can't create edge. An edge needs a source and a target.\",\n    error007: (id)=>`The old edge with id=${id} does not exist.`,\n    error009: (type)=>`Marker type \"${type}\" doesn't exist.`,\n    error008: (handleType, { id, sourceHandle, targetHandle })=>`Couldn't create edge for ${handleType} handle id: \"${handleType === \"source\" ? sourceHandle : targetHandle}\", edge id: ${id}.`,\n    error010: ()=>\"Handle: No node id found. Make sure to only use a Handle inside a custom Node.\",\n    error011: (edgeType)=>`Edge type \"${edgeType}\" not found. Using fallback type \"default\".`,\n    error012: (id)=>`Node with id \"${id}\" does not exist, it may have been removed. This can happen when a node is deleted before the \"onNodeClick\" handler is called.`,\n    error013: (lib = \"react\")=>`It seems that you haven't loaded the styles. Please import '@xyflow/${lib}/dist/style.css' or base.css to make sure everything is working properly.`,\n    error014: ()=>\"useNodeConnections: No node ID found. Call useNodeConnections inside a custom Node or provide a node ID.\",\n    error015: ()=>\"It seems that you are trying to drag a node that is not initialized. Please use onNodesChange as explained in the docs.\"\n};\nconst infiniteExtent = [\n    [\n        Number.NEGATIVE_INFINITY,\n        Number.NEGATIVE_INFINITY\n    ],\n    [\n        Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY\n    ]\n];\nconst elementSelectionKeys = [\n    \"Enter\",\n    \" \",\n    \"Escape\"\n];\nconst defaultAriaLabelConfig = {\n    \"node.a11yDescription.default\": \"Press enter or space to select a node. Press delete to remove it and escape to cancel.\",\n    \"node.a11yDescription.keyboardDisabled\": \"Press enter or space to select a node. You can then use the arrow keys to move the node around. Press delete to remove it and escape to cancel.\",\n    \"node.a11yDescription.ariaLiveMessage\": ({ direction, x, y })=>`Moved selected node ${direction}. New position, x: ${x}, y: ${y}`,\n    \"edge.a11yDescription.default\": \"Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.\",\n    // Control elements\n    \"controls.ariaLabel\": \"Control Panel\",\n    \"controls.zoomIn.ariaLabel\": \"Zoom In\",\n    \"controls.zoomOut.ariaLabel\": \"Zoom Out\",\n    \"controls.fitView.ariaLabel\": \"Fit View\",\n    \"controls.interactive.ariaLabel\": \"Toggle Interactivity\",\n    // Mini map\n    \"minimap.ariaLabel\": \"Mini Map\",\n    // Handle\n    \"handle.ariaLabel\": \"Handle\"\n};\n/**\n * The `ConnectionMode` is used to set the mode of connection between nodes.\n * The `Strict` mode is the default one and only allows source to target edges.\n * `Loose` mode allows source to source and target to target edges as well.\n *\n * @public\n */ var ConnectionMode;\n(function(ConnectionMode) {\n    ConnectionMode[\"Strict\"] = \"strict\";\n    ConnectionMode[\"Loose\"] = \"loose\";\n})(ConnectionMode || (ConnectionMode = {}));\n/**\n * This enum is used to set the different modes of panning the viewport when the\n * user scrolls. The `Free` mode allows the user to pan in any direction by scrolling\n * with a device like a trackpad. The `Vertical` and `Horizontal` modes restrict\n * scroll panning to only the vertical or horizontal axis, respectively.\n *\n * @public\n */ var PanOnScrollMode;\n(function(PanOnScrollMode) {\n    PanOnScrollMode[\"Free\"] = \"free\";\n    PanOnScrollMode[\"Vertical\"] = \"vertical\";\n    PanOnScrollMode[\"Horizontal\"] = \"horizontal\";\n})(PanOnScrollMode || (PanOnScrollMode = {}));\nvar SelectionMode;\n(function(SelectionMode) {\n    SelectionMode[\"Partial\"] = \"partial\";\n    SelectionMode[\"Full\"] = \"full\";\n})(SelectionMode || (SelectionMode = {}));\nconst initialConnection = {\n    inProgress: false,\n    isValid: null,\n    from: null,\n    fromHandle: null,\n    fromPosition: null,\n    fromNode: null,\n    to: null,\n    toHandle: null,\n    toPosition: null,\n    toNode: null\n};\n/**\n * If you set the `connectionLineType` prop on your [`<ReactFlow />`](/api-reference/react-flow#connection-connectionLineType)\n *component, it will dictate the style of connection line rendered when creating\n *new edges.\n *\n * @public\n *\n * @remarks If you choose to render a custom connection line component, this value will be\n *passed to your component as part of its [`ConnectionLineComponentProps`](/api-reference/types/connection-line-component-props).\n */ var ConnectionLineType;\n(function(ConnectionLineType) {\n    ConnectionLineType[\"Bezier\"] = \"default\";\n    ConnectionLineType[\"Straight\"] = \"straight\";\n    ConnectionLineType[\"Step\"] = \"step\";\n    ConnectionLineType[\"SmoothStep\"] = \"smoothstep\";\n    ConnectionLineType[\"SimpleBezier\"] = \"simplebezier\";\n})(ConnectionLineType || (ConnectionLineType = {}));\n/**\n * Edges may optionally have a marker on either end. The MarkerType type enumerates\n * the options available to you when configuring a given marker.\n *\n * @public\n */ var MarkerType;\n(function(MarkerType) {\n    MarkerType[\"Arrow\"] = \"arrow\";\n    MarkerType[\"ArrowClosed\"] = \"arrowclosed\";\n})(MarkerType || (MarkerType = {}));\n/**\n * While [`PanelPosition`](/api-reference/types/panel-position) can be used to place a\n * component in the corners of a container, the `Position` enum is less precise and used\n * primarily in relation to edges and handles.\n *\n * @public\n */ var Position;\n(function(Position) {\n    Position[\"Left\"] = \"left\";\n    Position[\"Top\"] = \"top\";\n    Position[\"Right\"] = \"right\";\n    Position[\"Bottom\"] = \"bottom\";\n})(Position || (Position = {}));\nconst oppositePosition = {\n    [Position.Left]: Position.Right,\n    [Position.Right]: Position.Left,\n    [Position.Top]: Position.Bottom,\n    [Position.Bottom]: Position.Top\n};\n/**\n * @internal\n */ function areConnectionMapsEqual(a, b) {\n    if (!a && !b) {\n        return true;\n    }\n    if (!a || !b || a.size !== b.size) {\n        return false;\n    }\n    if (!a.size && !b.size) {\n        return true;\n    }\n    for (const key of a.keys()){\n        if (!b.has(key)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * We call the callback for all connections in a that are not in b\n *\n * @internal\n */ function handleConnectionChange(a, b, cb) {\n    if (!cb) {\n        return;\n    }\n    const diff = [];\n    a.forEach((connection, key)=>{\n        if (!b?.has(key)) {\n            diff.push(connection);\n        }\n    });\n    if (diff.length) {\n        cb(diff);\n    }\n}\nfunction getConnectionStatus(isValid) {\n    return isValid === null ? null : isValid ? \"valid\" : \"invalid\";\n}\n/* eslint-disable @typescript-eslint/no-explicit-any */ /**\n * Test whether an object is usable as an Edge\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Edge if it returns true\n * @param element - The element to test\n * @returns A boolean indicating whether the element is an Edge\n */ const isEdgeBase = (element)=>\"id\" in element && \"source\" in element && \"target\" in element;\n/**\n * Test whether an object is usable as a Node\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Node if it returns true\n * @param element - The element to test\n * @returns A boolean indicating whether the element is an Node\n */ const isNodeBase = (element)=>\"id\" in element && \"position\" in element && !(\"source\" in element) && !(\"target\" in element);\nconst isInternalNodeBase = (element)=>\"id\" in element && \"internals\" in element && !(\"source\" in element) && !(\"target\" in element);\n/**\n * This util is used to tell you what nodes, if any, are connected to the given node\n * as the _target_ of an edge.\n * @public\n * @param node - The node to get the connected nodes from.\n * @param nodes - The array of all nodes.\n * @param edges - The array of all edges.\n * @returns An array of nodes that are connected over edges where the source is the given node.\n *\n * @example\n * ```ts\n *import { getOutgoers } from '@xyflow/react';\n *\n *const nodes = [];\n *const edges = [];\n *\n *const outgoers = getOutgoers(\n *  { id: '1', position: { x: 0, y: 0 }, data: { label: 'node' } },\n *  nodes,\n *  edges,\n *);\n *```\n */ const getOutgoers = (node, nodes, edges)=>{\n    if (!node.id) {\n        return [];\n    }\n    const outgoerIds = new Set();\n    edges.forEach((edge)=>{\n        if (edge.source === node.id) {\n            outgoerIds.add(edge.target);\n        }\n    });\n    return nodes.filter((n)=>outgoerIds.has(n.id));\n};\n/**\n * This util is used to tell you what nodes, if any, are connected to the given node\n * as the _source_ of an edge.\n * @public\n * @param node - The node to get the connected nodes from.\n * @param nodes - The array of all nodes.\n * @param edges - The array of all edges.\n * @returns An array of nodes that are connected over edges where the target is the given node.\n *\n * @example\n * ```ts\n *import { getIncomers } from '@xyflow/react';\n *\n *const nodes = [];\n *const edges = [];\n *\n *const incomers = getIncomers(\n *  { id: '1', position: { x: 0, y: 0 }, data: { label: 'node' } },\n *  nodes,\n *  edges,\n *);\n *```\n */ const getIncomers = (node, nodes, edges)=>{\n    if (!node.id) {\n        return [];\n    }\n    const incomersIds = new Set();\n    edges.forEach((edge)=>{\n        if (edge.target === node.id) {\n            incomersIds.add(edge.source);\n        }\n    });\n    return nodes.filter((n)=>incomersIds.has(n.id));\n};\nconst getNodePositionWithOrigin = (node, nodeOrigin = [\n    0,\n    0\n])=>{\n    const { width, height } = getNodeDimensions(node);\n    const origin = node.origin ?? nodeOrigin;\n    const offsetX = width * origin[0];\n    const offsetY = height * origin[1];\n    return {\n        x: node.position.x - offsetX,\n        y: node.position.y - offsetY\n    };\n};\n/**\n * Returns the bounding box that contains all the given nodes in an array. This can\n * be useful when combined with [`getViewportForBounds`](/api-reference/utils/get-viewport-for-bounds)\n * to calculate the correct transform to fit the given nodes in a viewport.\n * @public\n * @remarks Useful when combined with {@link getViewportForBounds} to calculate the correct transform to fit the given nodes in a viewport.\n * @param nodes - Nodes to calculate the bounds for.\n * @returns Bounding box enclosing all nodes.\n *\n * @remarks This function was previously called `getRectOfNodes`\n *\n * @example\n * ```js\n *import { getNodesBounds } from '@xyflow/react';\n *\n *const nodes = [\n *  {\n *    id: 'a',\n *    position: { x: 0, y: 0 },\n *    data: { label: 'a' },\n *    width: 50,\n *    height: 25,\n *  },\n *  {\n *    id: 'b',\n *    position: { x: 100, y: 100 },\n *    data: { label: 'b' },\n *    width: 50,\n *    height: 25,\n *  },\n *];\n *\n *const bounds = getNodesBounds(nodes);\n *```\n */ const getNodesBounds = (nodes, params = {\n    nodeOrigin: [\n        0,\n        0\n    ]\n})=>{\n    if ( true && !params.nodeLookup) {\n        console.warn(\"Please use `getNodesBounds` from `useReactFlow`/`useSvelteFlow` hook to ensure correct values for sub flows. If not possible, you have to provide a nodeLookup to support sub flows.\");\n    }\n    if (nodes.length === 0) {\n        return {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        };\n    }\n    const box = nodes.reduce((currBox, nodeOrId)=>{\n        const isId = typeof nodeOrId === \"string\";\n        let currentNode = !params.nodeLookup && !isId ? nodeOrId : undefined;\n        if (params.nodeLookup) {\n            currentNode = isId ? params.nodeLookup.get(nodeOrId) : !isInternalNodeBase(nodeOrId) ? params.nodeLookup.get(nodeOrId.id) : nodeOrId;\n        }\n        const nodeBox = currentNode ? nodeToBox(currentNode, params.nodeOrigin) : {\n            x: 0,\n            y: 0,\n            x2: 0,\n            y2: 0\n        };\n        return getBoundsOfBoxes(currBox, nodeBox);\n    }, {\n        x: Infinity,\n        y: Infinity,\n        x2: -Infinity,\n        y2: -Infinity\n    });\n    return boxToRect(box);\n};\n/**\n * Determines a bounding box that contains all given nodes in an array\n * @internal\n */ const getInternalNodesBounds = (nodeLookup, params = {})=>{\n    let box = {\n        x: Infinity,\n        y: Infinity,\n        x2: -Infinity,\n        y2: -Infinity\n    };\n    let hasVisibleNodes = false;\n    nodeLookup.forEach((node)=>{\n        if (params.filter === undefined || params.filter(node)) {\n            box = getBoundsOfBoxes(box, nodeToBox(node));\n            hasVisibleNodes = true;\n        }\n    });\n    return hasVisibleNodes ? boxToRect(box) : {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n    };\n};\nconst getNodesInside = (nodes, rect, [tx, ty, tScale] = [\n    0,\n    0,\n    1\n], partially = false, // set excludeNonSelectableNodes if you want to pay attention to the nodes \"selectable\" attribute\nexcludeNonSelectableNodes = false)=>{\n    const paneRect = {\n        ...pointToRendererPoint(rect, [\n            tx,\n            ty,\n            tScale\n        ]),\n        width: rect.width / tScale,\n        height: rect.height / tScale\n    };\n    const visibleNodes = [];\n    for (const node of nodes.values()){\n        const { measured, selectable = true, hidden = false } = node;\n        if (excludeNonSelectableNodes && !selectable || hidden) {\n            continue;\n        }\n        const width = measured.width ?? node.width ?? node.initialWidth ?? null;\n        const height = measured.height ?? node.height ?? node.initialHeight ?? null;\n        const overlappingArea = getOverlappingArea(paneRect, nodeToRect(node));\n        const area = (width ?? 0) * (height ?? 0);\n        const partiallyVisible = partially && overlappingArea > 0;\n        const forceInitialRender = !node.internals.handleBounds;\n        const isVisible = forceInitialRender || partiallyVisible || overlappingArea >= area;\n        if (isVisible || node.dragging) {\n            visibleNodes.push(node);\n        }\n    }\n    return visibleNodes;\n};\n/**\n * This utility filters an array of edges, keeping only those where either the source or target\n * node is present in the given array of nodes.\n * @public\n * @param nodes - Nodes you want to get the connected edges for.\n * @param edges - All edges.\n * @returns Array of edges that connect any of the given nodes with each other.\n *\n * @example\n * ```js\n *import { getConnectedEdges } from '@xyflow/react';\n *\n *const nodes = [\n *  { id: 'a', position: { x: 0, y: 0 } },\n *  { id: 'b', position: { x: 100, y: 0 } },\n *];\n *\n *const edges = [\n *  { id: 'a->c', source: 'a', target: 'c' },\n *  { id: 'c->d', source: 'c', target: 'd' },\n *];\n *\n *const connectedEdges = getConnectedEdges(nodes, edges);\n * // => [{ id: 'a->c', source: 'a', target: 'c' }]\n *```\n */ const getConnectedEdges = (nodes, edges)=>{\n    const nodeIds = new Set();\n    nodes.forEach((node)=>{\n        nodeIds.add(node.id);\n    });\n    return edges.filter((edge)=>nodeIds.has(edge.source) || nodeIds.has(edge.target));\n};\nfunction getFitViewNodes(nodeLookup, options) {\n    const fitViewNodes = new Map();\n    const optionNodeIds = options?.nodes ? new Set(options.nodes.map((node)=>node.id)) : null;\n    nodeLookup.forEach((n)=>{\n        const isVisible = n.measured.width && n.measured.height && (options?.includeHiddenNodes || !n.hidden);\n        if (isVisible && (!optionNodeIds || optionNodeIds.has(n.id))) {\n            fitViewNodes.set(n.id, n);\n        }\n    });\n    return fitViewNodes;\n}\nasync function fitViewport({ nodes, width, height, panZoom, minZoom, maxZoom }, options) {\n    if (nodes.size === 0) {\n        return Promise.resolve(true);\n    }\n    const nodesToFit = getFitViewNodes(nodes, options);\n    const bounds = getInternalNodesBounds(nodesToFit);\n    const viewport = getViewportForBounds(bounds, width, height, options?.minZoom ?? minZoom, options?.maxZoom ?? maxZoom, options?.padding ?? 0.1);\n    await panZoom.setViewport(viewport, {\n        duration: options?.duration,\n        ease: options?.ease,\n        interpolate: options?.interpolate\n    });\n    return Promise.resolve(true);\n}\n/**\n * This function calculates the next position of a node, taking into account the node's extent, parent node, and origin.\n *\n * @internal\n * @returns position, positionAbsolute\n */ function calculateNodePosition({ nodeId, nextPosition, nodeLookup, nodeOrigin = [\n    0,\n    0\n], nodeExtent, onError }) {\n    const node = nodeLookup.get(nodeId);\n    const parentNode = node.parentId ? nodeLookup.get(node.parentId) : undefined;\n    const { x: parentX, y: parentY } = parentNode ? parentNode.internals.positionAbsolute : {\n        x: 0,\n        y: 0\n    };\n    const origin = node.origin ?? nodeOrigin;\n    let extent = node.extent || nodeExtent;\n    if (node.extent === \"parent\" && !node.expandParent) {\n        if (!parentNode) {\n            onError?.(\"005\", errorMessages[\"error005\"]());\n        } else {\n            const parentWidth = parentNode.measured.width;\n            const parentHeight = parentNode.measured.height;\n            if (parentWidth && parentHeight) {\n                extent = [\n                    [\n                        parentX,\n                        parentY\n                    ],\n                    [\n                        parentX + parentWidth,\n                        parentY + parentHeight\n                    ]\n                ];\n            }\n        }\n    } else if (parentNode && isCoordinateExtent(node.extent)) {\n        extent = [\n            [\n                node.extent[0][0] + parentX,\n                node.extent[0][1] + parentY\n            ],\n            [\n                node.extent[1][0] + parentX,\n                node.extent[1][1] + parentY\n            ]\n        ];\n    }\n    const positionAbsolute = isCoordinateExtent(extent) ? clampPosition(nextPosition, extent, node.measured) : nextPosition;\n    if (node.measured.width === undefined || node.measured.height === undefined) {\n        onError?.(\"015\", errorMessages[\"error015\"]());\n    }\n    return {\n        position: {\n            x: positionAbsolute.x - parentX + (node.measured.width ?? 0) * origin[0],\n            y: positionAbsolute.y - parentY + (node.measured.height ?? 0) * origin[1]\n        },\n        positionAbsolute\n    };\n}\n/**\n * Pass in nodes & edges to delete, get arrays of nodes and edges that actually can be deleted\n * @internal\n * @param param.nodesToRemove - The nodes to remove\n * @param param.edgesToRemove - The edges to remove\n * @param param.nodes - All nodes\n * @param param.edges - All edges\n * @param param.onBeforeDelete - Callback to check which nodes and edges can be deleted\n * @returns nodes: nodes that can be deleted, edges: edges that can be deleted\n */ async function getElementsToRemove({ nodesToRemove = [], edgesToRemove = [], nodes, edges, onBeforeDelete }) {\n    const nodeIds = new Set(nodesToRemove.map((node)=>node.id));\n    const matchingNodes = [];\n    for (const node of nodes){\n        if (node.deletable === false) {\n            continue;\n        }\n        const isIncluded = nodeIds.has(node.id);\n        const parentHit = !isIncluded && node.parentId && matchingNodes.find((n)=>n.id === node.parentId);\n        if (isIncluded || parentHit) {\n            matchingNodes.push(node);\n        }\n    }\n    const edgeIds = new Set(edgesToRemove.map((edge)=>edge.id));\n    const deletableEdges = edges.filter((edge)=>edge.deletable !== false);\n    const connectedEdges = getConnectedEdges(matchingNodes, deletableEdges);\n    const matchingEdges = connectedEdges;\n    for (const edge of deletableEdges){\n        const isIncluded = edgeIds.has(edge.id);\n        if (isIncluded && !matchingEdges.find((e)=>e.id === edge.id)) {\n            matchingEdges.push(edge);\n        }\n    }\n    if (!onBeforeDelete) {\n        return {\n            edges: matchingEdges,\n            nodes: matchingNodes\n        };\n    }\n    const onBeforeDeleteResult = await onBeforeDelete({\n        nodes: matchingNodes,\n        edges: matchingEdges\n    });\n    if (typeof onBeforeDeleteResult === \"boolean\") {\n        return onBeforeDeleteResult ? {\n            edges: matchingEdges,\n            nodes: matchingNodes\n        } : {\n            edges: [],\n            nodes: []\n        };\n    }\n    return onBeforeDeleteResult;\n}\nconst clamp = (val, min = 0, max = 1)=>Math.min(Math.max(val, min), max);\nconst clampPosition = (position = {\n    x: 0,\n    y: 0\n}, extent, dimensions)=>({\n        x: clamp(position.x, extent[0][0], extent[1][0] - (dimensions?.width ?? 0)),\n        y: clamp(position.y, extent[0][1], extent[1][1] - (dimensions?.height ?? 0))\n    });\nfunction clampPositionToParent(childPosition, childDimensions, parent) {\n    const { width: parentWidth, height: parentHeight } = getNodeDimensions(parent);\n    const { x: parentX, y: parentY } = parent.internals.positionAbsolute;\n    return clampPosition(childPosition, [\n        [\n            parentX,\n            parentY\n        ],\n        [\n            parentX + parentWidth,\n            parentY + parentHeight\n        ]\n    ], childDimensions);\n}\n/**\n * Calculates the velocity of panning when the mouse is close to the edge of the canvas\n * @internal\n * @param value - One dimensional poition of the mouse (x or y)\n * @param min - Minimal position on canvas before panning starts\n * @param max - Maximal position on canvas before panning starts\n * @returns - A number between 0 and 1 that represents the velocity of panning\n */ const calcAutoPanVelocity = (value, min, max)=>{\n    if (value < min) {\n        return clamp(Math.abs(value - min), 1, min) / min;\n    } else if (value > max) {\n        return -clamp(Math.abs(value - max), 1, min) / min;\n    }\n    return 0;\n};\nconst calcAutoPan = (pos, bounds, speed = 15, distance = 40)=>{\n    const xMovement = calcAutoPanVelocity(pos.x, distance, bounds.width - distance) * speed;\n    const yMovement = calcAutoPanVelocity(pos.y, distance, bounds.height - distance) * speed;\n    return [\n        xMovement,\n        yMovement\n    ];\n};\nconst getBoundsOfBoxes = (box1, box2)=>({\n        x: Math.min(box1.x, box2.x),\n        y: Math.min(box1.y, box2.y),\n        x2: Math.max(box1.x2, box2.x2),\n        y2: Math.max(box1.y2, box2.y2)\n    });\nconst rectToBox = ({ x, y, width, height })=>({\n        x,\n        y,\n        x2: x + width,\n        y2: y + height\n    });\nconst boxToRect = ({ x, y, x2, y2 })=>({\n        x,\n        y,\n        width: x2 - x,\n        height: y2 - y\n    });\nconst nodeToRect = (node, nodeOrigin = [\n    0,\n    0\n])=>{\n    const { x, y } = isInternalNodeBase(node) ? node.internals.positionAbsolute : getNodePositionWithOrigin(node, nodeOrigin);\n    return {\n        x,\n        y,\n        width: node.measured?.width ?? node.width ?? node.initialWidth ?? 0,\n        height: node.measured?.height ?? node.height ?? node.initialHeight ?? 0\n    };\n};\nconst nodeToBox = (node, nodeOrigin = [\n    0,\n    0\n])=>{\n    const { x, y } = isInternalNodeBase(node) ? node.internals.positionAbsolute : getNodePositionWithOrigin(node, nodeOrigin);\n    return {\n        x,\n        y,\n        x2: x + (node.measured?.width ?? node.width ?? node.initialWidth ?? 0),\n        y2: y + (node.measured?.height ?? node.height ?? node.initialHeight ?? 0)\n    };\n};\nconst getBoundsOfRects = (rect1, rect2)=>boxToRect(getBoundsOfBoxes(rectToBox(rect1), rectToBox(rect2)));\nconst getOverlappingArea = (rectA, rectB)=>{\n    const xOverlap = Math.max(0, Math.min(rectA.x + rectA.width, rectB.x + rectB.width) - Math.max(rectA.x, rectB.x));\n    const yOverlap = Math.max(0, Math.min(rectA.y + rectA.height, rectB.y + rectB.height) - Math.max(rectA.y, rectB.y));\n    return Math.ceil(xOverlap * yOverlap);\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isRectObject = (obj)=>isNumeric(obj.width) && isNumeric(obj.height) && isNumeric(obj.x) && isNumeric(obj.y);\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */ const isNumeric = (n)=>!isNaN(n) && isFinite(n);\n// used for a11y key board controls for nodes and edges\nconst devWarn = (id, message)=>{\n    if (true) {\n        console.warn(`[React Flow]: ${message} Help: https://reactflow.dev/error#${id}`);\n    }\n};\nconst snapPosition = (position, snapGrid = [\n    1,\n    1\n])=>{\n    return {\n        x: snapGrid[0] * Math.round(position.x / snapGrid[0]),\n        y: snapGrid[1] * Math.round(position.y / snapGrid[1])\n    };\n};\nconst pointToRendererPoint = ({ x, y }, [tx, ty, tScale], snapToGrid = false, snapGrid = [\n    1,\n    1\n])=>{\n    const position = {\n        x: (x - tx) / tScale,\n        y: (y - ty) / tScale\n    };\n    return snapToGrid ? snapPosition(position, snapGrid) : position;\n};\nconst rendererPointToPoint = ({ x, y }, [tx, ty, tScale])=>{\n    return {\n        x: x * tScale + tx,\n        y: y * tScale + ty\n    };\n};\n/**\n * Parses a single padding value to a number\n * @internal\n * @param padding - Padding to parse\n * @param viewport - Width or height of the viewport\n * @returns The padding in pixels\n */ function parsePadding(padding, viewport) {\n    if (typeof padding === \"number\") {\n        return Math.floor((viewport - viewport / (1 + padding)) * 0.5);\n    }\n    if (typeof padding === \"string\" && padding.endsWith(\"px\")) {\n        const paddingValue = parseFloat(padding);\n        if (!Number.isNaN(paddingValue)) {\n            return Math.floor(paddingValue);\n        }\n    }\n    if (typeof padding === \"string\" && padding.endsWith(\"%\")) {\n        const paddingValue = parseFloat(padding);\n        if (!Number.isNaN(paddingValue)) {\n            return Math.floor(viewport * paddingValue * 0.01);\n        }\n    }\n    console.error(`[React Flow] The padding value \"${padding}\" is invalid. Please provide a number or a string with a valid unit (px or %).`);\n    return 0;\n}\n/**\n * Parses the paddings to an object with top, right, bottom, left, x and y paddings\n * @internal\n * @param padding - Padding to parse\n * @param width - Width of the viewport\n * @param height - Height of the viewport\n * @returns An object with the paddings in pixels\n */ function parsePaddings(padding, width, height) {\n    if (typeof padding === \"string\" || typeof padding === \"number\") {\n        const paddingY = parsePadding(padding, height);\n        const paddingX = parsePadding(padding, width);\n        return {\n            top: paddingY,\n            right: paddingX,\n            bottom: paddingY,\n            left: paddingX,\n            x: paddingX * 2,\n            y: paddingY * 2\n        };\n    }\n    if (typeof padding === \"object\") {\n        const top = parsePadding(padding.top ?? padding.y ?? 0, height);\n        const bottom = parsePadding(padding.bottom ?? padding.y ?? 0, height);\n        const left = parsePadding(padding.left ?? padding.x ?? 0, width);\n        const right = parsePadding(padding.right ?? padding.x ?? 0, width);\n        return {\n            top,\n            right,\n            bottom,\n            left,\n            x: left + right,\n            y: top + bottom\n        };\n    }\n    return {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0,\n        x: 0,\n        y: 0\n    };\n}\n/**\n * Calculates the resulting paddings if the new viewport is applied\n * @internal\n * @param bounds - Bounds to fit inside viewport\n * @param x - X position of the viewport\n * @param y - Y position of the viewport\n * @param zoom - Zoom level of the viewport\n * @param width - Width of the viewport\n * @param height - Height of the viewport\n * @returns An object with the minimum padding required to fit the bounds inside the viewport\n */ function calculateAppliedPaddings(bounds, x, y, zoom, width, height) {\n    const { x: left, y: top } = rendererPointToPoint(bounds, [\n        x,\n        y,\n        zoom\n    ]);\n    const { x: boundRight, y: boundBottom } = rendererPointToPoint({\n        x: bounds.x + bounds.width,\n        y: bounds.y + bounds.height\n    }, [\n        x,\n        y,\n        zoom\n    ]);\n    const right = width - boundRight;\n    const bottom = height - boundBottom;\n    return {\n        left: Math.floor(left),\n        top: Math.floor(top),\n        right: Math.floor(right),\n        bottom: Math.floor(bottom)\n    };\n}\n/**\n * Returns a viewport that encloses the given bounds with padding.\n * @public\n * @remarks You can determine bounds of nodes with {@link getNodesBounds} and {@link getBoundsOfRects}\n * @param bounds - Bounds to fit inside viewport.\n * @param width - Width of the viewport.\n * @param height  - Height of the viewport.\n * @param minZoom - Minimum zoom level of the resulting viewport.\n * @param maxZoom - Maximum zoom level of the resulting viewport.\n * @param padding - Padding around the bounds.\n * @returns A transformed {@link Viewport} that encloses the given bounds which you can pass to e.g. {@link setViewport}.\n * @example\n * const { x, y, zoom } = getViewportForBounds(\n * { x: 0, y: 0, width: 100, height: 100},\n * 1200, 800, 0.5, 2);\n */ const getViewportForBounds = (bounds, width, height, minZoom, maxZoom, padding)=>{\n    // First we resolve all the paddings to actual pixel values\n    const p = parsePaddings(padding, width, height);\n    const xZoom = (width - p.x) / bounds.width;\n    const yZoom = (height - p.y) / bounds.height;\n    // We calculate the new x, y, zoom for a centered view\n    const zoom = Math.min(xZoom, yZoom);\n    const clampedZoom = clamp(zoom, minZoom, maxZoom);\n    const boundsCenterX = bounds.x + bounds.width / 2;\n    const boundsCenterY = bounds.y + bounds.height / 2;\n    const x = width / 2 - boundsCenterX * clampedZoom;\n    const y = height / 2 - boundsCenterY * clampedZoom;\n    // Then we calculate the minimum padding, to respect asymmetric paddings\n    const newPadding = calculateAppliedPaddings(bounds, x, y, clampedZoom, width, height);\n    // We only want to have an offset if the newPadding is smaller than the required padding\n    const offset = {\n        left: Math.min(newPadding.left - p.left, 0),\n        top: Math.min(newPadding.top - p.top, 0),\n        right: Math.min(newPadding.right - p.right, 0),\n        bottom: Math.min(newPadding.bottom - p.bottom, 0)\n    };\n    return {\n        x: x - offset.left + offset.right,\n        y: y - offset.top + offset.bottom,\n        zoom: clampedZoom\n    };\n};\nconst isMacOs = ()=>typeof navigator !== \"undefined\" && navigator?.userAgent?.indexOf(\"Mac\") >= 0;\nfunction isCoordinateExtent(extent) {\n    return extent !== undefined && extent !== null && extent !== \"parent\";\n}\nfunction getNodeDimensions(node) {\n    return {\n        width: node.measured?.width ?? node.width ?? node.initialWidth ?? 0,\n        height: node.measured?.height ?? node.height ?? node.initialHeight ?? 0\n    };\n}\nfunction nodeHasDimensions(node) {\n    return (node.measured?.width ?? node.width ?? node.initialWidth) !== undefined && (node.measured?.height ?? node.height ?? node.initialHeight) !== undefined;\n}\n/**\n * Convert child position to aboslute position\n *\n * @internal\n * @param position\n * @param parentId\n * @param nodeLookup\n * @param nodeOrigin\n * @returns an internal node with an absolute position\n */ function evaluateAbsolutePosition(position, dimensions = {\n    width: 0,\n    height: 0\n}, parentId, nodeLookup, nodeOrigin) {\n    const positionAbsolute = {\n        ...position\n    };\n    const parent = nodeLookup.get(parentId);\n    if (parent) {\n        const origin = parent.origin || nodeOrigin;\n        positionAbsolute.x += parent.internals.positionAbsolute.x - (dimensions.width ?? 0) * origin[0];\n        positionAbsolute.y += parent.internals.positionAbsolute.y - (dimensions.height ?? 0) * origin[1];\n    }\n    return positionAbsolute;\n}\nfunction areSetsEqual(a, b) {\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const item of a){\n        if (!b.has(item)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Polyfill for Promise.withResolvers until we can use it in all browsers\n * @internal\n */ function withResolvers() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    return {\n        promise,\n        resolve,\n        reject\n    };\n}\nfunction mergeAriaLabelConfig(partial) {\n    return {\n        ...defaultAriaLabelConfig,\n        ...partial || {}\n    };\n}\nfunction getPointerPosition(event, { snapGrid = [\n    0,\n    0\n], snapToGrid = false, transform, containerBounds }) {\n    const { x, y } = getEventPosition(event);\n    const pointerPos = pointToRendererPoint({\n        x: x - (containerBounds?.left ?? 0),\n        y: y - (containerBounds?.top ?? 0)\n    }, transform);\n    const { x: xSnapped, y: ySnapped } = snapToGrid ? snapPosition(pointerPos, snapGrid) : pointerPos;\n    // we need the snapped position in order to be able to skip unnecessary drag events\n    return {\n        xSnapped,\n        ySnapped,\n        ...pointerPos\n    };\n}\nconst getDimensions = (node)=>({\n        width: node.offsetWidth,\n        height: node.offsetHeight\n    });\nconst getHostForElement = (element)=>element?.getRootNode?.() || window?.document;\nconst inputTags = [\n    \"INPUT\",\n    \"SELECT\",\n    \"TEXTAREA\"\n];\nfunction isInputDOMNode(event) {\n    // using composed path for handling shadow dom\n    const target = event.composedPath?.()?.[0] || event.target;\n    if (target?.nodeType !== 1 /* Node.ELEMENT_NODE */ ) return false;\n    const isInput = inputTags.includes(target.nodeName) || target.hasAttribute(\"contenteditable\");\n    // when an input field is focused we don't want to trigger deletion or movement of nodes\n    return isInput || !!target.closest(\".nokey\");\n}\nconst isMouseEvent = (event)=>\"clientX\" in event;\nconst getEventPosition = (event, bounds)=>{\n    const isMouse = isMouseEvent(event);\n    const evtX = isMouse ? event.clientX : event.touches?.[0].clientX;\n    const evtY = isMouse ? event.clientY : event.touches?.[0].clientY;\n    return {\n        x: evtX - (bounds?.left ?? 0),\n        y: evtY - (bounds?.top ?? 0)\n    };\n};\n/*\n * The handle bounds are calculated relative to the node element.\n * We store them in the internals object of the node in order to avoid\n * unnecessary recalculations.\n */ const getHandleBounds = (type, nodeElement, nodeBounds, zoom, nodeId)=>{\n    const handles = nodeElement.querySelectorAll(`.${type}`);\n    if (!handles || !handles.length) {\n        return null;\n    }\n    return Array.from(handles).map((handle)=>{\n        const handleBounds = handle.getBoundingClientRect();\n        return {\n            id: handle.getAttribute(\"data-handleid\"),\n            type,\n            nodeId,\n            position: handle.getAttribute(\"data-handlepos\"),\n            x: (handleBounds.left - nodeBounds.left) / zoom,\n            y: (handleBounds.top - nodeBounds.top) / zoom,\n            ...getDimensions(handle)\n        };\n    });\n};\nfunction getBezierEdgeCenter({ sourceX, sourceY, targetX, targetY, sourceControlX, sourceControlY, targetControlX, targetControlY }) {\n    /*\n     * cubic bezier t=0.5 mid point, not the actual mid point, but easy to calculate\n     * https://stackoverflow.com/questions/67516101/how-to-find-distance-mid-point-of-bezier-curve\n     */ const centerX = sourceX * 0.125 + sourceControlX * 0.375 + targetControlX * 0.375 + targetX * 0.125;\n    const centerY = sourceY * 0.125 + sourceControlY * 0.375 + targetControlY * 0.375 + targetY * 0.125;\n    const offsetX = Math.abs(centerX - sourceX);\n    const offsetY = Math.abs(centerY - sourceY);\n    return [\n        centerX,\n        centerY,\n        offsetX,\n        offsetY\n    ];\n}\nfunction calculateControlOffset(distance, curvature) {\n    if (distance >= 0) {\n        return 0.5 * distance;\n    }\n    return curvature * 25 * Math.sqrt(-distance);\n}\nfunction getControlWithCurvature({ pos, x1, y1, x2, y2, c }) {\n    switch(pos){\n        case Position.Left:\n            return [\n                x1 - calculateControlOffset(x1 - x2, c),\n                y1\n            ];\n        case Position.Right:\n            return [\n                x1 + calculateControlOffset(x2 - x1, c),\n                y1\n            ];\n        case Position.Top:\n            return [\n                x1,\n                y1 - calculateControlOffset(y1 - y2, c)\n            ];\n        case Position.Bottom:\n            return [\n                x1,\n                y1 + calculateControlOffset(y2 - y1, c)\n            ];\n    }\n}\n/**\n * The `getBezierPath` util returns everything you need to render a bezier edge\n *between two nodes.\n * @public\n * @returns A path string you can use in an SVG, the `labelX` and `labelY` position (center of path)\n * and `offsetX`, `offsetY` between source handle and label.\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n * @example\n * ```js\n *  const source = { x: 0, y: 20 };\n *  const target = { x: 150, y: 100 };\n *\n *  const [path, labelX, labelY, offsetX, offsetY] = getBezierPath({\n *    sourceX: source.x,\n *    sourceY: source.y,\n *    sourcePosition: Position.Right,\n *    targetX: target.x,\n *    targetY: target.y,\n *    targetPosition: Position.Left,\n *});\n *```\n *\n * @remarks This function returns a tuple (aka a fixed-size array) to make it easier to\n *work with multiple edge paths at once.\n */ function getBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, curvature = 0.25 }) {\n    const [sourceControlX, sourceControlY] = getControlWithCurvature({\n        pos: sourcePosition,\n        x1: sourceX,\n        y1: sourceY,\n        x2: targetX,\n        y2: targetY,\n        c: curvature\n    });\n    const [targetControlX, targetControlY] = getControlWithCurvature({\n        pos: targetPosition,\n        x1: targetX,\n        y1: targetY,\n        x2: sourceX,\n        y2: sourceY,\n        c: curvature\n    });\n    const [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n        sourceControlX,\n        sourceControlY,\n        targetControlX,\n        targetControlY\n    });\n    return [\n        `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY\n    ];\n}\n// this is used for straight edges and simple smoothstep edges (LTR, RTL, BTT, TTB)\nfunction getEdgeCenter({ sourceX, sourceY, targetX, targetY }) {\n    const xOffset = Math.abs(targetX - sourceX) / 2;\n    const centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset;\n    const yOffset = Math.abs(targetY - sourceY) / 2;\n    const centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;\n    return [\n        centerX,\n        centerY,\n        xOffset,\n        yOffset\n    ];\n}\n/**\n * Returns the z-index for an edge based on the node it connects and whether it is selected.\n * By default, edges are rendered below nodes. This behaviour is different for edges that are\n * connected to nodes with a parent, as they are rendered above the parent node.\n */ function getElevatedEdgeZIndex({ sourceNode, targetNode, selected = false, zIndex, elevateOnSelect = false }) {\n    if (zIndex !== undefined) {\n        return zIndex;\n    }\n    const edgeZ = elevateOnSelect && selected ? 1000 : 0;\n    const nodeZ = Math.max(sourceNode.parentId || elevateOnSelect && sourceNode.selected ? sourceNode.internals.z : 0, targetNode.parentId || elevateOnSelect && targetNode.selected ? targetNode.internals.z : 0);\n    return edgeZ + nodeZ;\n}\nfunction isEdgeVisible({ sourceNode, targetNode, width, height, transform }) {\n    const edgeBox = getBoundsOfBoxes(nodeToBox(sourceNode), nodeToBox(targetNode));\n    if (edgeBox.x === edgeBox.x2) {\n        edgeBox.x2 += 1;\n    }\n    if (edgeBox.y === edgeBox.y2) {\n        edgeBox.y2 += 1;\n    }\n    const viewRect = {\n        x: -transform[0] / transform[2],\n        y: -transform[1] / transform[2],\n        width: width / transform[2],\n        height: height / transform[2]\n    };\n    return getOverlappingArea(viewRect, boxToRect(edgeBox)) > 0;\n}\nconst getEdgeId = ({ source, sourceHandle, target, targetHandle })=>`xy-edge__${source}${sourceHandle || \"\"}-${target}${targetHandle || \"\"}`;\nconst connectionExists = (edge, edges)=>{\n    return edges.some((el)=>el.source === edge.source && el.target === edge.target && (el.sourceHandle === edge.sourceHandle || !el.sourceHandle && !edge.sourceHandle) && (el.targetHandle === edge.targetHandle || !el.targetHandle && !edge.targetHandle));\n};\n/**\n * This util is a convenience function to add a new Edge to an array of edges. It also performs some validation to make sure you don't add an invalid edge or duplicate an existing one.\n * @public\n * @param edgeParams - Either an `Edge` or a `Connection` you want to add.\n * @param edges - The array of all current edges.\n * @returns A new array of edges with the new edge added.\n *\n * @remarks If an edge with the same `target` and `source` already exists (and the same\n *`targetHandle` and `sourceHandle` if those are set), then this util won't add\n *a new edge even if the `id` property is different.\n *\n */ const addEdge = (edgeParams, edges)=>{\n    if (!edgeParams.source || !edgeParams.target) {\n        devWarn(\"006\", errorMessages[\"error006\"]());\n        return edges;\n    }\n    let edge;\n    if (isEdgeBase(edgeParams)) {\n        edge = {\n            ...edgeParams\n        };\n    } else {\n        edge = {\n            ...edgeParams,\n            id: getEdgeId(edgeParams)\n        };\n    }\n    if (connectionExists(edge, edges)) {\n        return edges;\n    }\n    if (edge.sourceHandle === null) {\n        delete edge.sourceHandle;\n    }\n    if (edge.targetHandle === null) {\n        delete edge.targetHandle;\n    }\n    return edges.concat(edge);\n};\n/**\n * A handy utility to update an existing [`Edge`](/api-reference/types/edge) with new properties.\n *This searches your edge array for an edge with a matching `id` and updates its\n *properties with the connection you provide.\n * @public\n * @param oldEdge - The edge you want to update.\n * @param newConnection - The new connection you want to update the edge with.\n * @param edges - The array of all current edges.\n * @returns The updated edges array.\n *\n * @example\n * ```js\n *const onReconnect = useCallback(\n *  (oldEdge: Edge, newConnection: Connection) => setEdges((els) => reconnectEdge(oldEdge, newConnection, els)),[]);\n *```\n */ const reconnectEdge = (oldEdge, newConnection, edges, options = {\n    shouldReplaceId: true\n})=>{\n    const { id: oldEdgeId, ...rest } = oldEdge;\n    if (!newConnection.source || !newConnection.target) {\n        devWarn(\"006\", errorMessages[\"error006\"]());\n        return edges;\n    }\n    const foundEdge = edges.find((e)=>e.id === oldEdge.id);\n    if (!foundEdge) {\n        devWarn(\"007\", errorMessages[\"error007\"](oldEdgeId));\n        return edges;\n    }\n    // Remove old edge and create the new edge with parameters of old edge.\n    const edge = {\n        ...rest,\n        id: options.shouldReplaceId ? getEdgeId(newConnection) : oldEdgeId,\n        source: newConnection.source,\n        target: newConnection.target,\n        sourceHandle: newConnection.sourceHandle,\n        targetHandle: newConnection.targetHandle\n    };\n    return edges.filter((e)=>e.id !== oldEdgeId).concat(edge);\n};\n/**\n * Calculates the straight line path between two points.\n * @public\n * @returns A path string you can use in an SVG, the `labelX` and `labelY` position (center of path)\n * and `offsetX`, `offsetY` between source handle and label.\n *\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n * @example\n * ```js\n *  const source = { x: 0, y: 20 };\n *  const target = { x: 150, y: 100 };\n *\n *  const [path, labelX, labelY, offsetX, offsetY] = getStraightPath({\n *    sourceX: source.x,\n *    sourceY: source.y,\n *    sourcePosition: Position.Right,\n *    targetX: target.x,\n *    targetY: target.y,\n *    targetPosition: Position.Left,\n *  });\n * ```\n * @remarks This function returns a tuple (aka a fixed-size array) to make it easier to work with multiple edge paths at once.\n */ function getStraightPath({ sourceX, sourceY, targetX, targetY }) {\n    const [labelX, labelY, offsetX, offsetY] = getEdgeCenter({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY\n    });\n    return [\n        `M ${sourceX},${sourceY}L ${targetX},${targetY}`,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY\n    ];\n}\nconst handleDirections = {\n    [Position.Left]: {\n        x: -1,\n        y: 0\n    },\n    [Position.Right]: {\n        x: 1,\n        y: 0\n    },\n    [Position.Top]: {\n        x: 0,\n        y: -1\n    },\n    [Position.Bottom]: {\n        x: 0,\n        y: 1\n    }\n};\nconst getDirection = ({ source, sourcePosition = Position.Bottom, target })=>{\n    if (sourcePosition === Position.Left || sourcePosition === Position.Right) {\n        return source.x < target.x ? {\n            x: 1,\n            y: 0\n        } : {\n            x: -1,\n            y: 0\n        };\n    }\n    return source.y < target.y ? {\n        x: 0,\n        y: 1\n    } : {\n        x: 0,\n        y: -1\n    };\n};\nconst distance = (a, b)=>Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));\n/*\n * With this function we try to mimic an orthogonal edge routing behaviour\n * It's not as good as a real orthogonal edge routing, but it's faster and good enough as a default for step and smooth step edges\n */ function getPoints({ source, sourcePosition = Position.Bottom, target, targetPosition = Position.Top, center, offset, stepPosition }) {\n    const sourceDir = handleDirections[sourcePosition];\n    const targetDir = handleDirections[targetPosition];\n    const sourceGapped = {\n        x: source.x + sourceDir.x * offset,\n        y: source.y + sourceDir.y * offset\n    };\n    const targetGapped = {\n        x: target.x + targetDir.x * offset,\n        y: target.y + targetDir.y * offset\n    };\n    const dir = getDirection({\n        source: sourceGapped,\n        sourcePosition,\n        target: targetGapped\n    });\n    const dirAccessor = dir.x !== 0 ? \"x\" : \"y\";\n    const currDir = dir[dirAccessor];\n    let points = [];\n    let centerX, centerY;\n    const sourceGapOffset = {\n        x: 0,\n        y: 0\n    };\n    const targetGapOffset = {\n        x: 0,\n        y: 0\n    };\n    const [, , defaultOffsetX, defaultOffsetY] = getEdgeCenter({\n        sourceX: source.x,\n        sourceY: source.y,\n        targetX: target.x,\n        targetY: target.y\n    });\n    // opposite handle positions, default case\n    if (sourceDir[dirAccessor] * targetDir[dirAccessor] === -1) {\n        if (dirAccessor === \"x\") {\n            // Primary direction is horizontal, so stepPosition affects X coordinate\n            centerX = center.x ?? sourceGapped.x + (targetGapped.x - sourceGapped.x) * stepPosition;\n            centerY = center.y ?? (sourceGapped.y + targetGapped.y) / 2;\n        } else {\n            // Primary direction is vertical, so stepPosition affects Y coordinate  \n            centerX = center.x ?? (sourceGapped.x + targetGapped.x) / 2;\n            centerY = center.y ?? sourceGapped.y + (targetGapped.y - sourceGapped.y) * stepPosition;\n        }\n        /*\n         *    --->\n         *    |\n         * >---\n         */ const verticalSplit = [\n            {\n                x: centerX,\n                y: sourceGapped.y\n            },\n            {\n                x: centerX,\n                y: targetGapped.y\n            }\n        ];\n        /*\n         *    |\n         *  ---\n         *  |\n         */ const horizontalSplit = [\n            {\n                x: sourceGapped.x,\n                y: centerY\n            },\n            {\n                x: targetGapped.x,\n                y: centerY\n            }\n        ];\n        if (sourceDir[dirAccessor] === currDir) {\n            points = dirAccessor === \"x\" ? verticalSplit : horizontalSplit;\n        } else {\n            points = dirAccessor === \"x\" ? horizontalSplit : verticalSplit;\n        }\n    } else {\n        // sourceTarget means we take x from source and y from target, targetSource is the opposite\n        const sourceTarget = [\n            {\n                x: sourceGapped.x,\n                y: targetGapped.y\n            }\n        ];\n        const targetSource = [\n            {\n                x: targetGapped.x,\n                y: sourceGapped.y\n            }\n        ];\n        // this handles edges with same handle positions\n        if (dirAccessor === \"x\") {\n            points = sourceDir.x === currDir ? targetSource : sourceTarget;\n        } else {\n            points = sourceDir.y === currDir ? sourceTarget : targetSource;\n        }\n        if (sourcePosition === targetPosition) {\n            const diff = Math.abs(source[dirAccessor] - target[dirAccessor]);\n            // if an edge goes from right to right for example (sourcePosition === targetPosition) and the distance between source.x and target.x is less than the offset, the added point and the gapped source/target will overlap. This leads to a weird edge path. To avoid this we add a gapOffset to the source/target\n            if (diff <= offset) {\n                const gapOffset = Math.min(offset - 1, offset - diff);\n                if (sourceDir[dirAccessor] === currDir) {\n                    sourceGapOffset[dirAccessor] = (sourceGapped[dirAccessor] > source[dirAccessor] ? -1 : 1) * gapOffset;\n                } else {\n                    targetGapOffset[dirAccessor] = (targetGapped[dirAccessor] > target[dirAccessor] ? -1 : 1) * gapOffset;\n                }\n            }\n        }\n        // these are conditions for handling mixed handle positions like Right -> Bottom for example\n        if (sourcePosition !== targetPosition) {\n            const dirAccessorOpposite = dirAccessor === \"x\" ? \"y\" : \"x\";\n            const isSameDir = sourceDir[dirAccessor] === targetDir[dirAccessorOpposite];\n            const sourceGtTargetOppo = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite];\n            const sourceLtTargetOppo = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];\n            const flipSourceTarget = sourceDir[dirAccessor] === 1 && (!isSameDir && sourceGtTargetOppo || isSameDir && sourceLtTargetOppo) || sourceDir[dirAccessor] !== 1 && (!isSameDir && sourceLtTargetOppo || isSameDir && sourceGtTargetOppo);\n            if (flipSourceTarget) {\n                points = dirAccessor === \"x\" ? sourceTarget : targetSource;\n            }\n        }\n        const sourceGapPoint = {\n            x: sourceGapped.x + sourceGapOffset.x,\n            y: sourceGapped.y + sourceGapOffset.y\n        };\n        const targetGapPoint = {\n            x: targetGapped.x + targetGapOffset.x,\n            y: targetGapped.y + targetGapOffset.y\n        };\n        const maxXDistance = Math.max(Math.abs(sourceGapPoint.x - points[0].x), Math.abs(targetGapPoint.x - points[0].x));\n        const maxYDistance = Math.max(Math.abs(sourceGapPoint.y - points[0].y), Math.abs(targetGapPoint.y - points[0].y));\n        // we want to place the label on the longest segment of the edge\n        if (maxXDistance >= maxYDistance) {\n            centerX = (sourceGapPoint.x + targetGapPoint.x) / 2;\n            centerY = points[0].y;\n        } else {\n            centerX = points[0].x;\n            centerY = (sourceGapPoint.y + targetGapPoint.y) / 2;\n        }\n    }\n    const pathPoints = [\n        source,\n        {\n            x: sourceGapped.x + sourceGapOffset.x,\n            y: sourceGapped.y + sourceGapOffset.y\n        },\n        ...points,\n        {\n            x: targetGapped.x + targetGapOffset.x,\n            y: targetGapped.y + targetGapOffset.y\n        },\n        target\n    ];\n    return [\n        pathPoints,\n        centerX,\n        centerY,\n        defaultOffsetX,\n        defaultOffsetY\n    ];\n}\nfunction getBend(a, b, c, size) {\n    const bendSize = Math.min(distance(a, b) / 2, distance(b, c) / 2, size);\n    const { x, y } = b;\n    // no bend\n    if (a.x === x && x === c.x || a.y === y && y === c.y) {\n        return `L${x} ${y}`;\n    }\n    // first segment is horizontal\n    if (a.y === y) {\n        const xDir = a.x < c.x ? -1 : 1;\n        const yDir = a.y < c.y ? 1 : -1;\n        return `L ${x + bendSize * xDir},${y}Q ${x},${y} ${x},${y + bendSize * yDir}`;\n    }\n    const xDir = a.x < c.x ? 1 : -1;\n    const yDir = a.y < c.y ? -1 : 1;\n    return `L ${x},${y + bendSize * yDir}Q ${x},${y} ${x + bendSize * xDir},${y}`;\n}\n/**\n * The `getSmoothStepPath` util returns everything you need to render a stepped path\n * between two nodes. The `borderRadius` property can be used to choose how rounded\n * the corners of those steps are.\n * @public\n * @returns A path string you can use in an SVG, the `labelX` and `labelY` position (center of path)\n * and `offsetX`, `offsetY` between source handle and label.\n *\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n * @example\n * ```js\n *  const source = { x: 0, y: 20 };\n *  const target = { x: 150, y: 100 };\n *\n *  const [path, labelX, labelY, offsetX, offsetY] = getSmoothStepPath({\n *    sourceX: source.x,\n *    sourceY: source.y,\n *    sourcePosition: Position.Right,\n *    targetX: target.x,\n *    targetY: target.y,\n *    targetPosition: Position.Left,\n *  });\n * ```\n * @remarks This function returns a tuple (aka a fixed-size array) to make it easier to work with multiple edge paths at once.\n */ function getSmoothStepPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, borderRadius = 5, centerX, centerY, offset = 20, stepPosition = 0.5 }) {\n    const [points, labelX, labelY, offsetX, offsetY] = getPoints({\n        source: {\n            x: sourceX,\n            y: sourceY\n        },\n        sourcePosition,\n        target: {\n            x: targetX,\n            y: targetY\n        },\n        targetPosition,\n        center: {\n            x: centerX,\n            y: centerY\n        },\n        offset,\n        stepPosition\n    });\n    const path = points.reduce((res, p, i)=>{\n        let segment = \"\";\n        if (i > 0 && i < points.length - 1) {\n            segment = getBend(points[i - 1], p, points[i + 1], borderRadius);\n        } else {\n            segment = `${i === 0 ? \"M\" : \"L\"}${p.x} ${p.y}`;\n        }\n        res += segment;\n        return res;\n    }, \"\");\n    return [\n        path,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY\n    ];\n}\nfunction isNodeInitialized(node) {\n    return node && !!(node.internals.handleBounds || node.handles?.length) && !!(node.measured.width || node.width || node.initialWidth);\n}\nfunction getEdgePosition(params) {\n    const { sourceNode, targetNode } = params;\n    if (!isNodeInitialized(sourceNode) || !isNodeInitialized(targetNode)) {\n        return null;\n    }\n    const sourceHandleBounds = sourceNode.internals.handleBounds || toHandleBounds(sourceNode.handles);\n    const targetHandleBounds = targetNode.internals.handleBounds || toHandleBounds(targetNode.handles);\n    const sourceHandle = getHandle$1(sourceHandleBounds?.source ?? [], params.sourceHandle);\n    const targetHandle = getHandle$1(// when connection type is loose we can define all handles as sources and connect source -> source\n    params.connectionMode === ConnectionMode.Strict ? targetHandleBounds?.target ?? [] : (targetHandleBounds?.target ?? []).concat(targetHandleBounds?.source ?? []), params.targetHandle);\n    if (!sourceHandle || !targetHandle) {\n        params.onError?.(\"008\", errorMessages[\"error008\"](!sourceHandle ? \"source\" : \"target\", {\n            id: params.id,\n            sourceHandle: params.sourceHandle,\n            targetHandle: params.targetHandle\n        }));\n        return null;\n    }\n    const sourcePosition = sourceHandle?.position || Position.Bottom;\n    const targetPosition = targetHandle?.position || Position.Top;\n    const source = getHandlePosition(sourceNode, sourceHandle, sourcePosition);\n    const target = getHandlePosition(targetNode, targetHandle, targetPosition);\n    return {\n        sourceX: source.x,\n        sourceY: source.y,\n        targetX: target.x,\n        targetY: target.y,\n        sourcePosition,\n        targetPosition\n    };\n}\nfunction toHandleBounds(handles) {\n    if (!handles) {\n        return null;\n    }\n    const source = [];\n    const target = [];\n    for (const handle of handles){\n        handle.width = handle.width ?? 1;\n        handle.height = handle.height ?? 1;\n        if (handle.type === \"source\") {\n            source.push(handle);\n        } else if (handle.type === \"target\") {\n            target.push(handle);\n        }\n    }\n    return {\n        source,\n        target\n    };\n}\nfunction getHandlePosition(node, handle, fallbackPosition = Position.Left, center = false) {\n    const x = (handle?.x ?? 0) + node.internals.positionAbsolute.x;\n    const y = (handle?.y ?? 0) + node.internals.positionAbsolute.y;\n    const { width, height } = handle ?? getNodeDimensions(node);\n    if (center) {\n        return {\n            x: x + width / 2,\n            y: y + height / 2\n        };\n    }\n    const position = handle?.position ?? fallbackPosition;\n    switch(position){\n        case Position.Top:\n            return {\n                x: x + width / 2,\n                y\n            };\n        case Position.Right:\n            return {\n                x: x + width,\n                y: y + height / 2\n            };\n        case Position.Bottom:\n            return {\n                x: x + width / 2,\n                y: y + height\n            };\n        case Position.Left:\n            return {\n                x,\n                y: y + height / 2\n            };\n    }\n}\nfunction getHandle$1(bounds, handleId) {\n    if (!bounds) {\n        return null;\n    }\n    // if no handleId is given, we use the first handle, otherwise we check for the id\n    return (!handleId ? bounds[0] : bounds.find((d)=>d.id === handleId)) || null;\n}\nfunction getMarkerId(marker, id) {\n    if (!marker) {\n        return \"\";\n    }\n    if (typeof marker === \"string\") {\n        return marker;\n    }\n    const idPrefix = id ? `${id}__` : \"\";\n    return `${idPrefix}${Object.keys(marker).sort().map((key)=>`${key}=${marker[key]}`).join(\"&\")}`;\n}\nfunction createMarkerIds(edges, { id, defaultColor, defaultMarkerStart, defaultMarkerEnd }) {\n    const ids = new Set();\n    return edges.reduce((markers, edge)=>{\n        [\n            edge.markerStart || defaultMarkerStart,\n            edge.markerEnd || defaultMarkerEnd\n        ].forEach((marker)=>{\n            if (marker && typeof marker === \"object\") {\n                const markerId = getMarkerId(marker, id);\n                if (!ids.has(markerId)) {\n                    markers.push({\n                        id: markerId,\n                        color: marker.color || defaultColor,\n                        ...marker\n                    });\n                    ids.add(markerId);\n                }\n            }\n        });\n        return markers;\n    }, []).sort((a, b)=>a.id.localeCompare(b.id));\n}\nfunction getNodeToolbarTransform(nodeRect, viewport, position, offset, align) {\n    let alignmentOffset = 0.5;\n    if (align === \"start\") {\n        alignmentOffset = 0;\n    } else if (align === \"end\") {\n        alignmentOffset = 1;\n    }\n    /*\n     * position === Position.Top\n     * we set the x any y position of the toolbar based on the nodes position\n     */ let pos = [\n        (nodeRect.x + nodeRect.width * alignmentOffset) * viewport.zoom + viewport.x,\n        nodeRect.y * viewport.zoom + viewport.y - offset\n    ];\n    // and than shift it based on the alignment. The shift values are in %.\n    let shift = [\n        -100 * alignmentOffset,\n        -100\n    ];\n    switch(position){\n        case Position.Right:\n            pos = [\n                (nodeRect.x + nodeRect.width) * viewport.zoom + viewport.x + offset,\n                (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y\n            ];\n            shift = [\n                0,\n                -100 * alignmentOffset\n            ];\n            break;\n        case Position.Bottom:\n            pos[1] = (nodeRect.y + nodeRect.height) * viewport.zoom + viewport.y + offset;\n            shift[1] = 0;\n            break;\n        case Position.Left:\n            pos = [\n                nodeRect.x * viewport.zoom + viewport.x - offset,\n                (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y\n            ];\n            shift = [\n                -100,\n                -100 * alignmentOffset\n            ];\n            break;\n    }\n    return `translate(${pos[0]}px, ${pos[1]}px) translate(${shift[0]}%, ${shift[1]}%)`;\n}\nconst alignXToPercent = {\n    left: 0,\n    center: 50,\n    right: 100\n};\nconst alignYToPercent = {\n    top: 0,\n    center: 50,\n    bottom: 100\n};\nfunction getEdgeToolbarTransform(x, y, zoom, alignX = \"center\", alignY = \"center\") {\n    return `translate(${x}px, ${y}px) scale(${1 / zoom}) translate(${-(alignXToPercent[alignX] ?? 50)}%, ${-(alignYToPercent[alignY] ?? 50)}%)`;\n}\nconst SELECTED_NODE_Z = 1000;\nconst ROOT_PARENT_Z_INCREMENT = 10;\nconst defaultOptions = {\n    nodeOrigin: [\n        0,\n        0\n    ],\n    nodeExtent: infiniteExtent,\n    elevateNodesOnSelect: true,\n    defaults: {}\n};\nconst adoptUserNodesDefaultOptions = {\n    ...defaultOptions,\n    checkEquality: true\n};\nfunction mergeObjects(base, incoming) {\n    const result = {\n        ...base\n    };\n    for(const key in incoming){\n        if (incoming[key] !== undefined) {\n            // typecast is safe here, because we check for undefined\n            result[key] = incoming[key];\n        }\n    }\n    return result;\n}\nfunction updateAbsolutePositions(nodeLookup, parentLookup, options) {\n    const _options = mergeObjects(defaultOptions, options);\n    for (const node of nodeLookup.values()){\n        if (node.parentId) {\n            updateChildNode(node, nodeLookup, parentLookup, _options);\n        } else {\n            const positionWithOrigin = getNodePositionWithOrigin(node, _options.nodeOrigin);\n            const extent = isCoordinateExtent(node.extent) ? node.extent : _options.nodeExtent;\n            const clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(node));\n            node.internals.positionAbsolute = clampedPosition;\n        }\n    }\n}\nfunction parseHandles(userNode, internalNode) {\n    if (!userNode.handles) {\n        return !userNode.measured ? undefined : internalNode?.internals.handleBounds;\n    }\n    const source = [];\n    const target = [];\n    for (const handle of userNode.handles){\n        const handleBounds = {\n            id: handle.id,\n            width: handle.width ?? 1,\n            height: handle.height ?? 1,\n            nodeId: userNode.id,\n            x: handle.x,\n            y: handle.y,\n            position: handle.position,\n            type: handle.type\n        };\n        if (handle.type === \"source\") {\n            source.push(handleBounds);\n        } else if (handle.type === \"target\") {\n            target.push(handleBounds);\n        }\n    }\n    return {\n        source,\n        target\n    };\n}\nfunction adoptUserNodes(nodes, nodeLookup, parentLookup, options) {\n    const _options = mergeObjects(adoptUserNodesDefaultOptions, options);\n    let rootParentIndex = {\n        i: -1\n    };\n    let nodesInitialized = nodes.length > 0;\n    const tmpLookup = new Map(nodeLookup);\n    const selectedNodeZ = _options?.elevateNodesOnSelect ? SELECTED_NODE_Z : 0;\n    nodeLookup.clear();\n    parentLookup.clear();\n    for (const userNode of nodes){\n        let internalNode = tmpLookup.get(userNode.id);\n        if (_options.checkEquality && userNode === internalNode?.internals.userNode) {\n            nodeLookup.set(userNode.id, internalNode);\n        } else {\n            const positionWithOrigin = getNodePositionWithOrigin(userNode, _options.nodeOrigin);\n            const extent = isCoordinateExtent(userNode.extent) ? userNode.extent : _options.nodeExtent;\n            const clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(userNode));\n            internalNode = {\n                ..._options.defaults,\n                ...userNode,\n                measured: {\n                    width: userNode.measured?.width,\n                    height: userNode.measured?.height\n                },\n                internals: {\n                    positionAbsolute: clampedPosition,\n                    // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured\n                    handleBounds: parseHandles(userNode, internalNode),\n                    z: calculateZ(userNode, selectedNodeZ),\n                    userNode\n                }\n            };\n            nodeLookup.set(userNode.id, internalNode);\n        }\n        if ((internalNode.measured === undefined || internalNode.measured.width === undefined || internalNode.measured.height === undefined) && !internalNode.hidden) {\n            nodesInitialized = false;\n        }\n        if (userNode.parentId) {\n            updateChildNode(internalNode, nodeLookup, parentLookup, options, rootParentIndex);\n        }\n    }\n    return nodesInitialized;\n}\nfunction updateParentLookup(node, parentLookup) {\n    if (!node.parentId) {\n        return;\n    }\n    const childNodes = parentLookup.get(node.parentId);\n    if (childNodes) {\n        childNodes.set(node.id, node);\n    } else {\n        parentLookup.set(node.parentId, new Map([\n            [\n                node.id,\n                node\n            ]\n        ]));\n    }\n}\n/**\n * Updates positionAbsolute and zIndex of a child node and the parentLookup.\n */ function updateChildNode(node, nodeLookup, parentLookup, options, rootParentIndex) {\n    const { elevateNodesOnSelect, nodeOrigin, nodeExtent } = mergeObjects(defaultOptions, options);\n    const parentId = node.parentId;\n    const parentNode = nodeLookup.get(parentId);\n    if (!parentNode) {\n        console.warn(`Parent node ${parentId} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);\n        return;\n    }\n    updateParentLookup(node, parentLookup);\n    // We just want to set the rootParentIndex for the first child\n    if (rootParentIndex && !parentNode.parentId && parentNode.internals.rootParentIndex === undefined) {\n        parentNode.internals.rootParentIndex = ++rootParentIndex.i;\n        parentNode.internals.z = parentNode.internals.z + rootParentIndex.i * ROOT_PARENT_Z_INCREMENT;\n    }\n    // But we need to update rootParentIndex.i also when parent has not been updated\n    if (rootParentIndex && parentNode.internals.rootParentIndex !== undefined) {\n        rootParentIndex.i = parentNode.internals.rootParentIndex;\n    }\n    const selectedNodeZ = elevateNodesOnSelect ? SELECTED_NODE_Z : 0;\n    const { x, y, z } = calculateChildXYZ(node, parentNode, nodeOrigin, nodeExtent, selectedNodeZ);\n    const { positionAbsolute } = node.internals;\n    const positionChanged = x !== positionAbsolute.x || y !== positionAbsolute.y;\n    if (positionChanged || z !== node.internals.z) {\n        // we create a new object to mark the node as updated\n        nodeLookup.set(node.id, {\n            ...node,\n            internals: {\n                ...node.internals,\n                positionAbsolute: positionChanged ? {\n                    x,\n                    y\n                } : positionAbsolute,\n                z\n            }\n        });\n    }\n}\nfunction calculateZ(node, selectedNodeZ) {\n    return (isNumeric(node.zIndex) ? node.zIndex : 0) + (node.selected ? selectedNodeZ : 0);\n}\nfunction calculateChildXYZ(childNode, parentNode, nodeOrigin, nodeExtent, selectedNodeZ) {\n    const { x: parentX, y: parentY } = parentNode.internals.positionAbsolute;\n    const childDimensions = getNodeDimensions(childNode);\n    const positionWithOrigin = getNodePositionWithOrigin(childNode, nodeOrigin);\n    const clampedPosition = isCoordinateExtent(childNode.extent) ? clampPosition(positionWithOrigin, childNode.extent, childDimensions) : positionWithOrigin;\n    let absolutePosition = clampPosition({\n        x: parentX + clampedPosition.x,\n        y: parentY + clampedPosition.y\n    }, nodeExtent, childDimensions);\n    if (childNode.extent === \"parent\") {\n        absolutePosition = clampPositionToParent(absolutePosition, childDimensions, parentNode);\n    }\n    const childZ = calculateZ(childNode, selectedNodeZ);\n    const parentZ = parentNode.internals.z ?? 0;\n    return {\n        x: absolutePosition.x,\n        y: absolutePosition.y,\n        z: parentZ >= childZ ? parentZ + 1 : childZ\n    };\n}\nfunction handleExpandParent(children, nodeLookup, parentLookup, nodeOrigin = [\n    0,\n    0\n]) {\n    const changes = [];\n    const parentExpansions = new Map();\n    // determine the expanded rectangle the child nodes would take for each parent\n    for (const child of children){\n        const parent = nodeLookup.get(child.parentId);\n        if (!parent) {\n            continue;\n        }\n        const parentRect = parentExpansions.get(child.parentId)?.expandedRect ?? nodeToRect(parent);\n        const expandedRect = getBoundsOfRects(parentRect, child.rect);\n        parentExpansions.set(child.parentId, {\n            expandedRect,\n            parent\n        });\n    }\n    if (parentExpansions.size > 0) {\n        parentExpansions.forEach(({ expandedRect, parent }, parentId)=>{\n            // determine the position & dimensions of the parent\n            const positionAbsolute = parent.internals.positionAbsolute;\n            const dimensions = getNodeDimensions(parent);\n            const origin = parent.origin ?? nodeOrigin;\n            // determine how much the parent expands in width and position\n            const xChange = expandedRect.x < positionAbsolute.x ? Math.round(Math.abs(positionAbsolute.x - expandedRect.x)) : 0;\n            const yChange = expandedRect.y < positionAbsolute.y ? Math.round(Math.abs(positionAbsolute.y - expandedRect.y)) : 0;\n            const newWidth = Math.max(dimensions.width, Math.round(expandedRect.width));\n            const newHeight = Math.max(dimensions.height, Math.round(expandedRect.height));\n            const widthChange = (newWidth - dimensions.width) * origin[0];\n            const heightChange = (newHeight - dimensions.height) * origin[1];\n            // We need to correct the position of the parent node if the origin is not [0,0]\n            if (xChange > 0 || yChange > 0 || widthChange || heightChange) {\n                changes.push({\n                    id: parentId,\n                    type: \"position\",\n                    position: {\n                        x: parent.position.x - xChange + widthChange,\n                        y: parent.position.y - yChange + heightChange\n                    }\n                });\n                /*\n                 * We move all child nodes in the oppsite direction\n                 * so the x,y changes of the parent do not move the children\n                 */ parentLookup.get(parentId)?.forEach((childNode)=>{\n                    if (!children.some((child)=>child.id === childNode.id)) {\n                        changes.push({\n                            id: childNode.id,\n                            type: \"position\",\n                            position: {\n                                x: childNode.position.x + xChange,\n                                y: childNode.position.y + yChange\n                            }\n                        });\n                    }\n                });\n            }\n            // We need to correct the dimensions of the parent node if the origin is not [0,0]\n            if (dimensions.width < expandedRect.width || dimensions.height < expandedRect.height || xChange || yChange) {\n                changes.push({\n                    id: parentId,\n                    type: \"dimensions\",\n                    setAttributes: true,\n                    dimensions: {\n                        width: newWidth + (xChange ? origin[0] * xChange - widthChange : 0),\n                        height: newHeight + (yChange ? origin[1] * yChange - heightChange : 0)\n                    }\n                });\n            }\n        });\n    }\n    return changes;\n}\nfunction updateNodeInternals(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent) {\n    const viewportNode = domNode?.querySelector(\".xyflow__viewport\");\n    let updatedInternals = false;\n    if (!viewportNode) {\n        return {\n            changes: [],\n            updatedInternals\n        };\n    }\n    const changes = [];\n    const style = window.getComputedStyle(viewportNode);\n    const { m22: zoom } = new window.DOMMatrixReadOnly(style.transform);\n    // in this array we collect nodes, that might trigger changes (like expanding parent)\n    const parentExpandChildren = [];\n    for (const update of updates.values()){\n        const node = nodeLookup.get(update.id);\n        if (!node) {\n            continue;\n        }\n        if (node.hidden) {\n            nodeLookup.set(node.id, {\n                ...node,\n                internals: {\n                    ...node.internals,\n                    handleBounds: undefined\n                }\n            });\n            updatedInternals = true;\n            continue;\n        }\n        const dimensions = getDimensions(update.nodeElement);\n        const dimensionChanged = node.measured.width !== dimensions.width || node.measured.height !== dimensions.height;\n        const doUpdate = !!(dimensions.width && dimensions.height && (dimensionChanged || !node.internals.handleBounds || update.force));\n        if (doUpdate) {\n            const nodeBounds = update.nodeElement.getBoundingClientRect();\n            const extent = isCoordinateExtent(node.extent) ? node.extent : nodeExtent;\n            let { positionAbsolute } = node.internals;\n            if (node.parentId && node.extent === \"parent\") {\n                positionAbsolute = clampPositionToParent(positionAbsolute, dimensions, nodeLookup.get(node.parentId));\n            } else if (extent) {\n                positionAbsolute = clampPosition(positionAbsolute, extent, dimensions);\n            }\n            const newNode = {\n                ...node,\n                measured: dimensions,\n                internals: {\n                    ...node.internals,\n                    positionAbsolute,\n                    handleBounds: {\n                        source: getHandleBounds(\"source\", update.nodeElement, nodeBounds, zoom, node.id),\n                        target: getHandleBounds(\"target\", update.nodeElement, nodeBounds, zoom, node.id)\n                    }\n                }\n            };\n            nodeLookup.set(node.id, newNode);\n            if (node.parentId) {\n                updateChildNode(newNode, nodeLookup, parentLookup, {\n                    nodeOrigin\n                });\n            }\n            updatedInternals = true;\n            if (dimensionChanged) {\n                changes.push({\n                    id: node.id,\n                    type: \"dimensions\",\n                    dimensions\n                });\n                if (node.expandParent && node.parentId) {\n                    parentExpandChildren.push({\n                        id: node.id,\n                        parentId: node.parentId,\n                        rect: nodeToRect(newNode, nodeOrigin)\n                    });\n                }\n            }\n        }\n    }\n    if (parentExpandChildren.length > 0) {\n        const parentExpandChanges = handleExpandParent(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);\n        changes.push(...parentExpandChanges);\n    }\n    return {\n        changes,\n        updatedInternals\n    };\n}\nasync function panBy({ delta, panZoom, transform, translateExtent, width, height }) {\n    if (!panZoom || !delta.x && !delta.y) {\n        return Promise.resolve(false);\n    }\n    const nextViewport = await panZoom.setViewportConstrained({\n        x: transform[0] + delta.x,\n        y: transform[1] + delta.y,\n        zoom: transform[2]\n    }, [\n        [\n            0,\n            0\n        ],\n        [\n            width,\n            height\n        ]\n    ], translateExtent);\n    const transformChanged = !!nextViewport && (nextViewport.x !== transform[0] || nextViewport.y !== transform[1] || nextViewport.k !== transform[2]);\n    return Promise.resolve(transformChanged);\n}\n/**\n * this function adds the connection to the connectionLookup\n * at the following keys: nodeId-type-handleId, nodeId-type and nodeId\n * @param type type of the connection\n * @param connection connection that should be added to the lookup\n * @param connectionKey at which key the connection should be added\n * @param connectionLookup reference to the connection lookup\n * @param nodeId nodeId of the connection\n * @param handleId handleId of the conneciton\n */ function addConnectionToLookup(type, connection, connectionKey, connectionLookup, nodeId, handleId) {\n    /*\n     * We add the connection to the connectionLookup at the following keys\n     * 1. nodeId, 2. nodeId-type, 3. nodeId-type-handleId\n     * If the key already exists, we add the connection to the existing map\n     */ let key = nodeId;\n    const nodeMap = connectionLookup.get(key) || new Map();\n    connectionLookup.set(key, nodeMap.set(connectionKey, connection));\n    key = `${nodeId}-${type}`;\n    const typeMap = connectionLookup.get(key) || new Map();\n    connectionLookup.set(key, typeMap.set(connectionKey, connection));\n    if (handleId) {\n        key = `${nodeId}-${type}-${handleId}`;\n        const handleMap = connectionLookup.get(key) || new Map();\n        connectionLookup.set(key, handleMap.set(connectionKey, connection));\n    }\n}\nfunction updateConnectionLookup(connectionLookup, edgeLookup, edges) {\n    connectionLookup.clear();\n    edgeLookup.clear();\n    for (const edge of edges){\n        const { source: sourceNode, target: targetNode, sourceHandle = null, targetHandle = null } = edge;\n        const connection = {\n            edgeId: edge.id,\n            source: sourceNode,\n            target: targetNode,\n            sourceHandle,\n            targetHandle\n        };\n        const sourceKey = `${sourceNode}-${sourceHandle}--${targetNode}-${targetHandle}`;\n        const targetKey = `${targetNode}-${targetHandle}--${sourceNode}-${sourceHandle}`;\n        addConnectionToLookup(\"source\", connection, targetKey, connectionLookup, sourceNode, sourceHandle);\n        addConnectionToLookup(\"target\", connection, sourceKey, connectionLookup, targetNode, targetHandle);\n        edgeLookup.set(edge.id, edge);\n    }\n}\nfunction shallowNodeData(a, b) {\n    if (a === null || b === null) {\n        return false;\n    }\n    const _a = Array.isArray(a) ? a : [\n        a\n    ];\n    const _b = Array.isArray(b) ? b : [\n        b\n    ];\n    if (_a.length !== _b.length) {\n        return false;\n    }\n    for(let i = 0; i < _a.length; i++){\n        if (_a[i].id !== _b[i].id || _a[i].type !== _b[i].type || !Object.is(_a[i].data, _b[i].data)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isParentSelected(node, nodeLookup) {\n    if (!node.parentId) {\n        return false;\n    }\n    const parentNode = nodeLookup.get(node.parentId);\n    if (!parentNode) {\n        return false;\n    }\n    if (parentNode.selected) {\n        return true;\n    }\n    return isParentSelected(parentNode, nodeLookup);\n}\nfunction hasSelector(target, selector, domNode) {\n    let current = target;\n    do {\n        if (current?.matches?.(selector)) return true;\n        if (current === domNode) return false;\n        current = current?.parentElement;\n    }while (current);\n    return false;\n}\n// looks for all selected nodes and created a NodeDragItem for each of them\nfunction getDragItems(nodeLookup, nodesDraggable, mousePos, nodeId) {\n    const dragItems = new Map();\n    for (const [id, node] of nodeLookup){\n        if ((node.selected || node.id === nodeId) && (!node.parentId || !isParentSelected(node, nodeLookup)) && (node.draggable || nodesDraggable && typeof node.draggable === \"undefined\")) {\n            const internalNode = nodeLookup.get(id);\n            if (internalNode) {\n                dragItems.set(id, {\n                    id,\n                    position: internalNode.position || {\n                        x: 0,\n                        y: 0\n                    },\n                    distance: {\n                        x: mousePos.x - internalNode.internals.positionAbsolute.x,\n                        y: mousePos.y - internalNode.internals.positionAbsolute.y\n                    },\n                    extent: internalNode.extent,\n                    parentId: internalNode.parentId,\n                    origin: internalNode.origin,\n                    expandParent: internalNode.expandParent,\n                    internals: {\n                        positionAbsolute: internalNode.internals.positionAbsolute || {\n                            x: 0,\n                            y: 0\n                        }\n                    },\n                    measured: {\n                        width: internalNode.measured.width ?? 0,\n                        height: internalNode.measured.height ?? 0\n                    }\n                });\n            }\n        }\n    }\n    return dragItems;\n}\n/*\n * returns two params:\n * 1. the dragged node (or the first of the list, if we are dragging a node selection)\n * 2. array of selected nodes (for multi selections)\n */ function getEventHandlerParams({ nodeId, dragItems, nodeLookup, dragging = true }) {\n    const nodesFromDragItems = [];\n    for (const [id, dragItem] of dragItems){\n        const node = nodeLookup.get(id)?.internals.userNode;\n        if (node) {\n            nodesFromDragItems.push({\n                ...node,\n                position: dragItem.position,\n                dragging\n            });\n        }\n    }\n    if (!nodeId) {\n        return [\n            nodesFromDragItems[0],\n            nodesFromDragItems\n        ];\n    }\n    const node = nodeLookup.get(nodeId)?.internals.userNode;\n    return [\n        !node ? nodesFromDragItems[0] : {\n            ...node,\n            position: dragItems.get(nodeId)?.position || node.position,\n            dragging\n        },\n        nodesFromDragItems\n    ];\n}\n/**\n * If a selection is being dragged we want to apply the same snap offset to all nodes in the selection.\n * This function calculates the snap offset based on the first node in the selection.\n */ function calculateSnapOffset({ dragItems, snapGrid, x, y }) {\n    const refDragItem = dragItems.values().next().value;\n    if (!refDragItem) {\n        return null;\n    }\n    const refPos = {\n        x: x - refDragItem.distance.x,\n        y: y - refDragItem.distance.y\n    };\n    const refPosSnapped = snapPosition(refPos, snapGrid);\n    return {\n        x: refPosSnapped.x - refPos.x,\n        y: refPosSnapped.y - refPos.y\n    };\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction XYDrag({ onNodeMouseDown, getStoreItems, onDragStart, onDrag, onDragStop }) {\n    let lastPos = {\n        x: null,\n        y: null\n    };\n    let autoPanId = 0;\n    let dragItems = new Map();\n    let autoPanStarted = false;\n    let mousePosition = {\n        x: 0,\n        y: 0\n    };\n    let containerBounds = null;\n    let dragStarted = false;\n    let d3Selection = null;\n    let abortDrag = false; // prevents unintentional dragging on multitouch\n    let nodePositionsChanged = false;\n    // we store the last drag event to be able to use it in the update function\n    let dragEvent = null;\n    // public functions\n    function update({ noDragClassName, handleSelector, domNode, isSelectable, nodeId, nodeClickDistance = 0 }) {\n        d3Selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode);\n        function updateNodes({ x, y }) {\n            const { nodeLookup, nodeExtent, snapGrid, snapToGrid, nodeOrigin, onNodeDrag, onSelectionDrag, onError, updateNodePositions } = getStoreItems();\n            lastPos = {\n                x,\n                y\n            };\n            let hasChange = false;\n            const isMultiDrag = dragItems.size > 1;\n            const nodesBox = isMultiDrag && nodeExtent ? rectToBox(getInternalNodesBounds(dragItems)) : null;\n            const multiDragSnapOffset = isMultiDrag && snapToGrid ? calculateSnapOffset({\n                dragItems,\n                snapGrid,\n                x,\n                y\n            }) : null;\n            for (const [id, dragItem] of dragItems){\n                /*\n                 * if the node is not in the nodeLookup anymore, it was probably deleted while dragging\n                 */ if (!nodeLookup.has(id)) {\n                    continue;\n                }\n                let nextPosition = {\n                    x: x - dragItem.distance.x,\n                    y: y - dragItem.distance.y\n                };\n                if (snapToGrid) {\n                    nextPosition = multiDragSnapOffset ? {\n                        x: Math.round(nextPosition.x + multiDragSnapOffset.x),\n                        y: Math.round(nextPosition.y + multiDragSnapOffset.y)\n                    } : snapPosition(nextPosition, snapGrid);\n                }\n                let adjustedNodeExtent = null;\n                if (isMultiDrag && nodeExtent && !dragItem.extent && nodesBox) {\n                    const { positionAbsolute } = dragItem.internals;\n                    const x1 = positionAbsolute.x - nodesBox.x + nodeExtent[0][0];\n                    const x2 = positionAbsolute.x + dragItem.measured.width - nodesBox.x2 + nodeExtent[1][0];\n                    const y1 = positionAbsolute.y - nodesBox.y + nodeExtent[0][1];\n                    const y2 = positionAbsolute.y + dragItem.measured.height - nodesBox.y2 + nodeExtent[1][1];\n                    adjustedNodeExtent = [\n                        [\n                            x1,\n                            y1\n                        ],\n                        [\n                            x2,\n                            y2\n                        ]\n                    ];\n                }\n                const { position, positionAbsolute } = calculateNodePosition({\n                    nodeId: id,\n                    nextPosition,\n                    nodeLookup,\n                    nodeExtent: adjustedNodeExtent ? adjustedNodeExtent : nodeExtent,\n                    nodeOrigin,\n                    onError\n                });\n                // we want to make sure that we only fire a change event when there is a change\n                hasChange = hasChange || dragItem.position.x !== position.x || dragItem.position.y !== position.y;\n                dragItem.position = position;\n                dragItem.internals.positionAbsolute = positionAbsolute;\n            }\n            nodePositionsChanged = nodePositionsChanged || hasChange;\n            if (!hasChange) {\n                return;\n            }\n            updateNodePositions(dragItems, true);\n            if (dragEvent && (onDrag || onNodeDrag || !nodeId && onSelectionDrag)) {\n                const [currentNode, currentNodes] = getEventHandlerParams({\n                    nodeId,\n                    dragItems,\n                    nodeLookup\n                });\n                onDrag?.(dragEvent, dragItems, currentNode, currentNodes);\n                onNodeDrag?.(dragEvent, currentNode, currentNodes);\n                if (!nodeId) {\n                    onSelectionDrag?.(dragEvent, currentNodes);\n                }\n            }\n        }\n        async function autoPan() {\n            if (!containerBounds) {\n                return;\n            }\n            const { transform, panBy, autoPanSpeed, autoPanOnNodeDrag } = getStoreItems();\n            if (!autoPanOnNodeDrag) {\n                autoPanStarted = false;\n                cancelAnimationFrame(autoPanId);\n                return;\n            }\n            const [xMovement, yMovement] = calcAutoPan(mousePosition, containerBounds, autoPanSpeed);\n            if (xMovement !== 0 || yMovement !== 0) {\n                lastPos.x = (lastPos.x ?? 0) - xMovement / transform[2];\n                lastPos.y = (lastPos.y ?? 0) - yMovement / transform[2];\n                if (await panBy({\n                    x: xMovement,\n                    y: yMovement\n                })) {\n                    updateNodes(lastPos);\n                }\n            }\n            autoPanId = requestAnimationFrame(autoPan);\n        }\n        function startDrag(event) {\n            const { nodeLookup, multiSelectionActive, nodesDraggable, transform, snapGrid, snapToGrid, selectNodesOnDrag, onNodeDragStart, onSelectionDragStart, unselectNodesAndEdges } = getStoreItems();\n            dragStarted = true;\n            if ((!selectNodesOnDrag || !isSelectable) && !multiSelectionActive && nodeId) {\n                if (!nodeLookup.get(nodeId)?.selected) {\n                    // we need to reset selected nodes when selectNodesOnDrag=false\n                    unselectNodesAndEdges();\n                }\n            }\n            if (isSelectable && selectNodesOnDrag && nodeId) {\n                onNodeMouseDown?.(nodeId);\n            }\n            const pointerPos = getPointerPosition(event.sourceEvent, {\n                transform,\n                snapGrid,\n                snapToGrid,\n                containerBounds\n            });\n            lastPos = pointerPos;\n            dragItems = getDragItems(nodeLookup, nodesDraggable, pointerPos, nodeId);\n            if (dragItems.size > 0 && (onDragStart || onNodeDragStart || !nodeId && onSelectionDragStart)) {\n                const [currentNode, currentNodes] = getEventHandlerParams({\n                    nodeId,\n                    dragItems,\n                    nodeLookup\n                });\n                onDragStart?.(event.sourceEvent, dragItems, currentNode, currentNodes);\n                onNodeDragStart?.(event.sourceEvent, currentNode, currentNodes);\n                if (!nodeId) {\n                    onSelectionDragStart?.(event.sourceEvent, currentNodes);\n                }\n            }\n        }\n        const d3DragInstance = (0,d3_drag__WEBPACK_IMPORTED_MODULE_2__[\"default\"])().clickDistance(nodeClickDistance).on(\"start\", (event)=>{\n            const { domNode, nodeDragThreshold, transform, snapGrid, snapToGrid } = getStoreItems();\n            containerBounds = domNode?.getBoundingClientRect() || null;\n            abortDrag = false;\n            nodePositionsChanged = false;\n            dragEvent = event.sourceEvent;\n            if (nodeDragThreshold === 0) {\n                startDrag(event);\n            }\n            const pointerPos = getPointerPosition(event.sourceEvent, {\n                transform,\n                snapGrid,\n                snapToGrid,\n                containerBounds\n            });\n            lastPos = pointerPos;\n            mousePosition = getEventPosition(event.sourceEvent, containerBounds);\n        }).on(\"drag\", (event)=>{\n            const { autoPanOnNodeDrag, transform, snapGrid, snapToGrid, nodeDragThreshold, nodeLookup } = getStoreItems();\n            const pointerPos = getPointerPosition(event.sourceEvent, {\n                transform,\n                snapGrid,\n                snapToGrid,\n                containerBounds\n            });\n            dragEvent = event.sourceEvent;\n            if (event.sourceEvent.type === \"touchmove\" && event.sourceEvent.touches.length > 1 || // if user deletes a node while dragging, we need to abort the drag to prevent errors\n            nodeId && !nodeLookup.has(nodeId)) {\n                abortDrag = true;\n            }\n            if (abortDrag) {\n                return;\n            }\n            if (!autoPanStarted && autoPanOnNodeDrag && dragStarted) {\n                autoPanStarted = true;\n                autoPan();\n            }\n            if (!dragStarted) {\n                // Calculate distance in client coordinates for consistent drag threshold behavior across zoom levels\n                const currentMousePosition = getEventPosition(event.sourceEvent, containerBounds);\n                const x = currentMousePosition.x - mousePosition.x;\n                const y = currentMousePosition.y - mousePosition.y;\n                const distance = Math.sqrt(x * x + y * y);\n                if (distance > nodeDragThreshold) {\n                    startDrag(event);\n                }\n            }\n            // skip events without movement\n            if ((lastPos.x !== pointerPos.xSnapped || lastPos.y !== pointerPos.ySnapped) && dragItems && dragStarted) {\n                mousePosition = getEventPosition(event.sourceEvent, containerBounds);\n                updateNodes(pointerPos);\n            }\n        }).on(\"end\", (event)=>{\n            if (!dragStarted || abortDrag) {\n                return;\n            }\n            autoPanStarted = false;\n            dragStarted = false;\n            cancelAnimationFrame(autoPanId);\n            if (dragItems.size > 0) {\n                const { nodeLookup, updateNodePositions, onNodeDragStop, onSelectionDragStop } = getStoreItems();\n                if (nodePositionsChanged) {\n                    updateNodePositions(dragItems, false);\n                    nodePositionsChanged = false;\n                }\n                if (onDragStop || onNodeDragStop || !nodeId && onSelectionDragStop) {\n                    const [currentNode, currentNodes] = getEventHandlerParams({\n                        nodeId,\n                        dragItems,\n                        nodeLookup,\n                        dragging: false\n                    });\n                    onDragStop?.(event.sourceEvent, dragItems, currentNode, currentNodes);\n                    onNodeDragStop?.(event.sourceEvent, currentNode, currentNodes);\n                    if (!nodeId) {\n                        onSelectionDragStop?.(event.sourceEvent, currentNodes);\n                    }\n                }\n            }\n        }).filter((event)=>{\n            const target = event.target;\n            const isDraggable = !event.button && (!noDragClassName || !hasSelector(target, `.${noDragClassName}`, domNode)) && (!handleSelector || hasSelector(target, handleSelector, domNode));\n            return isDraggable;\n        });\n        d3Selection.call(d3DragInstance);\n    }\n    function destroy() {\n        d3Selection?.on(\".drag\", null);\n    }\n    return {\n        update,\n        destroy\n    };\n}\nfunction getNodesWithinDistance(position, nodeLookup, distance) {\n    const nodes = [];\n    const rect = {\n        x: position.x - distance,\n        y: position.y - distance,\n        width: distance * 2,\n        height: distance * 2\n    };\n    for (const node of nodeLookup.values()){\n        if (getOverlappingArea(rect, nodeToRect(node)) > 0) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n/*\n * this distance is used for the area around the user pointer\n * while doing a connection for finding the closest nodes\n */ const ADDITIONAL_DISTANCE = 250;\nfunction getClosestHandle(position, connectionRadius, nodeLookup, fromHandle) {\n    let closestHandles = [];\n    let minDistance = Infinity;\n    const closeNodes = getNodesWithinDistance(position, nodeLookup, connectionRadius + ADDITIONAL_DISTANCE);\n    for (const node of closeNodes){\n        const allHandles = [\n            ...node.internals.handleBounds?.source ?? [],\n            ...node.internals.handleBounds?.target ?? []\n        ];\n        for (const handle of allHandles){\n            // if the handle is the same as the fromHandle we skip it\n            if (fromHandle.nodeId === handle.nodeId && fromHandle.type === handle.type && fromHandle.id === handle.id) {\n                continue;\n            }\n            // determine absolute position of the handle\n            const { x, y } = getHandlePosition(node, handle, handle.position, true);\n            const distance = Math.sqrt(Math.pow(x - position.x, 2) + Math.pow(y - position.y, 2));\n            if (distance > connectionRadius) {\n                continue;\n            }\n            if (distance < minDistance) {\n                closestHandles = [\n                    {\n                        ...handle,\n                        x,\n                        y\n                    }\n                ];\n                minDistance = distance;\n            } else if (distance === minDistance) {\n                // when multiple handles are on the same distance we collect all of them\n                closestHandles.push({\n                    ...handle,\n                    x,\n                    y\n                });\n            }\n        }\n    }\n    if (!closestHandles.length) {\n        return null;\n    }\n    // when multiple handles overlay each other we prefer the opposite handle\n    if (closestHandles.length > 1) {\n        const oppositeHandleType = fromHandle.type === \"source\" ? \"target\" : \"source\";\n        return closestHandles.find((handle)=>handle.type === oppositeHandleType) ?? closestHandles[0];\n    }\n    return closestHandles[0];\n}\nfunction getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode, withAbsolutePosition = false) {\n    const node = nodeLookup.get(nodeId);\n    if (!node) {\n        return null;\n    }\n    const handles = connectionMode === \"strict\" ? node.internals.handleBounds?.[handleType] : [\n        ...node.internals.handleBounds?.source ?? [],\n        ...node.internals.handleBounds?.target ?? []\n    ];\n    const handle = (handleId ? handles?.find((h)=>h.id === handleId) : handles?.[0]) ?? null;\n    return handle && withAbsolutePosition ? {\n        ...handle,\n        ...getHandlePosition(node, handle, handle.position, true)\n    } : handle;\n}\nfunction getHandleType(edgeUpdaterType, handleDomNode) {\n    if (edgeUpdaterType) {\n        return edgeUpdaterType;\n    } else if (handleDomNode?.classList.contains(\"target\")) {\n        return \"target\";\n    } else if (handleDomNode?.classList.contains(\"source\")) {\n        return \"source\";\n    }\n    return null;\n}\nfunction isConnectionValid(isInsideConnectionRadius, isHandleValid) {\n    let isValid = null;\n    if (isHandleValid) {\n        isValid = true;\n    } else if (isInsideConnectionRadius && !isHandleValid) {\n        isValid = false;\n    }\n    return isValid;\n}\nconst alwaysValid = ()=>true;\nfunction onPointerDown(event, { connectionMode, connectionRadius, handleId, nodeId, edgeUpdaterType, isTarget, domNode, nodeLookup, lib, autoPanOnConnect, flowId, panBy, cancelConnection, onConnectStart, onConnect, onConnectEnd, isValidConnection = alwaysValid, onReconnectEnd, updateConnection, getTransform, getFromHandle, autoPanSpeed, dragThreshold = 1, handleDomNode }) {\n    // when xyflow is used inside a shadow root we can't use document\n    const doc = getHostForElement(event.target);\n    let autoPanId = 0;\n    let closestHandle;\n    const { x, y } = getEventPosition(event);\n    const handleType = getHandleType(edgeUpdaterType, handleDomNode);\n    const containerBounds = domNode?.getBoundingClientRect();\n    let connectionStarted = false;\n    if (!containerBounds || !handleType) {\n        return;\n    }\n    const fromHandleInternal = getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode);\n    if (!fromHandleInternal) {\n        return;\n    }\n    let position = getEventPosition(event, containerBounds);\n    let autoPanStarted = false;\n    let connection = null;\n    let isValid = false;\n    let resultHandleDomNode = null;\n    // when the user is moving the mouse close to the edge of the canvas while connecting we move the canvas\n    function autoPan() {\n        if (!autoPanOnConnect || !containerBounds) {\n            return;\n        }\n        const [x, y] = calcAutoPan(position, containerBounds, autoPanSpeed);\n        panBy({\n            x,\n            y\n        });\n        autoPanId = requestAnimationFrame(autoPan);\n    }\n    // Stays the same for all consecutive pointermove events\n    const fromHandle = {\n        ...fromHandleInternal,\n        nodeId,\n        type: handleType,\n        position: fromHandleInternal.position\n    };\n    const fromNodeInternal = nodeLookup.get(nodeId);\n    const from = getHandlePosition(fromNodeInternal, fromHandle, Position.Left, true);\n    let previousConnection = {\n        inProgress: true,\n        isValid: null,\n        from,\n        fromHandle,\n        fromPosition: fromHandle.position,\n        fromNode: fromNodeInternal,\n        to: position,\n        toHandle: null,\n        toPosition: oppositePosition[fromHandle.position],\n        toNode: null\n    };\n    function startConnection() {\n        connectionStarted = true;\n        updateConnection(previousConnection);\n        onConnectStart?.(event, {\n            nodeId,\n            handleId,\n            handleType\n        });\n    }\n    if (dragThreshold === 0) {\n        startConnection();\n    }\n    function onPointerMove(event) {\n        if (!connectionStarted) {\n            const { x: evtX, y: evtY } = getEventPosition(event);\n            const dx = evtX - x;\n            const dy = evtY - y;\n            const nextConnectionStarted = dx * dx + dy * dy > dragThreshold * dragThreshold;\n            if (!nextConnectionStarted) {\n                return;\n            }\n            startConnection();\n        }\n        if (!getFromHandle() || !fromHandle) {\n            onPointerUp(event);\n            return;\n        }\n        const transform = getTransform();\n        position = getEventPosition(event, containerBounds);\n        closestHandle = getClosestHandle(pointToRendererPoint(position, transform, false, [\n            1,\n            1\n        ]), connectionRadius, nodeLookup, fromHandle);\n        if (!autoPanStarted) {\n            autoPan();\n            autoPanStarted = true;\n        }\n        const result = isValidHandle(event, {\n            handle: closestHandle,\n            connectionMode,\n            fromNodeId: nodeId,\n            fromHandleId: handleId,\n            fromType: isTarget ? \"target\" : \"source\",\n            isValidConnection,\n            doc,\n            lib,\n            flowId,\n            nodeLookup\n        });\n        resultHandleDomNode = result.handleDomNode;\n        connection = result.connection;\n        isValid = isConnectionValid(!!closestHandle, result.isValid);\n        const newConnection = {\n            // from stays the same\n            ...previousConnection,\n            isValid,\n            to: result.toHandle && isValid ? rendererPointToPoint({\n                x: result.toHandle.x,\n                y: result.toHandle.y\n            }, transform) : position,\n            toHandle: result.toHandle,\n            toPosition: isValid && result.toHandle ? result.toHandle.position : oppositePosition[fromHandle.position],\n            toNode: result.toHandle ? nodeLookup.get(result.toHandle.nodeId) : null\n        };\n        /*\n         * we don't want to trigger an update when the connection\n         * is snapped to the same handle as before\n         */ if (isValid && closestHandle && previousConnection.toHandle && newConnection.toHandle && previousConnection.toHandle.type === newConnection.toHandle.type && previousConnection.toHandle.nodeId === newConnection.toHandle.nodeId && previousConnection.toHandle.id === newConnection.toHandle.id && previousConnection.to.x === newConnection.to.x && previousConnection.to.y === newConnection.to.y) {\n            return;\n        }\n        updateConnection(newConnection);\n        previousConnection = newConnection;\n    }\n    function onPointerUp(event) {\n        // Prevent multi-touch aborting connection\n        if (\"touches\" in event && event.touches.length > 0) {\n            return;\n        }\n        if (connectionStarted) {\n            if ((closestHandle || resultHandleDomNode) && connection && isValid) {\n                onConnect?.(connection);\n            }\n            /*\n             * it's important to get a fresh reference from the store here\n             * in order to get the latest state of onConnectEnd\n             */ // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            const { inProgress, ...connectionState } = previousConnection;\n            const finalConnectionState = {\n                ...connectionState,\n                toPosition: previousConnection.toHandle ? previousConnection.toPosition : null\n            };\n            onConnectEnd?.(event, finalConnectionState);\n            if (edgeUpdaterType) {\n                onReconnectEnd?.(event, finalConnectionState);\n            }\n        }\n        cancelConnection();\n        cancelAnimationFrame(autoPanId);\n        autoPanStarted = false;\n        isValid = false;\n        connection = null;\n        resultHandleDomNode = null;\n        doc.removeEventListener(\"mousemove\", onPointerMove);\n        doc.removeEventListener(\"mouseup\", onPointerUp);\n        doc.removeEventListener(\"touchmove\", onPointerMove);\n        doc.removeEventListener(\"touchend\", onPointerUp);\n    }\n    doc.addEventListener(\"mousemove\", onPointerMove);\n    doc.addEventListener(\"mouseup\", onPointerUp);\n    doc.addEventListener(\"touchmove\", onPointerMove);\n    doc.addEventListener(\"touchend\", onPointerUp);\n}\n// checks if  and returns connection in fom of an object { source: 123, target: 312 }\nfunction isValidHandle(event, { handle, connectionMode, fromNodeId, fromHandleId, fromType, doc, lib, flowId, isValidConnection = alwaysValid, nodeLookup }) {\n    const isTarget = fromType === \"target\";\n    const handleDomNode = handle ? doc.querySelector(`.${lib}-flow__handle[data-id=\"${flowId}-${handle?.nodeId}-${handle?.id}-${handle?.type}\"]`) : null;\n    const { x, y } = getEventPosition(event);\n    const handleBelow = doc.elementFromPoint(x, y);\n    /*\n     * we always want to prioritize the handle below the mouse cursor over the closest distance handle,\n     * because it could be that the center of another handle is closer to the mouse pointer than the handle below the cursor\n     */ const handleToCheck = handleBelow?.classList.contains(`${lib}-flow__handle`) ? handleBelow : handleDomNode;\n    const result = {\n        handleDomNode: handleToCheck,\n        isValid: false,\n        connection: null,\n        toHandle: null\n    };\n    if (handleToCheck) {\n        const handleType = getHandleType(undefined, handleToCheck);\n        const handleNodeId = handleToCheck.getAttribute(\"data-nodeid\");\n        const handleId = handleToCheck.getAttribute(\"data-handleid\");\n        const connectable = handleToCheck.classList.contains(\"connectable\");\n        const connectableEnd = handleToCheck.classList.contains(\"connectableend\");\n        if (!handleNodeId || !handleType) {\n            return result;\n        }\n        const connection = {\n            source: isTarget ? handleNodeId : fromNodeId,\n            sourceHandle: isTarget ? handleId : fromHandleId,\n            target: isTarget ? fromNodeId : handleNodeId,\n            targetHandle: isTarget ? fromHandleId : handleId\n        };\n        result.connection = connection;\n        const isConnectable = connectable && connectableEnd;\n        // in strict mode we don't allow target to target or source to source connections\n        const isValid = isConnectable && (connectionMode === ConnectionMode.Strict ? isTarget && handleType === \"source\" || !isTarget && handleType === \"target\" : handleNodeId !== fromNodeId || handleId !== fromHandleId);\n        result.isValid = isValid && isValidConnection(connection);\n        result.toHandle = getHandle(handleNodeId, handleType, handleId, nodeLookup, connectionMode, true);\n    }\n    return result;\n}\nconst XYHandle = {\n    onPointerDown,\n    isValid: isValidHandle\n};\nfunction XYMinimap({ domNode, panZoom, getTransform, getViewScale }) {\n    const selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode);\n    function update({ translateExtent, width, height, zoomStep = 1, pannable = true, zoomable = true, inversePan = false }) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const zoomHandler = (event)=>{\n            if (event.sourceEvent.type !== \"wheel\" || !panZoom) {\n                return;\n            }\n            const transform = getTransform();\n            const factor = event.sourceEvent.ctrlKey && isMacOs() ? 10 : 1;\n            const pinchDelta = -event.sourceEvent.deltaY * (event.sourceEvent.deltaMode === 1 ? 0.05 : event.sourceEvent.deltaMode ? 1 : 0.002) * zoomStep;\n            const nextZoom = transform[2] * Math.pow(2, pinchDelta * factor);\n            panZoom.scaleTo(nextZoom);\n        };\n        let panStart = [\n            0,\n            0\n        ];\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const panStartHandler = (event)=>{\n            if (event.sourceEvent.type === \"mousedown\" || event.sourceEvent.type === \"touchstart\") {\n                panStart = [\n                    event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,\n                    event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY\n                ];\n            }\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const panHandler = (event)=>{\n            const transform = getTransform();\n            if (event.sourceEvent.type !== \"mousemove\" && event.sourceEvent.type !== \"touchmove\" || !panZoom) {\n                return;\n            }\n            const panCurrent = [\n                event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,\n                event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY\n            ];\n            const panDelta = [\n                panCurrent[0] - panStart[0],\n                panCurrent[1] - panStart[1]\n            ];\n            panStart = panCurrent;\n            const moveScale = getViewScale() * Math.max(transform[2], Math.log(transform[2])) * (inversePan ? -1 : 1);\n            const position = {\n                x: transform[0] - panDelta[0] * moveScale,\n                y: transform[1] - panDelta[1] * moveScale\n            };\n            const extent = [\n                [\n                    0,\n                    0\n                ],\n                [\n                    width,\n                    height\n                ]\n            ];\n            panZoom.setViewportConstrained({\n                x: position.x,\n                y: position.y,\n                zoom: transform[2]\n            }, extent, translateExtent);\n        };\n        const zoomAndPanHandler = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)().on(\"start\", panStartHandler)// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        .on(\"zoom\", pannable ? panHandler : null)// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        .on(\"zoom.wheel\", zoomable ? zoomHandler : null);\n        selection.call(zoomAndPanHandler, {});\n    }\n    function destroy() {\n        selection.on(\"zoom\", null);\n    }\n    return {\n        update,\n        destroy,\n        pointer: d3_selection__WEBPACK_IMPORTED_MODULE_3__[\"default\"]\n    };\n}\n/* eslint-disable @typescript-eslint/no-explicit-any */ const transformToViewport = (transform)=>({\n        x: transform.x,\n        y: transform.y,\n        zoom: transform.k\n    });\nconst viewportToTransform = ({ x, y, zoom })=>d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomIdentity.translate(x, y).scale(zoom);\nconst isWrappedWithClass = (event, className)=>event.target.closest(`.${className}`);\nconst isRightClickPan = (panOnDrag, usedButton)=>usedButton === 2 && Array.isArray(panOnDrag) && panOnDrag.includes(2);\n// taken from d3-ease: https://github.com/d3/d3-ease/blob/main/src/cubic.js\nconst defaultEase = (t)=>((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;\nconst getD3Transition = (selection, duration = 0, ease = defaultEase, onEnd = ()=>{})=>{\n    const hasDuration = typeof duration === \"number\" && duration > 0;\n    if (!hasDuration) {\n        onEnd();\n    }\n    return hasDuration ? selection.transition().duration(duration).ease(ease).on(\"end\", onEnd) : selection;\n};\nconst wheelDelta = (event)=>{\n    const factor = event.ctrlKey && isMacOs() ? 10 : 1;\n    return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * factor;\n};\nfunction createPanOnScrollHandler({ zoomPanValues, noWheelClassName, d3Selection, d3Zoom, panOnScrollMode, panOnScrollSpeed, zoomOnPinch, onPanZoomStart, onPanZoom, onPanZoomEnd }) {\n    return (event)=>{\n        if (isWrappedWithClass(event, noWheelClassName)) {\n            if (event.ctrlKey) {\n                event.preventDefault(); // stop native page zoom for pinch zooming\n            }\n            return false;\n        }\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        const currentZoom = d3Selection.property(\"__zoom\").k || 1;\n        // macos sets ctrlKey=true for pinch gesture on a trackpad\n        if (event.ctrlKey && zoomOnPinch) {\n            const point = (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(event);\n            const pinchDelta = wheelDelta(event);\n            const zoom = currentZoom * Math.pow(2, pinchDelta);\n            // @ts-ignore\n            d3Zoom.scaleTo(d3Selection, zoom, point, event);\n            return;\n        }\n        /*\n         * increase scroll speed in firefox\n         * firefox: deltaMode === 1; chrome: deltaMode === 0\n         */ const deltaNormalize = event.deltaMode === 1 ? 20 : 1;\n        let deltaX = panOnScrollMode === PanOnScrollMode.Vertical ? 0 : event.deltaX * deltaNormalize;\n        let deltaY = panOnScrollMode === PanOnScrollMode.Horizontal ? 0 : event.deltaY * deltaNormalize;\n        // this enables vertical scrolling with shift + scroll on windows\n        if (!isMacOs() && event.shiftKey && panOnScrollMode !== PanOnScrollMode.Vertical) {\n            deltaX = event.deltaY * deltaNormalize;\n            deltaY = 0;\n        }\n        d3Zoom.translateBy(d3Selection, -(deltaX / currentZoom) * panOnScrollSpeed, -(deltaY / currentZoom) * panOnScrollSpeed, // @ts-ignore\n        {\n            internal: true\n        });\n        const nextViewport = transformToViewport(d3Selection.property(\"__zoom\"));\n        clearTimeout(zoomPanValues.panScrollTimeout);\n        /*\n         * for pan on scroll we need to handle the event calls on our own\n         * we can't use the start, zoom and end events from d3-zoom\n         * because start and move gets called on every scroll event and not once at the beginning\n         */ if (!zoomPanValues.isPanScrolling) {\n            zoomPanValues.isPanScrolling = true;\n            onPanZoomStart?.(event, nextViewport);\n        } else {\n            onPanZoom?.(event, nextViewport);\n            zoomPanValues.panScrollTimeout = setTimeout(()=>{\n                onPanZoomEnd?.(event, nextViewport);\n                zoomPanValues.isPanScrolling = false;\n            }, 150);\n        }\n    };\n}\nfunction createZoomOnScrollHandler({ noWheelClassName, preventScrolling, d3ZoomHandler }) {\n    return function(event, d) {\n        const isWheel = event.type === \"wheel\";\n        // we still want to enable pinch zooming even if preventScrolling is set to false\n        const preventZoom = !preventScrolling && isWheel && !event.ctrlKey;\n        const hasNoWheelClass = isWrappedWithClass(event, noWheelClassName);\n        // if user is pinch zooming above a nowheel element, we don't want the browser to zoom\n        if (event.ctrlKey && isWheel && hasNoWheelClass) {\n            event.preventDefault();\n        }\n        if (preventZoom || hasNoWheelClass) {\n            return null;\n        }\n        event.preventDefault();\n        d3ZoomHandler.call(this, event, d);\n    };\n}\nfunction createPanZoomStartHandler({ zoomPanValues, onDraggingChange, onPanZoomStart }) {\n    return (event)=>{\n        if (event.sourceEvent?.internal) {\n            return;\n        }\n        const viewport = transformToViewport(event.transform);\n        // we need to remember it here, because it's always 0 in the \"zoom\" event\n        zoomPanValues.mouseButton = event.sourceEvent?.button || 0;\n        zoomPanValues.isZoomingOrPanning = true;\n        zoomPanValues.prevViewport = viewport;\n        if (event.sourceEvent?.type === \"mousedown\") {\n            onDraggingChange(true);\n        }\n        if (onPanZoomStart) {\n            onPanZoomStart?.(event.sourceEvent, viewport);\n        }\n    };\n}\nfunction createPanZoomHandler({ zoomPanValues, panOnDrag, onPaneContextMenu, onTransformChange, onPanZoom }) {\n    return (event)=>{\n        zoomPanValues.usedRightMouseButton = !!(onPaneContextMenu && isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0));\n        if (!event.sourceEvent?.sync) {\n            onTransformChange([\n                event.transform.x,\n                event.transform.y,\n                event.transform.k\n            ]);\n        }\n        if (onPanZoom && !event.sourceEvent?.internal) {\n            onPanZoom?.(event.sourceEvent, transformToViewport(event.transform));\n        }\n    };\n}\nfunction createPanZoomEndHandler({ zoomPanValues, panOnDrag, panOnScroll, onDraggingChange, onPanZoomEnd, onPaneContextMenu }) {\n    return (event)=>{\n        if (event.sourceEvent?.internal) {\n            return;\n        }\n        zoomPanValues.isZoomingOrPanning = false;\n        if (onPaneContextMenu && isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0) && !zoomPanValues.usedRightMouseButton && event.sourceEvent) {\n            onPaneContextMenu(event.sourceEvent);\n        }\n        zoomPanValues.usedRightMouseButton = false;\n        onDraggingChange(false);\n        if (onPanZoomEnd) {\n            const viewport = transformToViewport(event.transform);\n            zoomPanValues.prevViewport = viewport;\n            clearTimeout(zoomPanValues.timerId);\n            zoomPanValues.timerId = setTimeout(()=>{\n                onPanZoomEnd?.(event.sourceEvent, viewport);\n            }, // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll\n            panOnScroll ? 150 : 0);\n        }\n    };\n}\n/* eslint-disable @typescript-eslint/no-explicit-any */ function createFilter({ zoomActivationKeyPressed, zoomOnScroll, zoomOnPinch, panOnDrag, panOnScroll, zoomOnDoubleClick, userSelectionActive, noWheelClassName, noPanClassName, lib, connectionInProgress }) {\n    return (event)=>{\n        const zoomScroll = zoomActivationKeyPressed || zoomOnScroll;\n        const pinchZoom = zoomOnPinch && event.ctrlKey;\n        const isWheelEvent = event.type === \"wheel\";\n        if (event.button === 1 && event.type === \"mousedown\" && (isWrappedWithClass(event, `${lib}-flow__node`) || isWrappedWithClass(event, `${lib}-flow__edge`))) {\n            return true;\n        }\n        // if all interactions are disabled, we prevent all zoom events\n        if (!panOnDrag && !zoomScroll && !panOnScroll && !zoomOnDoubleClick && !zoomOnPinch) {\n            return false;\n        }\n        // during a selection we prevent all other interactions\n        if (userSelectionActive) {\n            return false;\n        }\n        // we want to disable pinch-zooming while making a connection\n        if (connectionInProgress && !isWheelEvent) {\n            return false;\n        }\n        // if the target element is inside an element with the nowheel class, we prevent zooming\n        if (isWrappedWithClass(event, noWheelClassName) && isWheelEvent) {\n            return false;\n        }\n        // if the target element is inside an element with the nopan class, we prevent panning\n        if (isWrappedWithClass(event, noPanClassName) && (!isWheelEvent || panOnScroll && isWheelEvent && !zoomActivationKeyPressed)) {\n            return false;\n        }\n        if (!zoomOnPinch && event.ctrlKey && isWheelEvent) {\n            return false;\n        }\n        if (!zoomOnPinch && event.type === \"touchstart\" && event.touches?.length > 1) {\n            event.preventDefault(); // if you manage to start with 2 touches, we prevent native zoom\n            return false;\n        }\n        // when there is no scroll handling enabled, we prevent all wheel events\n        if (!zoomScroll && !panOnScroll && !pinchZoom && isWheelEvent) {\n            return false;\n        }\n        // if the pane is not movable, we prevent dragging it with mousestart or touchstart\n        if (!panOnDrag && (event.type === \"mousedown\" || event.type === \"touchstart\")) {\n            return false;\n        }\n        // if the pane is only movable using allowed clicks\n        if (Array.isArray(panOnDrag) && !panOnDrag.includes(event.button) && event.type === \"mousedown\") {\n            return false;\n        }\n        // We only allow right clicks if pan on drag is set to right click\n        const buttonAllowed = Array.isArray(panOnDrag) && panOnDrag.includes(event.button) || !event.button || event.button <= 1;\n        // default filter for d3-zoom\n        return (!event.ctrlKey || isWheelEvent) && buttonAllowed;\n    };\n}\nfunction XYPanZoom({ domNode, minZoom, maxZoom, paneClickDistance, translateExtent, viewport, onPanZoom, onPanZoomStart, onPanZoomEnd, onDraggingChange }) {\n    const zoomPanValues = {\n        isZoomingOrPanning: false,\n        usedRightMouseButton: false,\n        prevViewport: {\n            x: 0,\n            y: 0,\n            zoom: 0\n        },\n        mouseButton: 0,\n        timerId: undefined,\n        panScrollTimeout: undefined,\n        isPanScrolling: false\n    };\n    const bbox = domNode.getBoundingClientRect();\n    const d3ZoomInstance = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)().clickDistance(!isNumeric(paneClickDistance) || paneClickDistance < 0 ? 0 : paneClickDistance).scaleExtent([\n        minZoom,\n        maxZoom\n    ]).translateExtent(translateExtent);\n    const d3Selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode).call(d3ZoomInstance);\n    setViewportConstrained({\n        x: viewport.x,\n        y: viewport.y,\n        zoom: clamp(viewport.zoom, minZoom, maxZoom)\n    }, [\n        [\n            0,\n            0\n        ],\n        [\n            bbox.width,\n            bbox.height\n        ]\n    ], translateExtent);\n    const d3ZoomHandler = d3Selection.on(\"wheel.zoom\");\n    const d3DblClickZoomHandler = d3Selection.on(\"dblclick.zoom\");\n    d3ZoomInstance.wheelDelta(wheelDelta);\n    function setTransform(transform, options) {\n        if (d3Selection) {\n            return new Promise((resolve)=>{\n                d3ZoomInstance?.interpolate(options?.interpolate === \"linear\" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_4__[\"default\"] : d3_interpolate__WEBPACK_IMPORTED_MODULE_5__[\"default\"]).transform(getD3Transition(d3Selection, options?.duration, options?.ease, ()=>resolve(true)), transform);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    // public functions\n    function update({ noWheelClassName, noPanClassName, onPaneContextMenu, userSelectionActive, panOnScroll, panOnDrag, panOnScrollMode, panOnScrollSpeed, preventScrolling, zoomOnPinch, zoomOnScroll, zoomOnDoubleClick, zoomActivationKeyPressed, lib, onTransformChange, connectionInProgress }) {\n        if (userSelectionActive && !zoomPanValues.isZoomingOrPanning) {\n            destroy();\n        }\n        const isPanOnScroll = panOnScroll && !zoomActivationKeyPressed && !userSelectionActive;\n        const wheelHandler = isPanOnScroll ? createPanOnScrollHandler({\n            zoomPanValues,\n            noWheelClassName,\n            d3Selection,\n            d3Zoom: d3ZoomInstance,\n            panOnScrollMode,\n            panOnScrollSpeed,\n            zoomOnPinch,\n            onPanZoomStart,\n            onPanZoom,\n            onPanZoomEnd\n        }) : createZoomOnScrollHandler({\n            noWheelClassName,\n            preventScrolling,\n            d3ZoomHandler\n        });\n        d3Selection.on(\"wheel.zoom\", wheelHandler, {\n            passive: false\n        });\n        if (!userSelectionActive) {\n            // pan zoom start\n            const startHandler = createPanZoomStartHandler({\n                zoomPanValues,\n                onDraggingChange,\n                onPanZoomStart\n            });\n            d3ZoomInstance.on(\"start\", startHandler);\n            // pan zoom\n            const panZoomHandler = createPanZoomHandler({\n                zoomPanValues,\n                panOnDrag,\n                onPaneContextMenu: !!onPaneContextMenu,\n                onPanZoom,\n                onTransformChange\n            });\n            d3ZoomInstance.on(\"zoom\", panZoomHandler);\n            // pan zoom end\n            const panZoomEndHandler = createPanZoomEndHandler({\n                zoomPanValues,\n                panOnDrag,\n                panOnScroll,\n                onPaneContextMenu,\n                onPanZoomEnd,\n                onDraggingChange\n            });\n            d3ZoomInstance.on(\"end\", panZoomEndHandler);\n        }\n        const filter = createFilter({\n            zoomActivationKeyPressed,\n            panOnDrag,\n            zoomOnScroll,\n            panOnScroll,\n            zoomOnDoubleClick,\n            zoomOnPinch,\n            userSelectionActive,\n            noPanClassName,\n            noWheelClassName,\n            lib,\n            connectionInProgress\n        });\n        d3ZoomInstance.filter(filter);\n        /*\n         * We cannot add zoomOnDoubleClick to the filter above because\n         * double tapping on touch screens circumvents the filter and\n         * dblclick.zoom is fired on the selection directly\n         */ if (zoomOnDoubleClick) {\n            d3Selection.on(\"dblclick.zoom\", d3DblClickZoomHandler);\n        } else {\n            d3Selection.on(\"dblclick.zoom\", null);\n        }\n    }\n    function destroy() {\n        d3ZoomInstance.on(\"zoom\", null);\n    }\n    async function setViewportConstrained(viewport, extent, translateExtent) {\n        const nextTransform = viewportToTransform(viewport);\n        const contrainedTransform = d3ZoomInstance?.constrain()(nextTransform, extent, translateExtent);\n        if (contrainedTransform) {\n            await setTransform(contrainedTransform);\n        }\n        return new Promise((resolve)=>resolve(contrainedTransform));\n    }\n    async function setViewport(viewport, options) {\n        const nextTransform = viewportToTransform(viewport);\n        await setTransform(nextTransform, options);\n        return new Promise((resolve)=>resolve(nextTransform));\n    }\n    function syncViewport(viewport) {\n        if (d3Selection) {\n            const nextTransform = viewportToTransform(viewport);\n            const currentTransform = d3Selection.property(\"__zoom\");\n            if (currentTransform.k !== viewport.zoom || currentTransform.x !== viewport.x || currentTransform.y !== viewport.y) {\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                d3ZoomInstance?.transform(d3Selection, nextTransform, null, {\n                    sync: true\n                });\n            }\n        }\n    }\n    function getViewport() {\n        const transform = d3Selection ? (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(d3Selection.node()) : {\n            x: 0,\n            y: 0,\n            k: 1\n        };\n        return {\n            x: transform.x,\n            y: transform.y,\n            zoom: transform.k\n        };\n    }\n    function scaleTo(zoom, options) {\n        if (d3Selection) {\n            return new Promise((resolve)=>{\n                d3ZoomInstance?.interpolate(options?.interpolate === \"linear\" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_4__[\"default\"] : d3_interpolate__WEBPACK_IMPORTED_MODULE_5__[\"default\"]).scaleTo(getD3Transition(d3Selection, options?.duration, options?.ease, ()=>resolve(true)), zoom);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    function scaleBy(factor, options) {\n        if (d3Selection) {\n            return new Promise((resolve)=>{\n                d3ZoomInstance?.interpolate(options?.interpolate === \"linear\" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_4__[\"default\"] : d3_interpolate__WEBPACK_IMPORTED_MODULE_5__[\"default\"]).scaleBy(getD3Transition(d3Selection, options?.duration, options?.ease, ()=>resolve(true)), factor);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    function setScaleExtent(scaleExtent) {\n        d3ZoomInstance?.scaleExtent(scaleExtent);\n    }\n    function setTranslateExtent(translateExtent) {\n        d3ZoomInstance?.translateExtent(translateExtent);\n    }\n    function setClickDistance(distance) {\n        const validDistance = !isNumeric(distance) || distance < 0 ? 0 : distance;\n        d3ZoomInstance?.clickDistance(validDistance);\n    }\n    return {\n        update,\n        destroy,\n        setViewport,\n        setViewportConstrained,\n        getViewport,\n        scaleTo,\n        scaleBy,\n        setScaleExtent,\n        setTranslateExtent,\n        syncViewport,\n        setClickDistance\n    };\n}\n/**\n * Used to determine the variant of the resize control\n *\n * @public\n */ var ResizeControlVariant;\n(function(ResizeControlVariant) {\n    ResizeControlVariant[\"Line\"] = \"line\";\n    ResizeControlVariant[\"Handle\"] = \"handle\";\n})(ResizeControlVariant || (ResizeControlVariant = {}));\nconst XY_RESIZER_HANDLE_POSITIONS = [\n    \"top-left\",\n    \"top-right\",\n    \"bottom-left\",\n    \"bottom-right\"\n];\nconst XY_RESIZER_LINE_POSITIONS = [\n    \"top\",\n    \"right\",\n    \"bottom\",\n    \"left\"\n];\n/**\n * Get all connecting edges for a given set of nodes\n * @param width - new width of the node\n * @param prevWidth - previous width of the node\n * @param height - new height of the node\n * @param prevHeight - previous height of the node\n * @param affectsX - whether to invert the resize direction for the x axis\n * @param affectsY - whether to invert the resize direction for the y axis\n * @returns array of two numbers representing the direction of the resize for each axis, 0 = no change, 1 = increase, -1 = decrease\n */ function getResizeDirection({ width, prevWidth, height, prevHeight, affectsX, affectsY }) {\n    const deltaWidth = width - prevWidth;\n    const deltaHeight = height - prevHeight;\n    const direction = [\n        deltaWidth > 0 ? 1 : deltaWidth < 0 ? -1 : 0,\n        deltaHeight > 0 ? 1 : deltaHeight < 0 ? -1 : 0\n    ];\n    if (deltaWidth && affectsX) {\n        direction[0] = direction[0] * -1;\n    }\n    if (deltaHeight && affectsY) {\n        direction[1] = direction[1] * -1;\n    }\n    return direction;\n}\n/**\n * Parses the control position that is being dragged to dimensions that are being resized\n * @param controlPosition - position of the control that is being dragged\n * @returns isHorizontal, isVertical, affectsX, affectsY,\n */ function getControlDirection(controlPosition) {\n    const isHorizontal = controlPosition.includes(\"right\") || controlPosition.includes(\"left\");\n    const isVertical = controlPosition.includes(\"bottom\") || controlPosition.includes(\"top\");\n    const affectsX = controlPosition.includes(\"left\");\n    const affectsY = controlPosition.includes(\"top\");\n    return {\n        isHorizontal,\n        isVertical,\n        affectsX,\n        affectsY\n    };\n}\nfunction getLowerExtentClamp(lowerExtent, lowerBound) {\n    return Math.max(0, lowerBound - lowerExtent);\n}\nfunction getUpperExtentClamp(upperExtent, upperBound) {\n    return Math.max(0, upperExtent - upperBound);\n}\nfunction getSizeClamp(size, minSize, maxSize) {\n    return Math.max(0, minSize - size, size - maxSize);\n}\nfunction xor(a, b) {\n    return a ? !b : b;\n}\n/**\n * Calculates new width & height and x & y of node after resize based on pointer position\n * @description - Buckle up, this is a chunky one... If you want to determine the new dimensions of a node after a resize,\n * you have to account for all possible restrictions: min/max width/height of the node, the maximum extent the node is allowed\n * to move in (in this case: resize into) determined by the parent node, the minimal extent determined by child nodes\n * with expandParent or extent: 'parent' set and oh yeah, these things also have to work with keepAspectRatio!\n * The way this is done is by determining how much each of these restricting actually restricts the resize and then applying the\n * strongest restriction. Because the resize affects x, y and width, height and width, height of a opposing side with keepAspectRatio,\n * the resize amount is always kept in distX & distY amount (the distance in mouse movement)\n * Instead of clamping each value, we first calculate the biggest 'clamp' (for the lack of a better name) and then apply it to all values.\n * To complicate things nodeOrigin has to be taken into account as well. This is done by offsetting the nodes as if their origin is [0, 0],\n * then calculating the restrictions as usual\n * @param startValues - starting values of resize\n * @param controlDirection - dimensions affected by the resize\n * @param pointerPosition - the current pointer position corrected for snapping\n * @param boundaries - minimum and maximum dimensions of the node\n * @param keepAspectRatio - prevent changes of asprect ratio\n * @returns x, y, width and height of the node after resize\n */ function getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, extent, childExtent) {\n    let { affectsX, affectsY } = controlDirection;\n    const { isHorizontal, isVertical } = controlDirection;\n    const isDiagonal = isHorizontal && isVertical;\n    const { xSnapped, ySnapped } = pointerPosition;\n    const { minWidth, maxWidth, minHeight, maxHeight } = boundaries;\n    const { x: startX, y: startY, width: startWidth, height: startHeight, aspectRatio } = startValues;\n    let distX = Math.floor(isHorizontal ? xSnapped - startValues.pointerX : 0);\n    let distY = Math.floor(isVertical ? ySnapped - startValues.pointerY : 0);\n    const newWidth = startWidth + (affectsX ? -distX : distX);\n    const newHeight = startHeight + (affectsY ? -distY : distY);\n    const originOffsetX = -nodeOrigin[0] * startWidth;\n    const originOffsetY = -nodeOrigin[1] * startHeight;\n    // Check if maxWidth, minWWidth, maxHeight, minHeight are restricting the resize\n    let clampX = getSizeClamp(newWidth, minWidth, maxWidth);\n    let clampY = getSizeClamp(newHeight, minHeight, maxHeight);\n    // Check if extent is restricting the resize\n    if (extent) {\n        let xExtentClamp = 0;\n        let yExtentClamp = 0;\n        if (affectsX && distX < 0) {\n            xExtentClamp = getLowerExtentClamp(startX + distX + originOffsetX, extent[0][0]);\n        } else if (!affectsX && distX > 0) {\n            xExtentClamp = getUpperExtentClamp(startX + newWidth + originOffsetX, extent[1][0]);\n        }\n        if (affectsY && distY < 0) {\n            yExtentClamp = getLowerExtentClamp(startY + distY + originOffsetY, extent[0][1]);\n        } else if (!affectsY && distY > 0) {\n            yExtentClamp = getUpperExtentClamp(startY + newHeight + originOffsetY, extent[1][1]);\n        }\n        clampX = Math.max(clampX, xExtentClamp);\n        clampY = Math.max(clampY, yExtentClamp);\n    }\n    // Check if the child extent is restricting the resize\n    if (childExtent) {\n        let xExtentClamp = 0;\n        let yExtentClamp = 0;\n        if (affectsX && distX > 0) {\n            xExtentClamp = getUpperExtentClamp(startX + distX, childExtent[0][0]);\n        } else if (!affectsX && distX < 0) {\n            xExtentClamp = getLowerExtentClamp(startX + newWidth, childExtent[1][0]);\n        }\n        if (affectsY && distY > 0) {\n            yExtentClamp = getUpperExtentClamp(startY + distY, childExtent[0][1]);\n        } else if (!affectsY && distY < 0) {\n            yExtentClamp = getLowerExtentClamp(startY + newHeight, childExtent[1][1]);\n        }\n        clampX = Math.max(clampX, xExtentClamp);\n        clampY = Math.max(clampY, yExtentClamp);\n    }\n    // Check if the aspect ratio resizing of the other side is restricting the resize\n    if (keepAspectRatio) {\n        if (isHorizontal) {\n            // Check if the max dimensions might be restricting the resize\n            const aspectHeightClamp = getSizeClamp(newWidth / aspectRatio, minHeight, maxHeight) * aspectRatio;\n            clampX = Math.max(clampX, aspectHeightClamp);\n            // Check if the extent is restricting the resize\n            if (extent) {\n                let aspectExtentClamp = 0;\n                if (!affectsX && !affectsY || affectsX && !affectsY && isDiagonal) {\n                    aspectExtentClamp = getUpperExtentClamp(startY + originOffsetY + newWidth / aspectRatio, extent[1][1]) * aspectRatio;\n                } else {\n                    aspectExtentClamp = getLowerExtentClamp(startY + originOffsetY + (affectsX ? distX : -distX) / aspectRatio, extent[0][1]) * aspectRatio;\n                }\n                clampX = Math.max(clampX, aspectExtentClamp);\n            }\n            // Check if the child extent is restricting the resize\n            if (childExtent) {\n                let aspectExtentClamp = 0;\n                if (!affectsX && !affectsY || affectsX && !affectsY && isDiagonal) {\n                    aspectExtentClamp = getLowerExtentClamp(startY + newWidth / aspectRatio, childExtent[1][1]) * aspectRatio;\n                } else {\n                    aspectExtentClamp = getUpperExtentClamp(startY + (affectsX ? distX : -distX) / aspectRatio, childExtent[0][1]) * aspectRatio;\n                }\n                clampX = Math.max(clampX, aspectExtentClamp);\n            }\n        }\n        // Do the same thing for vertical resizing\n        if (isVertical) {\n            const aspectWidthClamp = getSizeClamp(newHeight * aspectRatio, minWidth, maxWidth) / aspectRatio;\n            clampY = Math.max(clampY, aspectWidthClamp);\n            if (extent) {\n                let aspectExtentClamp = 0;\n                if (!affectsX && !affectsY || affectsY && !affectsX && isDiagonal) {\n                    aspectExtentClamp = getUpperExtentClamp(startX + newHeight * aspectRatio + originOffsetX, extent[1][0]) / aspectRatio;\n                } else {\n                    aspectExtentClamp = getLowerExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio + originOffsetX, extent[0][0]) / aspectRatio;\n                }\n                clampY = Math.max(clampY, aspectExtentClamp);\n            }\n            if (childExtent) {\n                let aspectExtentClamp = 0;\n                if (!affectsX && !affectsY || affectsY && !affectsX && isDiagonal) {\n                    aspectExtentClamp = getLowerExtentClamp(startX + newHeight * aspectRatio, childExtent[1][0]) / aspectRatio;\n                } else {\n                    aspectExtentClamp = getUpperExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio, childExtent[0][0]) / aspectRatio;\n                }\n                clampY = Math.max(clampY, aspectExtentClamp);\n            }\n        }\n    }\n    distY = distY + (distY < 0 ? clampY : -clampY);\n    distX = distX + (distX < 0 ? clampX : -clampX);\n    if (keepAspectRatio) {\n        if (isDiagonal) {\n            if (newWidth > newHeight * aspectRatio) {\n                distY = (xor(affectsX, affectsY) ? -distX : distX) / aspectRatio;\n            } else {\n                distX = (xor(affectsX, affectsY) ? -distY : distY) * aspectRatio;\n            }\n        } else {\n            if (isHorizontal) {\n                distY = distX / aspectRatio;\n                affectsY = affectsX;\n            } else {\n                distX = distY * aspectRatio;\n                affectsX = affectsY;\n            }\n        }\n    }\n    const x = affectsX ? startX + distX : startX;\n    const y = affectsY ? startY + distY : startY;\n    return {\n        width: startWidth + (affectsX ? -distX : distX),\n        height: startHeight + (affectsY ? -distY : distY),\n        x: nodeOrigin[0] * distX * (!affectsX ? 1 : -1) + x,\n        y: nodeOrigin[1] * distY * (!affectsY ? 1 : -1) + y\n    };\n}\nconst initPrevValues = {\n    width: 0,\n    height: 0,\n    x: 0,\n    y: 0\n};\nconst initStartValues = {\n    ...initPrevValues,\n    pointerX: 0,\n    pointerY: 0,\n    aspectRatio: 1\n};\nfunction nodeToParentExtent(node) {\n    return [\n        [\n            0,\n            0\n        ],\n        [\n            node.measured.width,\n            node.measured.height\n        ]\n    ];\n}\nfunction nodeToChildExtent(child, parent, nodeOrigin) {\n    const x = parent.position.x + child.position.x;\n    const y = parent.position.y + child.position.y;\n    const width = child.measured.width ?? 0;\n    const height = child.measured.height ?? 0;\n    const originOffsetX = nodeOrigin[0] * width;\n    const originOffsetY = nodeOrigin[1] * height;\n    return [\n        [\n            x - originOffsetX,\n            y - originOffsetY\n        ],\n        [\n            x + width - originOffsetX,\n            y + height - originOffsetY\n        ]\n    ];\n}\nfunction XYResizer({ domNode, nodeId, getStoreItems, onChange, onEnd }) {\n    const selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode);\n    let params = {\n        controlDirection: getControlDirection(\"bottom-right\"),\n        boundaries: {\n            minWidth: 0,\n            minHeight: 0,\n            maxWidth: Number.MAX_VALUE,\n            maxHeight: Number.MAX_VALUE\n        },\n        resizeDirection: undefined,\n        keepAspectRatio: false\n    };\n    function update({ controlPosition, boundaries, keepAspectRatio, resizeDirection, onResizeStart, onResize, onResizeEnd, shouldResize }) {\n        let prevValues = {\n            ...initPrevValues\n        };\n        let startValues = {\n            ...initStartValues\n        };\n        params = {\n            boundaries,\n            resizeDirection,\n            keepAspectRatio,\n            controlDirection: getControlDirection(controlPosition)\n        };\n        let node = undefined;\n        let containerBounds = null;\n        let childNodes = [];\n        let parentNode = undefined; // Needed to fix expandParent\n        let parentExtent = undefined;\n        let childExtent = undefined;\n        // we only want to trigger onResizeEnd if onResize was actually called\n        let resizeDetected = false;\n        const dragHandler = (0,d3_drag__WEBPACK_IMPORTED_MODULE_2__[\"default\"])().on(\"start\", (event)=>{\n            const { nodeLookup, transform, snapGrid, snapToGrid, nodeOrigin, paneDomNode } = getStoreItems();\n            node = nodeLookup.get(nodeId);\n            if (!node) {\n                return;\n            }\n            containerBounds = paneDomNode?.getBoundingClientRect() ?? null;\n            const { xSnapped, ySnapped } = getPointerPosition(event.sourceEvent, {\n                transform,\n                snapGrid,\n                snapToGrid,\n                containerBounds\n            });\n            prevValues = {\n                width: node.measured.width ?? 0,\n                height: node.measured.height ?? 0,\n                x: node.position.x ?? 0,\n                y: node.position.y ?? 0\n            };\n            startValues = {\n                ...prevValues,\n                pointerX: xSnapped,\n                pointerY: ySnapped,\n                aspectRatio: prevValues.width / prevValues.height\n            };\n            parentNode = undefined;\n            if (node.parentId && (node.extent === \"parent\" || node.expandParent)) {\n                parentNode = nodeLookup.get(node.parentId);\n                parentExtent = parentNode && node.extent === \"parent\" ? nodeToParentExtent(parentNode) : undefined;\n            }\n            /*\n             * Collect all child nodes to correct their relative positions when top/left changes\n             * Determine largest minimal extent the parent node is allowed to resize to\n             */ childNodes = [];\n            childExtent = undefined;\n            for (const [childId, child] of nodeLookup){\n                if (child.parentId === nodeId) {\n                    childNodes.push({\n                        id: childId,\n                        position: {\n                            ...child.position\n                        },\n                        extent: child.extent\n                    });\n                    if (child.extent === \"parent\" || child.expandParent) {\n                        const extent = nodeToChildExtent(child, node, child.origin ?? nodeOrigin);\n                        if (childExtent) {\n                            childExtent = [\n                                [\n                                    Math.min(extent[0][0], childExtent[0][0]),\n                                    Math.min(extent[0][1], childExtent[0][1])\n                                ],\n                                [\n                                    Math.max(extent[1][0], childExtent[1][0]),\n                                    Math.max(extent[1][1], childExtent[1][1])\n                                ]\n                            ];\n                        } else {\n                            childExtent = extent;\n                        }\n                    }\n                }\n            }\n            onResizeStart?.(event, {\n                ...prevValues\n            });\n        }).on(\"drag\", (event)=>{\n            const { transform, snapGrid, snapToGrid, nodeOrigin: storeNodeOrigin } = getStoreItems();\n            const pointerPosition = getPointerPosition(event.sourceEvent, {\n                transform,\n                snapGrid,\n                snapToGrid,\n                containerBounds\n            });\n            const childChanges = [];\n            if (!node) {\n                return;\n            }\n            const { x: prevX, y: prevY, width: prevWidth, height: prevHeight } = prevValues;\n            const change = {};\n            const nodeOrigin = node.origin ?? storeNodeOrigin;\n            const { width, height, x, y } = getDimensionsAfterResize(startValues, params.controlDirection, pointerPosition, params.boundaries, params.keepAspectRatio, nodeOrigin, parentExtent, childExtent);\n            const isWidthChange = width !== prevWidth;\n            const isHeightChange = height !== prevHeight;\n            const isXPosChange = x !== prevX && isWidthChange;\n            const isYPosChange = y !== prevY && isHeightChange;\n            if (!isXPosChange && !isYPosChange && !isWidthChange && !isHeightChange) {\n                return;\n            }\n            if (isXPosChange || isYPosChange || nodeOrigin[0] === 1 || nodeOrigin[1] === 1) {\n                change.x = isXPosChange ? x : prevValues.x;\n                change.y = isYPosChange ? y : prevValues.y;\n                prevValues.x = change.x;\n                prevValues.y = change.y;\n                /*\n                 * when top/left changes, correct the relative positions of child nodes\n                 * so that they stay in the same position\n                 */ if (childNodes.length > 0) {\n                    const xChange = x - prevX;\n                    const yChange = y - prevY;\n                    for (const childNode of childNodes){\n                        childNode.position = {\n                            x: childNode.position.x - xChange + nodeOrigin[0] * (width - prevWidth),\n                            y: childNode.position.y - yChange + nodeOrigin[1] * (height - prevHeight)\n                        };\n                        childChanges.push(childNode);\n                    }\n                }\n            }\n            if (isWidthChange || isHeightChange) {\n                change.width = isWidthChange && (!params.resizeDirection || params.resizeDirection === \"horizontal\") ? width : prevValues.width;\n                change.height = isHeightChange && (!params.resizeDirection || params.resizeDirection === \"vertical\") ? height : prevValues.height;\n                prevValues.width = change.width;\n                prevValues.height = change.height;\n            }\n            // Fix expandParent when resizing from top/left\n            if (parentNode && node.expandParent) {\n                const xLimit = nodeOrigin[0] * (change.width ?? 0);\n                if (change.x && change.x < xLimit) {\n                    prevValues.x = xLimit;\n                    startValues.x = startValues.x - (change.x - xLimit);\n                }\n                const yLimit = nodeOrigin[1] * (change.height ?? 0);\n                if (change.y && change.y < yLimit) {\n                    prevValues.y = yLimit;\n                    startValues.y = startValues.y - (change.y - yLimit);\n                }\n            }\n            const direction = getResizeDirection({\n                width: prevValues.width,\n                prevWidth,\n                height: prevValues.height,\n                prevHeight,\n                affectsX: params.controlDirection.affectsX,\n                affectsY: params.controlDirection.affectsY\n            });\n            const nextValues = {\n                ...prevValues,\n                direction\n            };\n            const callResize = shouldResize?.(event, nextValues);\n            if (callResize === false) {\n                return;\n            }\n            resizeDetected = true;\n            onResize?.(event, nextValues);\n            onChange(change, childChanges);\n        }).on(\"end\", (event)=>{\n            if (!resizeDetected) {\n                return;\n            }\n            onResizeEnd?.(event, {\n                ...prevValues\n            });\n            onEnd?.({\n                ...prevValues\n            });\n            resizeDetected = false;\n        });\n        selection.call(dragHandler);\n    }\n    function destroy() {\n        selection.on(\".drag\", null);\n    }\n    return {\n        update,\n        destroy\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9zeXN0ZW0vZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUErQjtBQUNnQjtBQUNhO0FBQ0U7QUFFOUQsTUFBTVEsZ0JBQWdCO0lBQ2xCQyxVQUFVLElBQU07SUFDaEJDLFVBQVUsSUFBTTtJQUNoQkMsVUFBVSxDQUFDQyxXQUFhLENBQUMsV0FBVyxFQUFFQSxTQUFTLDJDQUEyQyxDQUFDO0lBQzNGQyxVQUFVLElBQU07SUFDaEJDLFVBQVUsSUFBTTtJQUNoQkMsVUFBVSxJQUFNO0lBQ2hCQyxVQUFVLENBQUNDLEtBQU8sQ0FBQyxxQkFBcUIsRUFBRUEsR0FBRyxnQkFBZ0IsQ0FBQztJQUM5REMsVUFBVSxDQUFDQyxPQUFTLENBQUMsYUFBYSxFQUFFQSxLQUFLLGdCQUFnQixDQUFDO0lBQzFEQyxVQUFVLENBQUNDLFlBQVksRUFBRUosRUFBRSxFQUFFSyxZQUFZLEVBQUVDLFlBQVksRUFBRSxHQUFLLENBQUMseUJBQXlCLEVBQUVGLFdBQVcsYUFBYSxFQUFFQSxlQUFlLFdBQVdDLGVBQWVDLGFBQWEsWUFBWSxFQUFFTixHQUFHLENBQUMsQ0FBQztJQUM3TE8sVUFBVSxJQUFNO0lBQ2hCQyxVQUFVLENBQUNDLFdBQWEsQ0FBQyxXQUFXLEVBQUVBLFNBQVMsMkNBQTJDLENBQUM7SUFDM0ZDLFVBQVUsQ0FBQ1YsS0FBTyxDQUFDLGNBQWMsRUFBRUEsR0FBRyw4SEFBOEgsQ0FBQztJQUNyS1csVUFBVSxDQUFDQyxNQUFNLE9BQU8sR0FBSyxDQUFDLG9FQUFvRSxFQUFFQSxJQUFJLHlFQUF5RSxDQUFDO0lBQ2xMQyxVQUFVLElBQU07SUFDaEJDLFVBQVUsSUFBTTtBQUNwQjtBQUNBLE1BQU1DLGlCQUFpQjtJQUNuQjtRQUFDQyxP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QUkyMEIsT0FBTzMwQixDQUFDLEdBQUdpMUIsUUFBUTtvQkFDL0JoQixXQUFXajBCLENBQUMsR0FBR2kxQjtvQkFDZnpELFlBQVl4eEIsQ0FBQyxHQUFHd3hCLFlBQVl4eEIsQ0FBQyxHQUFJMjBCLENBQUFBLE9BQU8zMEIsQ0FBQyxHQUFHaTFCLE1BQUs7Z0JBQ3JEO1lBQ0o7WUFDQSxNQUFNbjFCLFlBQVlvd0IsbUJBQW1CO2dCQUNqQ3hzQixPQUFPdXdCLFdBQVd2d0IsS0FBSztnQkFDdkJ5c0I7Z0JBQ0F4c0IsUUFBUXN3QixXQUFXdHdCLE1BQU07Z0JBQ3pCeXNCO2dCQUNBQyxVQUFVbnNCLE9BQU91dEIsZ0JBQWdCLENBQUNwQixRQUFRO2dCQUMxQ0MsVUFBVXBzQixPQUFPdXRCLGdCQUFnQixDQUFDbkIsUUFBUTtZQUM5QztZQUNBLE1BQU00RSxhQUFhO2dCQUFFLEdBQUdqQixVQUFVO2dCQUFFbjBCO1lBQVU7WUFDOUMsTUFBTXExQixhQUFhbkIsZUFBZXJrQixPQUFPdWxCO1lBQ3pDLElBQUlDLGVBQWUsT0FBTztnQkFDdEI7WUFDSjtZQUNBaEIsaUJBQWlCO1lBQ2pCTCxXQUFXbmtCLE9BQU91bEI7WUFDbEJ4QixTQUFTaUIsUUFBUUg7UUFDckIsR0FDS3pRLEVBQUUsQ0FBQyxPQUFPLENBQUNwVTtZQUNaLElBQUksQ0FBQ3drQixnQkFBZ0I7Z0JBQ2pCO1lBQ0o7WUFDQUosY0FBY3BrQixPQUFPO2dCQUFFLEdBQUdza0IsVUFBVTtZQUFDO1lBQ3JDdEosUUFBUTtnQkFBRSxHQUFHc0osVUFBVTtZQUFDO1lBQ3hCRSxpQkFBaUI7UUFDckI7UUFDQXpMLFVBQVVwRSxJQUFJLENBQUM4UDtJQUNuQjtJQUNBLFNBQVM3UDtRQUNMbUUsVUFBVTNFLEVBQUUsQ0FBQyxTQUFTO0lBQzFCO0lBQ0EsT0FBTztRQUNINUY7UUFDQW9HO0lBQ0o7QUFDSjtBQUVvaUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYWlsby1ncm93dGgtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0B4eWZsb3cvc3lzdGVtL2Rpc3QvZXNtL2luZGV4LmpzP2NmNzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZHJhZyB9IGZyb20gJ2QzLWRyYWcnO1xuaW1wb3J0IHsgc2VsZWN0LCBwb2ludGVyIH0gZnJvbSAnZDMtc2VsZWN0aW9uJztcbmltcG9ydCB7IHpvb20sIHpvb21JZGVudGl0eSwgem9vbVRyYW5zZm9ybSB9IGZyb20gJ2QzLXpvb20nO1xuaW1wb3J0IHsgaW50ZXJwb2xhdGVab29tLCBpbnRlcnBvbGF0ZSB9IGZyb20gJ2QzLWludGVycG9sYXRlJztcblxuY29uc3QgZXJyb3JNZXNzYWdlcyA9IHtcbiAgICBlcnJvcjAwMTogKCkgPT4gJ1tSZWFjdCBGbG93XTogU2VlbXMgbGlrZSB5b3UgaGF2ZSBub3QgdXNlZCB6dXN0YW5kIHByb3ZpZGVyIGFzIGFuIGFuY2VzdG9yLiBIZWxwOiBodHRwczovL3JlYWN0Zmxvdy5kZXYvZXJyb3IjMDAxJyxcbiAgICBlcnJvcjAwMjogKCkgPT4gXCJJdCBsb29rcyBsaWtlIHlvdSd2ZSBjcmVhdGVkIGEgbmV3IG5vZGVUeXBlcyBvciBlZGdlVHlwZXMgb2JqZWN0LiBJZiB0aGlzIHdhc24ndCBvbiBwdXJwb3NlIHBsZWFzZSBkZWZpbmUgdGhlIG5vZGVUeXBlcy9lZGdlVHlwZXMgb3V0c2lkZSBvZiB0aGUgY29tcG9uZW50IG9yIG1lbW9pemUgdGhlbS5cIixcbiAgICBlcnJvcjAwMzogKG5vZGVUeXBlKSA9PiBgTm9kZSB0eXBlIFwiJHtub2RlVHlwZX1cIiBub3QgZm91bmQuIFVzaW5nIGZhbGxiYWNrIHR5cGUgXCJkZWZhdWx0XCIuYCxcbiAgICBlcnJvcjAwNDogKCkgPT4gJ1RoZSBSZWFjdCBGbG93IHBhcmVudCBjb250YWluZXIgbmVlZHMgYSB3aWR0aCBhbmQgYSBoZWlnaHQgdG8gcmVuZGVyIHRoZSBncmFwaC4nLFxuICAgIGVycm9yMDA1OiAoKSA9PiAnT25seSBjaGlsZCBub2RlcyBjYW4gdXNlIGEgcGFyZW50IGV4dGVudC4nLFxuICAgIGVycm9yMDA2OiAoKSA9PiBcIkNhbid0IGNyZWF0ZSBlZGdlLiBBbiBlZGdlIG5lZWRzIGEgc291cmNlIGFuZCBhIHRhcmdldC5cIixcbiAgICBlcnJvcjAwNzogKGlkKSA9PiBgVGhlIG9sZCBlZGdlIHdpdGggaWQ9JHtpZH0gZG9lcyBub3QgZXhpc3QuYCxcbiAgICBlcnJvcjAwOTogKHR5cGUpID0+IGBNYXJrZXIgdHlwZSBcIiR7dHlwZX1cIiBkb2Vzbid0IGV4aXN0LmAsXG4gICAgZXJyb3IwMDg6IChoYW5kbGVUeXBlLCB7IGlkLCBzb3VyY2VIYW5kbGUsIHRhcmdldEhhbmRsZSB9KSA9PiBgQ291bGRuJ3QgY3JlYXRlIGVkZ2UgZm9yICR7aGFuZGxlVHlwZX0gaGFuZGxlIGlkOiBcIiR7aGFuZGxlVHlwZSA9PT0gJ3NvdXJjZScgPyBzb3VyY2VIYW5kbGUgOiB0YXJnZXRIYW5kbGV9XCIsIGVkZ2UgaWQ6ICR7aWR9LmAsXG4gICAgZXJyb3IwMTA6ICgpID0+ICdIYW5kbGU6IE5vIG5vZGUgaWQgZm91bmQuIE1ha2Ugc3VyZSB0byBvbmx5IHVzZSBhIEhhbmRsZSBpbnNpZGUgYSBjdXN0b20gTm9kZS4nLFxuICAgIGVycm9yMDExOiAoZWRnZVR5cGUpID0+IGBFZGdlIHR5cGUgXCIke2VkZ2VUeXBlfVwiIG5vdCBmb3VuZC4gVXNpbmcgZmFsbGJhY2sgdHlwZSBcImRlZmF1bHRcIi5gLFxuICAgIGVycm9yMDEyOiAoaWQpID0+IGBOb2RlIHdpdGggaWQgXCIke2lkfVwiIGRvZXMgbm90IGV4aXN0LCBpdCBtYXkgaGF2ZSBiZWVuIHJlbW92ZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgbm9kZSBpcyBkZWxldGVkIGJlZm9yZSB0aGUgXCJvbk5vZGVDbGlja1wiIGhhbmRsZXIgaXMgY2FsbGVkLmAsXG4gICAgZXJyb3IwMTM6IChsaWIgPSAncmVhY3QnKSA9PiBgSXQgc2VlbXMgdGhhdCB5b3UgaGF2ZW4ndCBsb2FkZWQgdGhlIHN0eWxlcy4gUGxlYXNlIGltcG9ydCAnQHh5Zmxvdy8ke2xpYn0vZGlzdC9zdHlsZS5jc3MnIG9yIGJhc2UuY3NzIHRvIG1ha2Ugc3VyZSBldmVyeXRoaW5nIGlzIHdvcmtpbmcgcHJvcGVybHkuYCxcbiAgICBlcnJvcjAxNDogKCkgPT4gJ3VzZU5vZGVDb25uZWN0aW9uczogTm8gbm9kZSBJRCBmb3VuZC4gQ2FsbCB1c2VOb2RlQ29ubmVjdGlvbnMgaW5zaWRlIGEgY3VzdG9tIE5vZGUgb3IgcHJvdmlkZSBhIG5vZGUgSUQuJyxcbiAgICBlcnJvcjAxNTogKCkgPT4gJ0l0IHNlZW1zIHRoYXQgeW91IGFyZSB0cnlpbmcgdG8gZHJhZyBhIG5vZGUgdGhhdCBpcyBub3QgaW5pdGlhbGl6ZWQuIFBsZWFzZSB1c2Ugb25Ob2Rlc0NoYW5nZSBhcyBleHBsYWluZWQgaW4gdGhlIGRvY3MuJyxcbn07XG5jb25zdCBpbmZpbml0ZUV4dGVudCA9IFtcbiAgICBbTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFldLFxuICAgIFtOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIE51bWJlci5QT1NJVElWRV9JTkZJTklUWV0sXG5dO1xuY29uc3QgZWxlbWVudFNlbGVjdGlvbktleXMgPSBbJ0VudGVyJywgJyAnLCAnRXNjYXBlJ107XG5jb25zdCBkZWZhdWx0QXJpYUxhYmVsQ29uZmlnID0ge1xuICAgICdub2RlLmExMXlEZXNjcmlwdGlvbi5kZWZhdWx0JzogJ1ByZXNzIGVudGVyIG9yIHNwYWNlIHRvIHNlbGVjdCBhIG5vZGUuIFByZXNzIGRlbGV0ZSB0byByZW1vdmUgaXQgYW5kIGVzY2FwZSB0byBjYW5jZWwuJyxcbiAgICAnbm9kZS5hMTF5RGVzY3JpcHRpb24ua2V5Ym9hcmREaXNhYmxlZCc6ICdQcmVzcyBlbnRlciBvciBzcGFjZSB0byBzZWxlY3QgYSBub2RlLiBZb3UgY2FuIHRoZW4gdXNlIHRoZSBhcnJvdyBrZXlzIHRvIG1vdmUgdGhlIG5vZGUgYXJvdW5kLiBQcmVzcyBkZWxldGUgdG8gcmVtb3ZlIGl0IGFuZCBlc2NhcGUgdG8gY2FuY2VsLicsXG4gICAgJ25vZGUuYTExeURlc2NyaXB0aW9uLmFyaWFMaXZlTWVzc2FnZSc6ICh7IGRpcmVjdGlvbiwgeCwgeSB9KSA9PiBgTW92ZWQgc2VsZWN0ZWQgbm9kZSAke2RpcmVjdGlvbn0uIE5ldyBwb3NpdGlvbiwgeDogJHt4fSwgeTogJHt5fWAsXG4gICAgJ2VkZ2UuYTExeURlc2NyaXB0aW9uLmRlZmF1bHQnOiAnUHJlc3MgZW50ZXIgb3Igc3BhY2UgdG8gc2VsZWN0IGFuIGVkZ2UuIFlvdSBjYW4gdGhlbiBwcmVzcyBkZWxldGUgdG8gcmVtb3ZlIGl0IG9yIGVzY2FwZSB0byBjYW5jZWwuJyxcbiAgICAvLyBDb250cm9sIGVsZW1lbnRzXG4gICAgJ2NvbnRyb2xzLmFyaWFMYWJlbCc6ICdDb250cm9sIFBhbmVsJyxcbiAgICAnY29udHJvbHMuem9vbUluLmFyaWFMYWJlbCc6ICdab29tIEluJyxcbiAgICAnY29udHJvbHMuem9vbU91dC5hcmlhTGFiZWwnOiAnWm9vbSBPdXQnLFxuICAgICdjb250cm9scy5maXRWaWV3LmFyaWFMYWJlbCc6ICdGaXQgVmlldycsXG4gICAgJ2NvbnRyb2xzLmludGVyYWN0aXZlLmFyaWFMYWJlbCc6ICdUb2dnbGUgSW50ZXJhY3Rpdml0eScsXG4gICAgLy8gTWluaSBtYXBcbiAgICAnbWluaW1hcC5hcmlhTGFiZWwnOiAnTWluaSBNYXAnLFxuICAgIC8vIEhhbmRsZVxuICAgICdoYW5kbGUuYXJpYUxhYmVsJzogJ0hhbmRsZScsXG59O1xuXG4vKipcbiAqIFRoZSBgQ29ubmVjdGlvbk1vZGVgIGlzIHVzZWQgdG8gc2V0IHRoZSBtb2RlIG9mIGNvbm5lY3Rpb24gYmV0d2VlbiBub2Rlcy5cbiAqIFRoZSBgU3RyaWN0YCBtb2RlIGlzIHRoZSBkZWZhdWx0IG9uZSBhbmQgb25seSBhbGxvd3Mgc291cmNlIHRvIHRhcmdldCBlZGdlcy5cbiAqIGBMb29zZWAgbW9kZSBhbGxvd3Mgc291cmNlIHRvIHNvdXJjZSBhbmQgdGFyZ2V0IHRvIHRhcmdldCBlZGdlcyBhcyB3ZWxsLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIENvbm5lY3Rpb25Nb2RlO1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uTW9kZSkge1xuICAgIENvbm5lY3Rpb25Nb2RlW1wiU3RyaWN0XCJdID0gXCJzdHJpY3RcIjtcbiAgICBDb25uZWN0aW9uTW9kZVtcIkxvb3NlXCJdID0gXCJsb29zZVwiO1xufSkoQ29ubmVjdGlvbk1vZGUgfHwgKENvbm5lY3Rpb25Nb2RlID0ge30pKTtcbi8qKlxuICogVGhpcyBlbnVtIGlzIHVzZWQgdG8gc2V0IHRoZSBkaWZmZXJlbnQgbW9kZXMgb2YgcGFubmluZyB0aGUgdmlld3BvcnQgd2hlbiB0aGVcbiAqIHVzZXIgc2Nyb2xscy4gVGhlIGBGcmVlYCBtb2RlIGFsbG93cyB0aGUgdXNlciB0byBwYW4gaW4gYW55IGRpcmVjdGlvbiBieSBzY3JvbGxpbmdcbiAqIHdpdGggYSBkZXZpY2UgbGlrZSBhIHRyYWNrcGFkLiBUaGUgYFZlcnRpY2FsYCBhbmQgYEhvcml6b250YWxgIG1vZGVzIHJlc3RyaWN0XG4gKiBzY3JvbGwgcGFubmluZyB0byBvbmx5IHRoZSB2ZXJ0aWNhbCBvciBob3Jpem9udGFsIGF4aXMsIHJlc3BlY3RpdmVseS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBQYW5PblNjcm9sbE1vZGU7XG4oZnVuY3Rpb24gKFBhbk9uU2Nyb2xsTW9kZSkge1xuICAgIFBhbk9uU2Nyb2xsTW9kZVtcIkZyZWVcIl0gPSBcImZyZWVcIjtcbiAgICBQYW5PblNjcm9sbE1vZGVbXCJWZXJ0aWNhbFwiXSA9IFwidmVydGljYWxcIjtcbiAgICBQYW5PblNjcm9sbE1vZGVbXCJIb3Jpem9udGFsXCJdID0gXCJob3Jpem9udGFsXCI7XG59KShQYW5PblNjcm9sbE1vZGUgfHwgKFBhbk9uU2Nyb2xsTW9kZSA9IHt9KSk7XG52YXIgU2VsZWN0aW9uTW9kZTtcbihmdW5jdGlvbiAoU2VsZWN0aW9uTW9kZSkge1xuICAgIFNlbGVjdGlvbk1vZGVbXCJQYXJ0aWFsXCJdID0gXCJwYXJ0aWFsXCI7XG4gICAgU2VsZWN0aW9uTW9kZVtcIkZ1bGxcIl0gPSBcImZ1bGxcIjtcbn0pKFNlbGVjdGlvbk1vZGUgfHwgKFNlbGVjdGlvbk1vZGUgPSB7fSkpO1xuY29uc3QgaW5pdGlhbENvbm5lY3Rpb24gPSB7XG4gICAgaW5Qcm9ncmVzczogZmFsc2UsXG4gICAgaXNWYWxpZDogbnVsbCxcbiAgICBmcm9tOiBudWxsLFxuICAgIGZyb21IYW5kbGU6IG51bGwsXG4gICAgZnJvbVBvc2l0aW9uOiBudWxsLFxuICAgIGZyb21Ob2RlOiBudWxsLFxuICAgIHRvOiBudWxsLFxuICAgIHRvSGFuZGxlOiBudWxsLFxuICAgIHRvUG9zaXRpb246IG51bGwsXG4gICAgdG9Ob2RlOiBudWxsLFxufTtcblxuLyoqXG4gKiBJZiB5b3Ugc2V0IHRoZSBgY29ubmVjdGlvbkxpbmVUeXBlYCBwcm9wIG9uIHlvdXIgW2A8UmVhY3RGbG93IC8+YF0oL2FwaS1yZWZlcmVuY2UvcmVhY3QtZmxvdyNjb25uZWN0aW9uLWNvbm5lY3Rpb25MaW5lVHlwZSlcbiAqY29tcG9uZW50LCBpdCB3aWxsIGRpY3RhdGUgdGhlIHN0eWxlIG9mIGNvbm5lY3Rpb24gbGluZSByZW5kZXJlZCB3aGVuIGNyZWF0aW5nXG4gKm5ldyBlZGdlcy5cbiAqXG4gKiBAcHVibGljXG4gKlxuICogQHJlbWFya3MgSWYgeW91IGNob29zZSB0byByZW5kZXIgYSBjdXN0b20gY29ubmVjdGlvbiBsaW5lIGNvbXBvbmVudCwgdGhpcyB2YWx1ZSB3aWxsIGJlXG4gKnBhc3NlZCB0byB5b3VyIGNvbXBvbmVudCBhcyBwYXJ0IG9mIGl0cyBbYENvbm5lY3Rpb25MaW5lQ29tcG9uZW50UHJvcHNgXSgvYXBpLXJlZmVyZW5jZS90eXBlcy9jb25uZWN0aW9uLWxpbmUtY29tcG9uZW50LXByb3BzKS5cbiAqL1xudmFyIENvbm5lY3Rpb25MaW5lVHlwZTtcbihmdW5jdGlvbiAoQ29ubmVjdGlvbkxpbmVUeXBlKSB7XG4gICAgQ29ubmVjdGlvbkxpbmVUeXBlW1wiQmV6aWVyXCJdID0gXCJkZWZhdWx0XCI7XG4gICAgQ29ubmVjdGlvbkxpbmVUeXBlW1wiU3RyYWlnaHRcIl0gPSBcInN0cmFpZ2h0XCI7XG4gICAgQ29ubmVjdGlvbkxpbmVUeXBlW1wiU3RlcFwiXSA9IFwic3RlcFwiO1xuICAgIENvbm5lY3Rpb25MaW5lVHlwZVtcIlNtb290aFN0ZXBcIl0gPSBcInNtb290aHN0ZXBcIjtcbiAgICBDb25uZWN0aW9uTGluZVR5cGVbXCJTaW1wbGVCZXppZXJcIl0gPSBcInNpbXBsZWJlemllclwiO1xufSkoQ29ubmVjdGlvbkxpbmVUeXBlIHx8IChDb25uZWN0aW9uTGluZVR5cGUgPSB7fSkpO1xuLyoqXG4gKiBFZGdlcyBtYXkgb3B0aW9uYWxseSBoYXZlIGEgbWFya2VyIG9uIGVpdGhlciBlbmQuIFRoZSBNYXJrZXJUeXBlIHR5cGUgZW51bWVyYXRlc1xuICogdGhlIG9wdGlvbnMgYXZhaWxhYmxlIHRvIHlvdSB3aGVuIGNvbmZpZ3VyaW5nIGEgZ2l2ZW4gbWFya2VyLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIE1hcmtlclR5cGU7XG4oZnVuY3Rpb24gKE1hcmtlclR5cGUpIHtcbiAgICBNYXJrZXJUeXBlW1wiQXJyb3dcIl0gPSBcImFycm93XCI7XG4gICAgTWFya2VyVHlwZVtcIkFycm93Q2xvc2VkXCJdID0gXCJhcnJvd2Nsb3NlZFwiO1xufSkoTWFya2VyVHlwZSB8fCAoTWFya2VyVHlwZSA9IHt9KSk7XG5cbi8qKlxuICogV2hpbGUgW2BQYW5lbFBvc2l0aW9uYF0oL2FwaS1yZWZlcmVuY2UvdHlwZXMvcGFuZWwtcG9zaXRpb24pIGNhbiBiZSB1c2VkIHRvIHBsYWNlIGFcbiAqIGNvbXBvbmVudCBpbiB0aGUgY29ybmVycyBvZiBhIGNvbnRhaW5lciwgdGhlIGBQb3NpdGlvbmAgZW51bSBpcyBsZXNzIHByZWNpc2UgYW5kIHVzZWRcbiAqIHByaW1hcmlseSBpbiByZWxhdGlvbiB0byBlZGdlcyBhbmQgaGFuZGxlcy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBQb3NpdGlvbjtcbihmdW5jdGlvbiAoUG9zaXRpb24pIHtcbiAgICBQb3NpdGlvbltcIkxlZnRcIl0gPSBcImxlZnRcIjtcbiAgICBQb3NpdGlvbltcIlRvcFwiXSA9IFwidG9wXCI7XG4gICAgUG9zaXRpb25bXCJSaWdodFwiXSA9IFwicmlnaHRcIjtcbiAgICBQb3NpdGlvbltcIkJvdHRvbVwiXSA9IFwiYm90dG9tXCI7XG59KShQb3NpdGlvbiB8fCAoUG9zaXRpb24gPSB7fSkpO1xuY29uc3Qgb3Bwb3NpdGVQb3NpdGlvbiA9IHtcbiAgICBbUG9zaXRpb24uTGVmdF06IFBvc2l0aW9uLlJpZ2h0LFxuICAgIFtQb3NpdGlvbi5SaWdodF06IFBvc2l0aW9uLkxlZnQsXG4gICAgW1Bvc2l0aW9uLlRvcF06IFBvc2l0aW9uLkJvdHRvbSxcbiAgICBbUG9zaXRpb24uQm90dG9tXTogUG9zaXRpb24uVG9wLFxufTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gYXJlQ29ubmVjdGlvbk1hcHNFcXVhbChhLCBiKSB7XG4gICAgaWYgKCFhICYmICFiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWEgfHwgIWIgfHwgYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWEuc2l6ZSAmJiAhYi5zaXplKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBhLmtleXMoKSkge1xuICAgICAgICBpZiAoIWIuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogV2UgY2FsbCB0aGUgY2FsbGJhY2sgZm9yIGFsbCBjb25uZWN0aW9ucyBpbiBhIHRoYXQgYXJlIG5vdCBpbiBiXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUNvbm5lY3Rpb25DaGFuZ2UoYSwgYiwgY2IpIHtcbiAgICBpZiAoIWNiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGlmZiA9IFtdO1xuICAgIGEuZm9yRWFjaCgoY29ubmVjdGlvbiwga2V5KSA9PiB7XG4gICAgICAgIGlmICghYj8uaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGRpZmYucHVzaChjb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChkaWZmLmxlbmd0aCkge1xuICAgICAgICBjYihkaWZmKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRDb25uZWN0aW9uU3RhdHVzKGlzVmFsaWQpIHtcbiAgICByZXR1cm4gaXNWYWxpZCA9PT0gbnVsbCA/IG51bGwgOiBpc1ZhbGlkID8gJ3ZhbGlkJyA6ICdpbnZhbGlkJztcbn1cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuLyoqXG4gKiBUZXN0IHdoZXRoZXIgYW4gb2JqZWN0IGlzIHVzYWJsZSBhcyBhbiBFZGdlXG4gKiBAcHVibGljXG4gKiBAcmVtYXJrcyBJbiBUeXBlU2NyaXB0IHRoaXMgaXMgYSB0eXBlIGd1YXJkIHRoYXQgd2lsbCBuYXJyb3cgdGhlIHR5cGUgb2Ygd2hhdGV2ZXIgeW91IHBhc3MgaW4gdG8gRWRnZSBpZiBpdCByZXR1cm5zIHRydWVcbiAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgdG8gdGVzdFxuICogQHJldHVybnMgQSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgZWxlbWVudCBpcyBhbiBFZGdlXG4gKi9cbmNvbnN0IGlzRWRnZUJhc2UgPSAoZWxlbWVudCkgPT4gJ2lkJyBpbiBlbGVtZW50ICYmICdzb3VyY2UnIGluIGVsZW1lbnQgJiYgJ3RhcmdldCcgaW4gZWxlbWVudDtcbi8qKlxuICogVGVzdCB3aGV0aGVyIGFuIG9iamVjdCBpcyB1c2FibGUgYXMgYSBOb2RlXG4gKiBAcHVibGljXG4gKiBAcmVtYXJrcyBJbiBUeXBlU2NyaXB0IHRoaXMgaXMgYSB0eXBlIGd1YXJkIHRoYXQgd2lsbCBuYXJyb3cgdGhlIHR5cGUgb2Ygd2hhdGV2ZXIgeW91IHBhc3MgaW4gdG8gTm9kZSBpZiBpdCByZXR1cm5zIHRydWVcbiAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgdG8gdGVzdFxuICogQHJldHVybnMgQSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgZWxlbWVudCBpcyBhbiBOb2RlXG4gKi9cbmNvbnN0IGlzTm9kZUJhc2UgPSAoZWxlbWVudCkgPT4gJ2lkJyBpbiBlbGVtZW50ICYmICdwb3NpdGlvbicgaW4gZWxlbWVudCAmJiAhKCdzb3VyY2UnIGluIGVsZW1lbnQpICYmICEoJ3RhcmdldCcgaW4gZWxlbWVudCk7XG5jb25zdCBpc0ludGVybmFsTm9kZUJhc2UgPSAoZWxlbWVudCkgPT4gJ2lkJyBpbiBlbGVtZW50ICYmICdpbnRlcm5hbHMnIGluIGVsZW1lbnQgJiYgISgnc291cmNlJyBpbiBlbGVtZW50KSAmJiAhKCd0YXJnZXQnIGluIGVsZW1lbnQpO1xuLyoqXG4gKiBUaGlzIHV0aWwgaXMgdXNlZCB0byB0ZWxsIHlvdSB3aGF0IG5vZGVzLCBpZiBhbnksIGFyZSBjb25uZWN0ZWQgdG8gdGhlIGdpdmVuIG5vZGVcbiAqIGFzIHRoZSBfdGFyZ2V0XyBvZiBhbiBlZGdlLlxuICogQHB1YmxpY1xuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBnZXQgdGhlIGNvbm5lY3RlZCBub2RlcyBmcm9tLlxuICogQHBhcmFtIG5vZGVzIC0gVGhlIGFycmF5IG9mIGFsbCBub2Rlcy5cbiAqIEBwYXJhbSBlZGdlcyAtIFRoZSBhcnJheSBvZiBhbGwgZWRnZXMuXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBub2RlcyB0aGF0IGFyZSBjb25uZWN0ZWQgb3ZlciBlZGdlcyB3aGVyZSB0aGUgc291cmNlIGlzIHRoZSBnaXZlbiBub2RlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICppbXBvcnQgeyBnZXRPdXRnb2VycyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqY29uc3Qgbm9kZXMgPSBbXTtcbiAqY29uc3QgZWRnZXMgPSBbXTtcbiAqXG4gKmNvbnN0IG91dGdvZXJzID0gZ2V0T3V0Z29lcnMoXG4gKiAgeyBpZDogJzEnLCBwb3NpdGlvbjogeyB4OiAwLCB5OiAwIH0sIGRhdGE6IHsgbGFiZWw6ICdub2RlJyB9IH0sXG4gKiAgbm9kZXMsXG4gKiAgZWRnZXMsXG4gKik7XG4gKmBgYFxuICovXG5jb25zdCBnZXRPdXRnb2VycyA9IChub2RlLCBub2RlcywgZWRnZXMpID0+IHtcbiAgICBpZiAoIW5vZGUuaWQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBvdXRnb2VySWRzID0gbmV3IFNldCgpO1xuICAgIGVkZ2VzLmZvckVhY2goKGVkZ2UpID0+IHtcbiAgICAgICAgaWYgKGVkZ2Uuc291cmNlID09PSBub2RlLmlkKSB7XG4gICAgICAgICAgICBvdXRnb2VySWRzLmFkZChlZGdlLnRhcmdldCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbm9kZXMuZmlsdGVyKChuKSA9PiBvdXRnb2VySWRzLmhhcyhuLmlkKSk7XG59O1xuLyoqXG4gKiBUaGlzIHV0aWwgaXMgdXNlZCB0byB0ZWxsIHlvdSB3aGF0IG5vZGVzLCBpZiBhbnksIGFyZSBjb25uZWN0ZWQgdG8gdGhlIGdpdmVuIG5vZGVcbiAqIGFzIHRoZSBfc291cmNlXyBvZiBhbiBlZGdlLlxuICogQHB1YmxpY1xuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBnZXQgdGhlIGNvbm5lY3RlZCBub2RlcyBmcm9tLlxuICogQHBhcmFtIG5vZGVzIC0gVGhlIGFycmF5IG9mIGFsbCBub2Rlcy5cbiAqIEBwYXJhbSBlZGdlcyAtIFRoZSBhcnJheSBvZiBhbGwgZWRnZXMuXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBub2RlcyB0aGF0IGFyZSBjb25uZWN0ZWQgb3ZlciBlZGdlcyB3aGVyZSB0aGUgdGFyZ2V0IGlzIHRoZSBnaXZlbiBub2RlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICppbXBvcnQgeyBnZXRJbmNvbWVycyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqY29uc3Qgbm9kZXMgPSBbXTtcbiAqY29uc3QgZWRnZXMgPSBbXTtcbiAqXG4gKmNvbnN0IGluY29tZXJzID0gZ2V0SW5jb21lcnMoXG4gKiAgeyBpZDogJzEnLCBwb3NpdGlvbjogeyB4OiAwLCB5OiAwIH0sIGRhdGE6IHsgbGFiZWw6ICdub2RlJyB9IH0sXG4gKiAgbm9kZXMsXG4gKiAgZWRnZXMsXG4gKik7XG4gKmBgYFxuICovXG5jb25zdCBnZXRJbmNvbWVycyA9IChub2RlLCBub2RlcywgZWRnZXMpID0+IHtcbiAgICBpZiAoIW5vZGUuaWQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBpbmNvbWVyc0lkcyA9IG5ldyBTZXQoKTtcbiAgICBlZGdlcy5mb3JFYWNoKChlZGdlKSA9PiB7XG4gICAgICAgIGlmIChlZGdlLnRhcmdldCA9PT0gbm9kZS5pZCkge1xuICAgICAgICAgICAgaW5jb21lcnNJZHMuYWRkKGVkZ2Uuc291cmNlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBub2Rlcy5maWx0ZXIoKG4pID0+IGluY29tZXJzSWRzLmhhcyhuLmlkKSk7XG59O1xuY29uc3QgZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbiA9IChub2RlLCBub2RlT3JpZ2luID0gWzAsIDBdKSA9PiB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBnZXROb2RlRGltZW5zaW9ucyhub2RlKTtcbiAgICBjb25zdCBvcmlnaW4gPSBub2RlLm9yaWdpbiA/PyBub2RlT3JpZ2luO1xuICAgIGNvbnN0IG9mZnNldFggPSB3aWR0aCAqIG9yaWdpblswXTtcbiAgICBjb25zdCBvZmZzZXRZID0gaGVpZ2h0ICogb3JpZ2luWzFdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IG5vZGUucG9zaXRpb24ueCAtIG9mZnNldFgsXG4gICAgICAgIHk6IG5vZGUucG9zaXRpb24ueSAtIG9mZnNldFksXG4gICAgfTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGJvdW5kaW5nIGJveCB0aGF0IGNvbnRhaW5zIGFsbCB0aGUgZ2l2ZW4gbm9kZXMgaW4gYW4gYXJyYXkuIFRoaXMgY2FuXG4gKiBiZSB1c2VmdWwgd2hlbiBjb21iaW5lZCB3aXRoIFtgZ2V0Vmlld3BvcnRGb3JCb3VuZHNgXSgvYXBpLXJlZmVyZW5jZS91dGlscy9nZXQtdmlld3BvcnQtZm9yLWJvdW5kcylcbiAqIHRvIGNhbGN1bGF0ZSB0aGUgY29ycmVjdCB0cmFuc2Zvcm0gdG8gZml0IHRoZSBnaXZlbiBub2RlcyBpbiBhIHZpZXdwb3J0LlxuICogQHB1YmxpY1xuICogQHJlbWFya3MgVXNlZnVsIHdoZW4gY29tYmluZWQgd2l0aCB7QGxpbmsgZ2V0Vmlld3BvcnRGb3JCb3VuZHN9IHRvIGNhbGN1bGF0ZSB0aGUgY29ycmVjdCB0cmFuc2Zvcm0gdG8gZml0IHRoZSBnaXZlbiBub2RlcyBpbiBhIHZpZXdwb3J0LlxuICogQHBhcmFtIG5vZGVzIC0gTm9kZXMgdG8gY2FsY3VsYXRlIHRoZSBib3VuZHMgZm9yLlxuICogQHJldHVybnMgQm91bmRpbmcgYm94IGVuY2xvc2luZyBhbGwgbm9kZXMuXG4gKlxuICogQHJlbWFya3MgVGhpcyBmdW5jdGlvbiB3YXMgcHJldmlvdXNseSBjYWxsZWQgYGdldFJlY3RPZk5vZGVzYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICppbXBvcnQgeyBnZXROb2Rlc0JvdW5kcyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqY29uc3Qgbm9kZXMgPSBbXG4gKiAge1xuICogICAgaWQ6ICdhJyxcbiAqICAgIHBvc2l0aW9uOiB7IHg6IDAsIHk6IDAgfSxcbiAqICAgIGRhdGE6IHsgbGFiZWw6ICdhJyB9LFxuICogICAgd2lkdGg6IDUwLFxuICogICAgaGVpZ2h0OiAyNSxcbiAqICB9LFxuICogIHtcbiAqICAgIGlkOiAnYicsXG4gKiAgICBwb3NpdGlvbjogeyB4OiAxMDAsIHk6IDEwMCB9LFxuICogICAgZGF0YTogeyBsYWJlbDogJ2InIH0sXG4gKiAgICB3aWR0aDogNTAsXG4gKiAgICBoZWlnaHQ6IDI1LFxuICogIH0sXG4gKl07XG4gKlxuICpjb25zdCBib3VuZHMgPSBnZXROb2Rlc0JvdW5kcyhub2Rlcyk7XG4gKmBgYFxuICovXG5jb25zdCBnZXROb2Rlc0JvdW5kcyA9IChub2RlcywgcGFyYW1zID0geyBub2RlT3JpZ2luOiBbMCwgMF0gfSkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAhcGFyYW1zLm5vZGVMb29rdXApIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdQbGVhc2UgdXNlIGBnZXROb2Rlc0JvdW5kc2AgZnJvbSBgdXNlUmVhY3RGbG93YC9gdXNlU3ZlbHRlRmxvd2AgaG9vayB0byBlbnN1cmUgY29ycmVjdCB2YWx1ZXMgZm9yIHN1YiBmbG93cy4gSWYgbm90IHBvc3NpYmxlLCB5b3UgaGF2ZSB0byBwcm92aWRlIGEgbm9kZUxvb2t1cCB0byBzdXBwb3J0IHN1YiBmbG93cy4nKTtcbiAgICB9XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4geyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gICAgfVxuICAgIGNvbnN0IGJveCA9IG5vZGVzLnJlZHVjZSgoY3VyckJveCwgbm9kZU9ySWQpID0+IHtcbiAgICAgICAgY29uc3QgaXNJZCA9IHR5cGVvZiBub2RlT3JJZCA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGxldCBjdXJyZW50Tm9kZSA9ICFwYXJhbXMubm9kZUxvb2t1cCAmJiAhaXNJZCA/IG5vZGVPcklkIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAocGFyYW1zLm5vZGVMb29rdXApIHtcbiAgICAgICAgICAgIGN1cnJlbnROb2RlID0gaXNJZFxuICAgICAgICAgICAgICAgID8gcGFyYW1zLm5vZGVMb29rdXAuZ2V0KG5vZGVPcklkKVxuICAgICAgICAgICAgICAgIDogIWlzSW50ZXJuYWxOb2RlQmFzZShub2RlT3JJZClcbiAgICAgICAgICAgICAgICAgICAgPyBwYXJhbXMubm9kZUxvb2t1cC5nZXQobm9kZU9ySWQuaWQpXG4gICAgICAgICAgICAgICAgICAgIDogbm9kZU9ySWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZUJveCA9IGN1cnJlbnROb2RlID8gbm9kZVRvQm94KGN1cnJlbnROb2RlLCBwYXJhbXMubm9kZU9yaWdpbikgOiB7IHg6IDAsIHk6IDAsIHgyOiAwLCB5MjogMCB9O1xuICAgICAgICByZXR1cm4gZ2V0Qm91bmRzT2ZCb3hlcyhjdXJyQm94LCBub2RlQm94KTtcbiAgICB9LCB7IHg6IEluZmluaXR5LCB5OiBJbmZpbml0eSwgeDI6IC1JbmZpbml0eSwgeTI6IC1JbmZpbml0eSB9KTtcbiAgICByZXR1cm4gYm94VG9SZWN0KGJveCk7XG59O1xuLyoqXG4gKiBEZXRlcm1pbmVzIGEgYm91bmRpbmcgYm94IHRoYXQgY29udGFpbnMgYWxsIGdpdmVuIG5vZGVzIGluIGFuIGFycmF5XG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyA9IChub2RlTG9va3VwLCBwYXJhbXMgPSB7fSkgPT4ge1xuICAgIGxldCBib3ggPSB7IHg6IEluZmluaXR5LCB5OiBJbmZpbml0eSwgeDI6IC1JbmZpbml0eSwgeTI6IC1JbmZpbml0eSB9O1xuICAgIGxldCBoYXNWaXNpYmxlTm9kZXMgPSBmYWxzZTtcbiAgICBub2RlTG9va3VwLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIgPT09IHVuZGVmaW5lZCB8fCBwYXJhbXMuZmlsdGVyKG5vZGUpKSB7XG4gICAgICAgICAgICBib3ggPSBnZXRCb3VuZHNPZkJveGVzKGJveCwgbm9kZVRvQm94KG5vZGUpKTtcbiAgICAgICAgICAgIGhhc1Zpc2libGVOb2RlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaGFzVmlzaWJsZU5vZGVzID8gYm94VG9SZWN0KGJveCkgOiB7IHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcbn07XG5jb25zdCBnZXROb2Rlc0luc2lkZSA9IChub2RlcywgcmVjdCwgW3R4LCB0eSwgdFNjYWxlXSA9IFswLCAwLCAxXSwgcGFydGlhbGx5ID0gZmFsc2UsIFxuLy8gc2V0IGV4Y2x1ZGVOb25TZWxlY3RhYmxlTm9kZXMgaWYgeW91IHdhbnQgdG8gcGF5IGF0dGVudGlvbiB0byB0aGUgbm9kZXMgXCJzZWxlY3RhYmxlXCIgYXR0cmlidXRlXG5leGNsdWRlTm9uU2VsZWN0YWJsZU5vZGVzID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCBwYW5lUmVjdCA9IHtcbiAgICAgICAgLi4ucG9pbnRUb1JlbmRlcmVyUG9pbnQocmVjdCwgW3R4LCB0eSwgdFNjYWxlXSksXG4gICAgICAgIHdpZHRoOiByZWN0LndpZHRoIC8gdFNjYWxlLFxuICAgICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0IC8gdFNjYWxlLFxuICAgIH07XG4gICAgY29uc3QgdmlzaWJsZU5vZGVzID0gW107XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzLnZhbHVlcygpKSB7XG4gICAgICAgIGNvbnN0IHsgbWVhc3VyZWQsIHNlbGVjdGFibGUgPSB0cnVlLCBoaWRkZW4gPSBmYWxzZSB9ID0gbm9kZTtcbiAgICAgICAgaWYgKChleGNsdWRlTm9uU2VsZWN0YWJsZU5vZGVzICYmICFzZWxlY3RhYmxlKSB8fCBoaWRkZW4pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdpZHRoID0gbWVhc3VyZWQud2lkdGggPz8gbm9kZS53aWR0aCA/PyBub2RlLmluaXRpYWxXaWR0aCA/PyBudWxsO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBtZWFzdXJlZC5oZWlnaHQgPz8gbm9kZS5oZWlnaHQgPz8gbm9kZS5pbml0aWFsSGVpZ2h0ID8/IG51bGw7XG4gICAgICAgIGNvbnN0IG92ZXJsYXBwaW5nQXJlYSA9IGdldE92ZXJsYXBwaW5nQXJlYShwYW5lUmVjdCwgbm9kZVRvUmVjdChub2RlKSk7XG4gICAgICAgIGNvbnN0IGFyZWEgPSAod2lkdGggPz8gMCkgKiAoaGVpZ2h0ID8/IDApO1xuICAgICAgICBjb25zdCBwYXJ0aWFsbHlWaXNpYmxlID0gcGFydGlhbGx5ICYmIG92ZXJsYXBwaW5nQXJlYSA+IDA7XG4gICAgICAgIGNvbnN0IGZvcmNlSW5pdGlhbFJlbmRlciA9ICFub2RlLmludGVybmFscy5oYW5kbGVCb3VuZHM7XG4gICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IGZvcmNlSW5pdGlhbFJlbmRlciB8fCBwYXJ0aWFsbHlWaXNpYmxlIHx8IG92ZXJsYXBwaW5nQXJlYSA+PSBhcmVhO1xuICAgICAgICBpZiAoaXNWaXNpYmxlIHx8IG5vZGUuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHZpc2libGVOb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2aXNpYmxlTm9kZXM7XG59O1xuLyoqXG4gKiBUaGlzIHV0aWxpdHkgZmlsdGVycyBhbiBhcnJheSBvZiBlZGdlcywga2VlcGluZyBvbmx5IHRob3NlIHdoZXJlIGVpdGhlciB0aGUgc291cmNlIG9yIHRhcmdldFxuICogbm9kZSBpcyBwcmVzZW50IGluIHRoZSBnaXZlbiBhcnJheSBvZiBub2Rlcy5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBub2RlcyAtIE5vZGVzIHlvdSB3YW50IHRvIGdldCB0aGUgY29ubmVjdGVkIGVkZ2VzIGZvci5cbiAqIEBwYXJhbSBlZGdlcyAtIEFsbCBlZGdlcy5cbiAqIEByZXR1cm5zIEFycmF5IG9mIGVkZ2VzIHRoYXQgY29ubmVjdCBhbnkgb2YgdGhlIGdpdmVuIG5vZGVzIHdpdGggZWFjaCBvdGhlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqaW1wb3J0IHsgZ2V0Q29ubmVjdGVkRWRnZXMgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmNvbnN0IG5vZGVzID0gW1xuICogIHsgaWQ6ICdhJywgcG9zaXRpb246IHsgeDogMCwgeTogMCB9IH0sXG4gKiAgeyBpZDogJ2InLCBwb3NpdGlvbjogeyB4OiAxMDAsIHk6IDAgfSB9LFxuICpdO1xuICpcbiAqY29uc3QgZWRnZXMgPSBbXG4gKiAgeyBpZDogJ2EtPmMnLCBzb3VyY2U6ICdhJywgdGFyZ2V0OiAnYycgfSxcbiAqICB7IGlkOiAnYy0+ZCcsIHNvdXJjZTogJ2MnLCB0YXJnZXQ6ICdkJyB9LFxuICpdO1xuICpcbiAqY29uc3QgY29ubmVjdGVkRWRnZXMgPSBnZXRDb25uZWN0ZWRFZGdlcyhub2RlcywgZWRnZXMpO1xuICogLy8gPT4gW3sgaWQ6ICdhLT5jJywgc291cmNlOiAnYScsIHRhcmdldDogJ2MnIH1dXG4gKmBgYFxuICovXG5jb25zdCBnZXRDb25uZWN0ZWRFZGdlcyA9IChub2RlcywgZWRnZXMpID0+IHtcbiAgICBjb25zdCBub2RlSWRzID0gbmV3IFNldCgpO1xuICAgIG5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgbm9kZUlkcy5hZGQobm9kZS5pZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVkZ2VzLmZpbHRlcigoZWRnZSkgPT4gbm9kZUlkcy5oYXMoZWRnZS5zb3VyY2UpIHx8IG5vZGVJZHMuaGFzKGVkZ2UudGFyZ2V0KSk7XG59O1xuZnVuY3Rpb24gZ2V0Rml0Vmlld05vZGVzKG5vZGVMb29rdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmaXRWaWV3Tm9kZXMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3Qgb3B0aW9uTm9kZUlkcyA9IG9wdGlvbnM/Lm5vZGVzID8gbmV3IFNldChvcHRpb25zLm5vZGVzLm1hcCgobm9kZSkgPT4gbm9kZS5pZCkpIDogbnVsbDtcbiAgICBub2RlTG9va3VwLmZvckVhY2goKG4pID0+IHtcbiAgICAgICAgY29uc3QgaXNWaXNpYmxlID0gbi5tZWFzdXJlZC53aWR0aCAmJiBuLm1lYXN1cmVkLmhlaWdodCAmJiAob3B0aW9ucz8uaW5jbHVkZUhpZGRlbk5vZGVzIHx8ICFuLmhpZGRlbik7XG4gICAgICAgIGlmIChpc1Zpc2libGUgJiYgKCFvcHRpb25Ob2RlSWRzIHx8IG9wdGlvbk5vZGVJZHMuaGFzKG4uaWQpKSkge1xuICAgICAgICAgICAgZml0Vmlld05vZGVzLnNldChuLmlkLCBuKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmaXRWaWV3Tm9kZXM7XG59XG5hc3luYyBmdW5jdGlvbiBmaXRWaWV3cG9ydCh7IG5vZGVzLCB3aWR0aCwgaGVpZ2h0LCBwYW5ab29tLCBtaW5ab29tLCBtYXhab29tIH0sIG9wdGlvbnMpIHtcbiAgICBpZiAobm9kZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgIH1cbiAgICBjb25zdCBub2Rlc1RvRml0ID0gZ2V0Rml0Vmlld05vZGVzKG5vZGVzLCBvcHRpb25zKTtcbiAgICBjb25zdCBib3VuZHMgPSBnZXRJbnRlcm5hbE5vZGVzQm91bmRzKG5vZGVzVG9GaXQpO1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gZ2V0Vmlld3BvcnRGb3JCb3VuZHMoYm91bmRzLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zPy5taW5ab29tID8/IG1pblpvb20sIG9wdGlvbnM/Lm1heFpvb20gPz8gbWF4Wm9vbSwgb3B0aW9ucz8ucGFkZGluZyA/PyAwLjEpO1xuICAgIGF3YWl0IHBhblpvb20uc2V0Vmlld3BvcnQodmlld3BvcnQsIHtcbiAgICAgICAgZHVyYXRpb246IG9wdGlvbnM/LmR1cmF0aW9uLFxuICAgICAgICBlYXNlOiBvcHRpb25zPy5lYXNlLFxuICAgICAgICBpbnRlcnBvbGF0ZTogb3B0aW9ucz8uaW50ZXJwb2xhdGUsXG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbn1cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzIHRoZSBuZXh0IHBvc2l0aW9uIG9mIGEgbm9kZSwgdGFraW5nIGludG8gYWNjb3VudCB0aGUgbm9kZSdzIGV4dGVudCwgcGFyZW50IG5vZGUsIGFuZCBvcmlnaW4uXG4gKlxuICogQGludGVybmFsXG4gKiBAcmV0dXJucyBwb3NpdGlvbiwgcG9zaXRpb25BYnNvbHV0ZVxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVOb2RlUG9zaXRpb24oeyBub2RlSWQsIG5leHRQb3NpdGlvbiwgbm9kZUxvb2t1cCwgbm9kZU9yaWdpbiA9IFswLCAwXSwgbm9kZUV4dGVudCwgb25FcnJvciwgfSkge1xuICAgIGNvbnN0IG5vZGUgPSBub2RlTG9va3VwLmdldChub2RlSWQpO1xuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudElkID8gbm9kZUxvb2t1cC5nZXQobm9kZS5wYXJlbnRJZCkgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgeyB4OiBwYXJlbnRYLCB5OiBwYXJlbnRZIH0gPSBwYXJlbnROb2RlID8gcGFyZW50Tm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZSA6IHsgeDogMCwgeTogMCB9O1xuICAgIGNvbnN0IG9yaWdpbiA9IG5vZGUub3JpZ2luID8/IG5vZGVPcmlnaW47XG4gICAgbGV0IGV4dGVudCA9IG5vZGUuZXh0ZW50IHx8IG5vZGVFeHRlbnQ7XG4gICAgaWYgKG5vZGUuZXh0ZW50ID09PSAncGFyZW50JyAmJiAhbm9kZS5leHBhbmRQYXJlbnQpIHtcbiAgICAgICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBvbkVycm9yPy4oJzAwNScsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA1J10oKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRXaWR0aCA9IHBhcmVudE5vZGUubWVhc3VyZWQud2lkdGg7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRIZWlnaHQgPSBwYXJlbnROb2RlLm1lYXN1cmVkLmhlaWdodDtcbiAgICAgICAgICAgIGlmIChwYXJlbnRXaWR0aCAmJiBwYXJlbnRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBleHRlbnQgPSBbXG4gICAgICAgICAgICAgICAgICAgIFtwYXJlbnRYLCBwYXJlbnRZXSxcbiAgICAgICAgICAgICAgICAgICAgW3BhcmVudFggKyBwYXJlbnRXaWR0aCwgcGFyZW50WSArIHBhcmVudEhlaWdodF0sXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChwYXJlbnROb2RlICYmIGlzQ29vcmRpbmF0ZUV4dGVudChub2RlLmV4dGVudCkpIHtcbiAgICAgICAgZXh0ZW50ID0gW1xuICAgICAgICAgICAgW25vZGUuZXh0ZW50WzBdWzBdICsgcGFyZW50WCwgbm9kZS5leHRlbnRbMF1bMV0gKyBwYXJlbnRZXSxcbiAgICAgICAgICAgIFtub2RlLmV4dGVudFsxXVswXSArIHBhcmVudFgsIG5vZGUuZXh0ZW50WzFdWzFdICsgcGFyZW50WV0sXG4gICAgICAgIF07XG4gICAgfVxuICAgIGNvbnN0IHBvc2l0aW9uQWJzb2x1dGUgPSBpc0Nvb3JkaW5hdGVFeHRlbnQoZXh0ZW50KVxuICAgICAgICA/IGNsYW1wUG9zaXRpb24obmV4dFBvc2l0aW9uLCBleHRlbnQsIG5vZGUubWVhc3VyZWQpXG4gICAgICAgIDogbmV4dFBvc2l0aW9uO1xuICAgIGlmIChub2RlLm1lYXN1cmVkLndpZHRoID09PSB1bmRlZmluZWQgfHwgbm9kZS5tZWFzdXJlZC5oZWlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvbkVycm9yPy4oJzAxNScsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDE1J10oKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICB4OiBwb3NpdGlvbkFic29sdXRlLnggLSBwYXJlbnRYICsgKG5vZGUubWVhc3VyZWQud2lkdGggPz8gMCkgKiBvcmlnaW5bMF0sXG4gICAgICAgICAgICB5OiBwb3NpdGlvbkFic29sdXRlLnkgLSBwYXJlbnRZICsgKG5vZGUubWVhc3VyZWQuaGVpZ2h0ID8/IDApICogb3JpZ2luWzFdLFxuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbkFic29sdXRlLFxuICAgIH07XG59XG4vKipcbiAqIFBhc3MgaW4gbm9kZXMgJiBlZGdlcyB0byBkZWxldGUsIGdldCBhcnJheXMgb2Ygbm9kZXMgYW5kIGVkZ2VzIHRoYXQgYWN0dWFsbHkgY2FuIGJlIGRlbGV0ZWRcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHBhcmFtLm5vZGVzVG9SZW1vdmUgLSBUaGUgbm9kZXMgdG8gcmVtb3ZlXG4gKiBAcGFyYW0gcGFyYW0uZWRnZXNUb1JlbW92ZSAtIFRoZSBlZGdlcyB0byByZW1vdmVcbiAqIEBwYXJhbSBwYXJhbS5ub2RlcyAtIEFsbCBub2Rlc1xuICogQHBhcmFtIHBhcmFtLmVkZ2VzIC0gQWxsIGVkZ2VzXG4gKiBAcGFyYW0gcGFyYW0ub25CZWZvcmVEZWxldGUgLSBDYWxsYmFjayB0byBjaGVjayB3aGljaCBub2RlcyBhbmQgZWRnZXMgY2FuIGJlIGRlbGV0ZWRcbiAqIEByZXR1cm5zIG5vZGVzOiBub2RlcyB0aGF0IGNhbiBiZSBkZWxldGVkLCBlZGdlczogZWRnZXMgdGhhdCBjYW4gYmUgZGVsZXRlZFxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRFbGVtZW50c1RvUmVtb3ZlKHsgbm9kZXNUb1JlbW92ZSA9IFtdLCBlZGdlc1RvUmVtb3ZlID0gW10sIG5vZGVzLCBlZGdlcywgb25CZWZvcmVEZWxldGUsIH0pIHtcbiAgICBjb25zdCBub2RlSWRzID0gbmV3IFNldChub2Rlc1RvUmVtb3ZlLm1hcCgobm9kZSkgPT4gbm9kZS5pZCkpO1xuICAgIGNvbnN0IG1hdGNoaW5nTm9kZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgaWYgKG5vZGUuZGVsZXRhYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNJbmNsdWRlZCA9IG5vZGVJZHMuaGFzKG5vZGUuaWQpO1xuICAgICAgICBjb25zdCBwYXJlbnRIaXQgPSAhaXNJbmNsdWRlZCAmJiBub2RlLnBhcmVudElkICYmIG1hdGNoaW5nTm9kZXMuZmluZCgobikgPT4gbi5pZCA9PT0gbm9kZS5wYXJlbnRJZCk7XG4gICAgICAgIGlmIChpc0luY2x1ZGVkIHx8IHBhcmVudEhpdCkge1xuICAgICAgICAgICAgbWF0Y2hpbmdOb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVkZ2VJZHMgPSBuZXcgU2V0KGVkZ2VzVG9SZW1vdmUubWFwKChlZGdlKSA9PiBlZGdlLmlkKSk7XG4gICAgY29uc3QgZGVsZXRhYmxlRWRnZXMgPSBlZGdlcy5maWx0ZXIoKGVkZ2UpID0+IGVkZ2UuZGVsZXRhYmxlICE9PSBmYWxzZSk7XG4gICAgY29uc3QgY29ubmVjdGVkRWRnZXMgPSBnZXRDb25uZWN0ZWRFZGdlcyhtYXRjaGluZ05vZGVzLCBkZWxldGFibGVFZGdlcyk7XG4gICAgY29uc3QgbWF0Y2hpbmdFZGdlcyA9IGNvbm5lY3RlZEVkZ2VzO1xuICAgIGZvciAoY29uc3QgZWRnZSBvZiBkZWxldGFibGVFZGdlcykge1xuICAgICAgICBjb25zdCBpc0luY2x1ZGVkID0gZWRnZUlkcy5oYXMoZWRnZS5pZCk7XG4gICAgICAgIGlmIChpc0luY2x1ZGVkICYmICFtYXRjaGluZ0VkZ2VzLmZpbmQoKGUpID0+IGUuaWQgPT09IGVkZ2UuaWQpKSB7XG4gICAgICAgICAgICBtYXRjaGluZ0VkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFvbkJlZm9yZURlbGV0ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZWRnZXM6IG1hdGNoaW5nRWRnZXMsXG4gICAgICAgICAgICBub2RlczogbWF0Y2hpbmdOb2RlcyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgb25CZWZvcmVEZWxldGVSZXN1bHQgPSBhd2FpdCBvbkJlZm9yZURlbGV0ZSh7XG4gICAgICAgIG5vZGVzOiBtYXRjaGluZ05vZGVzLFxuICAgICAgICBlZGdlczogbWF0Y2hpbmdFZGdlcyxcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIG9uQmVmb3JlRGVsZXRlUmVzdWx0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIG9uQmVmb3JlRGVsZXRlUmVzdWx0ID8geyBlZGdlczogbWF0Y2hpbmdFZGdlcywgbm9kZXM6IG1hdGNoaW5nTm9kZXMgfSA6IHsgZWRnZXM6IFtdLCBub2RlczogW10gfTtcbiAgICB9XG4gICAgcmV0dXJuIG9uQmVmb3JlRGVsZXRlUmVzdWx0O1xufVxuXG5jb25zdCBjbGFtcCA9ICh2YWwsIG1pbiA9IDAsIG1heCA9IDEpID0+IE1hdGgubWluKE1hdGgubWF4KHZhbCwgbWluKSwgbWF4KTtcbmNvbnN0IGNsYW1wUG9zaXRpb24gPSAocG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfSwgZXh0ZW50LCBkaW1lbnNpb25zKSA9PiAoe1xuICAgIHg6IGNsYW1wKHBvc2l0aW9uLngsIGV4dGVudFswXVswXSwgZXh0ZW50WzFdWzBdIC0gKGRpbWVuc2lvbnM/LndpZHRoID8/IDApKSxcbiAgICB5OiBjbGFtcChwb3NpdGlvbi55LCBleHRlbnRbMF1bMV0sIGV4dGVudFsxXVsxXSAtIChkaW1lbnNpb25zPy5oZWlnaHQgPz8gMCkpLFxufSk7XG5mdW5jdGlvbiBjbGFtcFBvc2l0aW9uVG9QYXJlbnQoY2hpbGRQb3NpdGlvbiwgY2hpbGREaW1lbnNpb25zLCBwYXJlbnQpIHtcbiAgICBjb25zdCB7IHdpZHRoOiBwYXJlbnRXaWR0aCwgaGVpZ2h0OiBwYXJlbnRIZWlnaHQgfSA9IGdldE5vZGVEaW1lbnNpb25zKHBhcmVudCk7XG4gICAgY29uc3QgeyB4OiBwYXJlbnRYLCB5OiBwYXJlbnRZIH0gPSBwYXJlbnQuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGU7XG4gICAgcmV0dXJuIGNsYW1wUG9zaXRpb24oY2hpbGRQb3NpdGlvbiwgW1xuICAgICAgICBbcGFyZW50WCwgcGFyZW50WV0sXG4gICAgICAgIFtwYXJlbnRYICsgcGFyZW50V2lkdGgsIHBhcmVudFkgKyBwYXJlbnRIZWlnaHRdLFxuICAgIF0sIGNoaWxkRGltZW5zaW9ucyk7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHZlbG9jaXR5IG9mIHBhbm5pbmcgd2hlbiB0aGUgbW91c2UgaXMgY2xvc2UgdG8gdGhlIGVkZ2Ugb2YgdGhlIGNhbnZhc1xuICogQGludGVybmFsXG4gKiBAcGFyYW0gdmFsdWUgLSBPbmUgZGltZW5zaW9uYWwgcG9pdGlvbiBvZiB0aGUgbW91c2UgKHggb3IgeSlcbiAqIEBwYXJhbSBtaW4gLSBNaW5pbWFsIHBvc2l0aW9uIG9uIGNhbnZhcyBiZWZvcmUgcGFubmluZyBzdGFydHNcbiAqIEBwYXJhbSBtYXggLSBNYXhpbWFsIHBvc2l0aW9uIG9uIGNhbnZhcyBiZWZvcmUgcGFubmluZyBzdGFydHNcbiAqIEByZXR1cm5zIC0gQSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxIHRoYXQgcmVwcmVzZW50cyB0aGUgdmVsb2NpdHkgb2YgcGFubmluZ1xuICovXG5jb25zdCBjYWxjQXV0b1BhblZlbG9jaXR5ID0gKHZhbHVlLCBtaW4sIG1heCkgPT4ge1xuICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgICByZXR1cm4gY2xhbXAoTWF0aC5hYnModmFsdWUgLSBtaW4pLCAxLCBtaW4pIC8gbWluO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSA+IG1heCkge1xuICAgICAgICByZXR1cm4gLWNsYW1wKE1hdGguYWJzKHZhbHVlIC0gbWF4KSwgMSwgbWluKSAvIG1pbjtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59O1xuY29uc3QgY2FsY0F1dG9QYW4gPSAocG9zLCBib3VuZHMsIHNwZWVkID0gMTUsIGRpc3RhbmNlID0gNDApID0+IHtcbiAgICBjb25zdCB4TW92ZW1lbnQgPSBjYWxjQXV0b1BhblZlbG9jaXR5KHBvcy54LCBkaXN0YW5jZSwgYm91bmRzLndpZHRoIC0gZGlzdGFuY2UpICogc3BlZWQ7XG4gICAgY29uc3QgeU1vdmVtZW50ID0gY2FsY0F1dG9QYW5WZWxvY2l0eShwb3MueSwgZGlzdGFuY2UsIGJvdW5kcy5oZWlnaHQgLSBkaXN0YW5jZSkgKiBzcGVlZDtcbiAgICByZXR1cm4gW3hNb3ZlbWVudCwgeU1vdmVtZW50XTtcbn07XG5jb25zdCBnZXRCb3VuZHNPZkJveGVzID0gKGJveDEsIGJveDIpID0+ICh7XG4gICAgeDogTWF0aC5taW4oYm94MS54LCBib3gyLngpLFxuICAgIHk6IE1hdGgubWluKGJveDEueSwgYm94Mi55KSxcbiAgICB4MjogTWF0aC5tYXgoYm94MS54MiwgYm94Mi54MiksXG4gICAgeTI6IE1hdGgubWF4KGJveDEueTIsIGJveDIueTIpLFxufSk7XG5jb25zdCByZWN0VG9Cb3ggPSAoeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0pID0+ICh7XG4gICAgeCxcbiAgICB5LFxuICAgIHgyOiB4ICsgd2lkdGgsXG4gICAgeTI6IHkgKyBoZWlnaHQsXG59KTtcbmNvbnN0IGJveFRvUmVjdCA9ICh7IHgsIHksIHgyLCB5MiB9KSA9PiAoe1xuICAgIHgsXG4gICAgeSxcbiAgICB3aWR0aDogeDIgLSB4LFxuICAgIGhlaWdodDogeTIgLSB5LFxufSk7XG5jb25zdCBub2RlVG9SZWN0ID0gKG5vZGUsIG5vZGVPcmlnaW4gPSBbMCwgMF0pID0+IHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGlzSW50ZXJuYWxOb2RlQmFzZShub2RlKVxuICAgICAgICA/IG5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGVcbiAgICAgICAgOiBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luKG5vZGUsIG5vZGVPcmlnaW4pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHdpZHRoOiBub2RlLm1lYXN1cmVkPy53aWR0aCA/PyBub2RlLndpZHRoID8/IG5vZGUuaW5pdGlhbFdpZHRoID8/IDAsXG4gICAgICAgIGhlaWdodDogbm9kZS5tZWFzdXJlZD8uaGVpZ2h0ID8/IG5vZGUuaGVpZ2h0ID8/IG5vZGUuaW5pdGlhbEhlaWdodCA/PyAwLFxuICAgIH07XG59O1xuY29uc3Qgbm9kZVRvQm94ID0gKG5vZGUsIG5vZGVPcmlnaW4gPSBbMCwgMF0pID0+IHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGlzSW50ZXJuYWxOb2RlQmFzZShub2RlKVxuICAgICAgICA/IG5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGVcbiAgICAgICAgOiBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luKG5vZGUsIG5vZGVPcmlnaW4pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHgyOiB4ICsgKG5vZGUubWVhc3VyZWQ/LndpZHRoID8/IG5vZGUud2lkdGggPz8gbm9kZS5pbml0aWFsV2lkdGggPz8gMCksXG4gICAgICAgIHkyOiB5ICsgKG5vZGUubWVhc3VyZWQ/LmhlaWdodCA/PyBub2RlLmhlaWdodCA/PyBub2RlLmluaXRpYWxIZWlnaHQgPz8gMCksXG4gICAgfTtcbn07XG5jb25zdCBnZXRCb3VuZHNPZlJlY3RzID0gKHJlY3QxLCByZWN0MikgPT4gYm94VG9SZWN0KGdldEJvdW5kc09mQm94ZXMocmVjdFRvQm94KHJlY3QxKSwgcmVjdFRvQm94KHJlY3QyKSkpO1xuY29uc3QgZ2V0T3ZlcmxhcHBpbmdBcmVhID0gKHJlY3RBLCByZWN0QikgPT4ge1xuICAgIGNvbnN0IHhPdmVybGFwID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocmVjdEEueCArIHJlY3RBLndpZHRoLCByZWN0Qi54ICsgcmVjdEIud2lkdGgpIC0gTWF0aC5tYXgocmVjdEEueCwgcmVjdEIueCkpO1xuICAgIGNvbnN0IHlPdmVybGFwID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocmVjdEEueSArIHJlY3RBLmhlaWdodCwgcmVjdEIueSArIHJlY3RCLmhlaWdodCkgLSBNYXRoLm1heChyZWN0QS55LCByZWN0Qi55KSk7XG4gICAgcmV0dXJuIE1hdGguY2VpbCh4T3ZlcmxhcCAqIHlPdmVybGFwKTtcbn07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3QgaXNSZWN0T2JqZWN0ID0gKG9iaikgPT4gaXNOdW1lcmljKG9iai53aWR0aCkgJiYgaXNOdW1lcmljKG9iai5oZWlnaHQpICYmIGlzTnVtZXJpYyhvYmoueCkgJiYgaXNOdW1lcmljKG9iai55KTtcbi8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5jb25zdCBpc051bWVyaWMgPSAobikgPT4gIWlzTmFOKG4pICYmIGlzRmluaXRlKG4pO1xuLy8gdXNlZCBmb3IgYTExeSBrZXkgYm9hcmQgY29udHJvbHMgZm9yIG5vZGVzIGFuZCBlZGdlc1xuY29uc3QgZGV2V2FybiA9IChpZCwgbWVzc2FnZSkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICBjb25zb2xlLndhcm4oYFtSZWFjdCBGbG93XTogJHttZXNzYWdlfSBIZWxwOiBodHRwczovL3JlYWN0Zmxvdy5kZXYvZXJyb3IjJHtpZH1gKTtcbiAgICB9XG59O1xuY29uc3Qgc25hcFBvc2l0aW9uID0gKHBvc2l0aW9uLCBzbmFwR3JpZCA9IFsxLCAxXSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHNuYXBHcmlkWzBdICogTWF0aC5yb3VuZChwb3NpdGlvbi54IC8gc25hcEdyaWRbMF0pLFxuICAgICAgICB5OiBzbmFwR3JpZFsxXSAqIE1hdGgucm91bmQocG9zaXRpb24ueSAvIHNuYXBHcmlkWzFdKSxcbiAgICB9O1xufTtcbmNvbnN0IHBvaW50VG9SZW5kZXJlclBvaW50ID0gKHsgeCwgeSB9LCBbdHgsIHR5LCB0U2NhbGVdLCBzbmFwVG9HcmlkID0gZmFsc2UsIHNuYXBHcmlkID0gWzEsIDFdKSA9PiB7XG4gICAgY29uc3QgcG9zaXRpb24gPSB7XG4gICAgICAgIHg6ICh4IC0gdHgpIC8gdFNjYWxlLFxuICAgICAgICB5OiAoeSAtIHR5KSAvIHRTY2FsZSxcbiAgICB9O1xuICAgIHJldHVybiBzbmFwVG9HcmlkID8gc25hcFBvc2l0aW9uKHBvc2l0aW9uLCBzbmFwR3JpZCkgOiBwb3NpdGlvbjtcbn07XG5jb25zdCByZW5kZXJlclBvaW50VG9Qb2ludCA9ICh7IHgsIHkgfSwgW3R4LCB0eSwgdFNjYWxlXSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggKiB0U2NhbGUgKyB0eCxcbiAgICAgICAgeTogeSAqIHRTY2FsZSArIHR5LFxuICAgIH07XG59O1xuLyoqXG4gKiBQYXJzZXMgYSBzaW5nbGUgcGFkZGluZyB2YWx1ZSB0byBhIG51bWJlclxuICogQGludGVybmFsXG4gKiBAcGFyYW0gcGFkZGluZyAtIFBhZGRpbmcgdG8gcGFyc2VcbiAqIEBwYXJhbSB2aWV3cG9ydCAtIFdpZHRoIG9yIGhlaWdodCBvZiB0aGUgdmlld3BvcnRcbiAqIEByZXR1cm5zIFRoZSBwYWRkaW5nIGluIHBpeGVsc1xuICovXG5mdW5jdGlvbiBwYXJzZVBhZGRpbmcocGFkZGluZywgdmlld3BvcnQpIHtcbiAgICBpZiAodHlwZW9mIHBhZGRpbmcgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKCh2aWV3cG9ydCAtIHZpZXdwb3J0IC8gKDEgKyBwYWRkaW5nKSkgKiAwLjUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBhZGRpbmcgPT09ICdzdHJpbmcnICYmIHBhZGRpbmcuZW5kc1dpdGgoJ3B4JykpIHtcbiAgICAgICAgY29uc3QgcGFkZGluZ1ZhbHVlID0gcGFyc2VGbG9hdChwYWRkaW5nKTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4ocGFkZGluZ1ZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IocGFkZGluZ1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHBhZGRpbmcgPT09ICdzdHJpbmcnICYmIHBhZGRpbmcuZW5kc1dpdGgoJyUnKSkge1xuICAgICAgICBjb25zdCBwYWRkaW5nVmFsdWUgPSBwYXJzZUZsb2F0KHBhZGRpbmcpO1xuICAgICAgICBpZiAoIU51bWJlci5pc05hTihwYWRkaW5nVmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih2aWV3cG9ydCAqIHBhZGRpbmdWYWx1ZSAqIDAuMDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnNvbGUuZXJyb3IoYFtSZWFjdCBGbG93XSBUaGUgcGFkZGluZyB2YWx1ZSBcIiR7cGFkZGluZ31cIiBpcyBpbnZhbGlkLiBQbGVhc2UgcHJvdmlkZSBhIG51bWJlciBvciBhIHN0cmluZyB3aXRoIGEgdmFsaWQgdW5pdCAocHggb3IgJSkuYCk7XG4gICAgcmV0dXJuIDA7XG59XG4vKipcbiAqIFBhcnNlcyB0aGUgcGFkZGluZ3MgdG8gYW4gb2JqZWN0IHdpdGggdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCB4IGFuZCB5IHBhZGRpbmdzXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBwYWRkaW5nIC0gUGFkZGluZyB0byBwYXJzZVxuICogQHBhcmFtIHdpZHRoIC0gV2lkdGggb2YgdGhlIHZpZXdwb3J0XG4gKiBAcGFyYW0gaGVpZ2h0IC0gSGVpZ2h0IG9mIHRoZSB2aWV3cG9ydFxuICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggdGhlIHBhZGRpbmdzIGluIHBpeGVsc1xuICovXG5mdW5jdGlvbiBwYXJzZVBhZGRpbmdzKHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAodHlwZW9mIHBhZGRpbmcgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwYWRkaW5nID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25zdCBwYWRkaW5nWSA9IHBhcnNlUGFkZGluZyhwYWRkaW5nLCBoZWlnaHQpO1xuICAgICAgICBjb25zdCBwYWRkaW5nWCA9IHBhcnNlUGFkZGluZyhwYWRkaW5nLCB3aWR0aCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3A6IHBhZGRpbmdZLFxuICAgICAgICAgICAgcmlnaHQ6IHBhZGRpbmdYLFxuICAgICAgICAgICAgYm90dG9tOiBwYWRkaW5nWSxcbiAgICAgICAgICAgIGxlZnQ6IHBhZGRpbmdYLFxuICAgICAgICAgICAgeDogcGFkZGluZ1ggKiAyLFxuICAgICAgICAgICAgeTogcGFkZGluZ1kgKiAyLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBhZGRpbmcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHBhcnNlUGFkZGluZyhwYWRkaW5nLnRvcCA/PyBwYWRkaW5nLnkgPz8gMCwgaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgYm90dG9tID0gcGFyc2VQYWRkaW5nKHBhZGRpbmcuYm90dG9tID8/IHBhZGRpbmcueSA/PyAwLCBoZWlnaHQpO1xuICAgICAgICBjb25zdCBsZWZ0ID0gcGFyc2VQYWRkaW5nKHBhZGRpbmcubGVmdCA/PyBwYWRkaW5nLnggPz8gMCwgd2lkdGgpO1xuICAgICAgICBjb25zdCByaWdodCA9IHBhcnNlUGFkZGluZyhwYWRkaW5nLnJpZ2h0ID8/IHBhZGRpbmcueCA/PyAwLCB3aWR0aCk7XG4gICAgICAgIHJldHVybiB7IHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgeDogbGVmdCArIHJpZ2h0LCB5OiB0b3AgKyBib3R0b20gfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwLCB4OiAwLCB5OiAwIH07XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHJlc3VsdGluZyBwYWRkaW5ncyBpZiB0aGUgbmV3IHZpZXdwb3J0IGlzIGFwcGxpZWRcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIGJvdW5kcyAtIEJvdW5kcyB0byBmaXQgaW5zaWRlIHZpZXdwb3J0XG4gKiBAcGFyYW0geCAtIFggcG9zaXRpb24gb2YgdGhlIHZpZXdwb3J0XG4gKiBAcGFyYW0geSAtIFkgcG9zaXRpb24gb2YgdGhlIHZpZXdwb3J0XG4gKiBAcGFyYW0gem9vbSAtIFpvb20gbGV2ZWwgb2YgdGhlIHZpZXdwb3J0XG4gKiBAcGFyYW0gd2lkdGggLSBXaWR0aCBvZiB0aGUgdmlld3BvcnRcbiAqIEBwYXJhbSBoZWlnaHQgLSBIZWlnaHQgb2YgdGhlIHZpZXdwb3J0XG4gKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCB0aGUgbWluaW11bSBwYWRkaW5nIHJlcXVpcmVkIHRvIGZpdCB0aGUgYm91bmRzIGluc2lkZSB0aGUgdmlld3BvcnRcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlQXBwbGllZFBhZGRpbmdzKGJvdW5kcywgeCwgeSwgem9vbSwgd2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHsgeDogbGVmdCwgeTogdG9wIH0gPSByZW5kZXJlclBvaW50VG9Qb2ludChib3VuZHMsIFt4LCB5LCB6b29tXSk7XG4gICAgY29uc3QgeyB4OiBib3VuZFJpZ2h0LCB5OiBib3VuZEJvdHRvbSB9ID0gcmVuZGVyZXJQb2ludFRvUG9pbnQoeyB4OiBib3VuZHMueCArIGJvdW5kcy53aWR0aCwgeTogYm91bmRzLnkgKyBib3VuZHMuaGVpZ2h0IH0sIFt4LCB5LCB6b29tXSk7XG4gICAgY29uc3QgcmlnaHQgPSB3aWR0aCAtIGJvdW5kUmlnaHQ7XG4gICAgY29uc3QgYm90dG9tID0gaGVpZ2h0IC0gYm91bmRCb3R0b207XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogTWF0aC5mbG9vcihsZWZ0KSxcbiAgICAgICAgdG9wOiBNYXRoLmZsb29yKHRvcCksXG4gICAgICAgIHJpZ2h0OiBNYXRoLmZsb29yKHJpZ2h0KSxcbiAgICAgICAgYm90dG9tOiBNYXRoLmZsb29yKGJvdHRvbSksXG4gICAgfTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHZpZXdwb3J0IHRoYXQgZW5jbG9zZXMgdGhlIGdpdmVuIGJvdW5kcyB3aXRoIHBhZGRpbmcuXG4gKiBAcHVibGljXG4gKiBAcmVtYXJrcyBZb3UgY2FuIGRldGVybWluZSBib3VuZHMgb2Ygbm9kZXMgd2l0aCB7QGxpbmsgZ2V0Tm9kZXNCb3VuZHN9IGFuZCB7QGxpbmsgZ2V0Qm91bmRzT2ZSZWN0c31cbiAqIEBwYXJhbSBib3VuZHMgLSBCb3VuZHMgdG8gZml0IGluc2lkZSB2aWV3cG9ydC5cbiAqIEBwYXJhbSB3aWR0aCAtIFdpZHRoIG9mIHRoZSB2aWV3cG9ydC5cbiAqIEBwYXJhbSBoZWlnaHQgIC0gSGVpZ2h0IG9mIHRoZSB2aWV3cG9ydC5cbiAqIEBwYXJhbSBtaW5ab29tIC0gTWluaW11bSB6b29tIGxldmVsIG9mIHRoZSByZXN1bHRpbmcgdmlld3BvcnQuXG4gKiBAcGFyYW0gbWF4Wm9vbSAtIE1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgcmVzdWx0aW5nIHZpZXdwb3J0LlxuICogQHBhcmFtIHBhZGRpbmcgLSBQYWRkaW5nIGFyb3VuZCB0aGUgYm91bmRzLlxuICogQHJldHVybnMgQSB0cmFuc2Zvcm1lZCB7QGxpbmsgVmlld3BvcnR9IHRoYXQgZW5jbG9zZXMgdGhlIGdpdmVuIGJvdW5kcyB3aGljaCB5b3UgY2FuIHBhc3MgdG8gZS5nLiB7QGxpbmsgc2V0Vmlld3BvcnR9LlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHsgeCwgeSwgem9vbSB9ID0gZ2V0Vmlld3BvcnRGb3JCb3VuZHMoXG4gKiB7IHg6IDAsIHk6IDAsIHdpZHRoOiAxMDAsIGhlaWdodDogMTAwfSxcbiAqIDEyMDAsIDgwMCwgMC41LCAyKTtcbiAqL1xuY29uc3QgZ2V0Vmlld3BvcnRGb3JCb3VuZHMgPSAoYm91bmRzLCB3aWR0aCwgaGVpZ2h0LCBtaW5ab29tLCBtYXhab29tLCBwYWRkaW5nKSA9PiB7XG4gICAgLy8gRmlyc3Qgd2UgcmVzb2x2ZSBhbGwgdGhlIHBhZGRpbmdzIHRvIGFjdHVhbCBwaXhlbCB2YWx1ZXNcbiAgICBjb25zdCBwID0gcGFyc2VQYWRkaW5ncyhwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCB4Wm9vbSA9ICh3aWR0aCAtIHAueCkgLyBib3VuZHMud2lkdGg7XG4gICAgY29uc3QgeVpvb20gPSAoaGVpZ2h0IC0gcC55KSAvIGJvdW5kcy5oZWlnaHQ7XG4gICAgLy8gV2UgY2FsY3VsYXRlIHRoZSBuZXcgeCwgeSwgem9vbSBmb3IgYSBjZW50ZXJlZCB2aWV3XG4gICAgY29uc3Qgem9vbSA9IE1hdGgubWluKHhab29tLCB5Wm9vbSk7XG4gICAgY29uc3QgY2xhbXBlZFpvb20gPSBjbGFtcCh6b29tLCBtaW5ab29tLCBtYXhab29tKTtcbiAgICBjb25zdCBib3VuZHNDZW50ZXJYID0gYm91bmRzLnggKyBib3VuZHMud2lkdGggLyAyO1xuICAgIGNvbnN0IGJvdW5kc0NlbnRlclkgPSBib3VuZHMueSArIGJvdW5kcy5oZWlnaHQgLyAyO1xuICAgIGNvbnN0IHggPSB3aWR0aCAvIDIgLSBib3VuZHNDZW50ZXJYICogY2xhbXBlZFpvb207XG4gICAgY29uc3QgeSA9IGhlaWdodCAvIDIgLSBib3VuZHNDZW50ZXJZICogY2xhbXBlZFpvb207XG4gICAgLy8gVGhlbiB3ZSBjYWxjdWxhdGUgdGhlIG1pbmltdW0gcGFkZGluZywgdG8gcmVzcGVjdCBhc3ltbWV0cmljIHBhZGRpbmdzXG4gICAgY29uc3QgbmV3UGFkZGluZyA9IGNhbGN1bGF0ZUFwcGxpZWRQYWRkaW5ncyhib3VuZHMsIHgsIHksIGNsYW1wZWRab29tLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAvLyBXZSBvbmx5IHdhbnQgdG8gaGF2ZSBhbiBvZmZzZXQgaWYgdGhlIG5ld1BhZGRpbmcgaXMgc21hbGxlciB0aGFuIHRoZSByZXF1aXJlZCBwYWRkaW5nXG4gICAgY29uc3Qgb2Zmc2V0ID0ge1xuICAgICAgICBsZWZ0OiBNYXRoLm1pbihuZXdQYWRkaW5nLmxlZnQgLSBwLmxlZnQsIDApLFxuICAgICAgICB0b3A6IE1hdGgubWluKG5ld1BhZGRpbmcudG9wIC0gcC50b3AsIDApLFxuICAgICAgICByaWdodDogTWF0aC5taW4obmV3UGFkZGluZy5yaWdodCAtIHAucmlnaHQsIDApLFxuICAgICAgICBib3R0b206IE1hdGgubWluKG5ld1BhZGRpbmcuYm90dG9tIC0gcC5ib3R0b20sIDApLFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCAtIG9mZnNldC5sZWZ0ICsgb2Zmc2V0LnJpZ2h0LFxuICAgICAgICB5OiB5IC0gb2Zmc2V0LnRvcCArIG9mZnNldC5ib3R0b20sXG4gICAgICAgIHpvb206IGNsYW1wZWRab29tLFxuICAgIH07XG59O1xuY29uc3QgaXNNYWNPcyA9ICgpID0+IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvcj8udXNlckFnZW50Py5pbmRleE9mKCdNYWMnKSA+PSAwO1xuZnVuY3Rpb24gaXNDb29yZGluYXRlRXh0ZW50KGV4dGVudCkge1xuICAgIHJldHVybiBleHRlbnQgIT09IHVuZGVmaW5lZCAmJiBleHRlbnQgIT09IG51bGwgJiYgZXh0ZW50ICE9PSAncGFyZW50Jztcbn1cbmZ1bmN0aW9uIGdldE5vZGVEaW1lbnNpb25zKG5vZGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogbm9kZS5tZWFzdXJlZD8ud2lkdGggPz8gbm9kZS53aWR0aCA/PyBub2RlLmluaXRpYWxXaWR0aCA/PyAwLFxuICAgICAgICBoZWlnaHQ6IG5vZGUubWVhc3VyZWQ/LmhlaWdodCA/PyBub2RlLmhlaWdodCA/PyBub2RlLmluaXRpYWxIZWlnaHQgPz8gMCxcbiAgICB9O1xufVxuZnVuY3Rpb24gbm9kZUhhc0RpbWVuc2lvbnMobm9kZSkge1xuICAgIHJldHVybiAoKG5vZGUubWVhc3VyZWQ/LndpZHRoID8/IG5vZGUud2lkdGggPz8gbm9kZS5pbml0aWFsV2lkdGgpICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgKG5vZGUubWVhc3VyZWQ/LmhlaWdodCA/PyBub2RlLmhlaWdodCA/PyBub2RlLmluaXRpYWxIZWlnaHQpICE9PSB1bmRlZmluZWQpO1xufVxuLyoqXG4gKiBDb252ZXJ0IGNoaWxkIHBvc2l0aW9uIHRvIGFib3NsdXRlIHBvc2l0aW9uXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0gcG9zaXRpb25cbiAqIEBwYXJhbSBwYXJlbnRJZFxuICogQHBhcmFtIG5vZGVMb29rdXBcbiAqIEBwYXJhbSBub2RlT3JpZ2luXG4gKiBAcmV0dXJucyBhbiBpbnRlcm5hbCBub2RlIHdpdGggYW4gYWJzb2x1dGUgcG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gZXZhbHVhdGVBYnNvbHV0ZVBvc2l0aW9uKHBvc2l0aW9uLCBkaW1lbnNpb25zID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0sIHBhcmVudElkLCBub2RlTG9va3VwLCBub2RlT3JpZ2luKSB7XG4gICAgY29uc3QgcG9zaXRpb25BYnNvbHV0ZSA9IHsgLi4ucG9zaXRpb24gfTtcbiAgICBjb25zdCBwYXJlbnQgPSBub2RlTG9va3VwLmdldChwYXJlbnRJZCk7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgICBjb25zdCBvcmlnaW4gPSBwYXJlbnQub3JpZ2luIHx8IG5vZGVPcmlnaW47XG4gICAgICAgIHBvc2l0aW9uQWJzb2x1dGUueCArPSBwYXJlbnQuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueCAtIChkaW1lbnNpb25zLndpZHRoID8/IDApICogb3JpZ2luWzBdO1xuICAgICAgICBwb3NpdGlvbkFic29sdXRlLnkgKz0gcGFyZW50LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnkgLSAoZGltZW5zaW9ucy5oZWlnaHQgPz8gMCkgKiBvcmlnaW5bMV07XG4gICAgfVxuICAgIHJldHVybiBwb3NpdGlvbkFic29sdXRlO1xufVxuZnVuY3Rpb24gYXJlU2V0c0VxdWFsKGEsIGIpIHtcbiAgICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYSkge1xuICAgICAgICBpZiAoIWIuaGFzKGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFBvbHlmaWxsIGZvciBQcm9taXNlLndpdGhSZXNvbHZlcnMgdW50aWwgd2UgY2FuIHVzZSBpdCBpbiBhbGwgYnJvd3NlcnNcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB3aXRoUmVzb2x2ZXJzKCkge1xuICAgIGxldCByZXNvbHZlO1xuICAgIGxldCByZWplY3Q7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICByZXNvbHZlID0gcmVzO1xuICAgICAgICByZWplY3QgPSByZWo7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgcHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0IH07XG59XG5mdW5jdGlvbiBtZXJnZUFyaWFMYWJlbENvbmZpZyhwYXJ0aWFsKSB7XG4gICAgcmV0dXJuIHsgLi4uZGVmYXVsdEFyaWFMYWJlbENvbmZpZywgLi4uKHBhcnRpYWwgfHwge30pIH07XG59XG5cbmZ1bmN0aW9uIGdldFBvaW50ZXJQb3NpdGlvbihldmVudCwgeyBzbmFwR3JpZCA9IFswLCAwXSwgc25hcFRvR3JpZCA9IGZhbHNlLCB0cmFuc2Zvcm0sIGNvbnRhaW5lckJvdW5kcyB9KSB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50KTtcbiAgICBjb25zdCBwb2ludGVyUG9zID0gcG9pbnRUb1JlbmRlcmVyUG9pbnQoeyB4OiB4IC0gKGNvbnRhaW5lckJvdW5kcz8ubGVmdCA/PyAwKSwgeTogeSAtIChjb250YWluZXJCb3VuZHM/LnRvcCA/PyAwKSB9LCB0cmFuc2Zvcm0pO1xuICAgIGNvbnN0IHsgeDogeFNuYXBwZWQsIHk6IHlTbmFwcGVkIH0gPSBzbmFwVG9HcmlkID8gc25hcFBvc2l0aW9uKHBvaW50ZXJQb3MsIHNuYXBHcmlkKSA6IHBvaW50ZXJQb3M7XG4gICAgLy8gd2UgbmVlZCB0aGUgc25hcHBlZCBwb3NpdGlvbiBpbiBvcmRlciB0byBiZSBhYmxlIHRvIHNraXAgdW5uZWNlc3NhcnkgZHJhZyBldmVudHNcbiAgICByZXR1cm4ge1xuICAgICAgICB4U25hcHBlZCxcbiAgICAgICAgeVNuYXBwZWQsXG4gICAgICAgIC4uLnBvaW50ZXJQb3MsXG4gICAgfTtcbn1cbmNvbnN0IGdldERpbWVuc2lvbnMgPSAobm9kZSkgPT4gKHtcbiAgICB3aWR0aDogbm9kZS5vZmZzZXRXaWR0aCxcbiAgICBoZWlnaHQ6IG5vZGUub2Zmc2V0SGVpZ2h0LFxufSk7XG5jb25zdCBnZXRIb3N0Rm9yRWxlbWVudCA9IChlbGVtZW50KSA9PiBlbGVtZW50Py5nZXRSb290Tm9kZT8uKCkgfHwgd2luZG93Py5kb2N1bWVudDtcbmNvbnN0IGlucHV0VGFncyA9IFsnSU5QVVQnLCAnU0VMRUNUJywgJ1RFWFRBUkVBJ107XG5mdW5jdGlvbiBpc0lucHV0RE9NTm9kZShldmVudCkge1xuICAgIC8vIHVzaW5nIGNvbXBvc2VkIHBhdGggZm9yIGhhbmRsaW5nIHNoYWRvdyBkb21cbiAgICBjb25zdCB0YXJnZXQgPSAoZXZlbnQuY29tcG9zZWRQYXRoPy4oKT8uWzBdIHx8IGV2ZW50LnRhcmdldCk7XG4gICAgaWYgKHRhcmdldD8ubm9kZVR5cGUgIT09IDEgLyogTm9kZS5FTEVNRU5UX05PREUgKi8pXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBpc0lucHV0ID0gaW5wdXRUYWdzLmluY2x1ZGVzKHRhcmdldC5ub2RlTmFtZSkgfHwgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJyk7XG4gICAgLy8gd2hlbiBhbiBpbnB1dCBmaWVsZCBpcyBmb2N1c2VkIHdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciBkZWxldGlvbiBvciBtb3ZlbWVudCBvZiBub2Rlc1xuICAgIHJldHVybiBpc0lucHV0IHx8ICEhdGFyZ2V0LmNsb3Nlc3QoJy5ub2tleScpO1xufVxuY29uc3QgaXNNb3VzZUV2ZW50ID0gKGV2ZW50KSA9PiAnY2xpZW50WCcgaW4gZXZlbnQ7XG5jb25zdCBnZXRFdmVudFBvc2l0aW9uID0gKGV2ZW50LCBib3VuZHMpID0+IHtcbiAgICBjb25zdCBpc01vdXNlID0gaXNNb3VzZUV2ZW50KGV2ZW50KTtcbiAgICBjb25zdCBldnRYID0gaXNNb3VzZSA/IGV2ZW50LmNsaWVudFggOiBldmVudC50b3VjaGVzPy5bMF0uY2xpZW50WDtcbiAgICBjb25zdCBldnRZID0gaXNNb3VzZSA/IGV2ZW50LmNsaWVudFkgOiBldmVudC50b3VjaGVzPy5bMF0uY2xpZW50WTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBldnRYIC0gKGJvdW5kcz8ubGVmdCA/PyAwKSxcbiAgICAgICAgeTogZXZ0WSAtIChib3VuZHM/LnRvcCA/PyAwKSxcbiAgICB9O1xufTtcbi8qXG4gKiBUaGUgaGFuZGxlIGJvdW5kcyBhcmUgY2FsY3VsYXRlZCByZWxhdGl2ZSB0byB0aGUgbm9kZSBlbGVtZW50LlxuICogV2Ugc3RvcmUgdGhlbSBpbiB0aGUgaW50ZXJuYWxzIG9iamVjdCBvZiB0aGUgbm9kZSBpbiBvcmRlciB0byBhdm9pZFxuICogdW5uZWNlc3NhcnkgcmVjYWxjdWxhdGlvbnMuXG4gKi9cbmNvbnN0IGdldEhhbmRsZUJvdW5kcyA9ICh0eXBlLCBub2RlRWxlbWVudCwgbm9kZUJvdW5kcywgem9vbSwgbm9kZUlkKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlcyA9IG5vZGVFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke3R5cGV9YCk7XG4gICAgaWYgKCFoYW5kbGVzIHx8ICFoYW5kbGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20oaGFuZGxlcykubWFwKChoYW5kbGUpID0+IHtcbiAgICAgICAgY29uc3QgaGFuZGxlQm91bmRzID0gaGFuZGxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IGhhbmRsZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtaGFuZGxlaWQnKSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBub2RlSWQsXG4gICAgICAgICAgICBwb3NpdGlvbjogaGFuZGxlLmdldEF0dHJpYnV0ZSgnZGF0YS1oYW5kbGVwb3MnKSxcbiAgICAgICAgICAgIHg6IChoYW5kbGVCb3VuZHMubGVmdCAtIG5vZGVCb3VuZHMubGVmdCkgLyB6b29tLFxuICAgICAgICAgICAgeTogKGhhbmRsZUJvdW5kcy50b3AgLSBub2RlQm91bmRzLnRvcCkgLyB6b29tLFxuICAgICAgICAgICAgLi4uZ2V0RGltZW5zaW9ucyhoYW5kbGUpLFxuICAgICAgICB9O1xuICAgIH0pO1xufTtcblxuZnVuY3Rpb24gZ2V0QmV6aWVyRWRnZUNlbnRlcih7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZUNvbnRyb2xYLCBzb3VyY2VDb250cm9sWSwgdGFyZ2V0Q29udHJvbFgsIHRhcmdldENvbnRyb2xZLCB9KSB7XG4gICAgLypcbiAgICAgKiBjdWJpYyBiZXppZXIgdD0wLjUgbWlkIHBvaW50LCBub3QgdGhlIGFjdHVhbCBtaWQgcG9pbnQsIGJ1dCBlYXN5IHRvIGNhbGN1bGF0ZVxuICAgICAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzY3NTE2MTAxL2hvdy10by1maW5kLWRpc3RhbmNlLW1pZC1wb2ludC1vZi1iZXppZXItY3VydmVcbiAgICAgKi9cbiAgICBjb25zdCBjZW50ZXJYID0gc291cmNlWCAqIDAuMTI1ICsgc291cmNlQ29udHJvbFggKiAwLjM3NSArIHRhcmdldENvbnRyb2xYICogMC4zNzUgKyB0YXJnZXRYICogMC4xMjU7XG4gICAgY29uc3QgY2VudGVyWSA9IHNvdXJjZVkgKiAwLjEyNSArIHNvdXJjZUNvbnRyb2xZICogMC4zNzUgKyB0YXJnZXRDb250cm9sWSAqIDAuMzc1ICsgdGFyZ2V0WSAqIDAuMTI1O1xuICAgIGNvbnN0IG9mZnNldFggPSBNYXRoLmFicyhjZW50ZXJYIC0gc291cmNlWCk7XG4gICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGguYWJzKGNlbnRlclkgLSBzb3VyY2VZKTtcbiAgICByZXR1cm4gW2NlbnRlclgsIGNlbnRlclksIG9mZnNldFgsIG9mZnNldFldO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlQ29udHJvbE9mZnNldChkaXN0YW5jZSwgY3VydmF0dXJlKSB7XG4gICAgaWYgKGRpc3RhbmNlID49IDApIHtcbiAgICAgICAgcmV0dXJuIDAuNSAqIGRpc3RhbmNlO1xuICAgIH1cbiAgICByZXR1cm4gY3VydmF0dXJlICogMjUgKiBNYXRoLnNxcnQoLWRpc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIGdldENvbnRyb2xXaXRoQ3VydmF0dXJlKHsgcG9zLCB4MSwgeTEsIHgyLCB5MiwgYyB9KSB7XG4gICAgc3dpdGNoIChwb3MpIHtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5MZWZ0OlxuICAgICAgICAgICAgcmV0dXJuIFt4MSAtIGNhbGN1bGF0ZUNvbnRyb2xPZmZzZXQoeDEgLSB4MiwgYyksIHkxXTtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5SaWdodDpcbiAgICAgICAgICAgIHJldHVybiBbeDEgKyBjYWxjdWxhdGVDb250cm9sT2Zmc2V0KHgyIC0geDEsIGMpLCB5MV07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uVG9wOlxuICAgICAgICAgICAgcmV0dXJuIFt4MSwgeTEgLSBjYWxjdWxhdGVDb250cm9sT2Zmc2V0KHkxIC0geTIsIGMpXTtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5Cb3R0b206XG4gICAgICAgICAgICByZXR1cm4gW3gxLCB5MSArIGNhbGN1bGF0ZUNvbnRyb2xPZmZzZXQoeTIgLSB5MSwgYyldO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIGBnZXRCZXppZXJQYXRoYCB1dGlsIHJldHVybnMgZXZlcnl0aGluZyB5b3UgbmVlZCB0byByZW5kZXIgYSBiZXppZXIgZWRnZVxuICpiZXR3ZWVuIHR3byBub2Rlcy5cbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIEEgcGF0aCBzdHJpbmcgeW91IGNhbiB1c2UgaW4gYW4gU1ZHLCB0aGUgYGxhYmVsWGAgYW5kIGBsYWJlbFlgIHBvc2l0aW9uIChjZW50ZXIgb2YgcGF0aClcbiAqIGFuZCBgb2Zmc2V0WGAsIGBvZmZzZXRZYCBiZXR3ZWVuIHNvdXJjZSBoYW5kbGUgYW5kIGxhYmVsLlxuICogLSBgcGF0aGA6IHRoZSBwYXRoIHRvIHVzZSBpbiBhbiBTVkcgYDxwYXRoPmAgZWxlbWVudC5cbiAqIC0gYGxhYmVsWGA6IHRoZSBgeGAgcG9zaXRpb24geW91IGNhbiB1c2UgdG8gcmVuZGVyIGEgbGFiZWwgZm9yIHRoaXMgZWRnZS5cbiAqIC0gYGxhYmVsWWA6IHRoZSBgeWAgcG9zaXRpb24geW91IGNhbiB1c2UgdG8gcmVuZGVyIGEgbGFiZWwgZm9yIHRoaXMgZWRnZS5cbiAqIC0gYG9mZnNldFhgOiB0aGUgYWJzb2x1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzb3VyY2UgYHhgIHBvc2l0aW9uIGFuZCB0aGUgYHhgIHBvc2l0aW9uIG9mIHRoZVxuICogbWlkZGxlIG9mIHRoaXMgcGF0aC5cbiAqIC0gYG9mZnNldFlgOiB0aGUgYWJzb2x1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzb3VyY2UgYHlgIHBvc2l0aW9uIGFuZCB0aGUgYHlgIHBvc2l0aW9uIG9mIHRoZVxuICogbWlkZGxlIG9mIHRoaXMgcGF0aC5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogIGNvbnN0IHNvdXJjZSA9IHsgeDogMCwgeTogMjAgfTtcbiAqICBjb25zdCB0YXJnZXQgPSB7IHg6IDE1MCwgeTogMTAwIH07XG4gKlxuICogIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV0gPSBnZXRCZXppZXJQYXRoKHtcbiAqICAgIHNvdXJjZVg6IHNvdXJjZS54LFxuICogICAgc291cmNlWTogc291cmNlLnksXG4gKiAgICBzb3VyY2VQb3NpdGlvbjogUG9zaXRpb24uUmlnaHQsXG4gKiAgICB0YXJnZXRYOiB0YXJnZXQueCxcbiAqICAgIHRhcmdldFk6IHRhcmdldC55LFxuICogICAgdGFyZ2V0UG9zaXRpb246IFBvc2l0aW9uLkxlZnQsXG4gKn0pO1xuICpgYGBcbiAqXG4gKiBAcmVtYXJrcyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSB0dXBsZSAoYWthIGEgZml4ZWQtc2l6ZSBhcnJheSkgdG8gbWFrZSBpdCBlYXNpZXIgdG9cbiAqd29yayB3aXRoIG11bHRpcGxlIGVkZ2UgcGF0aHMgYXQgb25jZS5cbiAqL1xuZnVuY3Rpb24gZ2V0QmV6aWVyUGF0aCh7IHNvdXJjZVgsIHNvdXJjZVksIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXRYLCB0YXJnZXRZLCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgY3VydmF0dXJlID0gMC4yNSwgfSkge1xuICAgIGNvbnN0IFtzb3VyY2VDb250cm9sWCwgc291cmNlQ29udHJvbFldID0gZ2V0Q29udHJvbFdpdGhDdXJ2YXR1cmUoe1xuICAgICAgICBwb3M6IHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICB4MTogc291cmNlWCxcbiAgICAgICAgeTE6IHNvdXJjZVksXG4gICAgICAgIHgyOiB0YXJnZXRYLFxuICAgICAgICB5MjogdGFyZ2V0WSxcbiAgICAgICAgYzogY3VydmF0dXJlLFxuICAgIH0pO1xuICAgIGNvbnN0IFt0YXJnZXRDb250cm9sWCwgdGFyZ2V0Q29udHJvbFldID0gZ2V0Q29udHJvbFdpdGhDdXJ2YXR1cmUoe1xuICAgICAgICBwb3M6IHRhcmdldFBvc2l0aW9uLFxuICAgICAgICB4MTogdGFyZ2V0WCxcbiAgICAgICAgeTE6IHRhcmdldFksXG4gICAgICAgIHgyOiBzb3VyY2VYLFxuICAgICAgICB5Mjogc291cmNlWSxcbiAgICAgICAgYzogY3VydmF0dXJlLFxuICAgIH0pO1xuICAgIGNvbnN0IFtsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV0gPSBnZXRCZXppZXJFZGdlQ2VudGVyKHtcbiAgICAgICAgc291cmNlWCxcbiAgICAgICAgc291cmNlWSxcbiAgICAgICAgdGFyZ2V0WCxcbiAgICAgICAgdGFyZ2V0WSxcbiAgICAgICAgc291cmNlQ29udHJvbFgsXG4gICAgICAgIHNvdXJjZUNvbnRyb2xZLFxuICAgICAgICB0YXJnZXRDb250cm9sWCxcbiAgICAgICAgdGFyZ2V0Q29udHJvbFksXG4gICAgfSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgYE0ke3NvdXJjZVh9LCR7c291cmNlWX0gQyR7c291cmNlQ29udHJvbFh9LCR7c291cmNlQ29udHJvbFl9ICR7dGFyZ2V0Q29udHJvbFh9LCR7dGFyZ2V0Q29udHJvbFl9ICR7dGFyZ2V0WH0sJHt0YXJnZXRZfWAsXG4gICAgICAgIGxhYmVsWCxcbiAgICAgICAgbGFiZWxZLFxuICAgICAgICBvZmZzZXRYLFxuICAgICAgICBvZmZzZXRZLFxuICAgIF07XG59XG5cbi8vIHRoaXMgaXMgdXNlZCBmb3Igc3RyYWlnaHQgZWRnZXMgYW5kIHNpbXBsZSBzbW9vdGhzdGVwIGVkZ2VzIChMVFIsIFJUTCwgQlRULCBUVEIpXG5mdW5jdGlvbiBnZXRFZGdlQ2VudGVyKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgfSkge1xuICAgIGNvbnN0IHhPZmZzZXQgPSBNYXRoLmFicyh0YXJnZXRYIC0gc291cmNlWCkgLyAyO1xuICAgIGNvbnN0IGNlbnRlclggPSB0YXJnZXRYIDwgc291cmNlWCA/IHRhcmdldFggKyB4T2Zmc2V0IDogdGFyZ2V0WCAtIHhPZmZzZXQ7XG4gICAgY29uc3QgeU9mZnNldCA9IE1hdGguYWJzKHRhcmdldFkgLSBzb3VyY2VZKSAvIDI7XG4gICAgY29uc3QgY2VudGVyWSA9IHRhcmdldFkgPCBzb3VyY2VZID8gdGFyZ2V0WSArIHlPZmZzZXQgOiB0YXJnZXRZIC0geU9mZnNldDtcbiAgICByZXR1cm4gW2NlbnRlclgsIGNlbnRlclksIHhPZmZzZXQsIHlPZmZzZXRdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSB6LWluZGV4IGZvciBhbiBlZGdlIGJhc2VkIG9uIHRoZSBub2RlIGl0IGNvbm5lY3RzIGFuZCB3aGV0aGVyIGl0IGlzIHNlbGVjdGVkLlxuICogQnkgZGVmYXVsdCwgZWRnZXMgYXJlIHJlbmRlcmVkIGJlbG93IG5vZGVzLiBUaGlzIGJlaGF2aW91ciBpcyBkaWZmZXJlbnQgZm9yIGVkZ2VzIHRoYXQgYXJlXG4gKiBjb25uZWN0ZWQgdG8gbm9kZXMgd2l0aCBhIHBhcmVudCwgYXMgdGhleSBhcmUgcmVuZGVyZWQgYWJvdmUgdGhlIHBhcmVudCBub2RlLlxuICovXG5mdW5jdGlvbiBnZXRFbGV2YXRlZEVkZ2VaSW5kZXgoeyBzb3VyY2VOb2RlLCB0YXJnZXROb2RlLCBzZWxlY3RlZCA9IGZhbHNlLCB6SW5kZXgsIGVsZXZhdGVPblNlbGVjdCA9IGZhbHNlLCB9KSB7XG4gICAgaWYgKHpJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB6SW5kZXg7XG4gICAgfVxuICAgIGNvbnN0IGVkZ2VaID0gZWxldmF0ZU9uU2VsZWN0ICYmIHNlbGVjdGVkID8gMTAwMCA6IDA7XG4gICAgY29uc3Qgbm9kZVogPSBNYXRoLm1heChzb3VyY2VOb2RlLnBhcmVudElkIHx8IChlbGV2YXRlT25TZWxlY3QgJiYgc291cmNlTm9kZS5zZWxlY3RlZCkgPyBzb3VyY2VOb2RlLmludGVybmFscy56IDogMCwgdGFyZ2V0Tm9kZS5wYXJlbnRJZCB8fCAoZWxldmF0ZU9uU2VsZWN0ICYmIHRhcmdldE5vZGUuc2VsZWN0ZWQpID8gdGFyZ2V0Tm9kZS5pbnRlcm5hbHMueiA6IDApO1xuICAgIHJldHVybiBlZGdlWiArIG5vZGVaO1xufVxuZnVuY3Rpb24gaXNFZGdlVmlzaWJsZSh7IHNvdXJjZU5vZGUsIHRhcmdldE5vZGUsIHdpZHRoLCBoZWlnaHQsIHRyYW5zZm9ybSB9KSB7XG4gICAgY29uc3QgZWRnZUJveCA9IGdldEJvdW5kc09mQm94ZXMobm9kZVRvQm94KHNvdXJjZU5vZGUpLCBub2RlVG9Cb3godGFyZ2V0Tm9kZSkpO1xuICAgIGlmIChlZGdlQm94LnggPT09IGVkZ2VCb3gueDIpIHtcbiAgICAgICAgZWRnZUJveC54MiArPSAxO1xuICAgIH1cbiAgICBpZiAoZWRnZUJveC55ID09PSBlZGdlQm94LnkyKSB7XG4gICAgICAgIGVkZ2VCb3gueTIgKz0gMTtcbiAgICB9XG4gICAgY29uc3Qgdmlld1JlY3QgPSB7XG4gICAgICAgIHg6IC10cmFuc2Zvcm1bMF0gLyB0cmFuc2Zvcm1bMl0sXG4gICAgICAgIHk6IC10cmFuc2Zvcm1bMV0gLyB0cmFuc2Zvcm1bMl0sXG4gICAgICAgIHdpZHRoOiB3aWR0aCAvIHRyYW5zZm9ybVsyXSxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQgLyB0cmFuc2Zvcm1bMl0sXG4gICAgfTtcbiAgICByZXR1cm4gZ2V0T3ZlcmxhcHBpbmdBcmVhKHZpZXdSZWN0LCBib3hUb1JlY3QoZWRnZUJveCkpID4gMDtcbn1cbmNvbnN0IGdldEVkZ2VJZCA9ICh7IHNvdXJjZSwgc291cmNlSGFuZGxlLCB0YXJnZXQsIHRhcmdldEhhbmRsZSB9KSA9PiBgeHktZWRnZV9fJHtzb3VyY2V9JHtzb3VyY2VIYW5kbGUgfHwgJyd9LSR7dGFyZ2V0fSR7dGFyZ2V0SGFuZGxlIHx8ICcnfWA7XG5jb25zdCBjb25uZWN0aW9uRXhpc3RzID0gKGVkZ2UsIGVkZ2VzKSA9PiB7XG4gICAgcmV0dXJuIGVkZ2VzLnNvbWUoKGVsKSA9PiBlbC5zb3VyY2UgPT09IGVkZ2Uuc291cmNlICYmXG4gICAgICAgIGVsLnRhcmdldCA9PT0gZWRnZS50YXJnZXQgJiZcbiAgICAgICAgKGVsLnNvdXJjZUhhbmRsZSA9PT0gZWRnZS5zb3VyY2VIYW5kbGUgfHwgKCFlbC5zb3VyY2VIYW5kbGUgJiYgIWVkZ2Uuc291cmNlSGFuZGxlKSkgJiZcbiAgICAgICAgKGVsLnRhcmdldEhhbmRsZSA9PT0gZWRnZS50YXJnZXRIYW5kbGUgfHwgKCFlbC50YXJnZXRIYW5kbGUgJiYgIWVkZ2UudGFyZ2V0SGFuZGxlKSkpO1xufTtcbi8qKlxuICogVGhpcyB1dGlsIGlzIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gdG8gYWRkIGEgbmV3IEVkZ2UgdG8gYW4gYXJyYXkgb2YgZWRnZXMuIEl0IGFsc28gcGVyZm9ybXMgc29tZSB2YWxpZGF0aW9uIHRvIG1ha2Ugc3VyZSB5b3UgZG9uJ3QgYWRkIGFuIGludmFsaWQgZWRnZSBvciBkdXBsaWNhdGUgYW4gZXhpc3Rpbmcgb25lLlxuICogQHB1YmxpY1xuICogQHBhcmFtIGVkZ2VQYXJhbXMgLSBFaXRoZXIgYW4gYEVkZ2VgIG9yIGEgYENvbm5lY3Rpb25gIHlvdSB3YW50IHRvIGFkZC5cbiAqIEBwYXJhbSBlZGdlcyAtIFRoZSBhcnJheSBvZiBhbGwgY3VycmVudCBlZGdlcy5cbiAqIEByZXR1cm5zIEEgbmV3IGFycmF5IG9mIGVkZ2VzIHdpdGggdGhlIG5ldyBlZGdlIGFkZGVkLlxuICpcbiAqIEByZW1hcmtzIElmIGFuIGVkZ2Ugd2l0aCB0aGUgc2FtZSBgdGFyZ2V0YCBhbmQgYHNvdXJjZWAgYWxyZWFkeSBleGlzdHMgKGFuZCB0aGUgc2FtZVxuICpgdGFyZ2V0SGFuZGxlYCBhbmQgYHNvdXJjZUhhbmRsZWAgaWYgdGhvc2UgYXJlIHNldCksIHRoZW4gdGhpcyB1dGlsIHdvbid0IGFkZFxuICphIG5ldyBlZGdlIGV2ZW4gaWYgdGhlIGBpZGAgcHJvcGVydHkgaXMgZGlmZmVyZW50LlxuICpcbiAqL1xuY29uc3QgYWRkRWRnZSA9IChlZGdlUGFyYW1zLCBlZGdlcykgPT4ge1xuICAgIGlmICghZWRnZVBhcmFtcy5zb3VyY2UgfHwgIWVkZ2VQYXJhbXMudGFyZ2V0KSB7XG4gICAgICAgIGRldldhcm4oJzAwNicsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA2J10oKSk7XG4gICAgICAgIHJldHVybiBlZGdlcztcbiAgICB9XG4gICAgbGV0IGVkZ2U7XG4gICAgaWYgKGlzRWRnZUJhc2UoZWRnZVBhcmFtcykpIHtcbiAgICAgICAgZWRnZSA9IHsgLi4uZWRnZVBhcmFtcyB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZWRnZSA9IHtcbiAgICAgICAgICAgIC4uLmVkZ2VQYXJhbXMsXG4gICAgICAgICAgICBpZDogZ2V0RWRnZUlkKGVkZ2VQYXJhbXMpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoY29ubmVjdGlvbkV4aXN0cyhlZGdlLCBlZGdlcykpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2VzO1xuICAgIH1cbiAgICBpZiAoZWRnZS5zb3VyY2VIYW5kbGUgPT09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIGVkZ2Uuc291cmNlSGFuZGxlO1xuICAgIH1cbiAgICBpZiAoZWRnZS50YXJnZXRIYW5kbGUgPT09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIGVkZ2UudGFyZ2V0SGFuZGxlO1xuICAgIH1cbiAgICByZXR1cm4gZWRnZXMuY29uY2F0KGVkZ2UpO1xufTtcbi8qKlxuICogQSBoYW5keSB1dGlsaXR5IHRvIHVwZGF0ZSBhbiBleGlzdGluZyBbYEVkZ2VgXSgvYXBpLXJlZmVyZW5jZS90eXBlcy9lZGdlKSB3aXRoIG5ldyBwcm9wZXJ0aWVzLlxuICpUaGlzIHNlYXJjaGVzIHlvdXIgZWRnZSBhcnJheSBmb3IgYW4gZWRnZSB3aXRoIGEgbWF0Y2hpbmcgYGlkYCBhbmQgdXBkYXRlcyBpdHNcbiAqcHJvcGVydGllcyB3aXRoIHRoZSBjb25uZWN0aW9uIHlvdSBwcm92aWRlLlxuICogQHB1YmxpY1xuICogQHBhcmFtIG9sZEVkZ2UgLSBUaGUgZWRnZSB5b3Ugd2FudCB0byB1cGRhdGUuXG4gKiBAcGFyYW0gbmV3Q29ubmVjdGlvbiAtIFRoZSBuZXcgY29ubmVjdGlvbiB5b3Ugd2FudCB0byB1cGRhdGUgdGhlIGVkZ2Ugd2l0aC5cbiAqIEBwYXJhbSBlZGdlcyAtIFRoZSBhcnJheSBvZiBhbGwgY3VycmVudCBlZGdlcy5cbiAqIEByZXR1cm5zIFRoZSB1cGRhdGVkIGVkZ2VzIGFycmF5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICpjb25zdCBvblJlY29ubmVjdCA9IHVzZUNhbGxiYWNrKFxuICogIChvbGRFZGdlOiBFZGdlLCBuZXdDb25uZWN0aW9uOiBDb25uZWN0aW9uKSA9PiBzZXRFZGdlcygoZWxzKSA9PiByZWNvbm5lY3RFZGdlKG9sZEVkZ2UsIG5ld0Nvbm5lY3Rpb24sIGVscykpLFtdKTtcbiAqYGBgXG4gKi9cbmNvbnN0IHJlY29ubmVjdEVkZ2UgPSAob2xkRWRnZSwgbmV3Q29ubmVjdGlvbiwgZWRnZXMsIG9wdGlvbnMgPSB7IHNob3VsZFJlcGxhY2VJZDogdHJ1ZSB9KSA9PiB7XG4gICAgY29uc3QgeyBpZDogb2xkRWRnZUlkLCAuLi5yZXN0IH0gPSBvbGRFZGdlO1xuICAgIGlmICghbmV3Q29ubmVjdGlvbi5zb3VyY2UgfHwgIW5ld0Nvbm5lY3Rpb24udGFyZ2V0KSB7XG4gICAgICAgIGRldldhcm4oJzAwNicsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA2J10oKSk7XG4gICAgICAgIHJldHVybiBlZGdlcztcbiAgICB9XG4gICAgY29uc3QgZm91bmRFZGdlID0gZWRnZXMuZmluZCgoZSkgPT4gZS5pZCA9PT0gb2xkRWRnZS5pZCk7XG4gICAgaWYgKCFmb3VuZEVkZ2UpIHtcbiAgICAgICAgZGV2V2FybignMDA3JywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDcnXShvbGRFZGdlSWQpKTtcbiAgICAgICAgcmV0dXJuIGVkZ2VzO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgb2xkIGVkZ2UgYW5kIGNyZWF0ZSB0aGUgbmV3IGVkZ2Ugd2l0aCBwYXJhbWV0ZXJzIG9mIG9sZCBlZGdlLlxuICAgIGNvbnN0IGVkZ2UgPSB7XG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIGlkOiBvcHRpb25zLnNob3VsZFJlcGxhY2VJZCA/IGdldEVkZ2VJZChuZXdDb25uZWN0aW9uKSA6IG9sZEVkZ2VJZCxcbiAgICAgICAgc291cmNlOiBuZXdDb25uZWN0aW9uLnNvdXJjZSxcbiAgICAgICAgdGFyZ2V0OiBuZXdDb25uZWN0aW9uLnRhcmdldCxcbiAgICAgICAgc291cmNlSGFuZGxlOiBuZXdDb25uZWN0aW9uLnNvdXJjZUhhbmRsZSxcbiAgICAgICAgdGFyZ2V0SGFuZGxlOiBuZXdDb25uZWN0aW9uLnRhcmdldEhhbmRsZSxcbiAgICB9O1xuICAgIHJldHVybiBlZGdlcy5maWx0ZXIoKGUpID0+IGUuaWQgIT09IG9sZEVkZ2VJZCkuY29uY2F0KGVkZ2UpO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzdHJhaWdodCBsaW5lIHBhdGggYmV0d2VlbiB0d28gcG9pbnRzLlxuICogQHB1YmxpY1xuICogQHJldHVybnMgQSBwYXRoIHN0cmluZyB5b3UgY2FuIHVzZSBpbiBhbiBTVkcsIHRoZSBgbGFiZWxYYCBhbmQgYGxhYmVsWWAgcG9zaXRpb24gKGNlbnRlciBvZiBwYXRoKVxuICogYW5kIGBvZmZzZXRYYCwgYG9mZnNldFlgIGJldHdlZW4gc291cmNlIGhhbmRsZSBhbmQgbGFiZWwuXG4gKlxuICogLSBgcGF0aGA6IHRoZSBwYXRoIHRvIHVzZSBpbiBhbiBTVkcgYDxwYXRoPmAgZWxlbWVudC5cbiAqIC0gYGxhYmVsWGA6IHRoZSBgeGAgcG9zaXRpb24geW91IGNhbiB1c2UgdG8gcmVuZGVyIGEgbGFiZWwgZm9yIHRoaXMgZWRnZS5cbiAqIC0gYGxhYmVsWWA6IHRoZSBgeWAgcG9zaXRpb24geW91IGNhbiB1c2UgdG8gcmVuZGVyIGEgbGFiZWwgZm9yIHRoaXMgZWRnZS5cbiAqIC0gYG9mZnNldFhgOiB0aGUgYWJzb2x1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzb3VyY2UgYHhgIHBvc2l0aW9uIGFuZCB0aGUgYHhgIHBvc2l0aW9uIG9mIHRoZVxuICogbWlkZGxlIG9mIHRoaXMgcGF0aC5cbiAqIC0gYG9mZnNldFlgOiB0aGUgYWJzb2x1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzb3VyY2UgYHlgIHBvc2l0aW9uIGFuZCB0aGUgYHlgIHBvc2l0aW9uIG9mIHRoZVxuICogbWlkZGxlIG9mIHRoaXMgcGF0aC5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogIGNvbnN0IHNvdXJjZSA9IHsgeDogMCwgeTogMjAgfTtcbiAqICBjb25zdCB0YXJnZXQgPSB7IHg6IDE1MCwgeTogMTAwIH07XG4gKlxuICogIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV0gPSBnZXRTdHJhaWdodFBhdGgoe1xuICogICAgc291cmNlWDogc291cmNlLngsXG4gKiAgICBzb3VyY2VZOiBzb3VyY2UueSxcbiAqICAgIHNvdXJjZVBvc2l0aW9uOiBQb3NpdGlvbi5SaWdodCxcbiAqICAgIHRhcmdldFg6IHRhcmdldC54LFxuICogICAgdGFyZ2V0WTogdGFyZ2V0LnksXG4gKiAgICB0YXJnZXRQb3NpdGlvbjogUG9zaXRpb24uTGVmdCxcbiAqICB9KTtcbiAqIGBgYFxuICogQHJlbWFya3MgVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgdHVwbGUgKGFrYSBhIGZpeGVkLXNpemUgYXJyYXkpIHRvIG1ha2UgaXQgZWFzaWVyIHRvIHdvcmsgd2l0aCBtdWx0aXBsZSBlZGdlIHBhdGhzIGF0IG9uY2UuXG4gKi9cbmZ1bmN0aW9uIGdldFN0cmFpZ2h0UGF0aCh7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIH0pIHtcbiAgICBjb25zdCBbbGFiZWxYLCBsYWJlbFksIG9mZnNldFgsIG9mZnNldFldID0gZ2V0RWRnZUNlbnRlcih7XG4gICAgICAgIHNvdXJjZVgsXG4gICAgICAgIHNvdXJjZVksXG4gICAgICAgIHRhcmdldFgsXG4gICAgICAgIHRhcmdldFksXG4gICAgfSk7XG4gICAgcmV0dXJuIFtgTSAke3NvdXJjZVh9LCR7c291cmNlWX1MICR7dGFyZ2V0WH0sJHt0YXJnZXRZfWAsIGxhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXTtcbn1cblxuY29uc3QgaGFuZGxlRGlyZWN0aW9ucyA9IHtcbiAgICBbUG9zaXRpb24uTGVmdF06IHsgeDogLTEsIHk6IDAgfSxcbiAgICBbUG9zaXRpb24uUmlnaHRdOiB7IHg6IDEsIHk6IDAgfSxcbiAgICBbUG9zaXRpb24uVG9wXTogeyB4OiAwLCB5OiAtMSB9LFxuICAgIFtQb3NpdGlvbi5Cb3R0b21dOiB7IHg6IDAsIHk6IDEgfSxcbn07XG5jb25zdCBnZXREaXJlY3Rpb24gPSAoeyBzb3VyY2UsIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXQsIH0pID0+IHtcbiAgICBpZiAoc291cmNlUG9zaXRpb24gPT09IFBvc2l0aW9uLkxlZnQgfHwgc291cmNlUG9zaXRpb24gPT09IFBvc2l0aW9uLlJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UueCA8IHRhcmdldC54ID8geyB4OiAxLCB5OiAwIH0gOiB7IHg6IC0xLCB5OiAwIH07XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2UueSA8IHRhcmdldC55ID8geyB4OiAwLCB5OiAxIH0gOiB7IHg6IDAsIHk6IC0xIH07XG59O1xuY29uc3QgZGlzdGFuY2UgPSAoYSwgYikgPT4gTWF0aC5zcXJ0KE1hdGgucG93KGIueCAtIGEueCwgMikgKyBNYXRoLnBvdyhiLnkgLSBhLnksIDIpKTtcbi8qXG4gKiBXaXRoIHRoaXMgZnVuY3Rpb24gd2UgdHJ5IHRvIG1pbWljIGFuIG9ydGhvZ29uYWwgZWRnZSByb3V0aW5nIGJlaGF2aW91clxuICogSXQncyBub3QgYXMgZ29vZCBhcyBhIHJlYWwgb3J0aG9nb25hbCBlZGdlIHJvdXRpbmcsIGJ1dCBpdCdzIGZhc3RlciBhbmQgZ29vZCBlbm91Z2ggYXMgYSBkZWZhdWx0IGZvciBzdGVwIGFuZCBzbW9vdGggc3RlcCBlZGdlc1xuICovXG5mdW5jdGlvbiBnZXRQb2ludHMoeyBzb3VyY2UsIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXQsIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBjZW50ZXIsIG9mZnNldCwgc3RlcFBvc2l0aW9uLCB9KSB7XG4gICAgY29uc3Qgc291cmNlRGlyID0gaGFuZGxlRGlyZWN0aW9uc1tzb3VyY2VQb3NpdGlvbl07XG4gICAgY29uc3QgdGFyZ2V0RGlyID0gaGFuZGxlRGlyZWN0aW9uc1t0YXJnZXRQb3NpdGlvbl07XG4gICAgY29uc3Qgc291cmNlR2FwcGVkID0geyB4OiBzb3VyY2UueCArIHNvdXJjZURpci54ICogb2Zmc2V0LCB5OiBzb3VyY2UueSArIHNvdXJjZURpci55ICogb2Zmc2V0IH07XG4gICAgY29uc3QgdGFyZ2V0R2FwcGVkID0geyB4OiB0YXJnZXQueCArIHRhcmdldERpci54ICogb2Zmc2V0LCB5OiB0YXJnZXQueSArIHRhcmdldERpci55ICogb2Zmc2V0IH07XG4gICAgY29uc3QgZGlyID0gZ2V0RGlyZWN0aW9uKHtcbiAgICAgICAgc291cmNlOiBzb3VyY2VHYXBwZWQsXG4gICAgICAgIHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICB0YXJnZXQ6IHRhcmdldEdhcHBlZCxcbiAgICB9KTtcbiAgICBjb25zdCBkaXJBY2Nlc3NvciA9IGRpci54ICE9PSAwID8gJ3gnIDogJ3knO1xuICAgIGNvbnN0IGN1cnJEaXIgPSBkaXJbZGlyQWNjZXNzb3JdO1xuICAgIGxldCBwb2ludHMgPSBbXTtcbiAgICBsZXQgY2VudGVyWCwgY2VudGVyWTtcbiAgICBjb25zdCBzb3VyY2VHYXBPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICBjb25zdCB0YXJnZXRHYXBPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICBjb25zdCBbLCAsIGRlZmF1bHRPZmZzZXRYLCBkZWZhdWx0T2Zmc2V0WV0gPSBnZXRFZGdlQ2VudGVyKHtcbiAgICAgICAgc291cmNlWDogc291cmNlLngsXG4gICAgICAgIHNvdXJjZVk6IHNvdXJjZS55LFxuICAgICAgICB0YXJnZXRYOiB0YXJnZXQueCxcbiAgICAgICAgdGFyZ2V0WTogdGFyZ2V0LnksXG4gICAgfSk7XG4gICAgLy8gb3Bwb3NpdGUgaGFuZGxlIHBvc2l0aW9ucywgZGVmYXVsdCBjYXNlXG4gICAgaWYgKHNvdXJjZURpcltkaXJBY2Nlc3Nvcl0gKiB0YXJnZXREaXJbZGlyQWNjZXNzb3JdID09PSAtMSkge1xuICAgICAgICBpZiAoZGlyQWNjZXNzb3IgPT09ICd4Jykge1xuICAgICAgICAgICAgLy8gUHJpbWFyeSBkaXJlY3Rpb24gaXMgaG9yaXpvbnRhbCwgc28gc3RlcFBvc2l0aW9uIGFmZmVjdHMgWCBjb29yZGluYXRlXG4gICAgICAgICAgICBjZW50ZXJYID0gY2VudGVyLnggPz8gKHNvdXJjZUdhcHBlZC54ICsgKHRhcmdldEdhcHBlZC54IC0gc291cmNlR2FwcGVkLngpICogc3RlcFBvc2l0aW9uKTtcbiAgICAgICAgICAgIGNlbnRlclkgPSBjZW50ZXIueSA/PyAoc291cmNlR2FwcGVkLnkgKyB0YXJnZXRHYXBwZWQueSkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gUHJpbWFyeSBkaXJlY3Rpb24gaXMgdmVydGljYWwsIHNvIHN0ZXBQb3NpdGlvbiBhZmZlY3RzIFkgY29vcmRpbmF0ZSAgXG4gICAgICAgICAgICBjZW50ZXJYID0gY2VudGVyLnggPz8gKHNvdXJjZUdhcHBlZC54ICsgdGFyZ2V0R2FwcGVkLngpIC8gMjtcbiAgICAgICAgICAgIGNlbnRlclkgPSBjZW50ZXIueSA/PyAoc291cmNlR2FwcGVkLnkgKyAodGFyZ2V0R2FwcGVkLnkgLSBzb3VyY2VHYXBwZWQueSkgKiBzdGVwUG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAqICAgIC0tLT5cbiAgICAgICAgICogICAgfFxuICAgICAgICAgKiA+LS0tXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCB2ZXJ0aWNhbFNwbGl0ID0gW1xuICAgICAgICAgICAgeyB4OiBjZW50ZXJYLCB5OiBzb3VyY2VHYXBwZWQueSB9LFxuICAgICAgICAgICAgeyB4OiBjZW50ZXJYLCB5OiB0YXJnZXRHYXBwZWQueSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKlxuICAgICAgICAgKiAgICB8XG4gICAgICAgICAqICAtLS1cbiAgICAgICAgICogIHxcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGhvcml6b250YWxTcGxpdCA9IFtcbiAgICAgICAgICAgIHsgeDogc291cmNlR2FwcGVkLngsIHk6IGNlbnRlclkgfSxcbiAgICAgICAgICAgIHsgeDogdGFyZ2V0R2FwcGVkLngsIHk6IGNlbnRlclkgfSxcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKHNvdXJjZURpcltkaXJBY2Nlc3Nvcl0gPT09IGN1cnJEaXIpIHtcbiAgICAgICAgICAgIHBvaW50cyA9IGRpckFjY2Vzc29yID09PSAneCcgPyB2ZXJ0aWNhbFNwbGl0IDogaG9yaXpvbnRhbFNwbGl0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9pbnRzID0gZGlyQWNjZXNzb3IgPT09ICd4JyA/IGhvcml6b250YWxTcGxpdCA6IHZlcnRpY2FsU3BsaXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHNvdXJjZVRhcmdldCBtZWFucyB3ZSB0YWtlIHggZnJvbSBzb3VyY2UgYW5kIHkgZnJvbSB0YXJnZXQsIHRhcmdldFNvdXJjZSBpcyB0aGUgb3Bwb3NpdGVcbiAgICAgICAgY29uc3Qgc291cmNlVGFyZ2V0ID0gW3sgeDogc291cmNlR2FwcGVkLngsIHk6IHRhcmdldEdhcHBlZC55IH1dO1xuICAgICAgICBjb25zdCB0YXJnZXRTb3VyY2UgPSBbeyB4OiB0YXJnZXRHYXBwZWQueCwgeTogc291cmNlR2FwcGVkLnkgfV07XG4gICAgICAgIC8vIHRoaXMgaGFuZGxlcyBlZGdlcyB3aXRoIHNhbWUgaGFuZGxlIHBvc2l0aW9uc1xuICAgICAgICBpZiAoZGlyQWNjZXNzb3IgPT09ICd4Jykge1xuICAgICAgICAgICAgcG9pbnRzID0gc291cmNlRGlyLnggPT09IGN1cnJEaXIgPyB0YXJnZXRTb3VyY2UgOiBzb3VyY2VUYXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb2ludHMgPSBzb3VyY2VEaXIueSA9PT0gY3VyckRpciA/IHNvdXJjZVRhcmdldCA6IHRhcmdldFNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlUG9zaXRpb24gPT09IHRhcmdldFBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gTWF0aC5hYnMoc291cmNlW2RpckFjY2Vzc29yXSAtIHRhcmdldFtkaXJBY2Nlc3Nvcl0pO1xuICAgICAgICAgICAgLy8gaWYgYW4gZWRnZSBnb2VzIGZyb20gcmlnaHQgdG8gcmlnaHQgZm9yIGV4YW1wbGUgKHNvdXJjZVBvc2l0aW9uID09PSB0YXJnZXRQb3NpdGlvbikgYW5kIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHNvdXJjZS54IGFuZCB0YXJnZXQueCBpcyBsZXNzIHRoYW4gdGhlIG9mZnNldCwgdGhlIGFkZGVkIHBvaW50IGFuZCB0aGUgZ2FwcGVkIHNvdXJjZS90YXJnZXQgd2lsbCBvdmVybGFwLiBUaGlzIGxlYWRzIHRvIGEgd2VpcmQgZWRnZSBwYXRoLiBUbyBhdm9pZCB0aGlzIHdlIGFkZCBhIGdhcE9mZnNldCB0byB0aGUgc291cmNlL3RhcmdldFxuICAgICAgICAgICAgaWYgKGRpZmYgPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2FwT2Zmc2V0ID0gTWF0aC5taW4ob2Zmc2V0IC0gMSwgb2Zmc2V0IC0gZGlmZik7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZURpcltkaXJBY2Nlc3Nvcl0gPT09IGN1cnJEaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlR2FwT2Zmc2V0W2RpckFjY2Vzc29yXSA9IChzb3VyY2VHYXBwZWRbZGlyQWNjZXNzb3JdID4gc291cmNlW2RpckFjY2Vzc29yXSA/IC0xIDogMSkgKiBnYXBPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRHYXBPZmZzZXRbZGlyQWNjZXNzb3JdID0gKHRhcmdldEdhcHBlZFtkaXJBY2Nlc3Nvcl0gPiB0YXJnZXRbZGlyQWNjZXNzb3JdID8gLTEgOiAxKSAqIGdhcE9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlc2UgYXJlIGNvbmRpdGlvbnMgZm9yIGhhbmRsaW5nIG1peGVkIGhhbmRsZSBwb3NpdGlvbnMgbGlrZSBSaWdodCAtPiBCb3R0b20gZm9yIGV4YW1wbGVcbiAgICAgICAgaWYgKHNvdXJjZVBvc2l0aW9uICE9PSB0YXJnZXRQb3NpdGlvbikge1xuICAgICAgICAgICAgY29uc3QgZGlyQWNjZXNzb3JPcHBvc2l0ZSA9IGRpckFjY2Vzc29yID09PSAneCcgPyAneScgOiAneCc7XG4gICAgICAgICAgICBjb25zdCBpc1NhbWVEaXIgPSBzb3VyY2VEaXJbZGlyQWNjZXNzb3JdID09PSB0YXJnZXREaXJbZGlyQWNjZXNzb3JPcHBvc2l0ZV07XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VHdFRhcmdldE9wcG8gPSBzb3VyY2VHYXBwZWRbZGlyQWNjZXNzb3JPcHBvc2l0ZV0gPiB0YXJnZXRHYXBwZWRbZGlyQWNjZXNzb3JPcHBvc2l0ZV07XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VMdFRhcmdldE9wcG8gPSBzb3VyY2VHYXBwZWRbZGlyQWNjZXNzb3JPcHBvc2l0ZV0gPCB0YXJnZXRHYXBwZWRbZGlyQWNjZXNzb3JPcHBvc2l0ZV07XG4gICAgICAgICAgICBjb25zdCBmbGlwU291cmNlVGFyZ2V0ID0gKHNvdXJjZURpcltkaXJBY2Nlc3Nvcl0gPT09IDEgJiYgKCghaXNTYW1lRGlyICYmIHNvdXJjZUd0VGFyZ2V0T3BwbykgfHwgKGlzU2FtZURpciAmJiBzb3VyY2VMdFRhcmdldE9wcG8pKSkgfHxcbiAgICAgICAgICAgICAgICAoc291cmNlRGlyW2RpckFjY2Vzc29yXSAhPT0gMSAmJiAoKCFpc1NhbWVEaXIgJiYgc291cmNlTHRUYXJnZXRPcHBvKSB8fCAoaXNTYW1lRGlyICYmIHNvdXJjZUd0VGFyZ2V0T3BwbykpKTtcbiAgICAgICAgICAgIGlmIChmbGlwU291cmNlVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzID0gZGlyQWNjZXNzb3IgPT09ICd4JyA/IHNvdXJjZVRhcmdldCA6IHRhcmdldFNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb3VyY2VHYXBQb2ludCA9IHsgeDogc291cmNlR2FwcGVkLnggKyBzb3VyY2VHYXBPZmZzZXQueCwgeTogc291cmNlR2FwcGVkLnkgKyBzb3VyY2VHYXBPZmZzZXQueSB9O1xuICAgICAgICBjb25zdCB0YXJnZXRHYXBQb2ludCA9IHsgeDogdGFyZ2V0R2FwcGVkLnggKyB0YXJnZXRHYXBPZmZzZXQueCwgeTogdGFyZ2V0R2FwcGVkLnkgKyB0YXJnZXRHYXBPZmZzZXQueSB9O1xuICAgICAgICBjb25zdCBtYXhYRGlzdGFuY2UgPSBNYXRoLm1heChNYXRoLmFicyhzb3VyY2VHYXBQb2ludC54IC0gcG9pbnRzWzBdLngpLCBNYXRoLmFicyh0YXJnZXRHYXBQb2ludC54IC0gcG9pbnRzWzBdLngpKTtcbiAgICAgICAgY29uc3QgbWF4WURpc3RhbmNlID0gTWF0aC5tYXgoTWF0aC5hYnMoc291cmNlR2FwUG9pbnQueSAtIHBvaW50c1swXS55KSwgTWF0aC5hYnModGFyZ2V0R2FwUG9pbnQueSAtIHBvaW50c1swXS55KSk7XG4gICAgICAgIC8vIHdlIHdhbnQgdG8gcGxhY2UgdGhlIGxhYmVsIG9uIHRoZSBsb25nZXN0IHNlZ21lbnQgb2YgdGhlIGVkZ2VcbiAgICAgICAgaWYgKG1heFhEaXN0YW5jZSA+PSBtYXhZRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIGNlbnRlclggPSAoc291cmNlR2FwUG9pbnQueCArIHRhcmdldEdhcFBvaW50LngpIC8gMjtcbiAgICAgICAgICAgIGNlbnRlclkgPSBwb2ludHNbMF0ueTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNlbnRlclggPSBwb2ludHNbMF0ueDtcbiAgICAgICAgICAgIGNlbnRlclkgPSAoc291cmNlR2FwUG9pbnQueSArIHRhcmdldEdhcFBvaW50LnkpIC8gMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwYXRoUG9pbnRzID0gW1xuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHsgeDogc291cmNlR2FwcGVkLnggKyBzb3VyY2VHYXBPZmZzZXQueCwgeTogc291cmNlR2FwcGVkLnkgKyBzb3VyY2VHYXBPZmZzZXQueSB9LFxuICAgICAgICAuLi5wb2ludHMsXG4gICAgICAgIHsgeDogdGFyZ2V0R2FwcGVkLnggKyB0YXJnZXRHYXBPZmZzZXQueCwgeTogdGFyZ2V0R2FwcGVkLnkgKyB0YXJnZXRHYXBPZmZzZXQueSB9LFxuICAgICAgICB0YXJnZXQsXG4gICAgXTtcbiAgICByZXR1cm4gW3BhdGhQb2ludHMsIGNlbnRlclgsIGNlbnRlclksIGRlZmF1bHRPZmZzZXRYLCBkZWZhdWx0T2Zmc2V0WV07XG59XG5mdW5jdGlvbiBnZXRCZW5kKGEsIGIsIGMsIHNpemUpIHtcbiAgICBjb25zdCBiZW5kU2l6ZSA9IE1hdGgubWluKGRpc3RhbmNlKGEsIGIpIC8gMiwgZGlzdGFuY2UoYiwgYykgLyAyLCBzaXplKTtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGI7XG4gICAgLy8gbm8gYmVuZFxuICAgIGlmICgoYS54ID09PSB4ICYmIHggPT09IGMueCkgfHwgKGEueSA9PT0geSAmJiB5ID09PSBjLnkpKSB7XG4gICAgICAgIHJldHVybiBgTCR7eH0gJHt5fWA7XG4gICAgfVxuICAgIC8vIGZpcnN0IHNlZ21lbnQgaXMgaG9yaXpvbnRhbFxuICAgIGlmIChhLnkgPT09IHkpIHtcbiAgICAgICAgY29uc3QgeERpciA9IGEueCA8IGMueCA/IC0xIDogMTtcbiAgICAgICAgY29uc3QgeURpciA9IGEueSA8IGMueSA/IDEgOiAtMTtcbiAgICAgICAgcmV0dXJuIGBMICR7eCArIGJlbmRTaXplICogeERpcn0sJHt5fVEgJHt4fSwke3l9ICR7eH0sJHt5ICsgYmVuZFNpemUgKiB5RGlyfWA7XG4gICAgfVxuICAgIGNvbnN0IHhEaXIgPSBhLnggPCBjLnggPyAxIDogLTE7XG4gICAgY29uc3QgeURpciA9IGEueSA8IGMueSA/IC0xIDogMTtcbiAgICByZXR1cm4gYEwgJHt4fSwke3kgKyBiZW5kU2l6ZSAqIHlEaXJ9USAke3h9LCR7eX0gJHt4ICsgYmVuZFNpemUgKiB4RGlyfSwke3l9YDtcbn1cbi8qKlxuICogVGhlIGBnZXRTbW9vdGhTdGVwUGF0aGAgdXRpbCByZXR1cm5zIGV2ZXJ5dGhpbmcgeW91IG5lZWQgdG8gcmVuZGVyIGEgc3RlcHBlZCBwYXRoXG4gKiBiZXR3ZWVuIHR3byBub2Rlcy4gVGhlIGBib3JkZXJSYWRpdXNgIHByb3BlcnR5IGNhbiBiZSB1c2VkIHRvIGNob29zZSBob3cgcm91bmRlZFxuICogdGhlIGNvcm5lcnMgb2YgdGhvc2Ugc3RlcHMgYXJlLlxuICogQHB1YmxpY1xuICogQHJldHVybnMgQSBwYXRoIHN0cmluZyB5b3UgY2FuIHVzZSBpbiBhbiBTVkcsIHRoZSBgbGFiZWxYYCBhbmQgYGxhYmVsWWAgcG9zaXRpb24gKGNlbnRlciBvZiBwYXRoKVxuICogYW5kIGBvZmZzZXRYYCwgYG9mZnNldFlgIGJldHdlZW4gc291cmNlIGhhbmRsZSBhbmQgbGFiZWwuXG4gKlxuICogLSBgcGF0aGA6IHRoZSBwYXRoIHRvIHVzZSBpbiBhbiBTVkcgYDxwYXRoPmAgZWxlbWVudC5cbiAqIC0gYGxhYmVsWGA6IHRoZSBgeGAgcG9zaXRpb24geW91IGNhbiB1c2UgdG8gcmVuZGVyIGEgbGFiZWwgZm9yIHRoaXMgZWRnZS5cbiAqIC0gYGxhYmVsWWA6IHRoZSBgeWAgcG9zaXRpb24geW91IGNhbiB1c2UgdG8gcmVuZGVyIGEgbGFiZWwgZm9yIHRoaXMgZWRnZS5cbiAqIC0gYG9mZnNldFhgOiB0aGUgYWJzb2x1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzb3VyY2UgYHhgIHBvc2l0aW9uIGFuZCB0aGUgYHhgIHBvc2l0aW9uIG9mIHRoZVxuICogbWlkZGxlIG9mIHRoaXMgcGF0aC5cbiAqIC0gYG9mZnNldFlgOiB0aGUgYWJzb2x1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBzb3VyY2UgYHlgIHBvc2l0aW9uIGFuZCB0aGUgYHlgIHBvc2l0aW9uIG9mIHRoZVxuICogbWlkZGxlIG9mIHRoaXMgcGF0aC5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogIGNvbnN0IHNvdXJjZSA9IHsgeDogMCwgeTogMjAgfTtcbiAqICBjb25zdCB0YXJnZXQgPSB7IHg6IDE1MCwgeTogMTAwIH07XG4gKlxuICogIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV0gPSBnZXRTbW9vdGhTdGVwUGF0aCh7XG4gKiAgICBzb3VyY2VYOiBzb3VyY2UueCxcbiAqICAgIHNvdXJjZVk6IHNvdXJjZS55LFxuICogICAgc291cmNlUG9zaXRpb246IFBvc2l0aW9uLlJpZ2h0LFxuICogICAgdGFyZ2V0WDogdGFyZ2V0LngsXG4gKiAgICB0YXJnZXRZOiB0YXJnZXQueSxcbiAqICAgIHRhcmdldFBvc2l0aW9uOiBQb3NpdGlvbi5MZWZ0LFxuICogIH0pO1xuICogYGBgXG4gKiBAcmVtYXJrcyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSB0dXBsZSAoYWthIGEgZml4ZWQtc2l6ZSBhcnJheSkgdG8gbWFrZSBpdCBlYXNpZXIgdG8gd29yayB3aXRoIG11bHRpcGxlIGVkZ2UgcGF0aHMgYXQgb25jZS5cbiAqL1xuZnVuY3Rpb24gZ2V0U21vb3RoU3RlcFBhdGgoeyBzb3VyY2VYLCBzb3VyY2VZLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgdGFyZ2V0WCwgdGFyZ2V0WSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIGJvcmRlclJhZGl1cyA9IDUsIGNlbnRlclgsIGNlbnRlclksIG9mZnNldCA9IDIwLCBzdGVwUG9zaXRpb24gPSAwLjUsIH0pIHtcbiAgICBjb25zdCBbcG9pbnRzLCBsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV0gPSBnZXRQb2ludHMoe1xuICAgICAgICBzb3VyY2U6IHsgeDogc291cmNlWCwgeTogc291cmNlWSB9LFxuICAgICAgICBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgdGFyZ2V0OiB7IHg6IHRhcmdldFgsIHk6IHRhcmdldFkgfSxcbiAgICAgICAgdGFyZ2V0UG9zaXRpb24sXG4gICAgICAgIGNlbnRlcjogeyB4OiBjZW50ZXJYLCB5OiBjZW50ZXJZIH0sXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgc3RlcFBvc2l0aW9uLFxuICAgIH0pO1xuICAgIGNvbnN0IHBhdGggPSBwb2ludHMucmVkdWNlKChyZXMsIHAsIGkpID0+IHtcbiAgICAgICAgbGV0IHNlZ21lbnQgPSAnJztcbiAgICAgICAgaWYgKGkgPiAwICYmIGkgPCBwb2ludHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgc2VnbWVudCA9IGdldEJlbmQocG9pbnRzW2kgLSAxXSwgcCwgcG9pbnRzW2kgKyAxXSwgYm9yZGVyUmFkaXVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBgJHtpID09PSAwID8gJ00nIDogJ0wnfSR7cC54fSAke3AueX1gO1xuICAgICAgICB9XG4gICAgICAgIHJlcyArPSBzZWdtZW50O1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sICcnKTtcbiAgICByZXR1cm4gW3BhdGgsIGxhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlSW5pdGlhbGl6ZWQobm9kZSkge1xuICAgIHJldHVybiAobm9kZSAmJlxuICAgICAgICAhIShub2RlLmludGVybmFscy5oYW5kbGVCb3VuZHMgfHwgbm9kZS5oYW5kbGVzPy5sZW5ndGgpICYmXG4gICAgICAgICEhKG5vZGUubWVhc3VyZWQud2lkdGggfHwgbm9kZS53aWR0aCB8fCBub2RlLmluaXRpYWxXaWR0aCkpO1xufVxuZnVuY3Rpb24gZ2V0RWRnZVBvc2l0aW9uKHBhcmFtcykge1xuICAgIGNvbnN0IHsgc291cmNlTm9kZSwgdGFyZ2V0Tm9kZSB9ID0gcGFyYW1zO1xuICAgIGlmICghaXNOb2RlSW5pdGlhbGl6ZWQoc291cmNlTm9kZSkgfHwgIWlzTm9kZUluaXRpYWxpemVkKHRhcmdldE5vZGUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VIYW5kbGVCb3VuZHMgPSBzb3VyY2VOb2RlLmludGVybmFscy5oYW5kbGVCb3VuZHMgfHwgdG9IYW5kbGVCb3VuZHMoc291cmNlTm9kZS5oYW5kbGVzKTtcbiAgICBjb25zdCB0YXJnZXRIYW5kbGVCb3VuZHMgPSB0YXJnZXROb2RlLmludGVybmFscy5oYW5kbGVCb3VuZHMgfHwgdG9IYW5kbGVCb3VuZHModGFyZ2V0Tm9kZS5oYW5kbGVzKTtcbiAgICBjb25zdCBzb3VyY2VIYW5kbGUgPSBnZXRIYW5kbGUkMShzb3VyY2VIYW5kbGVCb3VuZHM/LnNvdXJjZSA/PyBbXSwgcGFyYW1zLnNvdXJjZUhhbmRsZSk7XG4gICAgY29uc3QgdGFyZ2V0SGFuZGxlID0gZ2V0SGFuZGxlJDEoXG4gICAgLy8gd2hlbiBjb25uZWN0aW9uIHR5cGUgaXMgbG9vc2Ugd2UgY2FuIGRlZmluZSBhbGwgaGFuZGxlcyBhcyBzb3VyY2VzIGFuZCBjb25uZWN0IHNvdXJjZSAtPiBzb3VyY2VcbiAgICBwYXJhbXMuY29ubmVjdGlvbk1vZGUgPT09IENvbm5lY3Rpb25Nb2RlLlN0cmljdFxuICAgICAgICA/IHRhcmdldEhhbmRsZUJvdW5kcz8udGFyZ2V0ID8/IFtdXG4gICAgICAgIDogKHRhcmdldEhhbmRsZUJvdW5kcz8udGFyZ2V0ID8/IFtdKS5jb25jYXQodGFyZ2V0SGFuZGxlQm91bmRzPy5zb3VyY2UgPz8gW10pLCBwYXJhbXMudGFyZ2V0SGFuZGxlKTtcbiAgICBpZiAoIXNvdXJjZUhhbmRsZSB8fCAhdGFyZ2V0SGFuZGxlKSB7XG4gICAgICAgIHBhcmFtcy5vbkVycm9yPy4oJzAwOCcsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA4J10oIXNvdXJjZUhhbmRsZSA/ICdzb3VyY2UnIDogJ3RhcmdldCcsIHtcbiAgICAgICAgICAgIGlkOiBwYXJhbXMuaWQsXG4gICAgICAgICAgICBzb3VyY2VIYW5kbGU6IHBhcmFtcy5zb3VyY2VIYW5kbGUsXG4gICAgICAgICAgICB0YXJnZXRIYW5kbGU6IHBhcmFtcy50YXJnZXRIYW5kbGUsXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZVBvc2l0aW9uID0gc291cmNlSGFuZGxlPy5wb3NpdGlvbiB8fCBQb3NpdGlvbi5Cb3R0b207XG4gICAgY29uc3QgdGFyZ2V0UG9zaXRpb24gPSB0YXJnZXRIYW5kbGU/LnBvc2l0aW9uIHx8IFBvc2l0aW9uLlRvcDtcbiAgICBjb25zdCBzb3VyY2UgPSBnZXRIYW5kbGVQb3NpdGlvbihzb3VyY2VOb2RlLCBzb3VyY2VIYW5kbGUsIHNvdXJjZVBvc2l0aW9uKTtcbiAgICBjb25zdCB0YXJnZXQgPSBnZXRIYW5kbGVQb3NpdGlvbih0YXJnZXROb2RlLCB0YXJnZXRIYW5kbGUsIHRhcmdldFBvc2l0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2VYOiBzb3VyY2UueCxcbiAgICAgICAgc291cmNlWTogc291cmNlLnksXG4gICAgICAgIHRhcmdldFg6IHRhcmdldC54LFxuICAgICAgICB0YXJnZXRZOiB0YXJnZXQueSxcbiAgICAgICAgc291cmNlUG9zaXRpb24sXG4gICAgICAgIHRhcmdldFBvc2l0aW9uLFxuICAgIH07XG59XG5mdW5jdGlvbiB0b0hhbmRsZUJvdW5kcyhoYW5kbGVzKSB7XG4gICAgaWYgKCFoYW5kbGVzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2UgPSBbXTtcbiAgICBjb25zdCB0YXJnZXQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGhhbmRsZSBvZiBoYW5kbGVzKSB7XG4gICAgICAgIGhhbmRsZS53aWR0aCA9IGhhbmRsZS53aWR0aCA/PyAxO1xuICAgICAgICBoYW5kbGUuaGVpZ2h0ID0gaGFuZGxlLmhlaWdodCA/PyAxO1xuICAgICAgICBpZiAoaGFuZGxlLnR5cGUgPT09ICdzb3VyY2UnKSB7XG4gICAgICAgICAgICBzb3VyY2UucHVzaChoYW5kbGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhbmRsZS50eXBlID09PSAndGFyZ2V0Jykge1xuICAgICAgICAgICAgdGFyZ2V0LnB1c2goaGFuZGxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHRhcmdldCxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0SGFuZGxlUG9zaXRpb24obm9kZSwgaGFuZGxlLCBmYWxsYmFja1Bvc2l0aW9uID0gUG9zaXRpb24uTGVmdCwgY2VudGVyID0gZmFsc2UpIHtcbiAgICBjb25zdCB4ID0gKGhhbmRsZT8ueCA/PyAwKSArIG5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueDtcbiAgICBjb25zdCB5ID0gKGhhbmRsZT8ueSA/PyAwKSArIG5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueTtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGhhbmRsZSA/PyBnZXROb2RlRGltZW5zaW9ucyhub2RlKTtcbiAgICBpZiAoY2VudGVyKSB7XG4gICAgICAgIHJldHVybiB7IHg6IHggKyB3aWR0aCAvIDIsIHk6IHkgKyBoZWlnaHQgLyAyIH07XG4gICAgfVxuICAgIGNvbnN0IHBvc2l0aW9uID0gaGFuZGxlPy5wb3NpdGlvbiA/PyBmYWxsYmFja1Bvc2l0aW9uO1xuICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5Ub3A6XG4gICAgICAgICAgICByZXR1cm4geyB4OiB4ICsgd2lkdGggLyAyLCB5IH07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uUmlnaHQ6XG4gICAgICAgICAgICByZXR1cm4geyB4OiB4ICsgd2lkdGgsIHk6IHkgKyBoZWlnaHQgLyAyIH07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uQm90dG9tOlxuICAgICAgICAgICAgcmV0dXJuIHsgeDogeCArIHdpZHRoIC8gMiwgeTogeSArIGhlaWdodCB9O1xuICAgICAgICBjYXNlIFBvc2l0aW9uLkxlZnQ6XG4gICAgICAgICAgICByZXR1cm4geyB4LCB5OiB5ICsgaGVpZ2h0IC8gMiB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEhhbmRsZSQxKGJvdW5kcywgaGFuZGxlSWQpIHtcbiAgICBpZiAoIWJvdW5kcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gaWYgbm8gaGFuZGxlSWQgaXMgZ2l2ZW4sIHdlIHVzZSB0aGUgZmlyc3QgaGFuZGxlLCBvdGhlcndpc2Ugd2UgY2hlY2sgZm9yIHRoZSBpZFxuICAgIHJldHVybiAoIWhhbmRsZUlkID8gYm91bmRzWzBdIDogYm91bmRzLmZpbmQoKGQpID0+IGQuaWQgPT09IGhhbmRsZUlkKSkgfHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0TWFya2VySWQobWFya2VyLCBpZCkge1xuICAgIGlmICghbWFya2VyKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBtYXJrZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBtYXJrZXI7XG4gICAgfVxuICAgIGNvbnN0IGlkUHJlZml4ID0gaWQgPyBgJHtpZH1fX2AgOiAnJztcbiAgICByZXR1cm4gYCR7aWRQcmVmaXh9JHtPYmplY3Qua2V5cyhtYXJrZXIpXG4gICAgICAgIC5zb3J0KClcbiAgICAgICAgLm1hcCgoa2V5KSA9PiBgJHtrZXl9PSR7bWFya2VyW2tleV19YClcbiAgICAgICAgLmpvaW4oJyYnKX1gO1xufVxuZnVuY3Rpb24gY3JlYXRlTWFya2VySWRzKGVkZ2VzLCB7IGlkLCBkZWZhdWx0Q29sb3IsIGRlZmF1bHRNYXJrZXJTdGFydCwgZGVmYXVsdE1hcmtlckVuZCwgfSkge1xuICAgIGNvbnN0IGlkcyA9IG5ldyBTZXQoKTtcbiAgICByZXR1cm4gZWRnZXNcbiAgICAgICAgLnJlZHVjZSgobWFya2VycywgZWRnZSkgPT4ge1xuICAgICAgICBbZWRnZS5tYXJrZXJTdGFydCB8fCBkZWZhdWx0TWFya2VyU3RhcnQsIGVkZ2UubWFya2VyRW5kIHx8IGRlZmF1bHRNYXJrZXJFbmRdLmZvckVhY2goKG1hcmtlcikgPT4ge1xuICAgICAgICAgICAgaWYgKG1hcmtlciAmJiB0eXBlb2YgbWFya2VyID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtlcklkID0gZ2V0TWFya2VySWQobWFya2VyLCBpZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpZHMuaGFzKG1hcmtlcklkKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXJzLnB1c2goeyBpZDogbWFya2VySWQsIGNvbG9yOiBtYXJrZXIuY29sb3IgfHwgZGVmYXVsdENvbG9yLCAuLi5tYXJrZXIgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlkcy5hZGQobWFya2VySWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXJrZXJzO1xuICAgIH0sIFtdKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5pZC5sb2NhbGVDb21wYXJlKGIuaWQpKTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZVRvb2xiYXJUcmFuc2Zvcm0obm9kZVJlY3QsIHZpZXdwb3J0LCBwb3NpdGlvbiwgb2Zmc2V0LCBhbGlnbikge1xuICAgIGxldCBhbGlnbm1lbnRPZmZzZXQgPSAwLjU7XG4gICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIGFsaWdubWVudE9mZnNldCA9IDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICBhbGlnbm1lbnRPZmZzZXQgPSAxO1xuICAgIH1cbiAgICAvKlxuICAgICAqIHBvc2l0aW9uID09PSBQb3NpdGlvbi5Ub3BcbiAgICAgKiB3ZSBzZXQgdGhlIHggYW55IHkgcG9zaXRpb24gb2YgdGhlIHRvb2xiYXIgYmFzZWQgb24gdGhlIG5vZGVzIHBvc2l0aW9uXG4gICAgICovXG4gICAgbGV0IHBvcyA9IFtcbiAgICAgICAgKG5vZGVSZWN0LnggKyBub2RlUmVjdC53aWR0aCAqIGFsaWdubWVudE9mZnNldCkgKiB2aWV3cG9ydC56b29tICsgdmlld3BvcnQueCxcbiAgICAgICAgbm9kZVJlY3QueSAqIHZpZXdwb3J0Lnpvb20gKyB2aWV3cG9ydC55IC0gb2Zmc2V0LFxuICAgIF07XG4gICAgLy8gYW5kIHRoYW4gc2hpZnQgaXQgYmFzZWQgb24gdGhlIGFsaWdubWVudC4gVGhlIHNoaWZ0IHZhbHVlcyBhcmUgaW4gJS5cbiAgICBsZXQgc2hpZnQgPSBbLTEwMCAqIGFsaWdubWVudE9mZnNldCwgLTEwMF07XG4gICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgICBjYXNlIFBvc2l0aW9uLlJpZ2h0OlxuICAgICAgICAgICAgcG9zID0gW1xuICAgICAgICAgICAgICAgIChub2RlUmVjdC54ICsgbm9kZVJlY3Qud2lkdGgpICogdmlld3BvcnQuem9vbSArIHZpZXdwb3J0LnggKyBvZmZzZXQsXG4gICAgICAgICAgICAgICAgKG5vZGVSZWN0LnkgKyBub2RlUmVjdC5oZWlnaHQgKiBhbGlnbm1lbnRPZmZzZXQpICogdmlld3BvcnQuem9vbSArIHZpZXdwb3J0LnksXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgc2hpZnQgPSBbMCwgLTEwMCAqIGFsaWdubWVudE9mZnNldF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5Cb3R0b206XG4gICAgICAgICAgICBwb3NbMV0gPSAobm9kZVJlY3QueSArIG5vZGVSZWN0LmhlaWdodCkgKiB2aWV3cG9ydC56b29tICsgdmlld3BvcnQueSArIG9mZnNldDtcbiAgICAgICAgICAgIHNoaWZ0WzFdID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFBvc2l0aW9uLkxlZnQ6XG4gICAgICAgICAgICBwb3MgPSBbXG4gICAgICAgICAgICAgICAgbm9kZVJlY3QueCAqIHZpZXdwb3J0Lnpvb20gKyB2aWV3cG9ydC54IC0gb2Zmc2V0LFxuICAgICAgICAgICAgICAgIChub2RlUmVjdC55ICsgbm9kZVJlY3QuaGVpZ2h0ICogYWxpZ25tZW50T2Zmc2V0KSAqIHZpZXdwb3J0Lnpvb20gKyB2aWV3cG9ydC55LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHNoaWZ0ID0gWy0xMDAsIC0xMDAgKiBhbGlnbm1lbnRPZmZzZXRdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBgdHJhbnNsYXRlKCR7cG9zWzBdfXB4LCAke3Bvc1sxXX1weCkgdHJhbnNsYXRlKCR7c2hpZnRbMF19JSwgJHtzaGlmdFsxXX0lKWA7XG59XG5cbmNvbnN0IGFsaWduWFRvUGVyY2VudCA9IHtcbiAgICBsZWZ0OiAwLFxuICAgIGNlbnRlcjogNTAsXG4gICAgcmlnaHQ6IDEwMCxcbn07XG5jb25zdCBhbGlnbllUb1BlcmNlbnQgPSB7XG4gICAgdG9wOiAwLFxuICAgIGNlbnRlcjogNTAsXG4gICAgYm90dG9tOiAxMDAsXG59O1xuZnVuY3Rpb24gZ2V0RWRnZVRvb2xiYXJUcmFuc2Zvcm0oeCwgeSwgem9vbSwgYWxpZ25YID0gJ2NlbnRlcicsIGFsaWduWSA9ICdjZW50ZXInKSB7XG4gICAgcmV0dXJuIGB0cmFuc2xhdGUoJHt4fXB4LCAke3l9cHgpIHNjYWxlKCR7MSAvIHpvb219KSB0cmFuc2xhdGUoJHstKGFsaWduWFRvUGVyY2VudFthbGlnblhdID8/IDUwKX0lLCAkey0oYWxpZ25ZVG9QZXJjZW50W2FsaWduWV0gPz8gNTApfSUpYDtcbn1cblxuY29uc3QgU0VMRUNURURfTk9ERV9aID0gMTAwMDtcbmNvbnN0IFJPT1RfUEFSRU5UX1pfSU5DUkVNRU5UID0gMTA7XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBub2RlT3JpZ2luOiBbMCwgMF0sXG4gICAgbm9kZUV4dGVudDogaW5maW5pdGVFeHRlbnQsXG4gICAgZWxldmF0ZU5vZGVzT25TZWxlY3Q6IHRydWUsXG4gICAgZGVmYXVsdHM6IHt9LFxufTtcbmNvbnN0IGFkb3B0VXNlck5vZGVzRGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgY2hlY2tFcXVhbGl0eTogdHJ1ZSxcbn07XG5mdW5jdGlvbiBtZXJnZU9iamVjdHMoYmFzZSwgaW5jb21pbmcpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7IC4uLmJhc2UgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbmNvbWluZykge1xuICAgICAgICBpZiAoaW5jb21pbmdba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyB0eXBlY2FzdCBpcyBzYWZlIGhlcmUsIGJlY2F1c2Ugd2UgY2hlY2sgZm9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBpbmNvbWluZ1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1cGRhdGVBYnNvbHV0ZVBvc2l0aW9ucyhub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBfb3B0aW9ucyA9IG1lcmdlT2JqZWN0cyhkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVMb29rdXAudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKG5vZGUucGFyZW50SWQpIHtcbiAgICAgICAgICAgIHVwZGF0ZUNoaWxkTm9kZShub2RlLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIF9vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uV2l0aE9yaWdpbiA9IGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4obm9kZSwgX29wdGlvbnMubm9kZU9yaWdpbik7XG4gICAgICAgICAgICBjb25zdCBleHRlbnQgPSBpc0Nvb3JkaW5hdGVFeHRlbnQobm9kZS5leHRlbnQpID8gbm9kZS5leHRlbnQgOiBfb3B0aW9ucy5ub2RlRXh0ZW50O1xuICAgICAgICAgICAgY29uc3QgY2xhbXBlZFBvc2l0aW9uID0gY2xhbXBQb3NpdGlvbihwb3NpdGlvbldpdGhPcmlnaW4sIGV4dGVudCwgZ2V0Tm9kZURpbWVuc2lvbnMobm9kZSkpO1xuICAgICAgICAgICAgbm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZSA9IGNsYW1wZWRQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlSGFuZGxlcyh1c2VyTm9kZSwgaW50ZXJuYWxOb2RlKSB7XG4gICAgaWYgKCF1c2VyTm9kZS5oYW5kbGVzKSB7XG4gICAgICAgIHJldHVybiAhdXNlck5vZGUubWVhc3VyZWQgPyB1bmRlZmluZWQgOiBpbnRlcm5hbE5vZGU/LmludGVybmFscy5oYW5kbGVCb3VuZHM7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZSA9IFtdO1xuICAgIGNvbnN0IHRhcmdldCA9IFtdO1xuICAgIGZvciAoY29uc3QgaGFuZGxlIG9mIHVzZXJOb2RlLmhhbmRsZXMpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlQm91bmRzID0ge1xuICAgICAgICAgICAgaWQ6IGhhbmRsZS5pZCxcbiAgICAgICAgICAgIHdpZHRoOiBoYW5kbGUud2lkdGggPz8gMSxcbiAgICAgICAgICAgIGhlaWdodDogaGFuZGxlLmhlaWdodCA/PyAxLFxuICAgICAgICAgICAgbm9kZUlkOiB1c2VyTm9kZS5pZCxcbiAgICAgICAgICAgIHg6IGhhbmRsZS54LFxuICAgICAgICAgICAgeTogaGFuZGxlLnksXG4gICAgICAgICAgICBwb3NpdGlvbjogaGFuZGxlLnBvc2l0aW9uLFxuICAgICAgICAgICAgdHlwZTogaGFuZGxlLnR5cGUsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChoYW5kbGUudHlwZSA9PT0gJ3NvdXJjZScpIHtcbiAgICAgICAgICAgIHNvdXJjZS5wdXNoKGhhbmRsZUJvdW5kcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFuZGxlLnR5cGUgPT09ICd0YXJnZXQnKSB7XG4gICAgICAgICAgICB0YXJnZXQucHVzaChoYW5kbGVCb3VuZHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgdGFyZ2V0LFxuICAgIH07XG59XG5mdW5jdGlvbiBhZG9wdFVzZXJOb2Rlcyhub2Rlcywgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBvcHRpb25zKSB7XG4gICAgY29uc3QgX29wdGlvbnMgPSBtZXJnZU9iamVjdHMoYWRvcHRVc2VyTm9kZXNEZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgbGV0IHJvb3RQYXJlbnRJbmRleCA9IHsgaTogLTEgfTtcbiAgICBsZXQgbm9kZXNJbml0aWFsaXplZCA9IG5vZGVzLmxlbmd0aCA+IDA7XG4gICAgY29uc3QgdG1wTG9va3VwID0gbmV3IE1hcChub2RlTG9va3VwKTtcbiAgICBjb25zdCBzZWxlY3RlZE5vZGVaID0gX29wdGlvbnM/LmVsZXZhdGVOb2Rlc09uU2VsZWN0ID8gU0VMRUNURURfTk9ERV9aIDogMDtcbiAgICBub2RlTG9va3VwLmNsZWFyKCk7XG4gICAgcGFyZW50TG9va3VwLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCB1c2VyTm9kZSBvZiBub2Rlcykge1xuICAgICAgICBsZXQgaW50ZXJuYWxOb2RlID0gdG1wTG9va3VwLmdldCh1c2VyTm9kZS5pZCk7XG4gICAgICAgIGlmIChfb3B0aW9ucy5jaGVja0VxdWFsaXR5ICYmIHVzZXJOb2RlID09PSBpbnRlcm5hbE5vZGU/LmludGVybmFscy51c2VyTm9kZSkge1xuICAgICAgICAgICAgbm9kZUxvb2t1cC5zZXQodXNlck5vZGUuaWQsIGludGVybmFsTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbldpdGhPcmlnaW4gPSBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luKHVzZXJOb2RlLCBfb3B0aW9ucy5ub2RlT3JpZ2luKTtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVudCA9IGlzQ29vcmRpbmF0ZUV4dGVudCh1c2VyTm9kZS5leHRlbnQpID8gdXNlck5vZGUuZXh0ZW50IDogX29wdGlvbnMubm9kZUV4dGVudDtcbiAgICAgICAgICAgIGNvbnN0IGNsYW1wZWRQb3NpdGlvbiA9IGNsYW1wUG9zaXRpb24ocG9zaXRpb25XaXRoT3JpZ2luLCBleHRlbnQsIGdldE5vZGVEaW1lbnNpb25zKHVzZXJOb2RlKSk7XG4gICAgICAgICAgICBpbnRlcm5hbE5vZGUgPSB7XG4gICAgICAgICAgICAgICAgLi4uX29wdGlvbnMuZGVmYXVsdHMsXG4gICAgICAgICAgICAgICAgLi4udXNlck5vZGUsXG4gICAgICAgICAgICAgICAgbWVhc3VyZWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHVzZXJOb2RlLm1lYXN1cmVkPy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB1c2VyTm9kZS5tZWFzdXJlZD8uaGVpZ2h0LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxzOiB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uQWJzb2x1dGU6IGNsYW1wZWRQb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdXNlciByZS1pbml0aWFsaXplcyB0aGUgbm9kZSBvciByZW1vdmVzIGBtZWFzdXJlZGAgZm9yIHdoYXRldmVyIHJlYXNvbiwgd2UgcmVzZXQgdGhlIGhhbmRsZUJvdW5kcyBzbyB0aGF0IHRoZSBub2RlIGdldHMgcmUtbWVhc3VyZWRcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlQm91bmRzOiBwYXJzZUhhbmRsZXModXNlck5vZGUsIGludGVybmFsTm9kZSksXG4gICAgICAgICAgICAgICAgICAgIHo6IGNhbGN1bGF0ZVoodXNlck5vZGUsIHNlbGVjdGVkTm9kZVopLFxuICAgICAgICAgICAgICAgICAgICB1c2VyTm9kZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG5vZGVMb29rdXAuc2V0KHVzZXJOb2RlLmlkLCBpbnRlcm5hbE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaW50ZXJuYWxOb2RlLm1lYXN1cmVkID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGludGVybmFsTm9kZS5tZWFzdXJlZC53aWR0aCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBpbnRlcm5hbE5vZGUubWVhc3VyZWQuaGVpZ2h0ID09PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAhaW50ZXJuYWxOb2RlLmhpZGRlbikge1xuICAgICAgICAgICAgbm9kZXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VyTm9kZS5wYXJlbnRJZCkge1xuICAgICAgICAgICAgdXBkYXRlQ2hpbGROb2RlKGludGVybmFsTm9kZSwgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBvcHRpb25zLCByb290UGFyZW50SW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2Rlc0luaXRpYWxpemVkO1xufVxuZnVuY3Rpb24gdXBkYXRlUGFyZW50TG9va3VwKG5vZGUsIHBhcmVudExvb2t1cCkge1xuICAgIGlmICghbm9kZS5wYXJlbnRJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBwYXJlbnRMb29rdXAuZ2V0KG5vZGUucGFyZW50SWQpO1xuICAgIGlmIChjaGlsZE5vZGVzKSB7XG4gICAgICAgIGNoaWxkTm9kZXMuc2V0KG5vZGUuaWQsIG5vZGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGFyZW50TG9va3VwLnNldChub2RlLnBhcmVudElkLCBuZXcgTWFwKFtbbm9kZS5pZCwgbm9kZV1dKSk7XG4gICAgfVxufVxuLyoqXG4gKiBVcGRhdGVzIHBvc2l0aW9uQWJzb2x1dGUgYW5kIHpJbmRleCBvZiBhIGNoaWxkIG5vZGUgYW5kIHRoZSBwYXJlbnRMb29rdXAuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkTm9kZShub2RlLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG9wdGlvbnMsIHJvb3RQYXJlbnRJbmRleCkge1xuICAgIGNvbnN0IHsgZWxldmF0ZU5vZGVzT25TZWxlY3QsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQgfSA9IG1lcmdlT2JqZWN0cyhkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgY29uc3QgcGFyZW50SWQgPSBub2RlLnBhcmVudElkO1xuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlTG9va3VwLmdldChwYXJlbnRJZCk7XG4gICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgUGFyZW50IG5vZGUgJHtwYXJlbnRJZH0gbm90IGZvdW5kLiBQbGVhc2UgbWFrZSBzdXJlIHRoYXQgcGFyZW50IG5vZGVzIGFyZSBpbiBmcm9udCBvZiB0aGVpciBjaGlsZCBub2RlcyBpbiB0aGUgbm9kZXMgYXJyYXkuYCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdXBkYXRlUGFyZW50TG9va3VwKG5vZGUsIHBhcmVudExvb2t1cCk7XG4gICAgLy8gV2UganVzdCB3YW50IHRvIHNldCB0aGUgcm9vdFBhcmVudEluZGV4IGZvciB0aGUgZmlyc3QgY2hpbGRcbiAgICBpZiAocm9vdFBhcmVudEluZGV4ICYmICFwYXJlbnROb2RlLnBhcmVudElkICYmIHBhcmVudE5vZGUuaW50ZXJuYWxzLnJvb3RQYXJlbnRJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcmVudE5vZGUuaW50ZXJuYWxzLnJvb3RQYXJlbnRJbmRleCA9ICsrcm9vdFBhcmVudEluZGV4Lmk7XG4gICAgICAgIHBhcmVudE5vZGUuaW50ZXJuYWxzLnogPSBwYXJlbnROb2RlLmludGVybmFscy56ICsgcm9vdFBhcmVudEluZGV4LmkgKiBST09UX1BBUkVOVF9aX0lOQ1JFTUVOVDtcbiAgICB9XG4gICAgLy8gQnV0IHdlIG5lZWQgdG8gdXBkYXRlIHJvb3RQYXJlbnRJbmRleC5pIGFsc28gd2hlbiBwYXJlbnQgaGFzIG5vdCBiZWVuIHVwZGF0ZWRcbiAgICBpZiAocm9vdFBhcmVudEluZGV4ICYmIHBhcmVudE5vZGUuaW50ZXJuYWxzLnJvb3RQYXJlbnRJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJvb3RQYXJlbnRJbmRleC5pID0gcGFyZW50Tm9kZS5pbnRlcm5hbHMucm9vdFBhcmVudEluZGV4O1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3RlZE5vZGVaID0gZWxldmF0ZU5vZGVzT25TZWxlY3QgPyBTRUxFQ1RFRF9OT0RFX1ogOiAwO1xuICAgIGNvbnN0IHsgeCwgeSwgeiB9ID0gY2FsY3VsYXRlQ2hpbGRYWVoobm9kZSwgcGFyZW50Tm9kZSwgbm9kZU9yaWdpbiwgbm9kZUV4dGVudCwgc2VsZWN0ZWROb2RlWik7XG4gICAgY29uc3QgeyBwb3NpdGlvbkFic29sdXRlIH0gPSBub2RlLmludGVybmFscztcbiAgICBjb25zdCBwb3NpdGlvbkNoYW5nZWQgPSB4ICE9PSBwb3NpdGlvbkFic29sdXRlLnggfHwgeSAhPT0gcG9zaXRpb25BYnNvbHV0ZS55O1xuICAgIGlmIChwb3NpdGlvbkNoYW5nZWQgfHwgeiAhPT0gbm9kZS5pbnRlcm5hbHMueikge1xuICAgICAgICAvLyB3ZSBjcmVhdGUgYSBuZXcgb2JqZWN0IHRvIG1hcmsgdGhlIG5vZGUgYXMgdXBkYXRlZFxuICAgICAgICBub2RlTG9va3VwLnNldChub2RlLmlkLCB7XG4gICAgICAgICAgICAuLi5ub2RlLFxuICAgICAgICAgICAgaW50ZXJuYWxzOiB7XG4gICAgICAgICAgICAgICAgLi4ubm9kZS5pbnRlcm5hbHMsXG4gICAgICAgICAgICAgICAgcG9zaXRpb25BYnNvbHV0ZTogcG9zaXRpb25DaGFuZ2VkID8geyB4LCB5IH0gOiBwb3NpdGlvbkFic29sdXRlLFxuICAgICAgICAgICAgICAgIHosXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVaKG5vZGUsIHNlbGVjdGVkTm9kZVopIHtcbiAgICByZXR1cm4gKGlzTnVtZXJpYyhub2RlLnpJbmRleCkgPyBub2RlLnpJbmRleCA6IDApICsgKG5vZGUuc2VsZWN0ZWQgPyBzZWxlY3RlZE5vZGVaIDogMCk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVDaGlsZFhZWihjaGlsZE5vZGUsIHBhcmVudE5vZGUsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQsIHNlbGVjdGVkTm9kZVopIHtcbiAgICBjb25zdCB7IHg6IHBhcmVudFgsIHk6IHBhcmVudFkgfSA9IHBhcmVudE5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGU7XG4gICAgY29uc3QgY2hpbGREaW1lbnNpb25zID0gZ2V0Tm9kZURpbWVuc2lvbnMoY2hpbGROb2RlKTtcbiAgICBjb25zdCBwb3NpdGlvbldpdGhPcmlnaW4gPSBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luKGNoaWxkTm9kZSwgbm9kZU9yaWdpbik7XG4gICAgY29uc3QgY2xhbXBlZFBvc2l0aW9uID0gaXNDb29yZGluYXRlRXh0ZW50KGNoaWxkTm9kZS5leHRlbnQpXG4gICAgICAgID8gY2xhbXBQb3NpdGlvbihwb3NpdGlvbldpdGhPcmlnaW4sIGNoaWxkTm9kZS5leHRlbnQsIGNoaWxkRGltZW5zaW9ucylcbiAgICAgICAgOiBwb3NpdGlvbldpdGhPcmlnaW47XG4gICAgbGV0IGFic29sdXRlUG9zaXRpb24gPSBjbGFtcFBvc2l0aW9uKHsgeDogcGFyZW50WCArIGNsYW1wZWRQb3NpdGlvbi54LCB5OiBwYXJlbnRZICsgY2xhbXBlZFBvc2l0aW9uLnkgfSwgbm9kZUV4dGVudCwgY2hpbGREaW1lbnNpb25zKTtcbiAgICBpZiAoY2hpbGROb2RlLmV4dGVudCA9PT0gJ3BhcmVudCcpIHtcbiAgICAgICAgYWJzb2x1dGVQb3NpdGlvbiA9IGNsYW1wUG9zaXRpb25Ub1BhcmVudChhYnNvbHV0ZVBvc2l0aW9uLCBjaGlsZERpbWVuc2lvbnMsIHBhcmVudE5vZGUpO1xuICAgIH1cbiAgICBjb25zdCBjaGlsZFogPSBjYWxjdWxhdGVaKGNoaWxkTm9kZSwgc2VsZWN0ZWROb2RlWik7XG4gICAgY29uc3QgcGFyZW50WiA9IHBhcmVudE5vZGUuaW50ZXJuYWxzLnogPz8gMDtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBhYnNvbHV0ZVBvc2l0aW9uLngsXG4gICAgICAgIHk6IGFic29sdXRlUG9zaXRpb24ueSxcbiAgICAgICAgejogcGFyZW50WiA+PSBjaGlsZFogPyBwYXJlbnRaICsgMSA6IGNoaWxkWixcbiAgICB9O1xufVxuZnVuY3Rpb24gaGFuZGxlRXhwYW5kUGFyZW50KGNoaWxkcmVuLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG5vZGVPcmlnaW4gPSBbMCwgMF0pIHtcbiAgICBjb25zdCBjaGFuZ2VzID0gW107XG4gICAgY29uc3QgcGFyZW50RXhwYW5zaW9ucyA9IG5ldyBNYXAoKTtcbiAgICAvLyBkZXRlcm1pbmUgdGhlIGV4cGFuZGVkIHJlY3RhbmdsZSB0aGUgY2hpbGQgbm9kZXMgd291bGQgdGFrZSBmb3IgZWFjaCBwYXJlbnRcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGVMb29rdXAuZ2V0KGNoaWxkLnBhcmVudElkKTtcbiAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudFJlY3QgPSBwYXJlbnRFeHBhbnNpb25zLmdldChjaGlsZC5wYXJlbnRJZCk/LmV4cGFuZGVkUmVjdCA/PyBub2RlVG9SZWN0KHBhcmVudCk7XG4gICAgICAgIGNvbnN0IGV4cGFuZGVkUmVjdCA9IGdldEJvdW5kc09mUmVjdHMocGFyZW50UmVjdCwgY2hpbGQucmVjdCk7XG4gICAgICAgIHBhcmVudEV4cGFuc2lvbnMuc2V0KGNoaWxkLnBhcmVudElkLCB7IGV4cGFuZGVkUmVjdCwgcGFyZW50IH0pO1xuICAgIH1cbiAgICBpZiAocGFyZW50RXhwYW5zaW9ucy5zaXplID4gMCkge1xuICAgICAgICBwYXJlbnRFeHBhbnNpb25zLmZvckVhY2goKHsgZXhwYW5kZWRSZWN0LCBwYXJlbnQgfSwgcGFyZW50SWQpID0+IHtcbiAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgcG9zaXRpb24gJiBkaW1lbnNpb25zIG9mIHRoZSBwYXJlbnRcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uQWJzb2x1dGUgPSBwYXJlbnQuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGU7XG4gICAgICAgICAgICBjb25zdCBkaW1lbnNpb25zID0gZ2V0Tm9kZURpbWVuc2lvbnMocGFyZW50KTtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbiA9IHBhcmVudC5vcmlnaW4gPz8gbm9kZU9yaWdpbjtcbiAgICAgICAgICAgIC8vIGRldGVybWluZSBob3cgbXVjaCB0aGUgcGFyZW50IGV4cGFuZHMgaW4gd2lkdGggYW5kIHBvc2l0aW9uXG4gICAgICAgICAgICBjb25zdCB4Q2hhbmdlID0gZXhwYW5kZWRSZWN0LnggPCBwb3NpdGlvbkFic29sdXRlLnggPyBNYXRoLnJvdW5kKE1hdGguYWJzKHBvc2l0aW9uQWJzb2x1dGUueCAtIGV4cGFuZGVkUmVjdC54KSkgOiAwO1xuICAgICAgICAgICAgY29uc3QgeUNoYW5nZSA9IGV4cGFuZGVkUmVjdC55IDwgcG9zaXRpb25BYnNvbHV0ZS55ID8gTWF0aC5yb3VuZChNYXRoLmFicyhwb3NpdGlvbkFic29sdXRlLnkgLSBleHBhbmRlZFJlY3QueSkpIDogMDtcbiAgICAgICAgICAgIGNvbnN0IG5ld1dpZHRoID0gTWF0aC5tYXgoZGltZW5zaW9ucy53aWR0aCwgTWF0aC5yb3VuZChleHBhbmRlZFJlY3Qud2lkdGgpKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0hlaWdodCA9IE1hdGgubWF4KGRpbWVuc2lvbnMuaGVpZ2h0LCBNYXRoLnJvdW5kKGV4cGFuZGVkUmVjdC5oZWlnaHQpKTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoQ2hhbmdlID0gKG5ld1dpZHRoIC0gZGltZW5zaW9ucy53aWR0aCkgKiBvcmlnaW5bMF07XG4gICAgICAgICAgICBjb25zdCBoZWlnaHRDaGFuZ2UgPSAobmV3SGVpZ2h0IC0gZGltZW5zaW9ucy5oZWlnaHQpICogb3JpZ2luWzFdO1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBjb3JyZWN0IHRoZSBwb3NpdGlvbiBvZiB0aGUgcGFyZW50IG5vZGUgaWYgdGhlIG9yaWdpbiBpcyBub3QgWzAsMF1cbiAgICAgICAgICAgIGlmICh4Q2hhbmdlID4gMCB8fCB5Q2hhbmdlID4gMCB8fCB3aWR0aENoYW5nZSB8fCBoZWlnaHRDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogcGFyZW50SWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwb3NpdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBwYXJlbnQucG9zaXRpb24ueCAtIHhDaGFuZ2UgKyB3aWR0aENoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHBhcmVudC5wb3NpdGlvbi55IC0geUNoYW5nZSArIGhlaWdodENoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIFdlIG1vdmUgYWxsIGNoaWxkIG5vZGVzIGluIHRoZSBvcHBzaXRlIGRpcmVjdGlvblxuICAgICAgICAgICAgICAgICAqIHNvIHRoZSB4LHkgY2hhbmdlcyBvZiB0aGUgcGFyZW50IGRvIG5vdCBtb3ZlIHRoZSBjaGlsZHJlblxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHBhcmVudExvb2t1cC5nZXQocGFyZW50SWQpPy5mb3JFYWNoKChjaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZHJlbi5zb21lKChjaGlsZCkgPT4gY2hpbGQuaWQgPT09IGNoaWxkTm9kZS5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGNoaWxkTm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGNoaWxkTm9kZS5wb3NpdGlvbi54ICsgeENoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogY2hpbGROb2RlLnBvc2l0aW9uLnkgKyB5Q2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBjb3JyZWN0IHRoZSBkaW1lbnNpb25zIG9mIHRoZSBwYXJlbnQgbm9kZSBpZiB0aGUgb3JpZ2luIGlzIG5vdCBbMCwwXVxuICAgICAgICAgICAgaWYgKGRpbWVuc2lvbnMud2lkdGggPCBleHBhbmRlZFJlY3Qud2lkdGggfHwgZGltZW5zaW9ucy5oZWlnaHQgPCBleHBhbmRlZFJlY3QuaGVpZ2h0IHx8IHhDaGFuZ2UgfHwgeUNoYW5nZSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBwYXJlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RpbWVuc2lvbnMnLFxuICAgICAgICAgICAgICAgICAgICBzZXRBdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogbmV3V2lkdGggKyAoeENoYW5nZSA/IG9yaWdpblswXSAqIHhDaGFuZ2UgLSB3aWR0aENoYW5nZSA6IDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBuZXdIZWlnaHQgKyAoeUNoYW5nZSA/IG9yaWdpblsxXSAqIHlDaGFuZ2UgLSBoZWlnaHRDaGFuZ2UgOiAwKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VzO1xufVxuZnVuY3Rpb24gdXBkYXRlTm9kZUludGVybmFscyh1cGRhdGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIGRvbU5vZGUsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQpIHtcbiAgICBjb25zdCB2aWV3cG9ydE5vZGUgPSBkb21Ob2RlPy5xdWVyeVNlbGVjdG9yKCcueHlmbG93X192aWV3cG9ydCcpO1xuICAgIGxldCB1cGRhdGVkSW50ZXJuYWxzID0gZmFsc2U7XG4gICAgaWYgKCF2aWV3cG9ydE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogW10sIHVwZGF0ZWRJbnRlcm5hbHMgfTtcbiAgICB9XG4gICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodmlld3BvcnROb2RlKTtcbiAgICBjb25zdCB7IG0yMjogem9vbSB9ID0gbmV3IHdpbmRvdy5ET01NYXRyaXhSZWFkT25seShzdHlsZS50cmFuc2Zvcm0pO1xuICAgIC8vIGluIHRoaXMgYXJyYXkgd2UgY29sbGVjdCBub2RlcywgdGhhdCBtaWdodCB0cmlnZ2VyIGNoYW5nZXMgKGxpa2UgZXhwYW5kaW5nIHBhcmVudClcbiAgICBjb25zdCBwYXJlbnRFeHBhbmRDaGlsZHJlbiA9IFtdO1xuICAgIGZvciAoY29uc3QgdXBkYXRlIG9mIHVwZGF0ZXMudmFsdWVzKCkpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KHVwZGF0ZS5pZCk7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuaGlkZGVuKSB7XG4gICAgICAgICAgICBub2RlTG9va3VwLnNldChub2RlLmlkLCB7XG4gICAgICAgICAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ubm9kZS5pbnRlcm5hbHMsXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUJvdW5kczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHVwZGF0ZWRJbnRlcm5hbHMgPSB0cnVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGltZW5zaW9ucyA9IGdldERpbWVuc2lvbnModXBkYXRlLm5vZGVFbGVtZW50KTtcbiAgICAgICAgY29uc3QgZGltZW5zaW9uQ2hhbmdlZCA9IG5vZGUubWVhc3VyZWQud2lkdGggIT09IGRpbWVuc2lvbnMud2lkdGggfHwgbm9kZS5tZWFzdXJlZC5oZWlnaHQgIT09IGRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICBjb25zdCBkb1VwZGF0ZSA9ICEhKGRpbWVuc2lvbnMud2lkdGggJiZcbiAgICAgICAgICAgIGRpbWVuc2lvbnMuaGVpZ2h0ICYmXG4gICAgICAgICAgICAoZGltZW5zaW9uQ2hhbmdlZCB8fCAhbm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzIHx8IHVwZGF0ZS5mb3JjZSkpO1xuICAgICAgICBpZiAoZG9VcGRhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVCb3VuZHMgPSB1cGRhdGUubm9kZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBjb25zdCBleHRlbnQgPSBpc0Nvb3JkaW5hdGVFeHRlbnQobm9kZS5leHRlbnQpID8gbm9kZS5leHRlbnQgOiBub2RlRXh0ZW50O1xuICAgICAgICAgICAgbGV0IHsgcG9zaXRpb25BYnNvbHV0ZSB9ID0gbm9kZS5pbnRlcm5hbHM7XG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnRJZCAmJiBub2RlLmV4dGVudCA9PT0gJ3BhcmVudCcpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkFic29sdXRlID0gY2xhbXBQb3NpdGlvblRvUGFyZW50KHBvc2l0aW9uQWJzb2x1dGUsIGRpbWVuc2lvbnMsIG5vZGVMb29rdXAuZ2V0KG5vZGUucGFyZW50SWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV4dGVudCkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uQWJzb2x1dGUgPSBjbGFtcFBvc2l0aW9uKHBvc2l0aW9uQWJzb2x1dGUsIGV4dGVudCwgZGltZW5zaW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXdOb2RlID0ge1xuICAgICAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICAgICAgbWVhc3VyZWQ6IGRpbWVuc2lvbnMsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxzOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLm5vZGUuaW50ZXJuYWxzLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkFic29sdXRlLFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVCb3VuZHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogZ2V0SGFuZGxlQm91bmRzKCdzb3VyY2UnLCB1cGRhdGUubm9kZUVsZW1lbnQsIG5vZGVCb3VuZHMsIHpvb20sIG5vZGUuaWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBnZXRIYW5kbGVCb3VuZHMoJ3RhcmdldCcsIHVwZGF0ZS5ub2RlRWxlbWVudCwgbm9kZUJvdW5kcywgem9vbSwgbm9kZS5pZCksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBub2RlTG9va3VwLnNldChub2RlLmlkLCBuZXdOb2RlKTtcbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlQ2hpbGROb2RlKG5ld05vZGUsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgeyBub2RlT3JpZ2luIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlZEludGVybmFscyA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZGltZW5zaW9uQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBub2RlLmlkLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGltZW5zaW9ucycsXG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZXhwYW5kUGFyZW50ICYmIG5vZGUucGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RXhwYW5kQ2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiBub2RlLnBhcmVudElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdDogbm9kZVRvUmVjdChuZXdOb2RlLCBub2RlT3JpZ2luKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJlbnRFeHBhbmRDaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudEV4cGFuZENoYW5nZXMgPSBoYW5kbGVFeHBhbmRQYXJlbnQocGFyZW50RXhwYW5kQ2hpbGRyZW4sIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgbm9kZU9yaWdpbik7XG4gICAgICAgIGNoYW5nZXMucHVzaCguLi5wYXJlbnRFeHBhbmRDaGFuZ2VzKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY2hhbmdlcywgdXBkYXRlZEludGVybmFscyB9O1xufVxuYXN5bmMgZnVuY3Rpb24gcGFuQnkoeyBkZWx0YSwgcGFuWm9vbSwgdHJhbnNmb3JtLCB0cmFuc2xhdGVFeHRlbnQsIHdpZHRoLCBoZWlnaHQsIH0pIHtcbiAgICBpZiAoIXBhblpvb20gfHwgKCFkZWx0YS54ICYmICFkZWx0YS55KSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICB9XG4gICAgY29uc3QgbmV4dFZpZXdwb3J0ID0gYXdhaXQgcGFuWm9vbS5zZXRWaWV3cG9ydENvbnN0cmFpbmVkKHtcbiAgICAgICAgeDogdHJhbnNmb3JtWzBdICsgZGVsdGEueCxcbiAgICAgICAgeTogdHJhbnNmb3JtWzFdICsgZGVsdGEueSxcbiAgICAgICAgem9vbTogdHJhbnNmb3JtWzJdLFxuICAgIH0sIFtcbiAgICAgICAgWzAsIDBdLFxuICAgICAgICBbd2lkdGgsIGhlaWdodF0sXG4gICAgXSwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICBjb25zdCB0cmFuc2Zvcm1DaGFuZ2VkID0gISFuZXh0Vmlld3BvcnQgJiZcbiAgICAgICAgKG5leHRWaWV3cG9ydC54ICE9PSB0cmFuc2Zvcm1bMF0gfHwgbmV4dFZpZXdwb3J0LnkgIT09IHRyYW5zZm9ybVsxXSB8fCBuZXh0Vmlld3BvcnQuayAhPT0gdHJhbnNmb3JtWzJdKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRyYW5zZm9ybUNoYW5nZWQpO1xufVxuLyoqXG4gKiB0aGlzIGZ1bmN0aW9uIGFkZHMgdGhlIGNvbm5lY3Rpb24gdG8gdGhlIGNvbm5lY3Rpb25Mb29rdXBcbiAqIGF0IHRoZSBmb2xsb3dpbmcga2V5czogbm9kZUlkLXR5cGUtaGFuZGxlSWQsIG5vZGVJZC10eXBlIGFuZCBub2RlSWRcbiAqIEBwYXJhbSB0eXBlIHR5cGUgb2YgdGhlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSBjb25uZWN0aW9uIGNvbm5lY3Rpb24gdGhhdCBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIGxvb2t1cFxuICogQHBhcmFtIGNvbm5lY3Rpb25LZXkgYXQgd2hpY2gga2V5IHRoZSBjb25uZWN0aW9uIHNob3VsZCBiZSBhZGRlZFxuICogQHBhcmFtIGNvbm5lY3Rpb25Mb29rdXAgcmVmZXJlbmNlIHRvIHRoZSBjb25uZWN0aW9uIGxvb2t1cFxuICogQHBhcmFtIG5vZGVJZCBub2RlSWQgb2YgdGhlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSBoYW5kbGVJZCBoYW5kbGVJZCBvZiB0aGUgY29ubmVjaXRvblxuICovXG5mdW5jdGlvbiBhZGRDb25uZWN0aW9uVG9Mb29rdXAodHlwZSwgY29ubmVjdGlvbiwgY29ubmVjdGlvbktleSwgY29ubmVjdGlvbkxvb2t1cCwgbm9kZUlkLCBoYW5kbGVJZCkge1xuICAgIC8qXG4gICAgICogV2UgYWRkIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBjb25uZWN0aW9uTG9va3VwIGF0IHRoZSBmb2xsb3dpbmcga2V5c1xuICAgICAqIDEuIG5vZGVJZCwgMi4gbm9kZUlkLXR5cGUsIDMuIG5vZGVJZC10eXBlLWhhbmRsZUlkXG4gICAgICogSWYgdGhlIGtleSBhbHJlYWR5IGV4aXN0cywgd2UgYWRkIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBleGlzdGluZyBtYXBcbiAgICAgKi9cbiAgICBsZXQga2V5ID0gbm9kZUlkO1xuICAgIGNvbnN0IG5vZGVNYXAgPSBjb25uZWN0aW9uTG9va3VwLmdldChrZXkpIHx8IG5ldyBNYXAoKTtcbiAgICBjb25uZWN0aW9uTG9va3VwLnNldChrZXksIG5vZGVNYXAuc2V0KGNvbm5lY3Rpb25LZXksIGNvbm5lY3Rpb24pKTtcbiAgICBrZXkgPSBgJHtub2RlSWR9LSR7dHlwZX1gO1xuICAgIGNvbnN0IHR5cGVNYXAgPSBjb25uZWN0aW9uTG9va3VwLmdldChrZXkpIHx8IG5ldyBNYXAoKTtcbiAgICBjb25uZWN0aW9uTG9va3VwLnNldChrZXksIHR5cGVNYXAuc2V0KGNvbm5lY3Rpb25LZXksIGNvbm5lY3Rpb24pKTtcbiAgICBpZiAoaGFuZGxlSWQpIHtcbiAgICAgICAga2V5ID0gYCR7bm9kZUlkfS0ke3R5cGV9LSR7aGFuZGxlSWR9YDtcbiAgICAgICAgY29uc3QgaGFuZGxlTWFwID0gY29ubmVjdGlvbkxvb2t1cC5nZXQoa2V5KSB8fCBuZXcgTWFwKCk7XG4gICAgICAgIGNvbm5lY3Rpb25Mb29rdXAuc2V0KGtleSwgaGFuZGxlTWFwLnNldChjb25uZWN0aW9uS2V5LCBjb25uZWN0aW9uKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlQ29ubmVjdGlvbkxvb2t1cChjb25uZWN0aW9uTG9va3VwLCBlZGdlTG9va3VwLCBlZGdlcykge1xuICAgIGNvbm5lY3Rpb25Mb29rdXAuY2xlYXIoKTtcbiAgICBlZGdlTG9va3VwLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCBlZGdlIG9mIGVkZ2VzKSB7XG4gICAgICAgIGNvbnN0IHsgc291cmNlOiBzb3VyY2VOb2RlLCB0YXJnZXQ6IHRhcmdldE5vZGUsIHNvdXJjZUhhbmRsZSA9IG51bGwsIHRhcmdldEhhbmRsZSA9IG51bGwgfSA9IGVkZ2U7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB7IGVkZ2VJZDogZWRnZS5pZCwgc291cmNlOiBzb3VyY2VOb2RlLCB0YXJnZXQ6IHRhcmdldE5vZGUsIHNvdXJjZUhhbmRsZSwgdGFyZ2V0SGFuZGxlIH07XG4gICAgICAgIGNvbnN0IHNvdXJjZUtleSA9IGAke3NvdXJjZU5vZGV9LSR7c291cmNlSGFuZGxlfS0tJHt0YXJnZXROb2RlfS0ke3RhcmdldEhhbmRsZX1gO1xuICAgICAgICBjb25zdCB0YXJnZXRLZXkgPSBgJHt0YXJnZXROb2RlfS0ke3RhcmdldEhhbmRsZX0tLSR7c291cmNlTm9kZX0tJHtzb3VyY2VIYW5kbGV9YDtcbiAgICAgICAgYWRkQ29ubmVjdGlvblRvTG9va3VwKCdzb3VyY2UnLCBjb25uZWN0aW9uLCB0YXJnZXRLZXksIGNvbm5lY3Rpb25Mb29rdXAsIHNvdXJjZU5vZGUsIHNvdXJjZUhhbmRsZSk7XG4gICAgICAgIGFkZENvbm5lY3Rpb25Ub0xvb2t1cCgndGFyZ2V0JywgY29ubmVjdGlvbiwgc291cmNlS2V5LCBjb25uZWN0aW9uTG9va3VwLCB0YXJnZXROb2RlLCB0YXJnZXRIYW5kbGUpO1xuICAgICAgICBlZGdlTG9va3VwLnNldChlZGdlLmlkLCBlZGdlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNoYWxsb3dOb2RlRGF0YShhLCBiKSB7XG4gICAgaWYgKGEgPT09IG51bGwgfHwgYiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IF9hID0gQXJyYXkuaXNBcnJheShhKSA/IGEgOiBbYV07XG4gICAgY29uc3QgX2IgPSBBcnJheS5pc0FycmF5KGIpID8gYiA6IFtiXTtcbiAgICBpZiAoX2EubGVuZ3RoICE9PSBfYi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IF9hLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChfYVtpXS5pZCAhPT0gX2JbaV0uaWQgfHwgX2FbaV0udHlwZSAhPT0gX2JbaV0udHlwZSB8fCAhT2JqZWN0LmlzKF9hW2ldLmRhdGEsIF9iW2ldLmRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzUGFyZW50U2VsZWN0ZWQobm9kZSwgbm9kZUxvb2t1cCkge1xuICAgIGlmICghbm9kZS5wYXJlbnRJZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlTG9va3VwLmdldChub2RlLnBhcmVudElkKTtcbiAgICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGFyZW50Tm9kZS5zZWxlY3RlZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzUGFyZW50U2VsZWN0ZWQocGFyZW50Tm9kZSwgbm9kZUxvb2t1cCk7XG59XG5mdW5jdGlvbiBoYXNTZWxlY3Rvcih0YXJnZXQsIHNlbGVjdG9yLCBkb21Ob2RlKSB7XG4gICAgbGV0IGN1cnJlbnQgPSB0YXJnZXQ7XG4gICAgZG8ge1xuICAgICAgICBpZiAoY3VycmVudD8ubWF0Y2hlcz8uKHNlbGVjdG9yKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoY3VycmVudCA9PT0gZG9tTm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQ/LnBhcmVudEVsZW1lbnQ7XG4gICAgfSB3aGlsZSAoY3VycmVudCk7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gbG9va3MgZm9yIGFsbCBzZWxlY3RlZCBub2RlcyBhbmQgY3JlYXRlZCBhIE5vZGVEcmFnSXRlbSBmb3IgZWFjaCBvZiB0aGVtXG5mdW5jdGlvbiBnZXREcmFnSXRlbXMobm9kZUxvb2t1cCwgbm9kZXNEcmFnZ2FibGUsIG1vdXNlUG9zLCBub2RlSWQpIHtcbiAgICBjb25zdCBkcmFnSXRlbXMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBbaWQsIG5vZGVdIG9mIG5vZGVMb29rdXApIHtcbiAgICAgICAgaWYgKChub2RlLnNlbGVjdGVkIHx8IG5vZGUuaWQgPT09IG5vZGVJZCkgJiZcbiAgICAgICAgICAgICghbm9kZS5wYXJlbnRJZCB8fCAhaXNQYXJlbnRTZWxlY3RlZChub2RlLCBub2RlTG9va3VwKSkgJiZcbiAgICAgICAgICAgIChub2RlLmRyYWdnYWJsZSB8fCAobm9kZXNEcmFnZ2FibGUgJiYgdHlwZW9mIG5vZGUuZHJhZ2dhYmxlID09PSAndW5kZWZpbmVkJykpKSB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcm5hbE5vZGUgPSBub2RlTG9va3VwLmdldChpZCk7XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWxOb2RlKSB7XG4gICAgICAgICAgICAgICAgZHJhZ0l0ZW1zLnNldChpZCwge1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGludGVybmFsTm9kZS5wb3NpdGlvbiB8fCB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IG1vdXNlUG9zLnggLSBpbnRlcm5hbE5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IG1vdXNlUG9zLnkgLSBpbnRlcm5hbE5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW50OiBpbnRlcm5hbE5vZGUuZXh0ZW50LFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZDogaW50ZXJuYWxOb2RlLnBhcmVudElkLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW46IGludGVybmFsTm9kZS5vcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZFBhcmVudDogaW50ZXJuYWxOb2RlLmV4cGFuZFBhcmVudCxcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkFic29sdXRlOiBpbnRlcm5hbE5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUgfHwgeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG1lYXN1cmVkOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogaW50ZXJuYWxOb2RlLm1lYXN1cmVkLndpZHRoID8/IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGludGVybmFsTm9kZS5tZWFzdXJlZC5oZWlnaHQgPz8gMCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZHJhZ0l0ZW1zO1xufVxuLypcbiAqIHJldHVybnMgdHdvIHBhcmFtczpcbiAqIDEuIHRoZSBkcmFnZ2VkIG5vZGUgKG9yIHRoZSBmaXJzdCBvZiB0aGUgbGlzdCwgaWYgd2UgYXJlIGRyYWdnaW5nIGEgbm9kZSBzZWxlY3Rpb24pXG4gKiAyLiBhcnJheSBvZiBzZWxlY3RlZCBub2RlcyAoZm9yIG11bHRpIHNlbGVjdGlvbnMpXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW50SGFuZGxlclBhcmFtcyh7IG5vZGVJZCwgZHJhZ0l0ZW1zLCBub2RlTG9va3VwLCBkcmFnZ2luZyA9IHRydWUsIH0pIHtcbiAgICBjb25zdCBub2Rlc0Zyb21EcmFnSXRlbXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtpZCwgZHJhZ0l0ZW1dIG9mIGRyYWdJdGVtcykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZUxvb2t1cC5nZXQoaWQpPy5pbnRlcm5hbHMudXNlck5vZGU7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBub2Rlc0Zyb21EcmFnSXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogZHJhZ0l0ZW0ucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW5vZGVJZCkge1xuICAgICAgICByZXR1cm4gW25vZGVzRnJvbURyYWdJdGVtc1swXSwgbm9kZXNGcm9tRHJhZ0l0ZW1zXTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KG5vZGVJZCk/LmludGVybmFscy51c2VyTm9kZTtcbiAgICByZXR1cm4gW1xuICAgICAgICAhbm9kZVxuICAgICAgICAgICAgPyBub2Rlc0Zyb21EcmFnSXRlbXNbMF1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGRyYWdJdGVtcy5nZXQobm9kZUlkKT8ucG9zaXRpb24gfHwgbm9kZS5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICBkcmFnZ2luZyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIG5vZGVzRnJvbURyYWdJdGVtcyxcbiAgICBdO1xufVxuLyoqXG4gKiBJZiBhIHNlbGVjdGlvbiBpcyBiZWluZyBkcmFnZ2VkIHdlIHdhbnQgdG8gYXBwbHkgdGhlIHNhbWUgc25hcCBvZmZzZXQgdG8gYWxsIG5vZGVzIGluIHRoZSBzZWxlY3Rpb24uXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIHNuYXAgb2Zmc2V0IGJhc2VkIG9uIHRoZSBmaXJzdCBub2RlIGluIHRoZSBzZWxlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZVNuYXBPZmZzZXQoeyBkcmFnSXRlbXMsIHNuYXBHcmlkLCB4LCB5LCB9KSB7XG4gICAgY29uc3QgcmVmRHJhZ0l0ZW0gPSBkcmFnSXRlbXMudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuICAgIGlmICghcmVmRHJhZ0l0ZW0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlZlBvcyA9IHtcbiAgICAgICAgeDogeCAtIHJlZkRyYWdJdGVtLmRpc3RhbmNlLngsXG4gICAgICAgIHk6IHkgLSByZWZEcmFnSXRlbS5kaXN0YW5jZS55LFxuICAgIH07XG4gICAgY29uc3QgcmVmUG9zU25hcHBlZCA9IHNuYXBQb3NpdGlvbihyZWZQb3MsIHNuYXBHcmlkKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiByZWZQb3NTbmFwcGVkLnggLSByZWZQb3MueCxcbiAgICAgICAgeTogcmVmUG9zU25hcHBlZC55IC0gcmVmUG9zLnksXG4gICAgfTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIFhZRHJhZyh7IG9uTm9kZU1vdXNlRG93biwgZ2V0U3RvcmVJdGVtcywgb25EcmFnU3RhcnQsIG9uRHJhZywgb25EcmFnU3RvcCwgfSkge1xuICAgIGxldCBsYXN0UG9zID0geyB4OiBudWxsLCB5OiBudWxsIH07XG4gICAgbGV0IGF1dG9QYW5JZCA9IDA7XG4gICAgbGV0IGRyYWdJdGVtcyA9IG5ldyBNYXAoKTtcbiAgICBsZXQgYXV0b1BhblN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBsZXQgbW91c2VQb3NpdGlvbiA9IHsgeDogMCwgeTogMCB9O1xuICAgIGxldCBjb250YWluZXJCb3VuZHMgPSBudWxsO1xuICAgIGxldCBkcmFnU3RhcnRlZCA9IGZhbHNlO1xuICAgIGxldCBkM1NlbGVjdGlvbiA9IG51bGw7XG4gICAgbGV0IGFib3J0RHJhZyA9IGZhbHNlOyAvLyBwcmV2ZW50cyB1bmludGVudGlvbmFsIGRyYWdnaW5nIG9uIG11bHRpdG91Y2hcbiAgICBsZXQgbm9kZVBvc2l0aW9uc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAvLyB3ZSBzdG9yZSB0aGUgbGFzdCBkcmFnIGV2ZW50IHRvIGJlIGFibGUgdG8gdXNlIGl0IGluIHRoZSB1cGRhdGUgZnVuY3Rpb25cbiAgICBsZXQgZHJhZ0V2ZW50ID0gbnVsbDtcbiAgICAvLyBwdWJsaWMgZnVuY3Rpb25zXG4gICAgZnVuY3Rpb24gdXBkYXRlKHsgbm9EcmFnQ2xhc3NOYW1lLCBoYW5kbGVTZWxlY3RvciwgZG9tTm9kZSwgaXNTZWxlY3RhYmxlLCBub2RlSWQsIG5vZGVDbGlja0Rpc3RhbmNlID0gMCwgfSkge1xuICAgICAgICBkM1NlbGVjdGlvbiA9IHNlbGVjdChkb21Ob2RlKTtcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlTm9kZXMoeyB4LCB5IH0pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgbm9kZUV4dGVudCwgc25hcEdyaWQsIHNuYXBUb0dyaWQsIG5vZGVPcmlnaW4sIG9uTm9kZURyYWcsIG9uU2VsZWN0aW9uRHJhZywgb25FcnJvciwgdXBkYXRlTm9kZVBvc2l0aW9ucywgfSA9IGdldFN0b3JlSXRlbXMoKTtcbiAgICAgICAgICAgIGxhc3RQb3MgPSB7IHgsIHkgfTtcbiAgICAgICAgICAgIGxldCBoYXNDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGlzTXVsdGlEcmFnID0gZHJhZ0l0ZW1zLnNpemUgPiAxO1xuICAgICAgICAgICAgY29uc3Qgbm9kZXNCb3ggPSBpc011bHRpRHJhZyAmJiBub2RlRXh0ZW50ID8gcmVjdFRvQm94KGdldEludGVybmFsTm9kZXNCb3VuZHMoZHJhZ0l0ZW1zKSkgOiBudWxsO1xuICAgICAgICAgICAgY29uc3QgbXVsdGlEcmFnU25hcE9mZnNldCA9IGlzTXVsdGlEcmFnICYmIHNuYXBUb0dyaWRcbiAgICAgICAgICAgICAgICA/IGNhbGN1bGF0ZVNuYXBPZmZzZXQoe1xuICAgICAgICAgICAgICAgICAgICBkcmFnSXRlbXMsXG4gICAgICAgICAgICAgICAgICAgIHNuYXBHcmlkLFxuICAgICAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaWQsIGRyYWdJdGVtXSBvZiBkcmFnSXRlbXMpIHtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIGlmIHRoZSBub2RlIGlzIG5vdCBpbiB0aGUgbm9kZUxvb2t1cCBhbnltb3JlLCBpdCB3YXMgcHJvYmFibHkgZGVsZXRlZCB3aGlsZSBkcmFnZ2luZ1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmICghbm9kZUxvb2t1cC5oYXMoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbmV4dFBvc2l0aW9uID0geyB4OiB4IC0gZHJhZ0l0ZW0uZGlzdGFuY2UueCwgeTogeSAtIGRyYWdJdGVtLmRpc3RhbmNlLnkgfTtcbiAgICAgICAgICAgICAgICBpZiAoc25hcFRvR3JpZCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0UG9zaXRpb24gPSBtdWx0aURyYWdTbmFwT2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBNYXRoLnJvdW5kKG5leHRQb3NpdGlvbi54ICsgbXVsdGlEcmFnU25hcE9mZnNldC54KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBNYXRoLnJvdW5kKG5leHRQb3NpdGlvbi55ICsgbXVsdGlEcmFnU25hcE9mZnNldC55KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogc25hcFBvc2l0aW9uKG5leHRQb3NpdGlvbiwgc25hcEdyaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgYWRqdXN0ZWROb2RlRXh0ZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoaXNNdWx0aURyYWcgJiYgbm9kZUV4dGVudCAmJiAhZHJhZ0l0ZW0uZXh0ZW50ICYmIG5vZGVzQm94KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcG9zaXRpb25BYnNvbHV0ZSB9ID0gZHJhZ0l0ZW0uaW50ZXJuYWxzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB4MSA9IHBvc2l0aW9uQWJzb2x1dGUueCAtIG5vZGVzQm94LnggKyBub2RlRXh0ZW50WzBdWzBdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB4MiA9IHBvc2l0aW9uQWJzb2x1dGUueCArIGRyYWdJdGVtLm1lYXN1cmVkLndpZHRoIC0gbm9kZXNCb3gueDIgKyBub2RlRXh0ZW50WzFdWzBdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB5MSA9IHBvc2l0aW9uQWJzb2x1dGUueSAtIG5vZGVzQm94LnkgKyBub2RlRXh0ZW50WzBdWzFdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB5MiA9IHBvc2l0aW9uQWJzb2x1dGUueSArIGRyYWdJdGVtLm1lYXN1cmVkLmhlaWdodCAtIG5vZGVzQm94LnkyICsgbm9kZUV4dGVudFsxXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgYWRqdXN0ZWROb2RlRXh0ZW50ID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgW3gxLCB5MV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBbeDIsIHkyXSxcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwb3NpdGlvbiwgcG9zaXRpb25BYnNvbHV0ZSB9ID0gY2FsY3VsYXRlTm9kZVBvc2l0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZUlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICAgICAgICAgICAgICBub2RlRXh0ZW50OiBhZGp1c3RlZE5vZGVFeHRlbnQgPyBhZGp1c3RlZE5vZGVFeHRlbnQgOiBub2RlRXh0ZW50LFxuICAgICAgICAgICAgICAgICAgICBub2RlT3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgd2Ugb25seSBmaXJlIGEgY2hhbmdlIGV2ZW50IHdoZW4gdGhlcmUgaXMgYSBjaGFuZ2VcbiAgICAgICAgICAgICAgICBoYXNDaGFuZ2UgPSBoYXNDaGFuZ2UgfHwgZHJhZ0l0ZW0ucG9zaXRpb24ueCAhPT0gcG9zaXRpb24ueCB8fCBkcmFnSXRlbS5wb3NpdGlvbi55ICE9PSBwb3NpdGlvbi55O1xuICAgICAgICAgICAgICAgIGRyYWdJdGVtLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgZHJhZ0l0ZW0uaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUgPSBwb3NpdGlvbkFic29sdXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZVBvc2l0aW9uc0NoYW5nZWQgPSBub2RlUG9zaXRpb25zQ2hhbmdlZCB8fCBoYXNDaGFuZ2U7XG4gICAgICAgICAgICBpZiAoIWhhc0NoYW5nZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZU5vZGVQb3NpdGlvbnMoZHJhZ0l0ZW1zLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChkcmFnRXZlbnQgJiYgKG9uRHJhZyB8fCBvbk5vZGVEcmFnIHx8ICghbm9kZUlkICYmIG9uU2VsZWN0aW9uRHJhZykpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2N1cnJlbnROb2RlLCBjdXJyZW50Tm9kZXNdID0gZ2V0RXZlbnRIYW5kbGVyUGFyYW1zKHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgICAgICAgICBkcmFnSXRlbXMsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb25EcmFnPy4oZHJhZ0V2ZW50LCBkcmFnSXRlbXMsIGN1cnJlbnROb2RlLCBjdXJyZW50Tm9kZXMpO1xuICAgICAgICAgICAgICAgIG9uTm9kZURyYWc/LihkcmFnRXZlbnQsIGN1cnJlbnROb2RlLCBjdXJyZW50Tm9kZXMpO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uU2VsZWN0aW9uRHJhZz8uKGRyYWdFdmVudCwgY3VycmVudE5vZGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gYXV0b1BhbigpIHtcbiAgICAgICAgICAgIGlmICghY29udGFpbmVyQm91bmRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm0sIHBhbkJ5LCBhdXRvUGFuU3BlZWQsIGF1dG9QYW5Pbk5vZGVEcmFnIH0gPSBnZXRTdG9yZUl0ZW1zKCk7XG4gICAgICAgICAgICBpZiAoIWF1dG9QYW5Pbk5vZGVEcmFnKSB7XG4gICAgICAgICAgICAgICAgYXV0b1BhblN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhdXRvUGFuSWQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFt4TW92ZW1lbnQsIHlNb3ZlbWVudF0gPSBjYWxjQXV0b1Bhbihtb3VzZVBvc2l0aW9uLCBjb250YWluZXJCb3VuZHMsIGF1dG9QYW5TcGVlZCk7XG4gICAgICAgICAgICBpZiAoeE1vdmVtZW50ICE9PSAwIHx8IHlNb3ZlbWVudCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGxhc3RQb3MueCA9IChsYXN0UG9zLnggPz8gMCkgLSB4TW92ZW1lbnQgLyB0cmFuc2Zvcm1bMl07XG4gICAgICAgICAgICAgICAgbGFzdFBvcy55ID0gKGxhc3RQb3MueSA/PyAwKSAtIHlNb3ZlbWVudCAvIHRyYW5zZm9ybVsyXTtcbiAgICAgICAgICAgICAgICBpZiAoYXdhaXQgcGFuQnkoeyB4OiB4TW92ZW1lbnQsIHk6IHlNb3ZlbWVudCB9KSkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVOb2RlcyhsYXN0UG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdXRvUGFuSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYXV0b1Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3RhcnREcmFnKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIG11bHRpU2VsZWN0aW9uQWN0aXZlLCBub2Rlc0RyYWdnYWJsZSwgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgc2VsZWN0Tm9kZXNPbkRyYWcsIG9uTm9kZURyYWdTdGFydCwgb25TZWxlY3Rpb25EcmFnU3RhcnQsIHVuc2VsZWN0Tm9kZXNBbmRFZGdlcywgfSA9IGdldFN0b3JlSXRlbXMoKTtcbiAgICAgICAgICAgIGRyYWdTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICgoIXNlbGVjdE5vZGVzT25EcmFnIHx8ICFpc1NlbGVjdGFibGUpICYmICFtdWx0aVNlbGVjdGlvbkFjdGl2ZSAmJiBub2RlSWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVMb29rdXAuZ2V0KG5vZGVJZCk/LnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gcmVzZXQgc2VsZWN0ZWQgbm9kZXMgd2hlbiBzZWxlY3ROb2Rlc09uRHJhZz1mYWxzZVxuICAgICAgICAgICAgICAgICAgICB1bnNlbGVjdE5vZGVzQW5kRWRnZXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTZWxlY3RhYmxlICYmIHNlbGVjdE5vZGVzT25EcmFnICYmIG5vZGVJZCkge1xuICAgICAgICAgICAgICAgIG9uTm9kZU1vdXNlRG93bj8uKG5vZGVJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwb2ludGVyUG9zID0gZ2V0UG9pbnRlclBvc2l0aW9uKGV2ZW50LnNvdXJjZUV2ZW50LCB7IHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQsIGNvbnRhaW5lckJvdW5kcyB9KTtcbiAgICAgICAgICAgIGxhc3RQb3MgPSBwb2ludGVyUG9zO1xuICAgICAgICAgICAgZHJhZ0l0ZW1zID0gZ2V0RHJhZ0l0ZW1zKG5vZGVMb29rdXAsIG5vZGVzRHJhZ2dhYmxlLCBwb2ludGVyUG9zLCBub2RlSWQpO1xuICAgICAgICAgICAgaWYgKGRyYWdJdGVtcy5zaXplID4gMCAmJiAob25EcmFnU3RhcnQgfHwgb25Ob2RlRHJhZ1N0YXJ0IHx8ICghbm9kZUlkICYmIG9uU2VsZWN0aW9uRHJhZ1N0YXJ0KSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlc10gPSBnZXRFdmVudEhhbmRsZXJQYXJhbXMoe1xuICAgICAgICAgICAgICAgICAgICBub2RlSWQsXG4gICAgICAgICAgICAgICAgICAgIGRyYWdJdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvbkRyYWdTdGFydD8uKGV2ZW50LnNvdXJjZUV2ZW50LCBkcmFnSXRlbXMsIGN1cnJlbnROb2RlLCBjdXJyZW50Tm9kZXMpO1xuICAgICAgICAgICAgICAgIG9uTm9kZURyYWdTdGFydD8uKGV2ZW50LnNvdXJjZUV2ZW50LCBjdXJyZW50Tm9kZSwgY3VycmVudE5vZGVzKTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVJZCkge1xuICAgICAgICAgICAgICAgICAgICBvblNlbGVjdGlvbkRyYWdTdGFydD8uKGV2ZW50LnNvdXJjZUV2ZW50LCBjdXJyZW50Tm9kZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkM0RyYWdJbnN0YW5jZSA9IGRyYWcoKVxuICAgICAgICAgICAgLmNsaWNrRGlzdGFuY2Uobm9kZUNsaWNrRGlzdGFuY2UpXG4gICAgICAgICAgICAub24oJ3N0YXJ0JywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGRvbU5vZGUsIG5vZGVEcmFnVGhyZXNob2xkLCB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkIH0gPSBnZXRTdG9yZUl0ZW1zKCk7XG4gICAgICAgICAgICBjb250YWluZXJCb3VuZHMgPSBkb21Ob2RlPy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB8fCBudWxsO1xuICAgICAgICAgICAgYWJvcnREcmFnID0gZmFsc2U7XG4gICAgICAgICAgICBub2RlUG9zaXRpb25zQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZHJhZ0V2ZW50ID0gZXZlbnQuc291cmNlRXZlbnQ7XG4gICAgICAgICAgICBpZiAobm9kZURyYWdUaHJlc2hvbGQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdGFydERyYWcoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcG9pbnRlclBvcyA9IGdldFBvaW50ZXJQb3NpdGlvbihldmVudC5zb3VyY2VFdmVudCwgeyB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBjb250YWluZXJCb3VuZHMgfSk7XG4gICAgICAgICAgICBsYXN0UG9zID0gcG9pbnRlclBvcztcbiAgICAgICAgICAgIG1vdXNlUG9zaXRpb24gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50LnNvdXJjZUV2ZW50LCBjb250YWluZXJCb3VuZHMpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdkcmFnJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGF1dG9QYW5Pbk5vZGVEcmFnLCB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBub2RlRHJhZ1RocmVzaG9sZCwgbm9kZUxvb2t1cCB9ID0gZ2V0U3RvcmVJdGVtcygpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRlclBvcyA9IGdldFBvaW50ZXJQb3NpdGlvbihldmVudC5zb3VyY2VFdmVudCwgeyB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBjb250YWluZXJCb3VuZHMgfSk7XG4gICAgICAgICAgICBkcmFnRXZlbnQgPSBldmVudC5zb3VyY2VFdmVudDtcbiAgICAgICAgICAgIGlmICgoZXZlbnQuc291cmNlRXZlbnQudHlwZSA9PT0gJ3RvdWNobW92ZScgJiYgZXZlbnQuc291cmNlRXZlbnQudG91Y2hlcy5sZW5ndGggPiAxKSB8fFxuICAgICAgICAgICAgICAgIC8vIGlmIHVzZXIgZGVsZXRlcyBhIG5vZGUgd2hpbGUgZHJhZ2dpbmcsIHdlIG5lZWQgdG8gYWJvcnQgdGhlIGRyYWcgdG8gcHJldmVudCBlcnJvcnNcbiAgICAgICAgICAgICAgICAobm9kZUlkICYmICFub2RlTG9va3VwLmhhcyhub2RlSWQpKSkge1xuICAgICAgICAgICAgICAgIGFib3J0RHJhZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWJvcnREcmFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhdXRvUGFuU3RhcnRlZCAmJiBhdXRvUGFuT25Ob2RlRHJhZyAmJiBkcmFnU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIGF1dG9QYW5TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhdXRvUGFuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRyYWdTdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlIGluIGNsaWVudCBjb29yZGluYXRlcyBmb3IgY29uc2lzdGVudCBkcmFnIHRocmVzaG9sZCBiZWhhdmlvciBhY3Jvc3Mgem9vbSBsZXZlbHNcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50TW91c2VQb3NpdGlvbiA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQuc291cmNlRXZlbnQsIGNvbnRhaW5lckJvdW5kcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IGN1cnJlbnRNb3VzZVBvc2l0aW9uLnggLSBtb3VzZVBvc2l0aW9uLng7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IGN1cnJlbnRNb3VzZVBvc2l0aW9uLnkgLSBtb3VzZVBvc2l0aW9uLnk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gbm9kZURyYWdUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREcmFnKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBza2lwIGV2ZW50cyB3aXRob3V0IG1vdmVtZW50XG4gICAgICAgICAgICBpZiAoKGxhc3RQb3MueCAhPT0gcG9pbnRlclBvcy54U25hcHBlZCB8fCBsYXN0UG9zLnkgIT09IHBvaW50ZXJQb3MueVNuYXBwZWQpICYmIGRyYWdJdGVtcyAmJiBkcmFnU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIG1vdXNlUG9zaXRpb24gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50LnNvdXJjZUV2ZW50LCBjb250YWluZXJCb3VuZHMpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZU5vZGVzKHBvaW50ZXJQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdlbmQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICghZHJhZ1N0YXJ0ZWQgfHwgYWJvcnREcmFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXV0b1BhblN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGRyYWdTdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhdXRvUGFuSWQpO1xuICAgICAgICAgICAgaWYgKGRyYWdJdGVtcy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgdXBkYXRlTm9kZVBvc2l0aW9ucywgb25Ob2RlRHJhZ1N0b3AsIG9uU2VsZWN0aW9uRHJhZ1N0b3AgfSA9IGdldFN0b3JlSXRlbXMoKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZVBvc2l0aW9uc0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlTm9kZVBvc2l0aW9ucyhkcmFnSXRlbXMsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZVBvc2l0aW9uc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9uRHJhZ1N0b3AgfHwgb25Ob2RlRHJhZ1N0b3AgfHwgKCFub2RlSWQgJiYgb25TZWxlY3Rpb25EcmFnU3RvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2N1cnJlbnROb2RlLCBjdXJyZW50Tm9kZXNdID0gZ2V0RXZlbnRIYW5kbGVyUGFyYW1zKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdJdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBvbkRyYWdTdG9wPy4oZXZlbnQuc291cmNlRXZlbnQsIGRyYWdJdGVtcywgY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgIG9uTm9kZURyYWdTdG9wPy4oZXZlbnQuc291cmNlRXZlbnQsIGN1cnJlbnROb2RlLCBjdXJyZW50Tm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGVJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25TZWxlY3Rpb25EcmFnU3RvcD8uKGV2ZW50LnNvdXJjZUV2ZW50LCBjdXJyZW50Tm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcigoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIGNvbnN0IGlzRHJhZ2dhYmxlID0gIWV2ZW50LmJ1dHRvbiAmJlxuICAgICAgICAgICAgICAgICghbm9EcmFnQ2xhc3NOYW1lIHx8ICFoYXNTZWxlY3Rvcih0YXJnZXQsIGAuJHtub0RyYWdDbGFzc05hbWV9YCwgZG9tTm9kZSkpICYmXG4gICAgICAgICAgICAgICAgKCFoYW5kbGVTZWxlY3RvciB8fCBoYXNTZWxlY3Rvcih0YXJnZXQsIGhhbmRsZVNlbGVjdG9yLCBkb21Ob2RlKSk7XG4gICAgICAgICAgICByZXR1cm4gaXNEcmFnZ2FibGU7XG4gICAgICAgIH0pO1xuICAgICAgICBkM1NlbGVjdGlvbi5jYWxsKGQzRHJhZ0luc3RhbmNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgZDNTZWxlY3Rpb24/Lm9uKCcuZHJhZycsIG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGUsXG4gICAgICAgIGRlc3Ryb3ksXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZXNXaXRoaW5EaXN0YW5jZShwb3NpdGlvbiwgbm9kZUxvb2t1cCwgZGlzdGFuY2UpIHtcbiAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgIGNvbnN0IHJlY3QgPSB7XG4gICAgICAgIHg6IHBvc2l0aW9uLnggLSBkaXN0YW5jZSxcbiAgICAgICAgeTogcG9zaXRpb24ueSAtIGRpc3RhbmNlLFxuICAgICAgICB3aWR0aDogZGlzdGFuY2UgKiAyLFxuICAgICAgICBoZWlnaHQ6IGRpc3RhbmNlICogMixcbiAgICB9O1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2RlTG9va3VwLnZhbHVlcygpKSB7XG4gICAgICAgIGlmIChnZXRPdmVybGFwcGluZ0FyZWEocmVjdCwgbm9kZVRvUmVjdChub2RlKSkgPiAwKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2Rlcztcbn1cbi8qXG4gKiB0aGlzIGRpc3RhbmNlIGlzIHVzZWQgZm9yIHRoZSBhcmVhIGFyb3VuZCB0aGUgdXNlciBwb2ludGVyXG4gKiB3aGlsZSBkb2luZyBhIGNvbm5lY3Rpb24gZm9yIGZpbmRpbmcgdGhlIGNsb3Nlc3Qgbm9kZXNcbiAqL1xuY29uc3QgQURESVRJT05BTF9ESVNUQU5DRSA9IDI1MDtcbmZ1bmN0aW9uIGdldENsb3Nlc3RIYW5kbGUocG9zaXRpb24sIGNvbm5lY3Rpb25SYWRpdXMsIG5vZGVMb29rdXAsIGZyb21IYW5kbGUpIHtcbiAgICBsZXQgY2xvc2VzdEhhbmRsZXMgPSBbXTtcbiAgICBsZXQgbWluRGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICBjb25zdCBjbG9zZU5vZGVzID0gZ2V0Tm9kZXNXaXRoaW5EaXN0YW5jZShwb3NpdGlvbiwgbm9kZUxvb2t1cCwgY29ubmVjdGlvblJhZGl1cyArIEFERElUSU9OQUxfRElTVEFOQ0UpO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBjbG9zZU5vZGVzKSB7XG4gICAgICAgIGNvbnN0IGFsbEhhbmRsZXMgPSBbLi4uKG5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcz8uc291cmNlID8/IFtdKSwgLi4uKG5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcz8udGFyZ2V0ID8/IFtdKV07XG4gICAgICAgIGZvciAoY29uc3QgaGFuZGxlIG9mIGFsbEhhbmRsZXMpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBoYW5kbGUgaXMgdGhlIHNhbWUgYXMgdGhlIGZyb21IYW5kbGUgd2Ugc2tpcCBpdFxuICAgICAgICAgICAgaWYgKGZyb21IYW5kbGUubm9kZUlkID09PSBoYW5kbGUubm9kZUlkICYmIGZyb21IYW5kbGUudHlwZSA9PT0gaGFuZGxlLnR5cGUgJiYgZnJvbUhhbmRsZS5pZCA9PT0gaGFuZGxlLmlkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGhhbmRsZVxuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBnZXRIYW5kbGVQb3NpdGlvbihub2RlLCBoYW5kbGUsIGhhbmRsZS5wb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdyh4IC0gcG9zaXRpb24ueCwgMikgKyBNYXRoLnBvdyh5IC0gcG9zaXRpb24ueSwgMikpO1xuICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gY29ubmVjdGlvblJhZGl1cykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBjbG9zZXN0SGFuZGxlcyA9IFt7IC4uLmhhbmRsZSwgeCwgeSB9XTtcbiAgICAgICAgICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGlzdGFuY2UgPT09IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgLy8gd2hlbiBtdWx0aXBsZSBoYW5kbGVzIGFyZSBvbiB0aGUgc2FtZSBkaXN0YW5jZSB3ZSBjb2xsZWN0IGFsbCBvZiB0aGVtXG4gICAgICAgICAgICAgICAgY2xvc2VzdEhhbmRsZXMucHVzaCh7IC4uLmhhbmRsZSwgeCwgeSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNsb3Nlc3RIYW5kbGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gd2hlbiBtdWx0aXBsZSBoYW5kbGVzIG92ZXJsYXkgZWFjaCBvdGhlciB3ZSBwcmVmZXIgdGhlIG9wcG9zaXRlIGhhbmRsZVxuICAgIGlmIChjbG9zZXN0SGFuZGxlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNvbnN0IG9wcG9zaXRlSGFuZGxlVHlwZSA9IGZyb21IYW5kbGUudHlwZSA9PT0gJ3NvdXJjZScgPyAndGFyZ2V0JyA6ICdzb3VyY2UnO1xuICAgICAgICByZXR1cm4gY2xvc2VzdEhhbmRsZXMuZmluZCgoaGFuZGxlKSA9PiBoYW5kbGUudHlwZSA9PT0gb3Bwb3NpdGVIYW5kbGVUeXBlKSA/PyBjbG9zZXN0SGFuZGxlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb3Nlc3RIYW5kbGVzWzBdO1xufVxuZnVuY3Rpb24gZ2V0SGFuZGxlKG5vZGVJZCwgaGFuZGxlVHlwZSwgaGFuZGxlSWQsIG5vZGVMb29rdXAsIGNvbm5lY3Rpb25Nb2RlLCB3aXRoQWJzb2x1dGVQb3NpdGlvbiA9IGZhbHNlKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KG5vZGVJZCk7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVzID0gY29ubmVjdGlvbk1vZGUgPT09ICdzdHJpY3QnXG4gICAgICAgID8gbm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzPy5baGFuZGxlVHlwZV1cbiAgICAgICAgOiBbLi4uKG5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcz8uc291cmNlID8/IFtdKSwgLi4uKG5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcz8udGFyZ2V0ID8/IFtdKV07XG4gICAgY29uc3QgaGFuZGxlID0gKGhhbmRsZUlkID8gaGFuZGxlcz8uZmluZCgoaCkgPT4gaC5pZCA9PT0gaGFuZGxlSWQpIDogaGFuZGxlcz8uWzBdKSA/PyBudWxsO1xuICAgIHJldHVybiBoYW5kbGUgJiYgd2l0aEFic29sdXRlUG9zaXRpb25cbiAgICAgICAgPyB7IC4uLmhhbmRsZSwgLi4uZ2V0SGFuZGxlUG9zaXRpb24obm9kZSwgaGFuZGxlLCBoYW5kbGUucG9zaXRpb24sIHRydWUpIH1cbiAgICAgICAgOiBoYW5kbGU7XG59XG5mdW5jdGlvbiBnZXRIYW5kbGVUeXBlKGVkZ2VVcGRhdGVyVHlwZSwgaGFuZGxlRG9tTm9kZSkge1xuICAgIGlmIChlZGdlVXBkYXRlclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2VVcGRhdGVyVHlwZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaGFuZGxlRG9tTm9kZT8uY2xhc3NMaXN0LmNvbnRhaW5zKCd0YXJnZXQnKSkge1xuICAgICAgICByZXR1cm4gJ3RhcmdldCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhhbmRsZURvbU5vZGU/LmNsYXNzTGlzdC5jb250YWlucygnc291cmNlJykpIHtcbiAgICAgICAgcmV0dXJuICdzb3VyY2UnO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzQ29ubmVjdGlvblZhbGlkKGlzSW5zaWRlQ29ubmVjdGlvblJhZGl1cywgaXNIYW5kbGVWYWxpZCkge1xuICAgIGxldCBpc1ZhbGlkID0gbnVsbDtcbiAgICBpZiAoaXNIYW5kbGVWYWxpZCkge1xuICAgICAgICBpc1ZhbGlkID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNJbnNpZGVDb25uZWN0aW9uUmFkaXVzICYmICFpc0hhbmRsZVZhbGlkKSB7XG4gICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzVmFsaWQ7XG59XG5cbmNvbnN0IGFsd2F5c1ZhbGlkID0gKCkgPT4gdHJ1ZTtcbmZ1bmN0aW9uIG9uUG9pbnRlckRvd24oZXZlbnQsIHsgY29ubmVjdGlvbk1vZGUsIGNvbm5lY3Rpb25SYWRpdXMsIGhhbmRsZUlkLCBub2RlSWQsIGVkZ2VVcGRhdGVyVHlwZSwgaXNUYXJnZXQsIGRvbU5vZGUsIG5vZGVMb29rdXAsIGxpYiwgYXV0b1Bhbk9uQ29ubmVjdCwgZmxvd0lkLCBwYW5CeSwgY2FuY2VsQ29ubmVjdGlvbiwgb25Db25uZWN0U3RhcnQsIG9uQ29ubmVjdCwgb25Db25uZWN0RW5kLCBpc1ZhbGlkQ29ubmVjdGlvbiA9IGFsd2F5c1ZhbGlkLCBvblJlY29ubmVjdEVuZCwgdXBkYXRlQ29ubmVjdGlvbiwgZ2V0VHJhbnNmb3JtLCBnZXRGcm9tSGFuZGxlLCBhdXRvUGFuU3BlZWQsIGRyYWdUaHJlc2hvbGQgPSAxLCBoYW5kbGVEb21Ob2RlLCB9KSB7XG4gICAgLy8gd2hlbiB4eWZsb3cgaXMgdXNlZCBpbnNpZGUgYSBzaGFkb3cgcm9vdCB3ZSBjYW4ndCB1c2UgZG9jdW1lbnRcbiAgICBjb25zdCBkb2MgPSBnZXRIb3N0Rm9yRWxlbWVudChldmVudC50YXJnZXQpO1xuICAgIGxldCBhdXRvUGFuSWQgPSAwO1xuICAgIGxldCBjbG9zZXN0SGFuZGxlO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudCk7XG4gICAgY29uc3QgaGFuZGxlVHlwZSA9IGdldEhhbmRsZVR5cGUoZWRnZVVwZGF0ZXJUeXBlLCBoYW5kbGVEb21Ob2RlKTtcbiAgICBjb25zdCBjb250YWluZXJCb3VuZHMgPSBkb21Ob2RlPy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgY29ubmVjdGlvblN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBpZiAoIWNvbnRhaW5lckJvdW5kcyB8fCAhaGFuZGxlVHlwZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZyb21IYW5kbGVJbnRlcm5hbCA9IGdldEhhbmRsZShub2RlSWQsIGhhbmRsZVR5cGUsIGhhbmRsZUlkLCBub2RlTG9va3VwLCBjb25uZWN0aW9uTW9kZSk7XG4gICAgaWYgKCFmcm9tSGFuZGxlSW50ZXJuYWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcG9zaXRpb24gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50LCBjb250YWluZXJCb3VuZHMpO1xuICAgIGxldCBhdXRvUGFuU3RhcnRlZCA9IGZhbHNlO1xuICAgIGxldCBjb25uZWN0aW9uID0gbnVsbDtcbiAgICBsZXQgaXNWYWxpZCA9IGZhbHNlO1xuICAgIGxldCByZXN1bHRIYW5kbGVEb21Ob2RlID0gbnVsbDtcbiAgICAvLyB3aGVuIHRoZSB1c2VyIGlzIG1vdmluZyB0aGUgbW91c2UgY2xvc2UgdG8gdGhlIGVkZ2Ugb2YgdGhlIGNhbnZhcyB3aGlsZSBjb25uZWN0aW5nIHdlIG1vdmUgdGhlIGNhbnZhc1xuICAgIGZ1bmN0aW9uIGF1dG9QYW4oKSB7XG4gICAgICAgIGlmICghYXV0b1Bhbk9uQ29ubmVjdCB8fCAhY29udGFpbmVyQm91bmRzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3gsIHldID0gY2FsY0F1dG9QYW4ocG9zaXRpb24sIGNvbnRhaW5lckJvdW5kcywgYXV0b1BhblNwZWVkKTtcbiAgICAgICAgcGFuQnkoeyB4LCB5IH0pO1xuICAgICAgICBhdXRvUGFuSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYXV0b1Bhbik7XG4gICAgfVxuICAgIC8vIFN0YXlzIHRoZSBzYW1lIGZvciBhbGwgY29uc2VjdXRpdmUgcG9pbnRlcm1vdmUgZXZlbnRzXG4gICAgY29uc3QgZnJvbUhhbmRsZSA9IHtcbiAgICAgICAgLi4uZnJvbUhhbmRsZUludGVybmFsLFxuICAgICAgICBub2RlSWQsXG4gICAgICAgIHR5cGU6IGhhbmRsZVR5cGUsXG4gICAgICAgIHBvc2l0aW9uOiBmcm9tSGFuZGxlSW50ZXJuYWwucG9zaXRpb24sXG4gICAgfTtcbiAgICBjb25zdCBmcm9tTm9kZUludGVybmFsID0gbm9kZUxvb2t1cC5nZXQobm9kZUlkKTtcbiAgICBjb25zdCBmcm9tID0gZ2V0SGFuZGxlUG9zaXRpb24oZnJvbU5vZGVJbnRlcm5hbCwgZnJvbUhhbmRsZSwgUG9zaXRpb24uTGVmdCwgdHJ1ZSk7XG4gICAgbGV0IHByZXZpb3VzQ29ubmVjdGlvbiA9IHtcbiAgICAgICAgaW5Qcm9ncmVzczogdHJ1ZSxcbiAgICAgICAgaXNWYWxpZDogbnVsbCxcbiAgICAgICAgZnJvbSxcbiAgICAgICAgZnJvbUhhbmRsZSxcbiAgICAgICAgZnJvbVBvc2l0aW9uOiBmcm9tSGFuZGxlLnBvc2l0aW9uLFxuICAgICAgICBmcm9tTm9kZTogZnJvbU5vZGVJbnRlcm5hbCxcbiAgICAgICAgdG86IHBvc2l0aW9uLFxuICAgICAgICB0b0hhbmRsZTogbnVsbCxcbiAgICAgICAgdG9Qb3NpdGlvbjogb3Bwb3NpdGVQb3NpdGlvbltmcm9tSGFuZGxlLnBvc2l0aW9uXSxcbiAgICAgICAgdG9Ob2RlOiBudWxsLFxuICAgIH07XG4gICAgZnVuY3Rpb24gc3RhcnRDb25uZWN0aW9uKCkge1xuICAgICAgICBjb25uZWN0aW9uU3RhcnRlZCA9IHRydWU7XG4gICAgICAgIHVwZGF0ZUNvbm5lY3Rpb24ocHJldmlvdXNDb25uZWN0aW9uKTtcbiAgICAgICAgb25Db25uZWN0U3RhcnQ/LihldmVudCwgeyBub2RlSWQsIGhhbmRsZUlkLCBoYW5kbGVUeXBlIH0pO1xuICAgIH1cbiAgICBpZiAoZHJhZ1RocmVzaG9sZCA9PT0gMCkge1xuICAgICAgICBzdGFydENvbm5lY3Rpb24oKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Qb2ludGVyTW92ZShldmVudCkge1xuICAgICAgICBpZiAoIWNvbm5lY3Rpb25TdGFydGVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHg6IGV2dFgsIHk6IGV2dFkgfSA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQpO1xuICAgICAgICAgICAgY29uc3QgZHggPSBldnRYIC0geDtcbiAgICAgICAgICAgIGNvbnN0IGR5ID0gZXZ0WSAtIHk7XG4gICAgICAgICAgICBjb25zdCBuZXh0Q29ubmVjdGlvblN0YXJ0ZWQgPSBkeCAqIGR4ICsgZHkgKiBkeSA+IGRyYWdUaHJlc2hvbGQgKiBkcmFnVGhyZXNob2xkO1xuICAgICAgICAgICAgaWYgKCFuZXh0Q29ubmVjdGlvblN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydENvbm5lY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWdldEZyb21IYW5kbGUoKSB8fCAhZnJvbUhhbmRsZSkge1xuICAgICAgICAgICAgb25Qb2ludGVyVXAoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGdldFRyYW5zZm9ybSgpO1xuICAgICAgICBwb3NpdGlvbiA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQsIGNvbnRhaW5lckJvdW5kcyk7XG4gICAgICAgIGNsb3Nlc3RIYW5kbGUgPSBnZXRDbG9zZXN0SGFuZGxlKHBvaW50VG9SZW5kZXJlclBvaW50KHBvc2l0aW9uLCB0cmFuc2Zvcm0sIGZhbHNlLCBbMSwgMV0pLCBjb25uZWN0aW9uUmFkaXVzLCBub2RlTG9va3VwLCBmcm9tSGFuZGxlKTtcbiAgICAgICAgaWYgKCFhdXRvUGFuU3RhcnRlZCkge1xuICAgICAgICAgICAgYXV0b1BhbigpO1xuICAgICAgICAgICAgYXV0b1BhblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGlzVmFsaWRIYW5kbGUoZXZlbnQsIHtcbiAgICAgICAgICAgIGhhbmRsZTogY2xvc2VzdEhhbmRsZSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Nb2RlLFxuICAgICAgICAgICAgZnJvbU5vZGVJZDogbm9kZUlkLFxuICAgICAgICAgICAgZnJvbUhhbmRsZUlkOiBoYW5kbGVJZCxcbiAgICAgICAgICAgIGZyb21UeXBlOiBpc1RhcmdldCA/ICd0YXJnZXQnIDogJ3NvdXJjZScsXG4gICAgICAgICAgICBpc1ZhbGlkQ29ubmVjdGlvbixcbiAgICAgICAgICAgIGRvYyxcbiAgICAgICAgICAgIGxpYixcbiAgICAgICAgICAgIGZsb3dJZCxcbiAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHRIYW5kbGVEb21Ob2RlID0gcmVzdWx0LmhhbmRsZURvbU5vZGU7XG4gICAgICAgIGNvbm5lY3Rpb24gPSByZXN1bHQuY29ubmVjdGlvbjtcbiAgICAgICAgaXNWYWxpZCA9IGlzQ29ubmVjdGlvblZhbGlkKCEhY2xvc2VzdEhhbmRsZSwgcmVzdWx0LmlzVmFsaWQpO1xuICAgICAgICBjb25zdCBuZXdDb25uZWN0aW9uID0ge1xuICAgICAgICAgICAgLy8gZnJvbSBzdGF5cyB0aGUgc2FtZVxuICAgICAgICAgICAgLi4ucHJldmlvdXNDb25uZWN0aW9uLFxuICAgICAgICAgICAgaXNWYWxpZCxcbiAgICAgICAgICAgIHRvOiByZXN1bHQudG9IYW5kbGUgJiYgaXNWYWxpZFxuICAgICAgICAgICAgICAgID8gcmVuZGVyZXJQb2ludFRvUG9pbnQoeyB4OiByZXN1bHQudG9IYW5kbGUueCwgeTogcmVzdWx0LnRvSGFuZGxlLnkgfSwgdHJhbnNmb3JtKVxuICAgICAgICAgICAgICAgIDogcG9zaXRpb24sXG4gICAgICAgICAgICB0b0hhbmRsZTogcmVzdWx0LnRvSGFuZGxlLFxuICAgICAgICAgICAgdG9Qb3NpdGlvbjogaXNWYWxpZCAmJiByZXN1bHQudG9IYW5kbGUgPyByZXN1bHQudG9IYW5kbGUucG9zaXRpb24gOiBvcHBvc2l0ZVBvc2l0aW9uW2Zyb21IYW5kbGUucG9zaXRpb25dLFxuICAgICAgICAgICAgdG9Ob2RlOiByZXN1bHQudG9IYW5kbGUgPyBub2RlTG9va3VwLmdldChyZXN1bHQudG9IYW5kbGUubm9kZUlkKSA6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIC8qXG4gICAgICAgICAqIHdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciBhbiB1cGRhdGUgd2hlbiB0aGUgY29ubmVjdGlvblxuICAgICAgICAgKiBpcyBzbmFwcGVkIHRvIHRoZSBzYW1lIGhhbmRsZSBhcyBiZWZvcmVcbiAgICAgICAgICovXG4gICAgICAgIGlmIChpc1ZhbGlkICYmXG4gICAgICAgICAgICBjbG9zZXN0SGFuZGxlICYmXG4gICAgICAgICAgICBwcmV2aW91c0Nvbm5lY3Rpb24udG9IYW5kbGUgJiZcbiAgICAgICAgICAgIG5ld0Nvbm5lY3Rpb24udG9IYW5kbGUgJiZcbiAgICAgICAgICAgIHByZXZpb3VzQ29ubmVjdGlvbi50b0hhbmRsZS50eXBlID09PSBuZXdDb25uZWN0aW9uLnRvSGFuZGxlLnR5cGUgJiZcbiAgICAgICAgICAgIHByZXZpb3VzQ29ubmVjdGlvbi50b0hhbmRsZS5ub2RlSWQgPT09IG5ld0Nvbm5lY3Rpb24udG9IYW5kbGUubm9kZUlkICYmXG4gICAgICAgICAgICBwcmV2aW91c0Nvbm5lY3Rpb24udG9IYW5kbGUuaWQgPT09IG5ld0Nvbm5lY3Rpb24udG9IYW5kbGUuaWQgJiZcbiAgICAgICAgICAgIHByZXZpb3VzQ29ubmVjdGlvbi50by54ID09PSBuZXdDb25uZWN0aW9uLnRvLnggJiZcbiAgICAgICAgICAgIHByZXZpb3VzQ29ubmVjdGlvbi50by55ID09PSBuZXdDb25uZWN0aW9uLnRvLnkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVDb25uZWN0aW9uKG5ld0Nvbm5lY3Rpb24pO1xuICAgICAgICBwcmV2aW91c0Nvbm5lY3Rpb24gPSBuZXdDb25uZWN0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvblBvaW50ZXJVcChldmVudCkge1xuICAgICAgICAvLyBQcmV2ZW50IG11bHRpLXRvdWNoIGFib3J0aW5nIGNvbm5lY3Rpb25cbiAgICAgICAgaWYgKCd0b3VjaGVzJyBpbiBldmVudCAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ubmVjdGlvblN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGlmICgoY2xvc2VzdEhhbmRsZSB8fCByZXN1bHRIYW5kbGVEb21Ob2RlKSAmJiBjb25uZWN0aW9uICYmIGlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICBvbkNvbm5lY3Q/Lihjb25uZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBpdCdzIGltcG9ydGFudCB0byBnZXQgYSBmcmVzaCByZWZlcmVuY2UgZnJvbSB0aGUgc3RvcmUgaGVyZVxuICAgICAgICAgICAgICogaW4gb3JkZXIgdG8gZ2V0IHRoZSBsYXRlc3Qgc3RhdGUgb2Ygb25Db25uZWN0RW5kXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgIGNvbnN0IHsgaW5Qcm9ncmVzcywgLi4uY29ubmVjdGlvblN0YXRlIH0gPSBwcmV2aW91c0Nvbm5lY3Rpb247XG4gICAgICAgICAgICBjb25zdCBmaW5hbENvbm5lY3Rpb25TdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAuLi5jb25uZWN0aW9uU3RhdGUsXG4gICAgICAgICAgICAgICAgdG9Qb3NpdGlvbjogcHJldmlvdXNDb25uZWN0aW9uLnRvSGFuZGxlID8gcHJldmlvdXNDb25uZWN0aW9uLnRvUG9zaXRpb24gOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG9uQ29ubmVjdEVuZD8uKGV2ZW50LCBmaW5hbENvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgICAgICBpZiAoZWRnZVVwZGF0ZXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgb25SZWNvbm5lY3RFbmQ/LihldmVudCwgZmluYWxDb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhbmNlbENvbm5lY3Rpb24oKTtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYXV0b1BhbklkKTtcbiAgICAgICAgYXV0b1BhblN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICBjb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgcmVzdWx0SGFuZGxlRG9tTm9kZSA9IG51bGw7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvblBvaW50ZXJNb3ZlKTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvblBvaW50ZXJVcCk7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblBvaW50ZXJNb3ZlKTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Qb2ludGVyVXApO1xuICAgIH1cbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Qb2ludGVyTW92ZSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvblBvaW50ZXJVcCk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uUG9pbnRlck1vdmUpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uUG9pbnRlclVwKTtcbn1cbi8vIGNoZWNrcyBpZiAgYW5kIHJldHVybnMgY29ubmVjdGlvbiBpbiBmb20gb2YgYW4gb2JqZWN0IHsgc291cmNlOiAxMjMsIHRhcmdldDogMzEyIH1cbmZ1bmN0aW9uIGlzVmFsaWRIYW5kbGUoZXZlbnQsIHsgaGFuZGxlLCBjb25uZWN0aW9uTW9kZSwgZnJvbU5vZGVJZCwgZnJvbUhhbmRsZUlkLCBmcm9tVHlwZSwgZG9jLCBsaWIsIGZsb3dJZCwgaXNWYWxpZENvbm5lY3Rpb24gPSBhbHdheXNWYWxpZCwgbm9kZUxvb2t1cCwgfSkge1xuICAgIGNvbnN0IGlzVGFyZ2V0ID0gZnJvbVR5cGUgPT09ICd0YXJnZXQnO1xuICAgIGNvbnN0IGhhbmRsZURvbU5vZGUgPSBoYW5kbGVcbiAgICAgICAgPyBkb2MucXVlcnlTZWxlY3RvcihgLiR7bGlifS1mbG93X19oYW5kbGVbZGF0YS1pZD1cIiR7Zmxvd0lkfS0ke2hhbmRsZT8ubm9kZUlkfS0ke2hhbmRsZT8uaWR9LSR7aGFuZGxlPy50eXBlfVwiXWApXG4gICAgICAgIDogbnVsbDtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQpO1xuICAgIGNvbnN0IGhhbmRsZUJlbG93ID0gZG9jLmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgLypcbiAgICAgKiB3ZSBhbHdheXMgd2FudCB0byBwcmlvcml0aXplIHRoZSBoYW5kbGUgYmVsb3cgdGhlIG1vdXNlIGN1cnNvciBvdmVyIHRoZSBjbG9zZXN0IGRpc3RhbmNlIGhhbmRsZSxcbiAgICAgKiBiZWNhdXNlIGl0IGNvdWxkIGJlIHRoYXQgdGhlIGNlbnRlciBvZiBhbm90aGVyIGhhbmRsZSBpcyBjbG9zZXIgdG8gdGhlIG1vdXNlIHBvaW50ZXIgdGhhbiB0aGUgaGFuZGxlIGJlbG93IHRoZSBjdXJzb3JcbiAgICAgKi9cbiAgICBjb25zdCBoYW5kbGVUb0NoZWNrID0gaGFuZGxlQmVsb3c/LmNsYXNzTGlzdC5jb250YWlucyhgJHtsaWJ9LWZsb3dfX2hhbmRsZWApID8gaGFuZGxlQmVsb3cgOiBoYW5kbGVEb21Ob2RlO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgaGFuZGxlRG9tTm9kZTogaGFuZGxlVG9DaGVjayxcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIGNvbm5lY3Rpb246IG51bGwsXG4gICAgICAgIHRvSGFuZGxlOiBudWxsLFxuICAgIH07XG4gICAgaWYgKGhhbmRsZVRvQ2hlY2spIHtcbiAgICAgICAgY29uc3QgaGFuZGxlVHlwZSA9IGdldEhhbmRsZVR5cGUodW5kZWZpbmVkLCBoYW5kbGVUb0NoZWNrKTtcbiAgICAgICAgY29uc3QgaGFuZGxlTm9kZUlkID0gaGFuZGxlVG9DaGVjay5nZXRBdHRyaWJ1dGUoJ2RhdGEtbm9kZWlkJyk7XG4gICAgICAgIGNvbnN0IGhhbmRsZUlkID0gaGFuZGxlVG9DaGVjay5nZXRBdHRyaWJ1dGUoJ2RhdGEtaGFuZGxlaWQnKTtcbiAgICAgICAgY29uc3QgY29ubmVjdGFibGUgPSBoYW5kbGVUb0NoZWNrLmNsYXNzTGlzdC5jb250YWlucygnY29ubmVjdGFibGUnKTtcbiAgICAgICAgY29uc3QgY29ubmVjdGFibGVFbmQgPSBoYW5kbGVUb0NoZWNrLmNsYXNzTGlzdC5jb250YWlucygnY29ubmVjdGFibGVlbmQnKTtcbiAgICAgICAgaWYgKCFoYW5kbGVOb2RlSWQgfHwgIWhhbmRsZVR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHtcbiAgICAgICAgICAgIHNvdXJjZTogaXNUYXJnZXQgPyBoYW5kbGVOb2RlSWQgOiBmcm9tTm9kZUlkLFxuICAgICAgICAgICAgc291cmNlSGFuZGxlOiBpc1RhcmdldCA/IGhhbmRsZUlkIDogZnJvbUhhbmRsZUlkLFxuICAgICAgICAgICAgdGFyZ2V0OiBpc1RhcmdldCA/IGZyb21Ob2RlSWQgOiBoYW5kbGVOb2RlSWQsXG4gICAgICAgICAgICB0YXJnZXRIYW5kbGU6IGlzVGFyZ2V0ID8gZnJvbUhhbmRsZUlkIDogaGFuZGxlSWQsXG4gICAgICAgIH07XG4gICAgICAgIHJlc3VsdC5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICAgICAgY29uc3QgaXNDb25uZWN0YWJsZSA9IGNvbm5lY3RhYmxlICYmIGNvbm5lY3RhYmxlRW5kO1xuICAgICAgICAvLyBpbiBzdHJpY3QgbW9kZSB3ZSBkb24ndCBhbGxvdyB0YXJnZXQgdG8gdGFyZ2V0IG9yIHNvdXJjZSB0byBzb3VyY2UgY29ubmVjdGlvbnNcbiAgICAgICAgY29uc3QgaXNWYWxpZCA9IGlzQ29ubmVjdGFibGUgJiZcbiAgICAgICAgICAgIChjb25uZWN0aW9uTW9kZSA9PT0gQ29ubmVjdGlvbk1vZGUuU3RyaWN0XG4gICAgICAgICAgICAgICAgPyAoaXNUYXJnZXQgJiYgaGFuZGxlVHlwZSA9PT0gJ3NvdXJjZScpIHx8ICghaXNUYXJnZXQgJiYgaGFuZGxlVHlwZSA9PT0gJ3RhcmdldCcpXG4gICAgICAgICAgICAgICAgOiBoYW5kbGVOb2RlSWQgIT09IGZyb21Ob2RlSWQgfHwgaGFuZGxlSWQgIT09IGZyb21IYW5kbGVJZCk7XG4gICAgICAgIHJlc3VsdC5pc1ZhbGlkID0gaXNWYWxpZCAmJiBpc1ZhbGlkQ29ubmVjdGlvbihjb25uZWN0aW9uKTtcbiAgICAgICAgcmVzdWx0LnRvSGFuZGxlID0gZ2V0SGFuZGxlKGhhbmRsZU5vZGVJZCwgaGFuZGxlVHlwZSwgaGFuZGxlSWQsIG5vZGVMb29rdXAsIGNvbm5lY3Rpb25Nb2RlLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IFhZSGFuZGxlID0ge1xuICAgIG9uUG9pbnRlckRvd24sXG4gICAgaXNWYWxpZDogaXNWYWxpZEhhbmRsZSxcbn07XG5cbmZ1bmN0aW9uIFhZTWluaW1hcCh7IGRvbU5vZGUsIHBhblpvb20sIGdldFRyYW5zZm9ybSwgZ2V0Vmlld1NjYWxlIH0pIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBzZWxlY3QoZG9tTm9kZSk7XG4gICAgZnVuY3Rpb24gdXBkYXRlKHsgdHJhbnNsYXRlRXh0ZW50LCB3aWR0aCwgaGVpZ2h0LCB6b29tU3RlcCA9IDEsIHBhbm5hYmxlID0gdHJ1ZSwgem9vbWFibGUgPSB0cnVlLCBpbnZlcnNlUGFuID0gZmFsc2UsIH0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3Qgem9vbUhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2VFdmVudC50eXBlICE9PSAnd2hlZWwnIHx8ICFwYW5ab29tKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gZ2V0VHJhbnNmb3JtKCk7XG4gICAgICAgICAgICBjb25zdCBmYWN0b3IgPSBldmVudC5zb3VyY2VFdmVudC5jdHJsS2V5ICYmIGlzTWFjT3MoKSA/IDEwIDogMTtcbiAgICAgICAgICAgIGNvbnN0IHBpbmNoRGVsdGEgPSAtZXZlbnQuc291cmNlRXZlbnQuZGVsdGFZICpcbiAgICAgICAgICAgICAgICAoZXZlbnQuc291cmNlRXZlbnQuZGVsdGFNb2RlID09PSAxID8gMC4wNSA6IGV2ZW50LnNvdXJjZUV2ZW50LmRlbHRhTW9kZSA/IDEgOiAwLjAwMikgKlxuICAgICAgICAgICAgICAgIHpvb21TdGVwO1xuICAgICAgICAgICAgY29uc3QgbmV4dFpvb20gPSB0cmFuc2Zvcm1bMl0gKiBNYXRoLnBvdygyLCBwaW5jaERlbHRhICogZmFjdG9yKTtcbiAgICAgICAgICAgIHBhblpvb20uc2NhbGVUbyhuZXh0Wm9vbSk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwYW5TdGFydCA9IFswLCAwXTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgcGFuU3RhcnRIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlRXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicgfHwgZXZlbnQuc291cmNlRXZlbnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgcGFuU3RhcnQgPSBbXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnNvdXJjZUV2ZW50LmNsaWVudFggPz8gZXZlbnQuc291cmNlRXZlbnQudG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICBldmVudC5zb3VyY2VFdmVudC5jbGllbnRZID8/IGV2ZW50LnNvdXJjZUV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBwYW5IYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBnZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIGlmICgoZXZlbnQuc291cmNlRXZlbnQudHlwZSAhPT0gJ21vdXNlbW92ZScgJiYgZXZlbnQuc291cmNlRXZlbnQudHlwZSAhPT0gJ3RvdWNobW92ZScpIHx8ICFwYW5ab29tKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFuQ3VycmVudCA9IFtcbiAgICAgICAgICAgICAgICBldmVudC5zb3VyY2VFdmVudC5jbGllbnRYID8/IGV2ZW50LnNvdXJjZUV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgICAgICAgICAgICBldmVudC5zb3VyY2VFdmVudC5jbGllbnRZID8/IGV2ZW50LnNvdXJjZUV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjb25zdCBwYW5EZWx0YSA9IFtwYW5DdXJyZW50WzBdIC0gcGFuU3RhcnRbMF0sIHBhbkN1cnJlbnRbMV0gLSBwYW5TdGFydFsxXV07XG4gICAgICAgICAgICBwYW5TdGFydCA9IHBhbkN1cnJlbnQ7XG4gICAgICAgICAgICBjb25zdCBtb3ZlU2NhbGUgPSBnZXRWaWV3U2NhbGUoKSAqIE1hdGgubWF4KHRyYW5zZm9ybVsyXSwgTWF0aC5sb2codHJhbnNmb3JtWzJdKSkgKiAoaW52ZXJzZVBhbiA/IC0xIDogMSk7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB4OiB0cmFuc2Zvcm1bMF0gLSBwYW5EZWx0YVswXSAqIG1vdmVTY2FsZSxcbiAgICAgICAgICAgICAgICB5OiB0cmFuc2Zvcm1bMV0gLSBwYW5EZWx0YVsxXSAqIG1vdmVTY2FsZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBleHRlbnQgPSBbXG4gICAgICAgICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgICAgICAgIFt3aWR0aCwgaGVpZ2h0XSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBwYW5ab29tLnNldFZpZXdwb3J0Q29uc3RyYWluZWQoe1xuICAgICAgICAgICAgICAgIHg6IHBvc2l0aW9uLngsXG4gICAgICAgICAgICAgICAgeTogcG9zaXRpb24ueSxcbiAgICAgICAgICAgICAgICB6b29tOiB0cmFuc2Zvcm1bMl0sXG4gICAgICAgICAgICB9LCBleHRlbnQsIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHpvb21BbmRQYW5IYW5kbGVyID0gem9vbSgpXG4gICAgICAgICAgICAub24oJ3N0YXJ0JywgcGFuU3RhcnRIYW5kbGVyKVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgLm9uKCd6b29tJywgcGFubmFibGUgPyBwYW5IYW5kbGVyIDogbnVsbClcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIC5vbignem9vbS53aGVlbCcsIHpvb21hYmxlID8gem9vbUhhbmRsZXIgOiBudWxsKTtcbiAgICAgICAgc2VsZWN0aW9uLmNhbGwoem9vbUFuZFBhbkhhbmRsZXIsIHt9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgc2VsZWN0aW9uLm9uKCd6b29tJywgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZSxcbiAgICAgICAgZGVzdHJveSxcbiAgICAgICAgcG9pbnRlcixcbiAgICB9O1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5jb25zdCB0cmFuc2Zvcm1Ub1ZpZXdwb3J0ID0gKHRyYW5zZm9ybSkgPT4gKHtcbiAgICB4OiB0cmFuc2Zvcm0ueCxcbiAgICB5OiB0cmFuc2Zvcm0ueSxcbiAgICB6b29tOiB0cmFuc2Zvcm0uayxcbn0pO1xuY29uc3Qgdmlld3BvcnRUb1RyYW5zZm9ybSA9ICh7IHgsIHksIHpvb20gfSkgPT4gem9vbUlkZW50aXR5LnRyYW5zbGF0ZSh4LCB5KS5zY2FsZSh6b29tKTtcbmNvbnN0IGlzV3JhcHBlZFdpdGhDbGFzcyA9IChldmVudCwgY2xhc3NOYW1lKSA9PiBldmVudC50YXJnZXQuY2xvc2VzdChgLiR7Y2xhc3NOYW1lfWApO1xuY29uc3QgaXNSaWdodENsaWNrUGFuID0gKHBhbk9uRHJhZywgdXNlZEJ1dHRvbikgPT4gdXNlZEJ1dHRvbiA9PT0gMiAmJiBBcnJheS5pc0FycmF5KHBhbk9uRHJhZykgJiYgcGFuT25EcmFnLmluY2x1ZGVzKDIpO1xuLy8gdGFrZW4gZnJvbSBkMy1lYXNlOiBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtZWFzZS9ibG9iL21haW4vc3JjL2N1YmljLmpzXG5jb25zdCBkZWZhdWx0RWFzZSA9ICh0KSA9PiAoKHQgKj0gMikgPD0gMSA/IHQgKiB0ICogdCA6ICh0IC09IDIpICogdCAqIHQgKyAyKSAvIDI7XG5jb25zdCBnZXREM1RyYW5zaXRpb24gPSAoc2VsZWN0aW9uLCBkdXJhdGlvbiA9IDAsIGVhc2UgPSBkZWZhdWx0RWFzZSwgb25FbmQgPSAoKSA9PiB7IH0pID0+IHtcbiAgICBjb25zdCBoYXNEdXJhdGlvbiA9IHR5cGVvZiBkdXJhdGlvbiA9PT0gJ251bWJlcicgJiYgZHVyYXRpb24gPiAwO1xuICAgIGlmICghaGFzRHVyYXRpb24pIHtcbiAgICAgICAgb25FbmQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc0R1cmF0aW9uID8gc2VsZWN0aW9uLnRyYW5zaXRpb24oKS5kdXJhdGlvbihkdXJhdGlvbikuZWFzZShlYXNlKS5vbignZW5kJywgb25FbmQpIDogc2VsZWN0aW9uO1xufTtcbmNvbnN0IHdoZWVsRGVsdGEgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBmYWN0b3IgPSBldmVudC5jdHJsS2V5ICYmIGlzTWFjT3MoKSA/IDEwIDogMTtcbiAgICByZXR1cm4gLWV2ZW50LmRlbHRhWSAqIChldmVudC5kZWx0YU1vZGUgPT09IDEgPyAwLjA1IDogZXZlbnQuZGVsdGFNb2RlID8gMSA6IDAuMDAyKSAqIGZhY3Rvcjtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhbk9uU2Nyb2xsSGFuZGxlcih7IHpvb21QYW5WYWx1ZXMsIG5vV2hlZWxDbGFzc05hbWUsIGQzU2VsZWN0aW9uLCBkM1pvb20sIHBhbk9uU2Nyb2xsTW9kZSwgcGFuT25TY3JvbGxTcGVlZCwgem9vbU9uUGluY2gsIG9uUGFuWm9vbVN0YXJ0LCBvblBhblpvb20sIG9uUGFuWm9vbUVuZCwgfSkge1xuICAgIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgbm9XaGVlbENsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5jdHJsS2V5KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gc3RvcCBuYXRpdmUgcGFnZSB6b29tIGZvciBwaW5jaCB6b29taW5nXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gZDNTZWxlY3Rpb24ucHJvcGVydHkoJ19fem9vbScpLmsgfHwgMTtcbiAgICAgICAgLy8gbWFjb3Mgc2V0cyBjdHJsS2V5PXRydWUgZm9yIHBpbmNoIGdlc3R1cmUgb24gYSB0cmFja3BhZFxuICAgICAgICBpZiAoZXZlbnQuY3RybEtleSAmJiB6b29tT25QaW5jaCkge1xuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludGVyKGV2ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IHBpbmNoRGVsdGEgPSB3aGVlbERlbHRhKGV2ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IHpvb20gPSBjdXJyZW50Wm9vbSAqIE1hdGgucG93KDIsIHBpbmNoRGVsdGEpO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgZDNab29tLnNjYWxlVG8oZDNTZWxlY3Rpb24sIHpvb20sIHBvaW50LCBldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICogaW5jcmVhc2Ugc2Nyb2xsIHNwZWVkIGluIGZpcmVmb3hcbiAgICAgICAgICogZmlyZWZveDogZGVsdGFNb2RlID09PSAxOyBjaHJvbWU6IGRlbHRhTW9kZSA9PT0gMFxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgZGVsdGFOb3JtYWxpemUgPSBldmVudC5kZWx0YU1vZGUgPT09IDEgPyAyMCA6IDE7XG4gICAgICAgIGxldCBkZWx0YVggPSBwYW5PblNjcm9sbE1vZGUgPT09IFBhbk9uU2Nyb2xsTW9kZS5WZXJ0aWNhbCA/IDAgOiBldmVudC5kZWx0YVggKiBkZWx0YU5vcm1hbGl6ZTtcbiAgICAgICAgbGV0IGRlbHRhWSA9IHBhbk9uU2Nyb2xsTW9kZSA9PT0gUGFuT25TY3JvbGxNb2RlLkhvcml6b250YWwgPyAwIDogZXZlbnQuZGVsdGFZICogZGVsdGFOb3JtYWxpemU7XG4gICAgICAgIC8vIHRoaXMgZW5hYmxlcyB2ZXJ0aWNhbCBzY3JvbGxpbmcgd2l0aCBzaGlmdCArIHNjcm9sbCBvbiB3aW5kb3dzXG4gICAgICAgIGlmICghaXNNYWNPcygpICYmIGV2ZW50LnNoaWZ0S2V5ICYmIHBhbk9uU2Nyb2xsTW9kZSAhPT0gUGFuT25TY3JvbGxNb2RlLlZlcnRpY2FsKSB7XG4gICAgICAgICAgICBkZWx0YVggPSBldmVudC5kZWx0YVkgKiBkZWx0YU5vcm1hbGl6ZTtcbiAgICAgICAgICAgIGRlbHRhWSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZDNab29tLnRyYW5zbGF0ZUJ5KGQzU2VsZWN0aW9uLCAtKGRlbHRhWCAvIGN1cnJlbnRab29tKSAqIHBhbk9uU2Nyb2xsU3BlZWQsIC0oZGVsdGFZIC8gY3VycmVudFpvb20pICogcGFuT25TY3JvbGxTcGVlZCwgXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgeyBpbnRlcm5hbDogdHJ1ZSB9KTtcbiAgICAgICAgY29uc3QgbmV4dFZpZXdwb3J0ID0gdHJhbnNmb3JtVG9WaWV3cG9ydChkM1NlbGVjdGlvbi5wcm9wZXJ0eSgnX196b29tJykpO1xuICAgICAgICBjbGVhclRpbWVvdXQoem9vbVBhblZhbHVlcy5wYW5TY3JvbGxUaW1lb3V0KTtcbiAgICAgICAgLypcbiAgICAgICAgICogZm9yIHBhbiBvbiBzY3JvbGwgd2UgbmVlZCB0byBoYW5kbGUgdGhlIGV2ZW50IGNhbGxzIG9uIG91ciBvd25cbiAgICAgICAgICogd2UgY2FuJ3QgdXNlIHRoZSBzdGFydCwgem9vbSBhbmQgZW5kIGV2ZW50cyBmcm9tIGQzLXpvb21cbiAgICAgICAgICogYmVjYXVzZSBzdGFydCBhbmQgbW92ZSBnZXRzIGNhbGxlZCBvbiBldmVyeSBzY3JvbGwgZXZlbnQgYW5kIG5vdCBvbmNlIGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgICAgICovXG4gICAgICAgIGlmICghem9vbVBhblZhbHVlcy5pc1BhblNjcm9sbGluZykge1xuICAgICAgICAgICAgem9vbVBhblZhbHVlcy5pc1BhblNjcm9sbGluZyA9IHRydWU7XG4gICAgICAgICAgICBvblBhblpvb21TdGFydD8uKGV2ZW50LCBuZXh0Vmlld3BvcnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb25QYW5ab29tPy4oZXZlbnQsIG5leHRWaWV3cG9ydCk7XG4gICAgICAgICAgICB6b29tUGFuVmFsdWVzLnBhblNjcm9sbFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBvblBhblpvb21FbmQ/LihldmVudCwgbmV4dFZpZXdwb3J0KTtcbiAgICAgICAgICAgICAgICB6b29tUGFuVmFsdWVzLmlzUGFuU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9LCAxNTApO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVpvb21PblNjcm9sbEhhbmRsZXIoeyBub1doZWVsQ2xhc3NOYW1lLCBwcmV2ZW50U2Nyb2xsaW5nLCBkM1pvb21IYW5kbGVyIH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50LCBkKSB7XG4gICAgICAgIGNvbnN0IGlzV2hlZWwgPSBldmVudC50eXBlID09PSAnd2hlZWwnO1xuICAgICAgICAvLyB3ZSBzdGlsbCB3YW50IHRvIGVuYWJsZSBwaW5jaCB6b29taW5nIGV2ZW4gaWYgcHJldmVudFNjcm9sbGluZyBpcyBzZXQgdG8gZmFsc2VcbiAgICAgICAgY29uc3QgcHJldmVudFpvb20gPSAhcHJldmVudFNjcm9sbGluZyAmJiBpc1doZWVsICYmICFldmVudC5jdHJsS2V5O1xuICAgICAgICBjb25zdCBoYXNOb1doZWVsQ2xhc3MgPSBpc1dyYXBwZWRXaXRoQ2xhc3MoZXZlbnQsIG5vV2hlZWxDbGFzc05hbWUpO1xuICAgICAgICAvLyBpZiB1c2VyIGlzIHBpbmNoIHpvb21pbmcgYWJvdmUgYSBub3doZWVsIGVsZW1lbnQsIHdlIGRvbid0IHdhbnQgdGhlIGJyb3dzZXIgdG8gem9vbVxuICAgICAgICBpZiAoZXZlbnQuY3RybEtleSAmJiBpc1doZWVsICYmIGhhc05vV2hlZWxDbGFzcykge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldmVudFpvb20gfHwgaGFzTm9XaGVlbENsYXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkM1pvb21IYW5kbGVyLmNhbGwodGhpcywgZXZlbnQsIGQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVQYW5ab29tU3RhcnRIYW5kbGVyKHsgem9vbVBhblZhbHVlcywgb25EcmFnZ2luZ0NoYW5nZSwgb25QYW5ab29tU3RhcnQgfSkge1xuICAgIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LnNvdXJjZUV2ZW50Py5pbnRlcm5hbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gdHJhbnNmb3JtVG9WaWV3cG9ydChldmVudC50cmFuc2Zvcm0pO1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIHJlbWVtYmVyIGl0IGhlcmUsIGJlY2F1c2UgaXQncyBhbHdheXMgMCBpbiB0aGUgXCJ6b29tXCIgZXZlbnRcbiAgICAgICAgem9vbVBhblZhbHVlcy5tb3VzZUJ1dHRvbiA9IGV2ZW50LnNvdXJjZUV2ZW50Py5idXR0b24gfHwgMDtcbiAgICAgICAgem9vbVBhblZhbHVlcy5pc1pvb21pbmdPclBhbm5pbmcgPSB0cnVlO1xuICAgICAgICB6b29tUGFuVmFsdWVzLnByZXZWaWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICBpZiAoZXZlbnQuc291cmNlRXZlbnQ/LnR5cGUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICAgICAgICBvbkRyYWdnaW5nQ2hhbmdlKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvblBhblpvb21TdGFydCkge1xuICAgICAgICAgICAgb25QYW5ab29tU3RhcnQ/LihldmVudC5zb3VyY2VFdmVudCwgdmlld3BvcnQpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhblpvb21IYW5kbGVyKHsgem9vbVBhblZhbHVlcywgcGFuT25EcmFnLCBvblBhbmVDb250ZXh0TWVudSwgb25UcmFuc2Zvcm1DaGFuZ2UsIG9uUGFuWm9vbSwgfSkge1xuICAgIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAgICAgem9vbVBhblZhbHVlcy51c2VkUmlnaHRNb3VzZUJ1dHRvbiA9ICEhKG9uUGFuZUNvbnRleHRNZW51ICYmIGlzUmlnaHRDbGlja1BhbihwYW5PbkRyYWcsIHpvb21QYW5WYWx1ZXMubW91c2VCdXR0b24gPz8gMCkpO1xuICAgICAgICBpZiAoIWV2ZW50LnNvdXJjZUV2ZW50Py5zeW5jKSB7XG4gICAgICAgICAgICBvblRyYW5zZm9ybUNoYW5nZShbZXZlbnQudHJhbnNmb3JtLngsIGV2ZW50LnRyYW5zZm9ybS55LCBldmVudC50cmFuc2Zvcm0ua10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvblBhblpvb20gJiYgIWV2ZW50LnNvdXJjZUV2ZW50Py5pbnRlcm5hbCkge1xuICAgICAgICAgICAgb25QYW5ab29tPy4oZXZlbnQuc291cmNlRXZlbnQsIHRyYW5zZm9ybVRvVmlld3BvcnQoZXZlbnQudHJhbnNmb3JtKSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUGFuWm9vbUVuZEhhbmRsZXIoeyB6b29tUGFuVmFsdWVzLCBwYW5PbkRyYWcsIHBhbk9uU2Nyb2xsLCBvbkRyYWdnaW5nQ2hhbmdlLCBvblBhblpvb21FbmQsIG9uUGFuZUNvbnRleHRNZW51LCB9KSB7XG4gICAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQuc291cmNlRXZlbnQ/LmludGVybmFsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgem9vbVBhblZhbHVlcy5pc1pvb21pbmdPclBhbm5pbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKG9uUGFuZUNvbnRleHRNZW51ICYmXG4gICAgICAgICAgICBpc1JpZ2h0Q2xpY2tQYW4ocGFuT25EcmFnLCB6b29tUGFuVmFsdWVzLm1vdXNlQnV0dG9uID8/IDApICYmXG4gICAgICAgICAgICAhem9vbVBhblZhbHVlcy51c2VkUmlnaHRNb3VzZUJ1dHRvbiAmJlxuICAgICAgICAgICAgZXZlbnQuc291cmNlRXZlbnQpIHtcbiAgICAgICAgICAgIG9uUGFuZUNvbnRleHRNZW51KGV2ZW50LnNvdXJjZUV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICB6b29tUGFuVmFsdWVzLnVzZWRSaWdodE1vdXNlQnV0dG9uID0gZmFsc2U7XG4gICAgICAgIG9uRHJhZ2dpbmdDaGFuZ2UoZmFsc2UpO1xuICAgICAgICBpZiAob25QYW5ab29tRW5kKSB7XG4gICAgICAgICAgICBjb25zdCB2aWV3cG9ydCA9IHRyYW5zZm9ybVRvVmlld3BvcnQoZXZlbnQudHJhbnNmb3JtKTtcbiAgICAgICAgICAgIHpvb21QYW5WYWx1ZXMucHJldlZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoem9vbVBhblZhbHVlcy50aW1lcklkKTtcbiAgICAgICAgICAgIHpvb21QYW5WYWx1ZXMudGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9uUGFuWm9vbUVuZD8uKGV2ZW50LnNvdXJjZUV2ZW50LCB2aWV3cG9ydCk7XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgYSBzZXRUaW1lb3V0IGZvciBwYW5PblNjcm9sbCB0byBzdXByZXNzIG11bHRpcGxlIGVuZCBldmVudHMgZmlyZWQgZHVyaW5nIHNjcm9sbFxuICAgICAgICAgICAgcGFuT25TY3JvbGwgPyAxNTAgOiAwKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmZ1bmN0aW9uIGNyZWF0ZUZpbHRlcih7IHpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCwgem9vbU9uU2Nyb2xsLCB6b29tT25QaW5jaCwgcGFuT25EcmFnLCBwYW5PblNjcm9sbCwgem9vbU9uRG91YmxlQ2xpY2ssIHVzZXJTZWxlY3Rpb25BY3RpdmUsIG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lLCBsaWIsIGNvbm5lY3Rpb25JblByb2dyZXNzLCB9KSB7XG4gICAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB6b29tU2Nyb2xsID0gem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkIHx8IHpvb21PblNjcm9sbDtcbiAgICAgICAgY29uc3QgcGluY2hab29tID0gem9vbU9uUGluY2ggJiYgZXZlbnQuY3RybEtleTtcbiAgICAgICAgY29uc3QgaXNXaGVlbEV2ZW50ID0gZXZlbnQudHlwZSA9PT0gJ3doZWVsJztcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gMSAmJlxuICAgICAgICAgICAgZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicgJiZcbiAgICAgICAgICAgIChpc1dyYXBwZWRXaXRoQ2xhc3MoZXZlbnQsIGAke2xpYn0tZmxvd19fbm9kZWApIHx8IGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgYCR7bGlifS1mbG93X19lZGdlYCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBhbGwgaW50ZXJhY3Rpb25zIGFyZSBkaXNhYmxlZCwgd2UgcHJldmVudCBhbGwgem9vbSBldmVudHNcbiAgICAgICAgaWYgKCFwYW5PbkRyYWcgJiYgIXpvb21TY3JvbGwgJiYgIXBhbk9uU2Nyb2xsICYmICF6b29tT25Eb3VibGVDbGljayAmJiAhem9vbU9uUGluY2gpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkdXJpbmcgYSBzZWxlY3Rpb24gd2UgcHJldmVudCBhbGwgb3RoZXIgaW50ZXJhY3Rpb25zXG4gICAgICAgIGlmICh1c2VyU2VsZWN0aW9uQWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2Ugd2FudCB0byBkaXNhYmxlIHBpbmNoLXpvb21pbmcgd2hpbGUgbWFraW5nIGEgY29ubmVjdGlvblxuICAgICAgICBpZiAoY29ubmVjdGlvbkluUHJvZ3Jlc3MgJiYgIWlzV2hlZWxFdmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBpbnNpZGUgYW4gZWxlbWVudCB3aXRoIHRoZSBub3doZWVsIGNsYXNzLCB3ZSBwcmV2ZW50IHpvb21pbmdcbiAgICAgICAgaWYgKGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgbm9XaGVlbENsYXNzTmFtZSkgJiYgaXNXaGVlbEV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGluc2lkZSBhbiBlbGVtZW50IHdpdGggdGhlIG5vcGFuIGNsYXNzLCB3ZSBwcmV2ZW50IHBhbm5pbmdcbiAgICAgICAgaWYgKGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgbm9QYW5DbGFzc05hbWUpICYmXG4gICAgICAgICAgICAoIWlzV2hlZWxFdmVudCB8fCAocGFuT25TY3JvbGwgJiYgaXNXaGVlbEV2ZW50ICYmICF6b29tQWN0aXZhdGlvbktleVByZXNzZWQpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghem9vbU9uUGluY2ggJiYgZXZlbnQuY3RybEtleSAmJiBpc1doZWVsRXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXpvb21PblBpbmNoICYmIGV2ZW50LnR5cGUgPT09ICd0b3VjaHN0YXJ0JyAmJiBldmVudC50b3VjaGVzPy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBpZiB5b3UgbWFuYWdlIHRvIHN0YXJ0IHdpdGggMiB0b3VjaGVzLCB3ZSBwcmV2ZW50IG5hdGl2ZSB6b29tXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2hlbiB0aGVyZSBpcyBubyBzY3JvbGwgaGFuZGxpbmcgZW5hYmxlZCwgd2UgcHJldmVudCBhbGwgd2hlZWwgZXZlbnRzXG4gICAgICAgIGlmICghem9vbVNjcm9sbCAmJiAhcGFuT25TY3JvbGwgJiYgIXBpbmNoWm9vbSAmJiBpc1doZWVsRXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgcGFuZSBpcyBub3QgbW92YWJsZSwgd2UgcHJldmVudCBkcmFnZ2luZyBpdCB3aXRoIG1vdXNlc3RhcnQgb3IgdG91Y2hzdGFydFxuICAgICAgICBpZiAoIXBhbk9uRHJhZyAmJiAoZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSBwYW5lIGlzIG9ubHkgbW92YWJsZSB1c2luZyBhbGxvd2VkIGNsaWNrc1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYW5PbkRyYWcpICYmICFwYW5PbkRyYWcuaW5jbHVkZXMoZXZlbnQuYnV0dG9uKSAmJiBldmVudC50eXBlID09PSAnbW91c2Vkb3duJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIG9ubHkgYWxsb3cgcmlnaHQgY2xpY2tzIGlmIHBhbiBvbiBkcmFnIGlzIHNldCB0byByaWdodCBjbGlja1xuICAgICAgICBjb25zdCBidXR0b25BbGxvd2VkID0gKEFycmF5LmlzQXJyYXkocGFuT25EcmFnKSAmJiBwYW5PbkRyYWcuaW5jbHVkZXMoZXZlbnQuYnV0dG9uKSkgfHwgIWV2ZW50LmJ1dHRvbiB8fCBldmVudC5idXR0b24gPD0gMTtcbiAgICAgICAgLy8gZGVmYXVsdCBmaWx0ZXIgZm9yIGQzLXpvb21cbiAgICAgICAgcmV0dXJuICghZXZlbnQuY3RybEtleSB8fCBpc1doZWVsRXZlbnQpICYmIGJ1dHRvbkFsbG93ZWQ7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gWFlQYW5ab29tKHsgZG9tTm9kZSwgbWluWm9vbSwgbWF4Wm9vbSwgcGFuZUNsaWNrRGlzdGFuY2UsIHRyYW5zbGF0ZUV4dGVudCwgdmlld3BvcnQsIG9uUGFuWm9vbSwgb25QYW5ab29tU3RhcnQsIG9uUGFuWm9vbUVuZCwgb25EcmFnZ2luZ0NoYW5nZSwgfSkge1xuICAgIGNvbnN0IHpvb21QYW5WYWx1ZXMgPSB7XG4gICAgICAgIGlzWm9vbWluZ09yUGFubmluZzogZmFsc2UsXG4gICAgICAgIHVzZWRSaWdodE1vdXNlQnV0dG9uOiBmYWxzZSxcbiAgICAgICAgcHJldlZpZXdwb3J0OiB7IHg6IDAsIHk6IDAsIHpvb206IDAgfSxcbiAgICAgICAgbW91c2VCdXR0b246IDAsXG4gICAgICAgIHRpbWVySWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgcGFuU2Nyb2xsVGltZW91dDogdW5kZWZpbmVkLFxuICAgICAgICBpc1BhblNjcm9sbGluZzogZmFsc2UsXG4gICAgfTtcbiAgICBjb25zdCBiYm94ID0gZG9tTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBkM1pvb21JbnN0YW5jZSA9IHpvb20oKVxuICAgICAgICAuY2xpY2tEaXN0YW5jZSghaXNOdW1lcmljKHBhbmVDbGlja0Rpc3RhbmNlKSB8fCBwYW5lQ2xpY2tEaXN0YW5jZSA8IDAgPyAwIDogcGFuZUNsaWNrRGlzdGFuY2UpXG4gICAgICAgIC5zY2FsZUV4dGVudChbbWluWm9vbSwgbWF4Wm9vbV0pXG4gICAgICAgIC50cmFuc2xhdGVFeHRlbnQodHJhbnNsYXRlRXh0ZW50KTtcbiAgICBjb25zdCBkM1NlbGVjdGlvbiA9IHNlbGVjdChkb21Ob2RlKS5jYWxsKGQzWm9vbUluc3RhbmNlKTtcbiAgICBzZXRWaWV3cG9ydENvbnN0cmFpbmVkKHtcbiAgICAgICAgeDogdmlld3BvcnQueCxcbiAgICAgICAgeTogdmlld3BvcnQueSxcbiAgICAgICAgem9vbTogY2xhbXAodmlld3BvcnQuem9vbSwgbWluWm9vbSwgbWF4Wm9vbSksXG4gICAgfSwgW1xuICAgICAgICBbMCwgMF0sXG4gICAgICAgIFtiYm94LndpZHRoLCBiYm94LmhlaWdodF0sXG4gICAgXSwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICBjb25zdCBkM1pvb21IYW5kbGVyID0gZDNTZWxlY3Rpb24ub24oJ3doZWVsLnpvb20nKTtcbiAgICBjb25zdCBkM0RibENsaWNrWm9vbUhhbmRsZXIgPSBkM1NlbGVjdGlvbi5vbignZGJsY2xpY2suem9vbScpO1xuICAgIGQzWm9vbUluc3RhbmNlLndoZWVsRGVsdGEod2hlZWxEZWx0YSk7XG4gICAgZnVuY3Rpb24gc2V0VHJhbnNmb3JtKHRyYW5zZm9ybSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoZDNTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGQzWm9vbUluc3RhbmNlPy5pbnRlcnBvbGF0ZShvcHRpb25zPy5pbnRlcnBvbGF0ZSA9PT0gJ2xpbmVhcicgPyBpbnRlcnBvbGF0ZSA6IGludGVycG9sYXRlWm9vbSkudHJhbnNmb3JtKGdldEQzVHJhbnNpdGlvbihkM1NlbGVjdGlvbiwgb3B0aW9ucz8uZHVyYXRpb24sIG9wdGlvbnM/LmVhc2UsICgpID0+IHJlc29sdmUodHJ1ZSkpLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgfVxuICAgIC8vIHB1YmxpYyBmdW5jdGlvbnNcbiAgICBmdW5jdGlvbiB1cGRhdGUoeyBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZSwgb25QYW5lQ29udGV4dE1lbnUsIHVzZXJTZWxlY3Rpb25BY3RpdmUsIHBhbk9uU2Nyb2xsLCBwYW5PbkRyYWcsIHBhbk9uU2Nyb2xsTW9kZSwgcGFuT25TY3JvbGxTcGVlZCwgcHJldmVudFNjcm9sbGluZywgem9vbU9uUGluY2gsIHpvb21PblNjcm9sbCwgem9vbU9uRG91YmxlQ2xpY2ssIHpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCwgbGliLCBvblRyYW5zZm9ybUNoYW5nZSwgY29ubmVjdGlvbkluUHJvZ3Jlc3MsIH0pIHtcbiAgICAgICAgaWYgKHVzZXJTZWxlY3Rpb25BY3RpdmUgJiYgIXpvb21QYW5WYWx1ZXMuaXNab29taW5nT3JQYW5uaW5nKSB7XG4gICAgICAgICAgICBkZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNQYW5PblNjcm9sbCA9IHBhbk9uU2Nyb2xsICYmICF6b29tQWN0aXZhdGlvbktleVByZXNzZWQgJiYgIXVzZXJTZWxlY3Rpb25BY3RpdmU7XG4gICAgICAgIGNvbnN0IHdoZWVsSGFuZGxlciA9IGlzUGFuT25TY3JvbGxcbiAgICAgICAgICAgID8gY3JlYXRlUGFuT25TY3JvbGxIYW5kbGVyKHtcbiAgICAgICAgICAgICAgICB6b29tUGFuVmFsdWVzLFxuICAgICAgICAgICAgICAgIG5vV2hlZWxDbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgZDNTZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgZDNab29tOiBkM1pvb21JbnN0YW5jZSxcbiAgICAgICAgICAgICAgICBwYW5PblNjcm9sbE1vZGUsXG4gICAgICAgICAgICAgICAgcGFuT25TY3JvbGxTcGVlZCxcbiAgICAgICAgICAgICAgICB6b29tT25QaW5jaCxcbiAgICAgICAgICAgICAgICBvblBhblpvb21TdGFydCxcbiAgICAgICAgICAgICAgICBvblBhblpvb20sXG4gICAgICAgICAgICAgICAgb25QYW5ab29tRW5kLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogY3JlYXRlWm9vbU9uU2Nyb2xsSGFuZGxlcih7XG4gICAgICAgICAgICAgICAgbm9XaGVlbENsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICBwcmV2ZW50U2Nyb2xsaW5nLFxuICAgICAgICAgICAgICAgIGQzWm9vbUhhbmRsZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgZDNTZWxlY3Rpb24ub24oJ3doZWVsLnpvb20nLCB3aGVlbEhhbmRsZXIsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgICAgIGlmICghdXNlclNlbGVjdGlvbkFjdGl2ZSkge1xuICAgICAgICAgICAgLy8gcGFuIHpvb20gc3RhcnRcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0SGFuZGxlciA9IGNyZWF0ZVBhblpvb21TdGFydEhhbmRsZXIoe1xuICAgICAgICAgICAgICAgIHpvb21QYW5WYWx1ZXMsXG4gICAgICAgICAgICAgICAgb25EcmFnZ2luZ0NoYW5nZSxcbiAgICAgICAgICAgICAgICBvblBhblpvb21TdGFydCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZDNab29tSW5zdGFuY2Uub24oJ3N0YXJ0Jywgc3RhcnRIYW5kbGVyKTtcbiAgICAgICAgICAgIC8vIHBhbiB6b29tXG4gICAgICAgICAgICBjb25zdCBwYW5ab29tSGFuZGxlciA9IGNyZWF0ZVBhblpvb21IYW5kbGVyKHtcbiAgICAgICAgICAgICAgICB6b29tUGFuVmFsdWVzLFxuICAgICAgICAgICAgICAgIHBhbk9uRHJhZyxcbiAgICAgICAgICAgICAgICBvblBhbmVDb250ZXh0TWVudTogISFvblBhbmVDb250ZXh0TWVudSxcbiAgICAgICAgICAgICAgICBvblBhblpvb20sXG4gICAgICAgICAgICAgICAgb25UcmFuc2Zvcm1DaGFuZ2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGQzWm9vbUluc3RhbmNlLm9uKCd6b29tJywgcGFuWm9vbUhhbmRsZXIpO1xuICAgICAgICAgICAgLy8gcGFuIHpvb20gZW5kXG4gICAgICAgICAgICBjb25zdCBwYW5ab29tRW5kSGFuZGxlciA9IGNyZWF0ZVBhblpvb21FbmRIYW5kbGVyKHtcbiAgICAgICAgICAgICAgICB6b29tUGFuVmFsdWVzLFxuICAgICAgICAgICAgICAgIHBhbk9uRHJhZyxcbiAgICAgICAgICAgICAgICBwYW5PblNjcm9sbCxcbiAgICAgICAgICAgICAgICBvblBhbmVDb250ZXh0TWVudSxcbiAgICAgICAgICAgICAgICBvblBhblpvb21FbmQsXG4gICAgICAgICAgICAgICAgb25EcmFnZ2luZ0NoYW5nZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZDNab29tSW5zdGFuY2Uub24oJ2VuZCcsIHBhblpvb21FbmRIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWx0ZXIgPSBjcmVhdGVGaWx0ZXIoe1xuICAgICAgICAgICAgem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkLFxuICAgICAgICAgICAgcGFuT25EcmFnLFxuICAgICAgICAgICAgem9vbU9uU2Nyb2xsLFxuICAgICAgICAgICAgcGFuT25TY3JvbGwsXG4gICAgICAgICAgICB6b29tT25Eb3VibGVDbGljayxcbiAgICAgICAgICAgIHpvb21PblBpbmNoLFxuICAgICAgICAgICAgdXNlclNlbGVjdGlvbkFjdGl2ZSxcbiAgICAgICAgICAgIG5vUGFuQ2xhc3NOYW1lLFxuICAgICAgICAgICAgbm9XaGVlbENsYXNzTmFtZSxcbiAgICAgICAgICAgIGxpYixcbiAgICAgICAgICAgIGNvbm5lY3Rpb25JblByb2dyZXNzLFxuICAgICAgICB9KTtcbiAgICAgICAgZDNab29tSW5zdGFuY2UuZmlsdGVyKGZpbHRlcik7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFdlIGNhbm5vdCBhZGQgem9vbU9uRG91YmxlQ2xpY2sgdG8gdGhlIGZpbHRlciBhYm92ZSBiZWNhdXNlXG4gICAgICAgICAqIGRvdWJsZSB0YXBwaW5nIG9uIHRvdWNoIHNjcmVlbnMgY2lyY3VtdmVudHMgdGhlIGZpbHRlciBhbmRcbiAgICAgICAgICogZGJsY2xpY2suem9vbSBpcyBmaXJlZCBvbiB0aGUgc2VsZWN0aW9uIGRpcmVjdGx5XG4gICAgICAgICAqL1xuICAgICAgICBpZiAoem9vbU9uRG91YmxlQ2xpY2spIHtcbiAgICAgICAgICAgIGQzU2VsZWN0aW9uLm9uKCdkYmxjbGljay56b29tJywgZDNEYmxDbGlja1pvb21IYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGQzU2VsZWN0aW9uLm9uKCdkYmxjbGljay56b29tJywgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgZDNab29tSW5zdGFuY2Uub24oJ3pvb20nLCBudWxsKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gc2V0Vmlld3BvcnRDb25zdHJhaW5lZCh2aWV3cG9ydCwgZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpIHtcbiAgICAgICAgY29uc3QgbmV4dFRyYW5zZm9ybSA9IHZpZXdwb3J0VG9UcmFuc2Zvcm0odmlld3BvcnQpO1xuICAgICAgICBjb25zdCBjb250cmFpbmVkVHJhbnNmb3JtID0gZDNab29tSW5zdGFuY2U/LmNvbnN0cmFpbigpKG5leHRUcmFuc2Zvcm0sIGV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICAgICAgaWYgKGNvbnRyYWluZWRUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIGF3YWl0IHNldFRyYW5zZm9ybShjb250cmFpbmVkVHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHJlc29sdmUoY29udHJhaW5lZFRyYW5zZm9ybSkpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBzZXRWaWV3cG9ydCh2aWV3cG9ydCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBuZXh0VHJhbnNmb3JtID0gdmlld3BvcnRUb1RyYW5zZm9ybSh2aWV3cG9ydCk7XG4gICAgICAgIGF3YWl0IHNldFRyYW5zZm9ybShuZXh0VHJhbnNmb3JtLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiByZXNvbHZlKG5leHRUcmFuc2Zvcm0pKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3luY1ZpZXdwb3J0KHZpZXdwb3J0KSB7XG4gICAgICAgIGlmIChkM1NlbGVjdGlvbikge1xuICAgICAgICAgICAgY29uc3QgbmV4dFRyYW5zZm9ybSA9IHZpZXdwb3J0VG9UcmFuc2Zvcm0odmlld3BvcnQpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFRyYW5zZm9ybSA9IGQzU2VsZWN0aW9uLnByb3BlcnR5KCdfX3pvb20nKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VHJhbnNmb3JtLmsgIT09IHZpZXdwb3J0Lnpvb20gfHxcbiAgICAgICAgICAgICAgICBjdXJyZW50VHJhbnNmb3JtLnggIT09IHZpZXdwb3J0LnggfHxcbiAgICAgICAgICAgICAgICBjdXJyZW50VHJhbnNmb3JtLnkgIT09IHZpZXdwb3J0LnkpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGQzWm9vbUluc3RhbmNlPy50cmFuc2Zvcm0oZDNTZWxlY3Rpb24sIG5leHRUcmFuc2Zvcm0sIG51bGwsIHsgc3luYzogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRWaWV3cG9ydCgpIHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gZDNTZWxlY3Rpb24gPyB6b29tVHJhbnNmb3JtKGQzU2VsZWN0aW9uLm5vZGUoKSkgOiB7IHg6IDAsIHk6IDAsIGs6IDEgfTtcbiAgICAgICAgcmV0dXJuIHsgeDogdHJhbnNmb3JtLngsIHk6IHRyYW5zZm9ybS55LCB6b29tOiB0cmFuc2Zvcm0uayB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FsZVRvKHpvb20sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGQzU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBkM1pvb21JbnN0YW5jZT8uaW50ZXJwb2xhdGUob3B0aW9ucz8uaW50ZXJwb2xhdGUgPT09ICdsaW5lYXInID8gaW50ZXJwb2xhdGUgOiBpbnRlcnBvbGF0ZVpvb20pLnNjYWxlVG8oZ2V0RDNUcmFuc2l0aW9uKGQzU2VsZWN0aW9uLCBvcHRpb25zPy5kdXJhdGlvbiwgb3B0aW9ucz8uZWFzZSwgKCkgPT4gcmVzb2x2ZSh0cnVlKSksIHpvb20pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYWxlQnkoZmFjdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChkM1NlbGVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgZDNab29tSW5zdGFuY2U/LmludGVycG9sYXRlKG9wdGlvbnM/LmludGVycG9sYXRlID09PSAnbGluZWFyJyA/IGludGVycG9sYXRlIDogaW50ZXJwb2xhdGVab29tKS5zY2FsZUJ5KGdldEQzVHJhbnNpdGlvbihkM1NlbGVjdGlvbiwgb3B0aW9ucz8uZHVyYXRpb24sIG9wdGlvbnM/LmVhc2UsICgpID0+IHJlc29sdmUodHJ1ZSkpLCBmYWN0b3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFNjYWxlRXh0ZW50KHNjYWxlRXh0ZW50KSB7XG4gICAgICAgIGQzWm9vbUluc3RhbmNlPy5zY2FsZUV4dGVudChzY2FsZUV4dGVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFRyYW5zbGF0ZUV4dGVudCh0cmFuc2xhdGVFeHRlbnQpIHtcbiAgICAgICAgZDNab29tSW5zdGFuY2U/LnRyYW5zbGF0ZUV4dGVudCh0cmFuc2xhdGVFeHRlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRDbGlja0Rpc3RhbmNlKGRpc3RhbmNlKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkRGlzdGFuY2UgPSAhaXNOdW1lcmljKGRpc3RhbmNlKSB8fCBkaXN0YW5jZSA8IDAgPyAwIDogZGlzdGFuY2U7XG4gICAgICAgIGQzWm9vbUluc3RhbmNlPy5jbGlja0Rpc3RhbmNlKHZhbGlkRGlzdGFuY2UpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGUsXG4gICAgICAgIGRlc3Ryb3ksXG4gICAgICAgIHNldFZpZXdwb3J0LFxuICAgICAgICBzZXRWaWV3cG9ydENvbnN0cmFpbmVkLFxuICAgICAgICBnZXRWaWV3cG9ydCxcbiAgICAgICAgc2NhbGVUbyxcbiAgICAgICAgc2NhbGVCeSxcbiAgICAgICAgc2V0U2NhbGVFeHRlbnQsXG4gICAgICAgIHNldFRyYW5zbGF0ZUV4dGVudCxcbiAgICAgICAgc3luY1ZpZXdwb3J0LFxuICAgICAgICBzZXRDbGlja0Rpc3RhbmNlLFxuICAgIH07XG59XG5cbi8qKlxuICogVXNlZCB0byBkZXRlcm1pbmUgdGhlIHZhcmlhbnQgb2YgdGhlIHJlc2l6ZSBjb250cm9sXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgUmVzaXplQ29udHJvbFZhcmlhbnQ7XG4oZnVuY3Rpb24gKFJlc2l6ZUNvbnRyb2xWYXJpYW50KSB7XG4gICAgUmVzaXplQ29udHJvbFZhcmlhbnRbXCJMaW5lXCJdID0gXCJsaW5lXCI7XG4gICAgUmVzaXplQ29udHJvbFZhcmlhbnRbXCJIYW5kbGVcIl0gPSBcImhhbmRsZVwiO1xufSkoUmVzaXplQ29udHJvbFZhcmlhbnQgfHwgKFJlc2l6ZUNvbnRyb2xWYXJpYW50ID0ge30pKTtcbmNvbnN0IFhZX1JFU0laRVJfSEFORExFX1BPU0lUSU9OUyA9IFsndG9wLWxlZnQnLCAndG9wLXJpZ2h0JywgJ2JvdHRvbS1sZWZ0JywgJ2JvdHRvbS1yaWdodCddO1xuY29uc3QgWFlfUkVTSVpFUl9MSU5FX1BPU0lUSU9OUyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J107XG5cbi8qKlxuICogR2V0IGFsbCBjb25uZWN0aW5nIGVkZ2VzIGZvciBhIGdpdmVuIHNldCBvZiBub2Rlc1xuICogQHBhcmFtIHdpZHRoIC0gbmV3IHdpZHRoIG9mIHRoZSBub2RlXG4gKiBAcGFyYW0gcHJldldpZHRoIC0gcHJldmlvdXMgd2lkdGggb2YgdGhlIG5vZGVcbiAqIEBwYXJhbSBoZWlnaHQgLSBuZXcgaGVpZ2h0IG9mIHRoZSBub2RlXG4gKiBAcGFyYW0gcHJldkhlaWdodCAtIHByZXZpb3VzIGhlaWdodCBvZiB0aGUgbm9kZVxuICogQHBhcmFtIGFmZmVjdHNYIC0gd2hldGhlciB0byBpbnZlcnQgdGhlIHJlc2l6ZSBkaXJlY3Rpb24gZm9yIHRoZSB4IGF4aXNcbiAqIEBwYXJhbSBhZmZlY3RzWSAtIHdoZXRoZXIgdG8gaW52ZXJ0IHRoZSByZXNpemUgZGlyZWN0aW9uIGZvciB0aGUgeSBheGlzXG4gKiBAcmV0dXJucyBhcnJheSBvZiB0d28gbnVtYmVycyByZXByZXNlbnRpbmcgdGhlIGRpcmVjdGlvbiBvZiB0aGUgcmVzaXplIGZvciBlYWNoIGF4aXMsIDAgPSBubyBjaGFuZ2UsIDEgPSBpbmNyZWFzZSwgLTEgPSBkZWNyZWFzZVxuICovXG5mdW5jdGlvbiBnZXRSZXNpemVEaXJlY3Rpb24oeyB3aWR0aCwgcHJldldpZHRoLCBoZWlnaHQsIHByZXZIZWlnaHQsIGFmZmVjdHNYLCBhZmZlY3RzWSwgfSkge1xuICAgIGNvbnN0IGRlbHRhV2lkdGggPSB3aWR0aCAtIHByZXZXaWR0aDtcbiAgICBjb25zdCBkZWx0YUhlaWdodCA9IGhlaWdodCAtIHByZXZIZWlnaHQ7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gW2RlbHRhV2lkdGggPiAwID8gMSA6IGRlbHRhV2lkdGggPCAwID8gLTEgOiAwLCBkZWx0YUhlaWdodCA+IDAgPyAxIDogZGVsdGFIZWlnaHQgPCAwID8gLTEgOiAwXTtcbiAgICBpZiAoZGVsdGFXaWR0aCAmJiBhZmZlY3RzWCkge1xuICAgICAgICBkaXJlY3Rpb25bMF0gPSBkaXJlY3Rpb25bMF0gKiAtMTtcbiAgICB9XG4gICAgaWYgKGRlbHRhSGVpZ2h0ICYmIGFmZmVjdHNZKSB7XG4gICAgICAgIGRpcmVjdGlvblsxXSA9IGRpcmVjdGlvblsxXSAqIC0xO1xuICAgIH1cbiAgICByZXR1cm4gZGlyZWN0aW9uO1xufVxuLyoqXG4gKiBQYXJzZXMgdGhlIGNvbnRyb2wgcG9zaXRpb24gdGhhdCBpcyBiZWluZyBkcmFnZ2VkIHRvIGRpbWVuc2lvbnMgdGhhdCBhcmUgYmVpbmcgcmVzaXplZFxuICogQHBhcmFtIGNvbnRyb2xQb3NpdGlvbiAtIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sIHRoYXQgaXMgYmVpbmcgZHJhZ2dlZFxuICogQHJldHVybnMgaXNIb3Jpem9udGFsLCBpc1ZlcnRpY2FsLCBhZmZlY3RzWCwgYWZmZWN0c1ksXG4gKi9cbmZ1bmN0aW9uIGdldENvbnRyb2xEaXJlY3Rpb24oY29udHJvbFBvc2l0aW9uKSB7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gY29udHJvbFBvc2l0aW9uLmluY2x1ZGVzKCdyaWdodCcpIHx8IGNvbnRyb2xQb3NpdGlvbi5pbmNsdWRlcygnbGVmdCcpO1xuICAgIGNvbnN0IGlzVmVydGljYWwgPSBjb250cm9sUG9zaXRpb24uaW5jbHVkZXMoJ2JvdHRvbScpIHx8IGNvbnRyb2xQb3NpdGlvbi5pbmNsdWRlcygndG9wJyk7XG4gICAgY29uc3QgYWZmZWN0c1ggPSBjb250cm9sUG9zaXRpb24uaW5jbHVkZXMoJ2xlZnQnKTtcbiAgICBjb25zdCBhZmZlY3RzWSA9IGNvbnRyb2xQb3NpdGlvbi5pbmNsdWRlcygndG9wJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNIb3Jpem9udGFsLFxuICAgICAgICBpc1ZlcnRpY2FsLFxuICAgICAgICBhZmZlY3RzWCxcbiAgICAgICAgYWZmZWN0c1ksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldExvd2VyRXh0ZW50Q2xhbXAobG93ZXJFeHRlbnQsIGxvd2VyQm91bmQpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgbG93ZXJCb3VuZCAtIGxvd2VyRXh0ZW50KTtcbn1cbmZ1bmN0aW9uIGdldFVwcGVyRXh0ZW50Q2xhbXAodXBwZXJFeHRlbnQsIHVwcGVyQm91bmQpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgdXBwZXJFeHRlbnQgLSB1cHBlckJvdW5kKTtcbn1cbmZ1bmN0aW9uIGdldFNpemVDbGFtcChzaXplLCBtaW5TaXplLCBtYXhTaXplKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIG1pblNpemUgLSBzaXplLCBzaXplIC0gbWF4U2l6ZSk7XG59XG5mdW5jdGlvbiB4b3IoYSwgYikge1xuICAgIHJldHVybiBhID8gIWIgOiBiO1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIG5ldyB3aWR0aCAmIGhlaWdodCBhbmQgeCAmIHkgb2Ygbm9kZSBhZnRlciByZXNpemUgYmFzZWQgb24gcG9pbnRlciBwb3NpdGlvblxuICogQGRlc2NyaXB0aW9uIC0gQnVja2xlIHVwLCB0aGlzIGlzIGEgY2h1bmt5IG9uZS4uLiBJZiB5b3Ugd2FudCB0byBkZXRlcm1pbmUgdGhlIG5ldyBkaW1lbnNpb25zIG9mIGEgbm9kZSBhZnRlciBhIHJlc2l6ZSxcbiAqIHlvdSBoYXZlIHRvIGFjY291bnQgZm9yIGFsbCBwb3NzaWJsZSByZXN0cmljdGlvbnM6IG1pbi9tYXggd2lkdGgvaGVpZ2h0IG9mIHRoZSBub2RlLCB0aGUgbWF4aW11bSBleHRlbnQgdGhlIG5vZGUgaXMgYWxsb3dlZFxuICogdG8gbW92ZSBpbiAoaW4gdGhpcyBjYXNlOiByZXNpemUgaW50bykgZGV0ZXJtaW5lZCBieSB0aGUgcGFyZW50IG5vZGUsIHRoZSBtaW5pbWFsIGV4dGVudCBkZXRlcm1pbmVkIGJ5IGNoaWxkIG5vZGVzXG4gKiB3aXRoIGV4cGFuZFBhcmVudCBvciBleHRlbnQ6ICdwYXJlbnQnIHNldCBhbmQgb2ggeWVhaCwgdGhlc2UgdGhpbmdzIGFsc28gaGF2ZSB0byB3b3JrIHdpdGgga2VlcEFzcGVjdFJhdGlvIVxuICogVGhlIHdheSB0aGlzIGlzIGRvbmUgaXMgYnkgZGV0ZXJtaW5pbmcgaG93IG11Y2ggZWFjaCBvZiB0aGVzZSByZXN0cmljdGluZyBhY3R1YWxseSByZXN0cmljdHMgdGhlIHJlc2l6ZSBhbmQgdGhlbiBhcHBseWluZyB0aGVcbiAqIHN0cm9uZ2VzdCByZXN0cmljdGlvbi4gQmVjYXVzZSB0aGUgcmVzaXplIGFmZmVjdHMgeCwgeSBhbmQgd2lkdGgsIGhlaWdodCBhbmQgd2lkdGgsIGhlaWdodCBvZiBhIG9wcG9zaW5nIHNpZGUgd2l0aCBrZWVwQXNwZWN0UmF0aW8sXG4gKiB0aGUgcmVzaXplIGFtb3VudCBpcyBhbHdheXMga2VwdCBpbiBkaXN0WCAmIGRpc3RZIGFtb3VudCAodGhlIGRpc3RhbmNlIGluIG1vdXNlIG1vdmVtZW50KVxuICogSW5zdGVhZCBvZiBjbGFtcGluZyBlYWNoIHZhbHVlLCB3ZSBmaXJzdCBjYWxjdWxhdGUgdGhlIGJpZ2dlc3QgJ2NsYW1wJyAoZm9yIHRoZSBsYWNrIG9mIGEgYmV0dGVyIG5hbWUpIGFuZCB0aGVuIGFwcGx5IGl0IHRvIGFsbCB2YWx1ZXMuXG4gKiBUbyBjb21wbGljYXRlIHRoaW5ncyBub2RlT3JpZ2luIGhhcyB0byBiZSB0YWtlbiBpbnRvIGFjY291bnQgYXMgd2VsbC4gVGhpcyBpcyBkb25lIGJ5IG9mZnNldHRpbmcgdGhlIG5vZGVzIGFzIGlmIHRoZWlyIG9yaWdpbiBpcyBbMCwgMF0sXG4gKiB0aGVuIGNhbGN1bGF0aW5nIHRoZSByZXN0cmljdGlvbnMgYXMgdXN1YWxcbiAqIEBwYXJhbSBzdGFydFZhbHVlcyAtIHN0YXJ0aW5nIHZhbHVlcyBvZiByZXNpemVcbiAqIEBwYXJhbSBjb250cm9sRGlyZWN0aW9uIC0gZGltZW5zaW9ucyBhZmZlY3RlZCBieSB0aGUgcmVzaXplXG4gKiBAcGFyYW0gcG9pbnRlclBvc2l0aW9uIC0gdGhlIGN1cnJlbnQgcG9pbnRlciBwb3NpdGlvbiBjb3JyZWN0ZWQgZm9yIHNuYXBwaW5nXG4gKiBAcGFyYW0gYm91bmRhcmllcyAtIG1pbmltdW0gYW5kIG1heGltdW0gZGltZW5zaW9ucyBvZiB0aGUgbm9kZVxuICogQHBhcmFtIGtlZXBBc3BlY3RSYXRpbyAtIHByZXZlbnQgY2hhbmdlcyBvZiBhc3ByZWN0IHJhdGlvXG4gKiBAcmV0dXJucyB4LCB5LCB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBub2RlIGFmdGVyIHJlc2l6ZVxuICovXG5mdW5jdGlvbiBnZXREaW1lbnNpb25zQWZ0ZXJSZXNpemUoc3RhcnRWYWx1ZXMsIGNvbnRyb2xEaXJlY3Rpb24sIHBvaW50ZXJQb3NpdGlvbiwgYm91bmRhcmllcywga2VlcEFzcGVjdFJhdGlvLCBub2RlT3JpZ2luLCBleHRlbnQsIGNoaWxkRXh0ZW50KSB7XG4gICAgbGV0IHsgYWZmZWN0c1gsIGFmZmVjdHNZIH0gPSBjb250cm9sRGlyZWN0aW9uO1xuICAgIGNvbnN0IHsgaXNIb3Jpem9udGFsLCBpc1ZlcnRpY2FsIH0gPSBjb250cm9sRGlyZWN0aW9uO1xuICAgIGNvbnN0IGlzRGlhZ29uYWwgPSBpc0hvcml6b250YWwgJiYgaXNWZXJ0aWNhbDtcbiAgICBjb25zdCB7IHhTbmFwcGVkLCB5U25hcHBlZCB9ID0gcG9pbnRlclBvc2l0aW9uO1xuICAgIGNvbnN0IHsgbWluV2lkdGgsIG1heFdpZHRoLCBtaW5IZWlnaHQsIG1heEhlaWdodCB9ID0gYm91bmRhcmllcztcbiAgICBjb25zdCB7IHg6IHN0YXJ0WCwgeTogc3RhcnRZLCB3aWR0aDogc3RhcnRXaWR0aCwgaGVpZ2h0OiBzdGFydEhlaWdodCwgYXNwZWN0UmF0aW8gfSA9IHN0YXJ0VmFsdWVzO1xuICAgIGxldCBkaXN0WCA9IE1hdGguZmxvb3IoaXNIb3Jpem9udGFsID8geFNuYXBwZWQgLSBzdGFydFZhbHVlcy5wb2ludGVyWCA6IDApO1xuICAgIGxldCBkaXN0WSA9IE1hdGguZmxvb3IoaXNWZXJ0aWNhbCA/IHlTbmFwcGVkIC0gc3RhcnRWYWx1ZXMucG9pbnRlclkgOiAwKTtcbiAgICBjb25zdCBuZXdXaWR0aCA9IHN0YXJ0V2lkdGggKyAoYWZmZWN0c1ggPyAtZGlzdFggOiBkaXN0WCk7XG4gICAgY29uc3QgbmV3SGVpZ2h0ID0gc3RhcnRIZWlnaHQgKyAoYWZmZWN0c1kgPyAtZGlzdFkgOiBkaXN0WSk7XG4gICAgY29uc3Qgb3JpZ2luT2Zmc2V0WCA9IC1ub2RlT3JpZ2luWzBdICogc3RhcnRXaWR0aDtcbiAgICBjb25zdCBvcmlnaW5PZmZzZXRZID0gLW5vZGVPcmlnaW5bMV0gKiBzdGFydEhlaWdodDtcbiAgICAvLyBDaGVjayBpZiBtYXhXaWR0aCwgbWluV1dpZHRoLCBtYXhIZWlnaHQsIG1pbkhlaWdodCBhcmUgcmVzdHJpY3RpbmcgdGhlIHJlc2l6ZVxuICAgIGxldCBjbGFtcFggPSBnZXRTaXplQ2xhbXAobmV3V2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCk7XG4gICAgbGV0IGNsYW1wWSA9IGdldFNpemVDbGFtcChuZXdIZWlnaHQsIG1pbkhlaWdodCwgbWF4SGVpZ2h0KTtcbiAgICAvLyBDaGVjayBpZiBleHRlbnQgaXMgcmVzdHJpY3RpbmcgdGhlIHJlc2l6ZVxuICAgIGlmIChleHRlbnQpIHtcbiAgICAgICAgbGV0IHhFeHRlbnRDbGFtcCA9IDA7XG4gICAgICAgIGxldCB5RXh0ZW50Q2xhbXAgPSAwO1xuICAgICAgICBpZiAoYWZmZWN0c1ggJiYgZGlzdFggPCAwKSB7XG4gICAgICAgICAgICB4RXh0ZW50Q2xhbXAgPSBnZXRMb3dlckV4dGVudENsYW1wKHN0YXJ0WCArIGRpc3RYICsgb3JpZ2luT2Zmc2V0WCwgZXh0ZW50WzBdWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghYWZmZWN0c1ggJiYgZGlzdFggPiAwKSB7XG4gICAgICAgICAgICB4RXh0ZW50Q2xhbXAgPSBnZXRVcHBlckV4dGVudENsYW1wKHN0YXJ0WCArIG5ld1dpZHRoICsgb3JpZ2luT2Zmc2V0WCwgZXh0ZW50WzFdWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWZmZWN0c1kgJiYgZGlzdFkgPCAwKSB7XG4gICAgICAgICAgICB5RXh0ZW50Q2xhbXAgPSBnZXRMb3dlckV4dGVudENsYW1wKHN0YXJ0WSArIGRpc3RZICsgb3JpZ2luT2Zmc2V0WSwgZXh0ZW50WzBdWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghYWZmZWN0c1kgJiYgZGlzdFkgPiAwKSB7XG4gICAgICAgICAgICB5RXh0ZW50Q2xhbXAgPSBnZXRVcHBlckV4dGVudENsYW1wKHN0YXJ0WSArIG5ld0hlaWdodCArIG9yaWdpbk9mZnNldFksIGV4dGVudFsxXVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgY2xhbXBYID0gTWF0aC5tYXgoY2xhbXBYLCB4RXh0ZW50Q2xhbXApO1xuICAgICAgICBjbGFtcFkgPSBNYXRoLm1heChjbGFtcFksIHlFeHRlbnRDbGFtcCk7XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIHRoZSBjaGlsZCBleHRlbnQgaXMgcmVzdHJpY3RpbmcgdGhlIHJlc2l6ZVxuICAgIGlmIChjaGlsZEV4dGVudCkge1xuICAgICAgICBsZXQgeEV4dGVudENsYW1wID0gMDtcbiAgICAgICAgbGV0IHlFeHRlbnRDbGFtcCA9IDA7XG4gICAgICAgIGlmIChhZmZlY3RzWCAmJiBkaXN0WCA+IDApIHtcbiAgICAgICAgICAgIHhFeHRlbnRDbGFtcCA9IGdldFVwcGVyRXh0ZW50Q2xhbXAoc3RhcnRYICsgZGlzdFgsIGNoaWxkRXh0ZW50WzBdWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghYWZmZWN0c1ggJiYgZGlzdFggPCAwKSB7XG4gICAgICAgICAgICB4RXh0ZW50Q2xhbXAgPSBnZXRMb3dlckV4dGVudENsYW1wKHN0YXJ0WCArIG5ld1dpZHRoLCBjaGlsZEV4dGVudFsxXVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFmZmVjdHNZICYmIGRpc3RZID4gMCkge1xuICAgICAgICAgICAgeUV4dGVudENsYW1wID0gZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFkgKyBkaXN0WSwgY2hpbGRFeHRlbnRbMF1bMV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFhZmZlY3RzWSAmJiBkaXN0WSA8IDApIHtcbiAgICAgICAgICAgIHlFeHRlbnRDbGFtcCA9IGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRZICsgbmV3SGVpZ2h0LCBjaGlsZEV4dGVudFsxXVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgY2xhbXBYID0gTWF0aC5tYXgoY2xhbXBYLCB4RXh0ZW50Q2xhbXApO1xuICAgICAgICBjbGFtcFkgPSBNYXRoLm1heChjbGFtcFksIHlFeHRlbnRDbGFtcCk7XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIHRoZSBhc3BlY3QgcmF0aW8gcmVzaXppbmcgb2YgdGhlIG90aGVyIHNpZGUgaXMgcmVzdHJpY3RpbmcgdGhlIHJlc2l6ZVxuICAgIGlmIChrZWVwQXNwZWN0UmF0aW8pIHtcbiAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIG1heCBkaW1lbnNpb25zIG1pZ2h0IGJlIHJlc3RyaWN0aW5nIHRoZSByZXNpemVcbiAgICAgICAgICAgIGNvbnN0IGFzcGVjdEhlaWdodENsYW1wID0gZ2V0U2l6ZUNsYW1wKG5ld1dpZHRoIC8gYXNwZWN0UmF0aW8sIG1pbkhlaWdodCwgbWF4SGVpZ2h0KSAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgY2xhbXBYID0gTWF0aC5tYXgoY2xhbXBYLCBhc3BlY3RIZWlnaHRDbGFtcCk7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgZXh0ZW50IGlzIHJlc3RyaWN0aW5nIHRoZSByZXNpemVcbiAgICAgICAgICAgIGlmIChleHRlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgYXNwZWN0RXh0ZW50Q2xhbXAgPSAwO1xuICAgICAgICAgICAgICAgIGlmICgoIWFmZmVjdHNYICYmICFhZmZlY3RzWSkgfHwgKGFmZmVjdHNYICYmICFhZmZlY3RzWSAmJiBpc0RpYWdvbmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBhc3BlY3RFeHRlbnRDbGFtcCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRVcHBlckV4dGVudENsYW1wKHN0YXJ0WSArIG9yaWdpbk9mZnNldFkgKyBuZXdXaWR0aCAvIGFzcGVjdFJhdGlvLCBleHRlbnRbMV1bMV0pICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhc3BlY3RFeHRlbnRDbGFtcCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRMb3dlckV4dGVudENsYW1wKHN0YXJ0WSArIG9yaWdpbk9mZnNldFkgKyAoYWZmZWN0c1ggPyBkaXN0WCA6IC1kaXN0WCkgLyBhc3BlY3RSYXRpbywgZXh0ZW50WzBdWzFdKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNwZWN0UmF0aW87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsYW1wWCA9IE1hdGgubWF4KGNsYW1wWCwgYXNwZWN0RXh0ZW50Q2xhbXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNoaWxkIGV4dGVudCBpcyByZXN0cmljdGluZyB0aGUgcmVzaXplXG4gICAgICAgICAgICBpZiAoY2hpbGRFeHRlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgYXNwZWN0RXh0ZW50Q2xhbXAgPSAwO1xuICAgICAgICAgICAgICAgIGlmICgoIWFmZmVjdHNYICYmICFhZmZlY3RzWSkgfHwgKGFmZmVjdHNYICYmICFhZmZlY3RzWSAmJiBpc0RpYWdvbmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBhc3BlY3RFeHRlbnRDbGFtcCA9IGdldExvd2VyRXh0ZW50Q2xhbXAoc3RhcnRZICsgbmV3V2lkdGggLyBhc3BlY3RSYXRpbywgY2hpbGRFeHRlbnRbMV1bMV0pICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhc3BlY3RFeHRlbnRDbGFtcCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRVcHBlckV4dGVudENsYW1wKHN0YXJ0WSArIChhZmZlY3RzWCA/IGRpc3RYIDogLWRpc3RYKSAvIGFzcGVjdFJhdGlvLCBjaGlsZEV4dGVudFswXVsxXSkgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xhbXBYID0gTWF0aC5tYXgoY2xhbXBYLCBhc3BlY3RFeHRlbnRDbGFtcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gdGhlIHNhbWUgdGhpbmcgZm9yIHZlcnRpY2FsIHJlc2l6aW5nXG4gICAgICAgIGlmIChpc1ZlcnRpY2FsKSB7XG4gICAgICAgICAgICBjb25zdCBhc3BlY3RXaWR0aENsYW1wID0gZ2V0U2l6ZUNsYW1wKG5ld0hlaWdodCAqIGFzcGVjdFJhdGlvLCBtaW5XaWR0aCwgbWF4V2lkdGgpIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICBjbGFtcFkgPSBNYXRoLm1heChjbGFtcFksIGFzcGVjdFdpZHRoQ2xhbXApO1xuICAgICAgICAgICAgaWYgKGV4dGVudCkge1xuICAgICAgICAgICAgICAgIGxldCBhc3BlY3RFeHRlbnRDbGFtcCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKCghYWZmZWN0c1ggJiYgIWFmZmVjdHNZKSB8fCAoYWZmZWN0c1kgJiYgIWFmZmVjdHNYICYmIGlzRGlhZ29uYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEV4dGVudENsYW1wID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFVwcGVyRXh0ZW50Q2xhbXAoc3RhcnRYICsgbmV3SGVpZ2h0ICogYXNwZWN0UmF0aW8gKyBvcmlnaW5PZmZzZXRYLCBleHRlbnRbMV1bMF0pIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhc3BlY3RFeHRlbnRDbGFtcCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRMb3dlckV4dGVudENsYW1wKHN0YXJ0WCArIChhZmZlY3RzWSA/IGRpc3RZIDogLWRpc3RZKSAqIGFzcGVjdFJhdGlvICsgb3JpZ2luT2Zmc2V0WCwgZXh0ZW50WzBdWzBdKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNwZWN0UmF0aW87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsYW1wWSA9IE1hdGgubWF4KGNsYW1wWSwgYXNwZWN0RXh0ZW50Q2xhbXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoaWxkRXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IGFzcGVjdEV4dGVudENsYW1wID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoKCFhZmZlY3RzWCAmJiAhYWZmZWN0c1kpIHx8IChhZmZlY3RzWSAmJiAhYWZmZWN0c1ggJiYgaXNEaWFnb25hbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0RXh0ZW50Q2xhbXAgPSBnZXRMb3dlckV4dGVudENsYW1wKHN0YXJ0WCArIG5ld0hlaWdodCAqIGFzcGVjdFJhdGlvLCBjaGlsZEV4dGVudFsxXVswXSkgLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEV4dGVudENsYW1wID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFVwcGVyRXh0ZW50Q2xhbXAoc3RhcnRYICsgKGFmZmVjdHNZID8gZGlzdFkgOiAtZGlzdFkpICogYXNwZWN0UmF0aW8sIGNoaWxkRXh0ZW50WzBdWzBdKSAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbGFtcFkgPSBNYXRoLm1heChjbGFtcFksIGFzcGVjdEV4dGVudENsYW1wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXN0WSA9IGRpc3RZICsgKGRpc3RZIDwgMCA/IGNsYW1wWSA6IC1jbGFtcFkpO1xuICAgIGRpc3RYID0gZGlzdFggKyAoZGlzdFggPCAwID8gY2xhbXBYIDogLWNsYW1wWCk7XG4gICAgaWYgKGtlZXBBc3BlY3RSYXRpbykge1xuICAgICAgICBpZiAoaXNEaWFnb25hbCkge1xuICAgICAgICAgICAgaWYgKG5ld1dpZHRoID4gbmV3SGVpZ2h0ICogYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgICAgICBkaXN0WSA9ICh4b3IoYWZmZWN0c1gsIGFmZmVjdHNZKSA/IC1kaXN0WCA6IGRpc3RYKSAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlzdFggPSAoeG9yKGFmZmVjdHNYLCBhZmZlY3RzWSkgPyAtZGlzdFkgOiBkaXN0WSkgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICBkaXN0WSA9IGRpc3RYIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICAgICAgYWZmZWN0c1kgPSBhZmZlY3RzWDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpc3RYID0gZGlzdFkgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICBhZmZlY3RzWCA9IGFmZmVjdHNZO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHggPSBhZmZlY3RzWCA/IHN0YXJ0WCArIGRpc3RYIDogc3RhcnRYO1xuICAgIGNvbnN0IHkgPSBhZmZlY3RzWSA/IHN0YXJ0WSArIGRpc3RZIDogc3RhcnRZO1xuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBzdGFydFdpZHRoICsgKGFmZmVjdHNYID8gLWRpc3RYIDogZGlzdFgpLFxuICAgICAgICBoZWlnaHQ6IHN0YXJ0SGVpZ2h0ICsgKGFmZmVjdHNZID8gLWRpc3RZIDogZGlzdFkpLFxuICAgICAgICB4OiBub2RlT3JpZ2luWzBdICogZGlzdFggKiAoIWFmZmVjdHNYID8gMSA6IC0xKSArIHgsXG4gICAgICAgIHk6IG5vZGVPcmlnaW5bMV0gKiBkaXN0WSAqICghYWZmZWN0c1kgPyAxIDogLTEpICsgeSxcbiAgICB9O1xufVxuXG5jb25zdCBpbml0UHJldlZhbHVlcyA9IHsgd2lkdGg6IDAsIGhlaWdodDogMCwgeDogMCwgeTogMCB9O1xuY29uc3QgaW5pdFN0YXJ0VmFsdWVzID0ge1xuICAgIC4uLmluaXRQcmV2VmFsdWVzLFxuICAgIHBvaW50ZXJYOiAwLFxuICAgIHBvaW50ZXJZOiAwLFxuICAgIGFzcGVjdFJhdGlvOiAxLFxufTtcbmZ1bmN0aW9uIG5vZGVUb1BhcmVudEV4dGVudChub2RlKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgWzAsIDBdLFxuICAgICAgICBbbm9kZS5tZWFzdXJlZC53aWR0aCwgbm9kZS5tZWFzdXJlZC5oZWlnaHRdLFxuICAgIF07XG59XG5mdW5jdGlvbiBub2RlVG9DaGlsZEV4dGVudChjaGlsZCwgcGFyZW50LCBub2RlT3JpZ2luKSB7XG4gICAgY29uc3QgeCA9IHBhcmVudC5wb3NpdGlvbi54ICsgY2hpbGQucG9zaXRpb24ueDtcbiAgICBjb25zdCB5ID0gcGFyZW50LnBvc2l0aW9uLnkgKyBjaGlsZC5wb3NpdGlvbi55O1xuICAgIGNvbnN0IHdpZHRoID0gY2hpbGQubWVhc3VyZWQud2lkdGggPz8gMDtcbiAgICBjb25zdCBoZWlnaHQgPSBjaGlsZC5tZWFzdXJlZC5oZWlnaHQgPz8gMDtcbiAgICBjb25zdCBvcmlnaW5PZmZzZXRYID0gbm9kZU9yaWdpblswXSAqIHdpZHRoO1xuICAgIGNvbnN0IG9yaWdpbk9mZnNldFkgPSBub2RlT3JpZ2luWzFdICogaGVpZ2h0O1xuICAgIHJldHVybiBbXG4gICAgICAgIFt4IC0gb3JpZ2luT2Zmc2V0WCwgeSAtIG9yaWdpbk9mZnNldFldLFxuICAgICAgICBbeCArIHdpZHRoIC0gb3JpZ2luT2Zmc2V0WCwgeSArIGhlaWdodCAtIG9yaWdpbk9mZnNldFldLFxuICAgIF07XG59XG5mdW5jdGlvbiBYWVJlc2l6ZXIoeyBkb21Ob2RlLCBub2RlSWQsIGdldFN0b3JlSXRlbXMsIG9uQ2hhbmdlLCBvbkVuZCB9KSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gc2VsZWN0KGRvbU5vZGUpO1xuICAgIGxldCBwYXJhbXMgPSB7XG4gICAgICAgIGNvbnRyb2xEaXJlY3Rpb246IGdldENvbnRyb2xEaXJlY3Rpb24oJ2JvdHRvbS1yaWdodCcpLFxuICAgICAgICBib3VuZGFyaWVzOiB7XG4gICAgICAgICAgICBtaW5XaWR0aDogMCxcbiAgICAgICAgICAgIG1pbkhlaWdodDogMCxcbiAgICAgICAgICAgIG1heFdpZHRoOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgbWF4SGVpZ2h0OiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICB9LFxuICAgICAgICByZXNpemVEaXJlY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgICAga2VlcEFzcGVjdFJhdGlvOiBmYWxzZSxcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHVwZGF0ZSh7IGNvbnRyb2xQb3NpdGlvbiwgYm91bmRhcmllcywga2VlcEFzcGVjdFJhdGlvLCByZXNpemVEaXJlY3Rpb24sIG9uUmVzaXplU3RhcnQsIG9uUmVzaXplLCBvblJlc2l6ZUVuZCwgc2hvdWxkUmVzaXplLCB9KSB7XG4gICAgICAgIGxldCBwcmV2VmFsdWVzID0geyAuLi5pbml0UHJldlZhbHVlcyB9O1xuICAgICAgICBsZXQgc3RhcnRWYWx1ZXMgPSB7IC4uLmluaXRTdGFydFZhbHVlcyB9O1xuICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICBib3VuZGFyaWVzLFxuICAgICAgICAgICAgcmVzaXplRGlyZWN0aW9uLFxuICAgICAgICAgICAga2VlcEFzcGVjdFJhdGlvLFxuICAgICAgICAgICAgY29udHJvbERpcmVjdGlvbjogZ2V0Q29udHJvbERpcmVjdGlvbihjb250cm9sUG9zaXRpb24pLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgbm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGNvbnRhaW5lckJvdW5kcyA9IG51bGw7XG4gICAgICAgIGxldCBjaGlsZE5vZGVzID0gW107XG4gICAgICAgIGxldCBwYXJlbnROb2RlID0gdW5kZWZpbmVkOyAvLyBOZWVkZWQgdG8gZml4IGV4cGFuZFBhcmVudFxuICAgICAgICBsZXQgcGFyZW50RXh0ZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgY2hpbGRFeHRlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIHdlIG9ubHkgd2FudCB0byB0cmlnZ2VyIG9uUmVzaXplRW5kIGlmIG9uUmVzaXplIHdhcyBhY3R1YWxseSBjYWxsZWRcbiAgICAgICAgbGV0IHJlc2l6ZURldGVjdGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGRyYWdIYW5kbGVyID0gZHJhZygpXG4gICAgICAgICAgICAub24oJ3N0YXJ0JywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQsIG5vZGVPcmlnaW4sIHBhbmVEb21Ob2RlIH0gPSBnZXRTdG9yZUl0ZW1zKCk7XG4gICAgICAgICAgICBub2RlID0gbm9kZUxvb2t1cC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRhaW5lckJvdW5kcyA9IHBhbmVEb21Ob2RlPy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA/PyBudWxsO1xuICAgICAgICAgICAgY29uc3QgeyB4U25hcHBlZCwgeVNuYXBwZWQgfSA9IGdldFBvaW50ZXJQb3NpdGlvbihldmVudC5zb3VyY2VFdmVudCwge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICBzbmFwR3JpZCxcbiAgICAgICAgICAgICAgICBzbmFwVG9HcmlkLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lckJvdW5kcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJldlZhbHVlcyA9IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogbm9kZS5tZWFzdXJlZC53aWR0aCA/PyAwLFxuICAgICAgICAgICAgICAgIGhlaWdodDogbm9kZS5tZWFzdXJlZC5oZWlnaHQgPz8gMCxcbiAgICAgICAgICAgICAgICB4OiBub2RlLnBvc2l0aW9uLnggPz8gMCxcbiAgICAgICAgICAgICAgICB5OiBub2RlLnBvc2l0aW9uLnkgPz8gMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzdGFydFZhbHVlcyA9IHtcbiAgICAgICAgICAgICAgICAuLi5wcmV2VmFsdWVzLFxuICAgICAgICAgICAgICAgIHBvaW50ZXJYOiB4U25hcHBlZCxcbiAgICAgICAgICAgICAgICBwb2ludGVyWTogeVNuYXBwZWQsXG4gICAgICAgICAgICAgICAgYXNwZWN0UmF0aW86IHByZXZWYWx1ZXMud2lkdGggLyBwcmV2VmFsdWVzLmhlaWdodCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwYXJlbnROb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50SWQgJiYgKG5vZGUuZXh0ZW50ID09PSAncGFyZW50JyB8fCBub2RlLmV4cGFuZFBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlID0gbm9kZUxvb2t1cC5nZXQobm9kZS5wYXJlbnRJZCk7XG4gICAgICAgICAgICAgICAgcGFyZW50RXh0ZW50ID0gcGFyZW50Tm9kZSAmJiBub2RlLmV4dGVudCA9PT0gJ3BhcmVudCcgPyBub2RlVG9QYXJlbnRFeHRlbnQocGFyZW50Tm9kZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogQ29sbGVjdCBhbGwgY2hpbGQgbm9kZXMgdG8gY29ycmVjdCB0aGVpciByZWxhdGl2ZSBwb3NpdGlvbnMgd2hlbiB0b3AvbGVmdCBjaGFuZ2VzXG4gICAgICAgICAgICAgKiBEZXRlcm1pbmUgbGFyZ2VzdCBtaW5pbWFsIGV4dGVudCB0aGUgcGFyZW50IG5vZGUgaXMgYWxsb3dlZCB0byByZXNpemUgdG9cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY2hpbGROb2RlcyA9IFtdO1xuICAgICAgICAgICAgY2hpbGRFeHRlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtjaGlsZElkLCBjaGlsZF0gb2Ygbm9kZUxvb2t1cCkge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnRJZCA9PT0gbm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogY2hpbGRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7IC4uLmNoaWxkLnBvc2l0aW9uIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbnQ6IGNoaWxkLmV4dGVudCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5leHRlbnQgPT09ICdwYXJlbnQnIHx8IGNoaWxkLmV4cGFuZFBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXh0ZW50ID0gbm9kZVRvQ2hpbGRFeHRlbnQoY2hpbGQsIG5vZGUsIGNoaWxkLm9yaWdpbiA/PyBub2RlT3JpZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZEV4dGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkRXh0ZW50ID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbTWF0aC5taW4oZXh0ZW50WzBdWzBdLCBjaGlsZEV4dGVudFswXVswXSksIE1hdGgubWluKGV4dGVudFswXVsxXSwgY2hpbGRFeHRlbnRbMF1bMV0pXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW01hdGgubWF4KGV4dGVudFsxXVswXSwgY2hpbGRFeHRlbnRbMV1bMF0pLCBNYXRoLm1heChleHRlbnRbMV1bMV0sIGNoaWxkRXh0ZW50WzFdWzFdKV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkRXh0ZW50ID0gZXh0ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25SZXNpemVTdGFydD8uKGV2ZW50LCB7IC4uLnByZXZWYWx1ZXMgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2RyYWcnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgbm9kZU9yaWdpbjogc3RvcmVOb2RlT3JpZ2luIH0gPSBnZXRTdG9yZUl0ZW1zKCk7XG4gICAgICAgICAgICBjb25zdCBwb2ludGVyUG9zaXRpb24gPSBnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQuc291cmNlRXZlbnQsIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgc25hcEdyaWQsXG4gICAgICAgICAgICAgICAgc25hcFRvR3JpZCxcbiAgICAgICAgICAgICAgICBjb250YWluZXJCb3VuZHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkQ2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB4OiBwcmV2WCwgeTogcHJldlksIHdpZHRoOiBwcmV2V2lkdGgsIGhlaWdodDogcHJldkhlaWdodCB9ID0gcHJldlZhbHVlcztcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZSA9IHt9O1xuICAgICAgICAgICAgY29uc3Qgbm9kZU9yaWdpbiA9IG5vZGUub3JpZ2luID8/IHN0b3JlTm9kZU9yaWdpbjtcbiAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgeCwgeSB9ID0gZ2V0RGltZW5zaW9uc0FmdGVyUmVzaXplKHN0YXJ0VmFsdWVzLCBwYXJhbXMuY29udHJvbERpcmVjdGlvbiwgcG9pbnRlclBvc2l0aW9uLCBwYXJhbXMuYm91bmRhcmllcywgcGFyYW1zLmtlZXBBc3BlY3RSYXRpbywgbm9kZU9yaWdpbiwgcGFyZW50RXh0ZW50LCBjaGlsZEV4dGVudCk7XG4gICAgICAgICAgICBjb25zdCBpc1dpZHRoQ2hhbmdlID0gd2lkdGggIT09IHByZXZXaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGlzSGVpZ2h0Q2hhbmdlID0gaGVpZ2h0ICE9PSBwcmV2SGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgaXNYUG9zQ2hhbmdlID0geCAhPT0gcHJldlggJiYgaXNXaWR0aENoYW5nZTtcbiAgICAgICAgICAgIGNvbnN0IGlzWVBvc0NoYW5nZSA9IHkgIT09IHByZXZZICYmIGlzSGVpZ2h0Q2hhbmdlO1xuICAgICAgICAgICAgaWYgKCFpc1hQb3NDaGFuZ2UgJiYgIWlzWVBvc0NoYW5nZSAmJiAhaXNXaWR0aENoYW5nZSAmJiAhaXNIZWlnaHRDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNYUG9zQ2hhbmdlIHx8IGlzWVBvc0NoYW5nZSB8fCBub2RlT3JpZ2luWzBdID09PSAxIHx8IG5vZGVPcmlnaW5bMV0gPT09IDEpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2UueCA9IGlzWFBvc0NoYW5nZSA/IHggOiBwcmV2VmFsdWVzLng7XG4gICAgICAgICAgICAgICAgY2hhbmdlLnkgPSBpc1lQb3NDaGFuZ2UgPyB5IDogcHJldlZhbHVlcy55O1xuICAgICAgICAgICAgICAgIHByZXZWYWx1ZXMueCA9IGNoYW5nZS54O1xuICAgICAgICAgICAgICAgIHByZXZWYWx1ZXMueSA9IGNoYW5nZS55O1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogd2hlbiB0b3AvbGVmdCBjaGFuZ2VzLCBjb3JyZWN0IHRoZSByZWxhdGl2ZSBwb3NpdGlvbnMgb2YgY2hpbGQgbm9kZXNcbiAgICAgICAgICAgICAgICAgKiBzbyB0aGF0IHRoZXkgc3RheSBpbiB0aGUgc2FtZSBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeENoYW5nZSA9IHggLSBwcmV2WDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeUNoYW5nZSA9IHkgLSBwcmV2WTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZE5vZGUgb2YgY2hpbGROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlLnBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGNoaWxkTm9kZS5wb3NpdGlvbi54IC0geENoYW5nZSArIG5vZGVPcmlnaW5bMF0gKiAod2lkdGggLSBwcmV2V2lkdGgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNoaWxkTm9kZS5wb3NpdGlvbi55IC0geUNoYW5nZSArIG5vZGVPcmlnaW5bMV0gKiAoaGVpZ2h0IC0gcHJldkhlaWdodCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRDaGFuZ2VzLnB1c2goY2hpbGROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1dpZHRoQ2hhbmdlIHx8IGlzSGVpZ2h0Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlLndpZHRoID1cbiAgICAgICAgICAgICAgICAgICAgaXNXaWR0aENoYW5nZSAmJiAoIXBhcmFtcy5yZXNpemVEaXJlY3Rpb24gfHwgcGFyYW1zLnJlc2l6ZURpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB3aWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwcmV2VmFsdWVzLndpZHRoO1xuICAgICAgICAgICAgICAgIGNoYW5nZS5oZWlnaHQgPVxuICAgICAgICAgICAgICAgICAgICBpc0hlaWdodENoYW5nZSAmJiAoIXBhcmFtcy5yZXNpemVEaXJlY3Rpb24gfHwgcGFyYW1zLnJlc2l6ZURpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJylcbiAgICAgICAgICAgICAgICAgICAgICAgID8gaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHByZXZWYWx1ZXMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHByZXZWYWx1ZXMud2lkdGggPSBjaGFuZ2Uud2lkdGg7XG4gICAgICAgICAgICAgICAgcHJldlZhbHVlcy5oZWlnaHQgPSBjaGFuZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRml4IGV4cGFuZFBhcmVudCB3aGVuIHJlc2l6aW5nIGZyb20gdG9wL2xlZnRcbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlICYmIG5vZGUuZXhwYW5kUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeExpbWl0ID0gbm9kZU9yaWdpblswXSAqIChjaGFuZ2Uud2lkdGggPz8gMCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZS54ICYmIGNoYW5nZS54IDwgeExpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZWYWx1ZXMueCA9IHhMaW1pdDtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRWYWx1ZXMueCA9IHN0YXJ0VmFsdWVzLnggLSAoY2hhbmdlLnggLSB4TGltaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB5TGltaXQgPSBub2RlT3JpZ2luWzFdICogKGNoYW5nZS5oZWlnaHQgPz8gMCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZS55ICYmIGNoYW5nZS55IDwgeUxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZWYWx1ZXMueSA9IHlMaW1pdDtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRWYWx1ZXMueSA9IHN0YXJ0VmFsdWVzLnkgLSAoY2hhbmdlLnkgLSB5TGltaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGdldFJlc2l6ZURpcmVjdGlvbih7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHByZXZWYWx1ZXMud2lkdGgsXG4gICAgICAgICAgICAgICAgcHJldldpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcHJldlZhbHVlcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgcHJldkhlaWdodCxcbiAgICAgICAgICAgICAgICBhZmZlY3RzWDogcGFyYW1zLmNvbnRyb2xEaXJlY3Rpb24uYWZmZWN0c1gsXG4gICAgICAgICAgICAgICAgYWZmZWN0c1k6IHBhcmFtcy5jb250cm9sRGlyZWN0aW9uLmFmZmVjdHNZLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBuZXh0VmFsdWVzID0geyAuLi5wcmV2VmFsdWVzLCBkaXJlY3Rpb24gfTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxSZXNpemUgPSBzaG91bGRSZXNpemU/LihldmVudCwgbmV4dFZhbHVlcyk7XG4gICAgICAgICAgICBpZiAoY2FsbFJlc2l6ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNpemVEZXRlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICBvblJlc2l6ZT8uKGV2ZW50LCBuZXh0VmFsdWVzKTtcbiAgICAgICAgICAgIG9uQ2hhbmdlKGNoYW5nZSwgY2hpbGRDaGFuZ2VzKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignZW5kJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlc2l6ZURldGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25SZXNpemVFbmQ/LihldmVudCwgeyAuLi5wcmV2VmFsdWVzIH0pO1xuICAgICAgICAgICAgb25FbmQ/Lih7IC4uLnByZXZWYWx1ZXMgfSk7XG4gICAgICAgICAgICByZXNpemVEZXRlY3RlZCA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgc2VsZWN0aW9uLmNhbGwoZHJhZ0hhbmRsZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBzZWxlY3Rpb24ub24oJy5kcmFnJywgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZSxcbiAgICAgICAgZGVzdHJveSxcbiAgICB9O1xufVxuXG5leHBvcnQgeyBDb25uZWN0aW9uTGluZVR5cGUsIENvbm5lY3Rpb25Nb2RlLCBNYXJrZXJUeXBlLCBQYW5PblNjcm9sbE1vZGUsIFBvc2l0aW9uLCBSZXNpemVDb250cm9sVmFyaWFudCwgU2VsZWN0aW9uTW9kZSwgWFlEcmFnLCBYWUhhbmRsZSwgWFlNaW5pbWFwLCBYWVBhblpvb20sIFhZUmVzaXplciwgWFlfUkVTSVpFUl9IQU5ETEVfUE9TSVRJT05TLCBYWV9SRVNJWkVSX0xJTkVfUE9TSVRJT05TLCBhZGRFZGdlLCBhZG9wdFVzZXJOb2RlcywgYXJlQ29ubmVjdGlvbk1hcHNFcXVhbCwgYXJlU2V0c0VxdWFsLCBib3hUb1JlY3QsIGNhbGNBdXRvUGFuLCBjYWxjdWxhdGVOb2RlUG9zaXRpb24sIGNsYW1wLCBjbGFtcFBvc2l0aW9uLCBjbGFtcFBvc2l0aW9uVG9QYXJlbnQsIGNyZWF0ZU1hcmtlcklkcywgZGVmYXVsdEFyaWFMYWJlbENvbmZpZywgZGV2V2FybiwgZWxlbWVudFNlbGVjdGlvbktleXMsIGVycm9yTWVzc2FnZXMsIGV2YWx1YXRlQWJzb2x1dGVQb3NpdGlvbiwgZml0Vmlld3BvcnQsIGdldEJlemllckVkZ2VDZW50ZXIsIGdldEJlemllclBhdGgsIGdldEJvdW5kc09mQm94ZXMsIGdldEJvdW5kc09mUmVjdHMsIGdldENvbm5lY3RlZEVkZ2VzLCBnZXRDb25uZWN0aW9uU3RhdHVzLCBnZXREaW1lbnNpb25zLCBnZXRFZGdlQ2VudGVyLCBnZXRFZGdlUG9zaXRpb24sIGdldEVkZ2VUb29sYmFyVHJhbnNmb3JtLCBnZXRFbGVtZW50c1RvUmVtb3ZlLCBnZXRFbGV2YXRlZEVkZ2VaSW5kZXgsIGdldEV2ZW50UG9zaXRpb24sIGdldEhhbmRsZUJvdW5kcywgZ2V0SGFuZGxlUG9zaXRpb24sIGdldEhvc3RGb3JFbGVtZW50LCBnZXRJbmNvbWVycywgZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcywgZ2V0TWFya2VySWQsIGdldE5vZGVEaW1lbnNpb25zLCBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luLCBnZXROb2RlVG9vbGJhclRyYW5zZm9ybSwgZ2V0Tm9kZXNCb3VuZHMsIGdldE5vZGVzSW5zaWRlLCBnZXRPdXRnb2VycywgZ2V0T3ZlcmxhcHBpbmdBcmVhLCBnZXRQb2ludGVyUG9zaXRpb24sIGdldFNtb290aFN0ZXBQYXRoLCBnZXRTdHJhaWdodFBhdGgsIGdldFZpZXdwb3J0Rm9yQm91bmRzLCBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlLCBoYW5kbGVFeHBhbmRQYXJlbnQsIGluZmluaXRlRXh0ZW50LCBpbml0aWFsQ29ubmVjdGlvbiwgaXNDb29yZGluYXRlRXh0ZW50LCBpc0VkZ2VCYXNlLCBpc0VkZ2VWaXNpYmxlLCBpc0lucHV0RE9NTm9kZSwgaXNJbnRlcm5hbE5vZGVCYXNlLCBpc01hY09zLCBpc01vdXNlRXZlbnQsIGlzTm9kZUJhc2UsIGlzTnVtZXJpYywgaXNSZWN0T2JqZWN0LCBtZXJnZUFyaWFMYWJlbENvbmZpZywgbm9kZUhhc0RpbWVuc2lvbnMsIG5vZGVUb0JveCwgbm9kZVRvUmVjdCwgb3Bwb3NpdGVQb3NpdGlvbiwgcGFuQnksIHBvaW50VG9SZW5kZXJlclBvaW50LCByZWNvbm5lY3RFZGdlLCByZWN0VG9Cb3gsIHJlbmRlcmVyUG9pbnRUb1BvaW50LCBzaGFsbG93Tm9kZURhdGEsIHNuYXBQb3NpdGlvbiwgdXBkYXRlQWJzb2x1dGVQb3NpdGlvbnMsIHVwZGF0ZUNvbm5lY3Rpb25Mb29rdXAsIHVwZGF0ZU5vZGVJbnRlcm5hbHMsIHdpdGhSZXNvbHZlcnMgfTtcbiJdLCJuYW1lcyI6WyJkcmFnIiwic2VsZWN0IiwicG9pbnRlciIsInpvb20iLCJ6b29tSWRlbnRpdHkiLCJ6b29tVHJhbnNmb3JtIiwiaW50ZXJwb2xhdGVab29tIiwiaW50ZXJwb2xhdGUiLCJlcnJvck1lc3NhZ2VzIiwiZXJyb3IwMDEiLCJlcnJvcjAwMiIsImVycm9yMDAzIiwibm9kZVR5cGUiLCJlcnJvcjAwNCIsImVycm9yMDA1IiwiZXJyb3IwMDYiLCJlcnJvcjAwNyIsImlkIiwiZXJyb3IwMDkiLCJ0eXBlIiwiZXJyb3IwMDgiLCJoYW5kbGVUeXBlIiwic291cmNlSGFuZGxlIiwidGFyZ2V0SGFuZGxlIiwiZXJyb3IwMTAiLCJlcnJvcjAxMSIsImVkZ2VUeXBlIiwiZXJyb3IwMTIiLCJlcnJvcjAxMyIsImxpYiIsImVycm9yMDE0IiwiZXJyb3IwMTUiLCJpbmZpbml0ZUV4dGVudCIsIk51bWJlciIsIk5FR0FUSVZFX0lORklOSVRZIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJlbGVtZW50U2VsZWN0aW9uS2V5cyIsImRlZmF1bHRBcmlhTGFiZWxDb25maWciLCJkaXJlY3Rpb24iLCJ4IiwieSIsIkNvbm5lY3Rpb25Nb2RlIiwiUGFuT25TY3JvbGxNb2RlIiwiU2VsZWN0aW9uTW9kZSIsImluaXRpYWxDb25uZWN0aW9uIiwiaW5Qcm9ncmVzcyIsImlzVmFsaWQiLCJmcm9tIiwiZnJvbUhhbmRsZSIsImZyb21Qb3NpdGlvbiIsImZyb21Ob2RlIiwidG8iLCJ0b0hhbmRsZSIsInRvUG9zaXRpb24iLCJ0b05vZGUiLCJDb25uZWN0aW9uTGluZVR5cGUiLCJNYXJrZXJUeXBlIiwiUG9zaXRpb24iLCJvcHBvc2l0ZVBvc2l0aW9uIiwiTGVmdCIsIlJpZ2h0IiwiVG9wIiwiQm90dG9tIiwiYXJlQ29ubmVjdGlvbk1hcHNFcXVhbCIsImEiLCJiIiwic2l6ZSIsImtleSIsImtleXMiLCJoYXMiLCJoYW5kbGVDb25uZWN0aW9uQ2hhbmdlIiwiY2IiLCJkaWZmIiwiZm9yRWFjaCIsImNvbm5lY3Rpb24iLCJwdXNoIiwibGVuZ3RoIiwiZ2V0Q29ubmVjdGlvblN0YXR1cyIsImlzRWRnZUJhc2UiLCJlbGVtZW50IiwiaXNOb2RlQmFzZSIsImlzSW50ZXJuYWxOb2RlQmFzZSIsImdldE91dGdvZXJzIiwibm9kZSIsIm5vZGVzIiwiZWRnZXMiLCJvdXRnb2VySWRzIiwiU2V0IiwiZWRnZSIsInNvdXJjZSIsImFkZCIsInRhcmdldCIsImZpbHRlciIsIm4iLCJnZXRJbmNvbWVycyIsImluY29tZXJzSWRzIiwiZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbiIsIm5vZGVPcmlnaW4iLCJ3aWR0aCIsImhlaWdodCIsImdldE5vZGVEaW1lbnNpb25zIiwib3JpZ2luIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJwb3NpdGlvbiIsImdldE5vZGVzQm91bmRzIiwicGFyYW1zIiwicHJvY2VzcyIsIm5vZGVMb29rdXAiLCJjb25zb2xlIiwid2FybiIsImJveCIsInJlZHVjZSIsImN1cnJCb3giLCJub2RlT3JJZCIsImlzSWQiLCJjdXJyZW50Tm9kZSIsInVuZGVmaW5lZCIsImdldCIsIm5vZGVCb3giLCJub2RlVG9Cb3giLCJ4MiIsInkyIiwiZ2V0Qm91bmRzT2ZCb3hlcyIsIkluZmluaXR5IiwiYm94VG9SZWN0IiwiZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyIsImhhc1Zpc2libGVOb2RlcyIsImdldE5vZGVzSW5zaWRlIiwicmVjdCIsInR4IiwidHkiLCJ0U2NhbGUiLCJwYXJ0aWFsbHkiLCJleGNsdWRlTm9uU2VsZWN0YWJsZU5vZGVzIiwicGFuZVJlY3QiLCJwb2ludFRvUmVuZGVyZXJQb2ludCIsInZpc2libGVOb2RlcyIsInZhbHVlcyIsIm1lYXN1cmVkIiwic2VsZWN0YWJsZSIsImhpZGRlbiIsImluaXRpYWxXaWR0aCIsImluaXRpYWxIZWlnaHQiLCJvdmVybGFwcGluZ0FyZWEiLCJnZXRPdmVybGFwcGluZ0FyZWEiLCJub2RlVG9SZWN0IiwiYXJlYSIsInBhcnRpYWxseVZpc2libGUiLCJmb3JjZUluaXRpYWxSZW5kZXIiLCJpbnRlcm5hbHMiLCJoYW5kbGVCb3VuZHMiLCJpc1Zpc2libGUiLCJkcmFnZ2luZyIsImdldENvbm5lY3RlZEVkZ2VzIiwibm9kZUlkcyIsImdldEZpdFZpZXdOb2RlcyIsIm9wdGlvbnMiLCJmaXRWaWV3Tm9kZXMiLCJNYXAiLCJvcHRpb25Ob2RlSWRzIiwibWFwIiwiaW5jbHVkZUhpZGRlbk5vZGVzIiwic2V0IiwiZml0Vmlld3BvcnQiLCJwYW5ab29tIiwibWluWm9vbSIsIm1heFpvb20iLCJQcm9taXNlIiwicmVzb2x2ZSIsIm5vZGVzVG9GaXQiLCJib3VuZHMiLCJ2aWV3cG9ydCIsImdldFZpZXdwb3J0Rm9yQm91bmRzIiwicGFkZGluZyIsInNldFZpZXdwb3J0IiwiZHVyYXRpb24iLCJlYXNlIiwiY2FsY3VsYXRlTm9kZVBvc2l0aW9uIiwibm9kZUlkIiwibmV4dFBvc2l0aW9uIiwibm9kZUV4dGVudCIsIm9uRXJyb3IiLCJwYXJlbnROb2RlIiwicGFyZW50SWQiLCJwYXJlbnRYIiwicGFyZW50WSIsInBvc2l0aW9uQWJzb2x1dGUiLCJleHRlbnQiLCJleHBhbmRQYXJlbnQiLCJwYXJlbnRXaWR0aCIsInBhcmVudEhlaWdodCIsImlzQ29vcmRpbmF0ZUV4dGVudCIsImNsYW1wUG9zaXRpb24iLCJnZXRFbGVtZW50c1RvUmVtb3ZlIiwibm9kZXNUb1JlbW92ZSIsImVkZ2VzVG9SZW1vdmUiLCJvbkJlZm9yZURlbGV0ZSIsIm1hdGNoaW5nTm9kZXMiLCJkZWxldGFibGUiLCJpc0luY2x1ZGVkIiwicGFyZW50SGl0IiwiZmluZCIsImVkZ2VJZHMiLCJkZWxldGFibGVFZGdlcyIsImNvbm5lY3RlZEVkZ2VzIiwibWF0Y2hpbmdFZGdlcyIsImUiLCJvbkJlZm9yZURlbGV0ZVJlc3VsdCIsImNsYW1wIiwidmFsIiwibWluIiwibWF4IiwiTWF0aCIsImRpbWVuc2lvbnMiLCJjbGFtcFBvc2l0aW9uVG9QYXJlbnQiLCJjaGlsZFBvc2l0aW9uIiwiY2hpbGREaW1lbnNpb25zIiwicGFyZW50IiwiY2FsY0F1dG9QYW5WZWxvY2l0eSIsInZhbHVlIiwiYWJzIiwiY2FsY0F1dG9QYW4iLCJwb3MiLCJzcGVlZCIsImRpc3RhbmNlIiwieE1vdmVtZW50IiwieU1vdmVtZW50IiwiYm94MSIsImJveDIiLCJyZWN0VG9Cb3giLCJnZXRCb3VuZHNPZlJlY3RzIiwicmVjdDEiLCJyZWN0MiIsInJlY3RBIiwicmVjdEIiLCJ4T3ZlcmxhcCIsInlPdmVybGFwIiwiY2VpbCIsImlzUmVjdE9iamVjdCIsIm9iaiIsImlzTnVtZXJpYyIsImlzTmFOIiwiaXNGaW5pdGUiLCJkZXZXYXJuIiwibWVzc2FnZSIsInNuYXBQb3NpdGlvbiIsInNuYXBHcmlkIiwicm91bmQiLCJzbmFwVG9HcmlkIiwicmVuZGVyZXJQb2ludFRvUG9pbnQiLCJwYXJzZVBhZGRpbmciLCJmbG9vciIsImVuZHNXaXRoIiwicGFkZGluZ1ZhbHVlIiwicGFyc2VGbG9hdCIsImVycm9yIiwicGFyc2VQYWRkaW5ncyIsInBhZGRpbmdZIiwicGFkZGluZ1giLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImxlZnQiLCJjYWxjdWxhdGVBcHBsaWVkUGFkZGluZ3MiLCJib3VuZFJpZ2h0IiwiYm91bmRCb3R0b20iLCJwIiwieFpvb20iLCJ5Wm9vbSIsImNsYW1wZWRab29tIiwiYm91bmRzQ2VudGVyWCIsImJvdW5kc0NlbnRlclkiLCJuZXdQYWRkaW5nIiwib2Zmc2V0IiwiaXNNYWNPcyIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImluZGV4T2YiLCJub2RlSGFzRGltZW5zaW9ucyIsImV2YWx1YXRlQWJzb2x1dGVQb3NpdGlvbiIsImFyZVNldHNFcXVhbCIsIml0ZW0iLCJ3aXRoUmVzb2x2ZXJzIiwicmVqZWN0IiwicHJvbWlzZSIsInJlcyIsInJlaiIsIm1lcmdlQXJpYUxhYmVsQ29uZmlnIiwicGFydGlhbCIsImdldFBvaW50ZXJQb3NpdGlvbiIsImV2ZW50IiwidHJhbnNmb3JtIiwiY29udGFpbmVyQm91bmRzIiwiZ2V0RXZlbnRQb3NpdGlvbiIsInBvaW50ZXJQb3MiLCJ4U25hcHBlZCIsInlTbmFwcGVkIiwiZ2V0RGltZW5zaW9ucyIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0IiwiZ2V0SG9zdEZvckVsZW1lbnQiLCJnZXRSb290Tm9kZSIsIndpbmRvdyIsImRvY3VtZW50IiwiaW5wdXRUYWdzIiwiaXNJbnB1dERPTU5vZGUiLCJjb21wb3NlZFBhdGgiLCJpc0lucHV0IiwiaW5jbHVkZXMiLCJub2RlTmFtZSIsImhhc0F0dHJpYnV0ZSIsImNsb3Nlc3QiLCJpc01vdXNlRXZlbnQiLCJpc01vdXNlIiwiZXZ0WCIsImNsaWVudFgiLCJ0b3VjaGVzIiwiZXZ0WSIsImNsaWVudFkiLCJnZXRIYW5kbGVCb3VuZHMiLCJub2RlRWxlbWVudCIsIm5vZGVCb3VuZHMiLCJoYW5kbGVzIiwicXVlcnlTZWxlY3RvckFsbCIsIkFycmF5IiwiaGFuZGxlIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZ2V0QXR0cmlidXRlIiwiZ2V0QmV6aWVyRWRnZUNlbnRlciIsInNvdXJjZVgiLCJzb3VyY2VZIiwidGFyZ2V0WCIsInRhcmdldFkiLCJzb3VyY2VDb250cm9sWCIsInNvdXJjZUNvbnRyb2xZIiwidGFyZ2V0Q29udHJvbFgiLCJ0YXJnZXRDb250cm9sWSIsImNlbnRlclgiLCJjZW50ZXJZIiwiY2FsY3VsYXRlQ29udHJvbE9mZnNldCIsImN1cnZhdHVyZSIsInNxcnQiLCJnZXRDb250cm9sV2l0aEN1cnZhdHVyZSIsIngxIiwieTEiLCJjIiwiZ2V0QmV6aWVyUGF0aCIsInNvdXJjZVBvc2l0aW9uIiwidGFyZ2V0UG9zaXRpb24iLCJsYWJlbFgiLCJsYWJlbFkiLCJnZXRFZGdlQ2VudGVyIiwieE9mZnNldCIsInlPZmZzZXQiLCJnZXRFbGV2YXRlZEVkZ2VaSW5kZXgiLCJzb3VyY2VOb2RlIiwidGFyZ2V0Tm9kZSIsInNlbGVjdGVkIiwiekluZGV4IiwiZWxldmF0ZU9uU2VsZWN0IiwiZWRnZVoiLCJub2RlWiIsInoiLCJpc0VkZ2VWaXNpYmxlIiwiZWRnZUJveCIsInZpZXdSZWN0IiwiZ2V0RWRnZUlkIiwiY29ubmVjdGlvbkV4aXN0cyIsInNvbWUiLCJlbCIsImFkZEVkZ2UiLCJlZGdlUGFyYW1zIiwiY29uY2F0IiwicmVjb25uZWN0RWRnZSIsIm9sZEVkZ2UiLCJuZXdDb25uZWN0aW9uIiwic2hvdWxkUmVwbGFjZUlkIiwib2xkRWRnZUlkIiwicmVzdCIsImZvdW5kRWRnZSIsImdldFN0cmFpZ2h0UGF0aCIsImhhbmRsZURpcmVjdGlvbnMiLCJnZXREaXJlY3Rpb24iLCJwb3ciLCJnZXRQb2ludHMiLCJjZW50ZXIiLCJzdGVwUG9zaXRpb24iLCJzb3VyY2VEaXIiLCJ0YXJnZXREaXIiLCJzb3VyY2VHYXBwZWQiLCJ0YXJnZXRHYXBwZWQiLCJkaXIiLCJkaXJBY2Nlc3NvciIsImN1cnJEaXIiLCJwb2ludHMiLCJzb3VyY2VHYXBPZmZzZXQiLCJ0YXJnZXRHYXBPZmZzZXQiLCJkZWZhdWx0T2Zmc2V0WCIsImRlZmF1bHRPZmZzZXRZIiwidmVydGljYWxTcGxpdCIsImhvcml6b250YWxTcGxpdCIsInNvdXJjZVRhcmdldCIsInRhcmdldFNvdXJjZSIsImdhcE9mZnNldCIsImRpckFjY2Vzc29yT3Bwb3NpdGUiLCJpc1NhbWVEaXIiLCJzb3VyY2VHdFRhcmdldE9wcG8iLCJzb3VyY2VMdFRhcmdldE9wcG8iLCJmbGlwU291cmNlVGFyZ2V0Iiwic291cmNlR2FwUG9pbnQiLCJ0YXJnZXRHYXBQb2ludCIsIm1heFhEaXN0YW5jZSIsIm1heFlEaXN0YW5jZSIsInBhdGhQb2ludHMiLCJnZXRCZW5kIiwiYmVuZFNpemUiLCJ4RGlyIiwieURpciIsImdldFNtb290aFN0ZXBQYXRoIiwiYm9yZGVyUmFkaXVzIiwicGF0aCIsImkiLCJzZWdtZW50IiwiaXNOb2RlSW5pdGlhbGl6ZWQiLCJnZXRFZGdlUG9zaXRpb24iLCJzb3VyY2VIYW5kbGVCb3VuZHMiLCJ0b0hhbmRsZUJvdW5kcyIsInRhcmdldEhhbmRsZUJvdW5kcyIsImdldEhhbmRsZSQxIiwiY29ubmVjdGlvbk1vZGUiLCJTdHJpY3QiLCJnZXRIYW5kbGVQb3NpdGlvbiIsImZhbGxiYWNrUG9zaXRpb24iLCJoYW5kbGVJZCIsImQiLCJnZXRNYXJrZXJJZCIsIm1hcmtlciIsImlkUHJlZml4IiwiT2JqZWN0Iiwic29ydCIsImpvaW4iLCJjcmVhdGVNYXJrZXJJZHMiLCJkZWZhdWx0Q29sb3IiLCJkZWZhdWx0TWFya2VyU3RhcnQiLCJkZWZhdWx0TWFya2VyRW5kIiwiaWRzIiwibWFya2VycyIsIm1hcmtlclN0YXJ0IiwibWFya2VyRW5kIiwibWFya2VySWQiLCJjb2xvciIsImxvY2FsZUNvbXBhcmUiLCJnZXROb2RlVG9vbGJhclRyYW5zZm9ybSIsIm5vZGVSZWN0IiwiYWxpZ24iLCJhbGlnbm1lbnRPZmZzZXQiLCJzaGlmdCIsImFsaWduWFRvUGVyY2VudCIsImFsaWduWVRvUGVyY2VudCIsImdldEVkZ2VUb29sYmFyVHJhbnNmb3JtIiwiYWxpZ25YIiwiYWxpZ25ZIiwiU0VMRUNURURfTk9ERV9aIiwiUk9PVF9QQVJFTlRfWl9JTkNSRU1FTlQiLCJkZWZhdWx0T3B0aW9ucyIsImVsZXZhdGVOb2Rlc09uU2VsZWN0IiwiZGVmYXVsdHMiLCJhZG9wdFVzZXJOb2Rlc0RlZmF1bHRPcHRpb25zIiwiY2hlY2tFcXVhbGl0eSIsIm1lcmdlT2JqZWN0cyIsImJhc2UiLCJpbmNvbWluZyIsInJlc3VsdCIsInVwZGF0ZUFic29sdXRlUG9zaXRpb25zIiwicGFyZW50TG9va3VwIiwiX29wdGlvbnMiLCJ1cGRhdGVDaGlsZE5vZGUiLCJwb3NpdGlvbldpdGhPcmlnaW4iLCJjbGFtcGVkUG9zaXRpb24iLCJwYXJzZUhhbmRsZXMiLCJ1c2VyTm9kZSIsImludGVybmFsTm9kZSIsImFkb3B0VXNlck5vZGVzIiwicm9vdFBhcmVudEluZGV4Iiwibm9kZXNJbml0aWFsaXplZCIsInRtcExvb2t1cCIsInNlbGVjdGVkTm9kZVoiLCJjbGVhciIsImNhbGN1bGF0ZVoiLCJ1cGRhdGVQYXJlbnRMb29rdXAiLCJjaGlsZE5vZGVzIiwiY2FsY3VsYXRlQ2hpbGRYWVoiLCJwb3NpdGlvbkNoYW5nZWQiLCJjaGlsZE5vZGUiLCJhYnNvbHV0ZVBvc2l0aW9uIiwiY2hpbGRaIiwicGFyZW50WiIsImhhbmRsZUV4cGFuZFBhcmVudCIsImNoaWxkcmVuIiwiY2hhbmdlcyIsInBhcmVudEV4cGFuc2lvbnMiLCJjaGlsZCIsInBhcmVudFJlY3QiLCJleHBhbmRlZFJlY3QiLCJ4Q2hhbmdlIiwieUNoYW5nZSIsIm5ld1dpZHRoIiwibmV3SGVpZ2h0Iiwid2lkdGhDaGFuZ2UiLCJoZWlnaHRDaGFuZ2UiLCJzZXRBdHRyaWJ1dGVzIiwidXBkYXRlTm9kZUludGVybmFscyIsInVwZGF0ZXMiLCJkb21Ob2RlIiwidmlld3BvcnROb2RlIiwicXVlcnlTZWxlY3RvciIsInVwZGF0ZWRJbnRlcm5hbHMiLCJzdHlsZSIsImdldENvbXB1dGVkU3R5bGUiLCJtMjIiLCJET01NYXRyaXhSZWFkT25seSIsInBhcmVudEV4cGFuZENoaWxkcmVuIiwidXBkYXRlIiwiZGltZW5zaW9uQ2hhbmdlZCIsImRvVXBkYXRlIiwiZm9yY2UiLCJuZXdOb2RlIiwicGFyZW50RXhwYW5kQ2hhbmdlcyIsInBhbkJ5IiwiZGVsdGEiLCJ0cmFuc2xhdGVFeHRlbnQiLCJuZXh0Vmlld3BvcnQiLCJzZXRWaWV3cG9ydENvbnN0cmFpbmVkIiwidHJhbnNmb3JtQ2hhbmdlZCIsImsiLCJhZGRDb25uZWN0aW9uVG9Mb29rdXAiLCJjb25uZWN0aW9uS2V5IiwiY29ubmVjdGlvbkxvb2t1cCIsIm5vZGVNYXAiLCJ0eXBlTWFwIiwiaGFuZGxlTWFwIiwidXBkYXRlQ29ubmVjdGlvbkxvb2t1cCIsImVkZ2VMb29rdXAiLCJlZGdlSWQiLCJzb3VyY2VLZXkiLCJ0YXJnZXRLZXkiLCJzaGFsbG93Tm9kZURhdGEiLCJfYSIsImlzQXJyYXkiLCJfYiIsImlzIiwiZGF0YSIsImlzUGFyZW50U2VsZWN0ZWQiLCJoYXNTZWxlY3RvciIsInNlbGVjdG9yIiwiY3VycmVudCIsIm1hdGNoZXMiLCJwYXJlbnRFbGVtZW50IiwiZ2V0RHJhZ0l0ZW1zIiwibm9kZXNEcmFnZ2FibGUiLCJtb3VzZVBvcyIsImRyYWdJdGVtcyIsImRyYWdnYWJsZSIsImdldEV2ZW50SGFuZGxlclBhcmFtcyIsIm5vZGVzRnJvbURyYWdJdGVtcyIsImRyYWdJdGVtIiwiY2FsY3VsYXRlU25hcE9mZnNldCIsInJlZkRyYWdJdGVtIiwibmV4dCIsInJlZlBvcyIsInJlZlBvc1NuYXBwZWQiLCJYWURyYWciLCJvbk5vZGVNb3VzZURvd24iLCJnZXRTdG9yZUl0ZW1zIiwib25EcmFnU3RhcnQiLCJvbkRyYWciLCJvbkRyYWdTdG9wIiwibGFzdFBvcyIsImF1dG9QYW5JZCIsImF1dG9QYW5TdGFydGVkIiwibW91c2VQb3NpdGlvbiIsImRyYWdTdGFydGVkIiwiZDNTZWxlY3Rpb24iLCJhYm9ydERyYWciLCJub2RlUG9zaXRpb25zQ2hhbmdlZCIsImRyYWdFdmVudCIsIm5vRHJhZ0NsYXNzTmFtZSIsImhhbmRsZVNlbGVjdG9yIiwiaXNTZWxlY3RhYmxlIiwibm9kZUNsaWNrRGlzdGFuY2UiLCJ1cGRhdGVOb2RlcyIsIm9uTm9kZURyYWciLCJvblNlbGVjdGlvbkRyYWciLCJ1cGRhdGVOb2RlUG9zaXRpb25zIiwiaGFzQ2hhbmdlIiwiaXNNdWx0aURyYWciLCJub2Rlc0JveCIsIm11bHRpRHJhZ1NuYXBPZmZzZXQiLCJhZGp1c3RlZE5vZGVFeHRlbnQiLCJjdXJyZW50Tm9kZXMiLCJhdXRvUGFuIiwiYXV0b1BhblNwZWVkIiwiYXV0b1Bhbk9uTm9kZURyYWciLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInN0YXJ0RHJhZyIsIm11bHRpU2VsZWN0aW9uQWN0aXZlIiwic2VsZWN0Tm9kZXNPbkRyYWciLCJvbk5vZGVEcmFnU3RhcnQiLCJvblNlbGVjdGlvbkRyYWdTdGFydCIsInVuc2VsZWN0Tm9kZXNBbmRFZGdlcyIsInNvdXJjZUV2ZW50IiwiZDNEcmFnSW5zdGFuY2UiLCJjbGlja0Rpc3RhbmNlIiwib24iLCJub2RlRHJhZ1RocmVzaG9sZCIsImN1cnJlbnRNb3VzZVBvc2l0aW9uIiwib25Ob2RlRHJhZ1N0b3AiLCJvblNlbGVjdGlvbkRyYWdTdG9wIiwiaXNEcmFnZ2FibGUiLCJidXR0b24iLCJjYWxsIiwiZGVzdHJveSIsImdldE5vZGVzV2l0aGluRGlzdGFuY2UiLCJBRERJVElPTkFMX0RJU1RBTkNFIiwiZ2V0Q2xvc2VzdEhhbmRsZSIsImNvbm5lY3Rpb25SYWRpdXMiLCJjbG9zZXN0SGFuZGxlcyIsIm1pbkRpc3RhbmNlIiwiY2xvc2VOb2RlcyIsImFsbEhhbmRsZXMiLCJvcHBvc2l0ZUhhbmRsZVR5cGUiLCJnZXRIYW5kbGUiLCJ3aXRoQWJzb2x1dGVQb3NpdGlvbiIsImgiLCJnZXRIYW5kbGVUeXBlIiwiZWRnZVVwZGF0ZXJUeXBlIiwiaGFuZGxlRG9tTm9kZSIsImNsYXNzTGlzdCIsImNvbnRhaW5zIiwiaXNDb25uZWN0aW9uVmFsaWQiLCJpc0luc2lkZUNvbm5lY3Rpb25SYWRpdXMiLCJpc0hhbmRsZVZhbGlkIiwiYWx3YXlzVmFsaWQiLCJvblBvaW50ZXJEb3duIiwiaXNUYXJnZXQiLCJhdXRvUGFuT25Db25uZWN0IiwiZmxvd0lkIiwiY2FuY2VsQ29ubmVjdGlvbiIsIm9uQ29ubmVjdFN0YXJ0Iiwib25Db25uZWN0Iiwib25Db25uZWN0RW5kIiwiaXNWYWxpZENvbm5lY3Rpb24iLCJvblJlY29ubmVjdEVuZCIsInVwZGF0ZUNvbm5lY3Rpb24iLCJnZXRUcmFuc2Zvcm0iLCJnZXRGcm9tSGFuZGxlIiwiZHJhZ1RocmVzaG9sZCIsImRvYyIsImNsb3Nlc3RIYW5kbGUiLCJjb25uZWN0aW9uU3RhcnRlZCIsImZyb21IYW5kbGVJbnRlcm5hbCIsInJlc3VsdEhhbmRsZURvbU5vZGUiLCJmcm9tTm9kZUludGVybmFsIiwicHJldmlvdXNDb25uZWN0aW9uIiwic3RhcnRDb25uZWN0aW9uIiwib25Qb2ludGVyTW92ZSIsImR4IiwiZHkiLCJuZXh0Q29ubmVjdGlvblN0YXJ0ZWQiLCJvblBvaW50ZXJVcCIsImlzVmFsaWRIYW5kbGUiLCJmcm9tTm9kZUlkIiwiZnJvbUhhbmRsZUlkIiwiZnJvbVR5cGUiLCJjb25uZWN0aW9uU3RhdGUiLCJmaW5hbENvbm5lY3Rpb25TdGF0ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwiaGFuZGxlQmVsb3ciLCJlbGVtZW50RnJvbVBvaW50IiwiaGFuZGxlVG9DaGVjayIsImhhbmRsZU5vZGVJZCIsImNvbm5lY3RhYmxlIiwiY29ubmVjdGFibGVFbmQiLCJpc0Nvbm5lY3RhYmxlIiwiWFlIYW5kbGUiLCJYWU1pbmltYXAiLCJnZXRWaWV3U2NhbGUiLCJzZWxlY3Rpb24iLCJ6b29tU3RlcCIsInBhbm5hYmxlIiwiem9vbWFibGUiLCJpbnZlcnNlUGFuIiwiem9vbUhhbmRsZXIiLCJmYWN0b3IiLCJjdHJsS2V5IiwicGluY2hEZWx0YSIsImRlbHRhWSIsImRlbHRhTW9kZSIsIm5leHRab29tIiwic2NhbGVUbyIsInBhblN0YXJ0IiwicGFuU3RhcnRIYW5kbGVyIiwicGFuSGFuZGxlciIsInBhbkN1cnJlbnQiLCJwYW5EZWx0YSIsIm1vdmVTY2FsZSIsImxvZyIsInpvb21BbmRQYW5IYW5kbGVyIiwidHJhbnNmb3JtVG9WaWV3cG9ydCIsInZpZXdwb3J0VG9UcmFuc2Zvcm0iLCJ0cmFuc2xhdGUiLCJzY2FsZSIsImlzV3JhcHBlZFdpdGhDbGFzcyIsImNsYXNzTmFtZSIsImlzUmlnaHRDbGlja1BhbiIsInBhbk9uRHJhZyIsInVzZWRCdXR0b24iLCJkZWZhdWx0RWFzZSIsInQiLCJnZXREM1RyYW5zaXRpb24iLCJvbkVuZCIsImhhc0R1cmF0aW9uIiwidHJhbnNpdGlvbiIsIndoZWVsRGVsdGEiLCJjcmVhdGVQYW5PblNjcm9sbEhhbmRsZXIiLCJ6b29tUGFuVmFsdWVzIiwibm9XaGVlbENsYXNzTmFtZSIsImQzWm9vbSIsInBhbk9uU2Nyb2xsTW9kZSIsInBhbk9uU2Nyb2xsU3BlZWQiLCJ6b29tT25QaW5jaCIsIm9uUGFuWm9vbVN0YXJ0Iiwib25QYW5ab29tIiwib25QYW5ab29tRW5kIiwicHJldmVudERlZmF1bHQiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJjdXJyZW50Wm9vbSIsInByb3BlcnR5IiwicG9pbnQiLCJkZWx0YU5vcm1hbGl6ZSIsImRlbHRhWCIsIlZlcnRpY2FsIiwiSG9yaXpvbnRhbCIsInNoaWZ0S2V5IiwidHJhbnNsYXRlQnkiLCJpbnRlcm5hbCIsImNsZWFyVGltZW91dCIsInBhblNjcm9sbFRpbWVvdXQiLCJpc1BhblNjcm9sbGluZyIsInNldFRpbWVvdXQiLCJjcmVhdGVab29tT25TY3JvbGxIYW5kbGVyIiwicHJldmVudFNjcm9sbGluZyIsImQzWm9vbUhhbmRsZXIiLCJpc1doZWVsIiwicHJldmVudFpvb20iLCJoYXNOb1doZWVsQ2xhc3MiLCJjcmVhdGVQYW5ab29tU3RhcnRIYW5kbGVyIiwib25EcmFnZ2luZ0NoYW5nZSIsIm1vdXNlQnV0dG9uIiwiaXNab29taW5nT3JQYW5uaW5nIiwicHJldlZpZXdwb3J0IiwiY3JlYXRlUGFuWm9vbUhhbmRsZXIiLCJvblBhbmVDb250ZXh0TWVudSIsIm9uVHJhbnNmb3JtQ2hhbmdlIiwidXNlZFJpZ2h0TW91c2VCdXR0b24iLCJzeW5jIiwiY3JlYXRlUGFuWm9vbUVuZEhhbmRsZXIiLCJwYW5PblNjcm9sbCIsInRpbWVySWQiLCJjcmVhdGVGaWx0ZXIiLCJ6b29tQWN0aXZhdGlvbktleVByZXNzZWQiLCJ6b29tT25TY3JvbGwiLCJ6b29tT25Eb3VibGVDbGljayIsInVzZXJTZWxlY3Rpb25BY3RpdmUiLCJub1BhbkNsYXNzTmFtZSIsImNvbm5lY3Rpb25JblByb2dyZXNzIiwiem9vbVNjcm9sbCIsInBpbmNoWm9vbSIsImlzV2hlZWxFdmVudCIsImJ1dHRvbkFsbG93ZWQiLCJYWVBhblpvb20iLCJwYW5lQ2xpY2tEaXN0YW5jZSIsImJib3giLCJkM1pvb21JbnN0YW5jZSIsInNjYWxlRXh0ZW50IiwiZDNEYmxDbGlja1pvb21IYW5kbGVyIiwic2V0VHJhbnNmb3JtIiwiaXNQYW5PblNjcm9sbCIsIndoZWVsSGFuZGxlciIsInBhc3NpdmUiLCJzdGFydEhhbmRsZXIiLCJwYW5ab29tSGFuZGxlciIsInBhblpvb21FbmRIYW5kbGVyIiwibmV4dFRyYW5zZm9ybSIsImNvbnRyYWluZWRUcmFuc2Zvcm0iLCJjb25zdHJhaW4iLCJzeW5jVmlld3BvcnQiLCJjdXJyZW50VHJhbnNmb3JtIiwiZ2V0Vmlld3BvcnQiLCJzY2FsZUJ5Iiwic2V0U2NhbGVFeHRlbnQiLCJzZXRUcmFuc2xhdGVFeHRlbnQiLCJzZXRDbGlja0Rpc3RhbmNlIiwidmFsaWREaXN0YW5jZSIsIlJlc2l6ZUNvbnRyb2xWYXJpYW50IiwiWFlfUkVTSVpFUl9IQU5ETEVfUE9TSVRJT05TIiwiWFlfUkVTSVpFUl9MSU5FX1BPU0lUSU9OUyIsImdldFJlc2l6ZURpcmVjdGlvbiIsInByZXZXaWR0aCIsInByZXZIZWlnaHQiLCJhZmZlY3RzWCIsImFmZmVjdHNZIiwiZGVsdGFXaWR0aCIsImRlbHRhSGVpZ2h0IiwiZ2V0Q29udHJvbERpcmVjdGlvbiIsImNvbnRyb2xQb3NpdGlvbiIsImlzSG9yaXpvbnRhbCIsImlzVmVydGljYWwiLCJnZXRMb3dlckV4dGVudENsYW1wIiwibG93ZXJFeHRlbnQiLCJsb3dlckJvdW5kIiwiZ2V0VXBwZXJFeHRlbnRDbGFtcCIsInVwcGVyRXh0ZW50IiwidXBwZXJCb3VuZCIsImdldFNpemVDbGFtcCIsIm1pblNpemUiLCJtYXhTaXplIiwieG9yIiwiZ2V0RGltZW5zaW9uc0FmdGVyUmVzaXplIiwic3RhcnRWYWx1ZXMiLCJjb250cm9sRGlyZWN0aW9uIiwicG9pbnRlclBvc2l0aW9uIiwiYm91bmRhcmllcyIsImtlZXBBc3BlY3RSYXRpbyIsImNoaWxkRXh0ZW50IiwiaXNEaWFnb25hbCIsIm1pbldpZHRoIiwibWF4V2lkdGgiLCJtaW5IZWlnaHQiLCJtYXhIZWlnaHQiLCJzdGFydFgiLCJzdGFydFkiLCJzdGFydFdpZHRoIiwic3RhcnRIZWlnaHQiLCJhc3BlY3RSYXRpbyIsImRpc3RYIiwicG9pbnRlclgiLCJkaXN0WSIsInBvaW50ZXJZIiwib3JpZ2luT2Zmc2V0WCIsIm9yaWdpbk9mZnNldFkiLCJjbGFtcFgiLCJjbGFtcFkiLCJ4RXh0ZW50Q2xhbXAiLCJ5RXh0ZW50Q2xhbXAiLCJhc3BlY3RIZWlnaHRDbGFtcCIsImFzcGVjdEV4dGVudENsYW1wIiwiYXNwZWN0V2lkdGhDbGFtcCIsImluaXRQcmV2VmFsdWVzIiwiaW5pdFN0YXJ0VmFsdWVzIiwibm9kZVRvUGFyZW50RXh0ZW50Iiwibm9kZVRvQ2hpbGRFeHRlbnQiLCJYWVJlc2l6ZXIiLCJvbkNoYW5nZSIsIk1BWF9WQUxVRSIsInJlc2l6ZURpcmVjdGlvbiIsIm9uUmVzaXplU3RhcnQiLCJvblJlc2l6ZSIsIm9uUmVzaXplRW5kIiwic2hvdWxkUmVzaXplIiwicHJldlZhbHVlcyIsInBhcmVudEV4dGVudCIsInJlc2l6ZURldGVjdGVkIiwiZHJhZ0hhbmRsZXIiLCJwYW5lRG9tTm9kZSIsImNoaWxkSWQiLCJzdG9yZU5vZGVPcmlnaW4iLCJjaGlsZENoYW5nZXMiLCJwcmV2WCIsInByZXZZIiwiY2hhbmdlIiwiaXNXaWR0aENoYW5nZSIsImlzSGVpZ2h0Q2hhbmdlIiwiaXNYUG9zQ2hhbmdlIiwiaXNZUG9zQ2hhbmdlIiwieExpbWl0IiwieUxpbWl0IiwibmV4dFZhbHVlcyIsImNhbGxSZXNpemUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xyflow/system/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xyflow/react/dist/style.css":
/*!***************************************************!*\
  !*** ./node_modules/@xyflow/react/dist/style.css ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"d393e6a432f7\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9yZWFjdC9kaXN0L3N0eWxlLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL3NhaWxvLWdyb3d0aC1uZXh0anMvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9yZWFjdC9kaXN0L3N0eWxlLmNzcz9jNDJjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiZDM5M2U2YTQzMmY3XCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xyflow/react/dist/style.css\n");

/***/ })

};
;