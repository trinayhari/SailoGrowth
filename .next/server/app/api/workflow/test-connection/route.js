"use strict";(()=>{var e={};e.id=697,e.ids=[697],e.modules={30517:e=>{e.exports=require("next/dist/compiled/next-server/app-route.runtime.prod.js")},97505:(e,t,s)=>{s.r(t),s.d(t,{headerHooks:()=>d,originalPathname:()=>f,patchFetch:()=>w,requestAsyncStorage:()=>l,routeModule:()=>p,serverHooks:()=>y,staticGenerationAsyncStorage:()=>h,staticGenerationBailout:()=>m});var a={};s.r(a),s.d(a,{POST:()=>u});var n=s(10884),o=s(16132),r=s(21040),i=s(95798),c=s(2701);async function u(e){try{let t=await e.json(),{connectionConfig:s}=t;if(!s)return i.Z.json({error:"Connection configuration is required"},{status:400});let{type:a,endpoint:n,apiKey:o,database:r}=s;if(!a||!n||!o)return i.Z.json({error:"Missing required connection fields (type, endpoint, apiKey)"},{status:400});let u=await c.h.testConnection({type:a,endpoint:n,apiKey:o,database:r});if(u.success)return i.Z.json({success:!0,message:u.message,connectionTime:u.connectionTime});return i.Z.json({success:!1,error:u.message},{status:400})}catch(e){return console.error("Connection test failed:",e),i.Z.json({error:e.message||"Connection test failed"},{status:500})}}let p=new n.AppRouteRouteModule({definition:{kind:o.x.APP_ROUTE,page:"/api/workflow/test-connection/route",pathname:"/api/workflow/test-connection",filename:"route",bundlePath:"app/api/workflow/test-connection/route"},resolvedPagePath:"/Users/trinayhari/SailoGrowth/app/api/workflow/test-connection/route.ts",nextConfigOutput:"",userland:a}),{requestAsyncStorage:l,staticGenerationAsyncStorage:h,serverHooks:y,headerHooks:d,staticGenerationBailout:m}=p,f="/api/workflow/test-connection/route";function w(){return(0,r.patchFetch)({serverHooks:y,staticGenerationAsyncStorage:h})}},2701:(e,t,s)=>{s.d(t,{h:()=>n});class a{async testConnection(e){let t=Date.now();try{switch(e.type){case"supabase":return await this.testSupabase(e);case"posthog":return await this.testPostHog(e);case"postgresql":case"mysql":return await this.testSQLDatabase(e);default:return{success:!1,message:`Unsupported connection type: ${e.type}`}}}catch(e){return{success:!1,message:`Connection failed: ${e.message}`,connectionTime:Date.now()-t}}}async testSupabase(e){let t=Date.now();try{let s=await fetch(`${e.endpoint}/rest/v1/`,{method:"GET",headers:{apikey:e.apiKey,Authorization:`Bearer ${e.apiKey}`}});if(s.ok)return{success:!0,message:"Successfully connected to Supabase",connectionTime:Date.now()-t};return{success:!1,message:`Supabase connection failed: ${s.statusText}`,connectionTime:Date.now()-t}}catch(e){throw Error(`Supabase connection error: ${e.message}`)}}async testPostHog(e){let t=Date.now();try{let s=await fetch(`${e.endpoint}/api/projects`,{method:"GET",headers:{Authorization:`Bearer ${e.apiKey}`}});if(s.ok)return{success:!0,message:"Successfully connected to PostHog",connectionTime:Date.now()-t};return{success:!1,message:`PostHog connection failed: ${s.statusText}`,connectionTime:Date.now()-t}}catch(e){throw Error(`PostHog connection error: ${e.message}`)}}async testSQLDatabase(e){return{success:!0,message:`SQL connection test not fully implemented yet for ${e.type}`,connectionTime:0}}async fetchSchema(e){switch(e.type){case"supabase":return await this.fetchSupabaseSchema(e);case"posthog":return await this.fetchPostHogSchema(e);case"postgresql":case"mysql":return await this.fetchSQLSchema(e);default:throw Error(`Unsupported connection type: ${e.type}`)}}async fetchSupabaseSchema(e){try{let t=await fetch(`${e.endpoint}/rest/v1/`,{method:"GET",headers:{apikey:e.apiKey,Authorization:`Bearer ${e.apiKey}`,Accept:"application/json"}});if(!t.ok)throw Error(`Failed to fetch schema: ${t.statusText}`);return{tables:[],relationships:[],entities:[]}}catch(e){throw Error(`Failed to fetch Supabase schema: ${e.message}`)}}async fetchPostHogSchema(e){try{let t=await fetch(`${e.endpoint}/api/projects/@current/event_definitions`,{method:"GET",headers:{Authorization:`Bearer ${e.apiKey}`}});if(!t.ok)throw Error(`Failed to fetch PostHog schema: ${t.statusText}`);return await t.json(),{tables:[{name:"events",columns:[{name:"event",type:"string",nullable:!1},{name:"timestamp",type:"timestamp",nullable:!1},{name:"distinct_id",type:"string",nullable:!1},{name:"properties",type:"jsonb",nullable:!0}]},{name:"persons",columns:[{name:"distinct_id",type:"string",nullable:!1,primaryKey:!0},{name:"properties",type:"jsonb",nullable:!0},{name:"created_at",type:"timestamp",nullable:!1}]}],relationships:[],entities:[{name:"User",table:"persons",description:"User entity tracked in PostHog",keyFields:["distinct_id"]},{name:"Event",table:"events",description:"User events and interactions",keyFields:["event","distinct_id"],eventFields:["event","timestamp"]}]}}catch(e){throw Error(`Failed to fetch PostHog schema: ${e.message}`)}}async fetchSQLSchema(e){return{tables:[],relationships:[],entities:[]}}async executeQuery(e,t){switch(e.type){case"supabase":return await this.executeSupabaseQuery(e,t);case"posthog":return await this.executePostHogQuery(e,t);default:throw Error(`Query execution not supported for ${e.type}`)}}async executeSupabaseQuery(e,t){try{let s=await fetch(`${e.endpoint}/rest/v1/rpc/execute_sql`,{method:"POST",headers:{apikey:e.apiKey,Authorization:`Bearer ${e.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({query:t})});if(!s.ok)throw Error(`Query failed: ${s.statusText}`);return await s.json()}catch(e){throw Error(`Supabase query execution failed: ${e.message}`)}}async executePostHogQuery(e,t){try{let s=await fetch(`${e.endpoint}/api/projects/@current/query`,{method:"POST",headers:{Authorization:`Bearer ${e.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({query:{kind:"HogQLQuery",query:t}})});if(!s.ok)throw Error(`Query failed: ${s.statusText}`);let a=await s.json();return a.results||[]}catch(e){throw Error(`PostHog query execution failed: ${e.message}`)}}}let n=new a}};var t=require("../../../../webpack-runtime.js");t.C(e);var s=e=>t(t.s=e),a=t.X(0,[271,107],()=>s(97505));module.exports=a})();