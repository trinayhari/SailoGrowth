"use strict";(()=>{var e={};e.id=151,e.ids=[151],e.modules={30517:e=>{e.exports=require("next/dist/compiled/next-server/app-route.runtime.prod.js")},8348:(e,t,a)=>{a.r(t),a.d(t,{headerHooks:()=>w,originalPathname:()=>x,patchFetch:()=>k,requestAsyncStorage:()=>y,routeModule:()=>m,serverHooks:()=>f,staticGenerationAsyncStorage:()=>g,staticGenerationBailout:()=>b});var o={};a.r(o),a.d(o,{POST:()=>d});var s=a(10884),r=a(16132),n=a(21040),i=a(95798),c=a(2701),l=a(53569),u=a(14197);class h{async executeWorkflow(e,t,a){this.execution={id:`exec-${Date.now()}`,workflowId:e,status:"running",startedAt:new Date,logs:[]};try{this.log("info","workflow","Workflow execution started");let e=this.buildExecutionOrder(t,a);this.log("info","workflow",`Execution order: ${e.map(e=>e.data.label).join(" â†’ ")}`);let o={};for(let t of e)await this.executeNode(t,o);return this.execution.status="completed",this.execution.completedAt=new Date,this.log("info","workflow","Workflow execution completed successfully"),this.execution}catch(e){return this.execution.status="failed",this.execution.completedAt=new Date,this.execution.error=e.message,this.log("error","workflow",`Workflow execution failed: ${e.message}`),this.execution}}buildExecutionOrder(e,t){let a=new Map,o=new Map,s=new Map;e.forEach(e=>{a.set(e.id,e),o.set(e.id,0),s.set(e.id,[])}),t.forEach(e=>{s.get(e.source)?.push(e.target),o.set(e.target,(o.get(e.target)||0)+1)});let r=[];o.forEach((e,t)=>{0===e&&r.push(t)});let n=[];for(;r.length>0;){let e=r.shift(),t=a.get(e);n.push(t),s.get(e)?.forEach(e=>{let t=(o.get(e)||0)-1;o.set(e,t),0===t&&r.push(e)})}return n}async executeNode(e,t){this.log("info",e.id,`Executing node: ${e.data.label}`);try{switch(e.type){case"data-connector":await this.executeDataConnector(e,t);break;case"schema-interpreter":await this.executeSchemaInterpreter(e,t);break;case"monitor-builder":await this.executeMonitorBuilder(e,t);break;case"action-executor":await this.executeActionExecutor(e,t);break;default:throw Error(`Unknown node type: ${e.type}`)}this.log("info",e.id,"Node completed successfully")}catch(t){throw this.log("error",e.id,`Node execution failed: ${t.message}`),t}}async executeDataConnector(e,t){let a=e.data.config;if(!a||!a.connectionType||!a.endpoint||!a.apiKey)throw Error("Data connector configuration is incomplete");let o=await c.h.testConnection({type:a.connectionType,endpoint:a.endpoint,apiKey:a.apiKey,database:a.database});if(!o.success)throw Error(`Connection failed: ${o.message}`);let s=await c.h.fetchSchema({type:a.connectionType,endpoint:a.endpoint,apiKey:a.apiKey,database:a.database});t.connectionConfig={type:a.connectionType,endpoint:a.endpoint,apiKey:a.apiKey,database:a.database},t.schema=s,this.log("info",e.id,`Connected to ${a.connectionType}, found ${s.tables.length} tables`)}async executeSchemaInterpreter(e,t){if(!t.schema)throw Error("No schema available. Connect a data source first.");let a=e.data.config,o=a?.model||"anthropic/claude-3-sonnet",s=a?.temperature||.7,r=JSON.stringify(t.schema,null,2),n=await l.t.interpretSchema(r,o,s);t.schemaInterpretation=n,this.log("info",e.id,`Schema interpreted using ${o}`)}async executeMonitorBuilder(e,t){if(!t.schemaInterpretation)throw Error("No schema interpretation available");let a=e.data.config;if(!a?.condition)throw Error("Monitor condition not configured");let o=await l.t.generateMonitorQuery(t.schemaInterpretation,a.condition,a.model||"anthropic/claude-3-sonnet");if(t.connectionConfig){let a=await c.h.executeQuery(t.connectionConfig,o.query);t.monitorResults=a,t.monitorQuery=o.query,this.log("info",e.id,`Monitor executed: ${o.explanation}`),this.log("info",e.id,`Results: ${JSON.stringify(a).substring(0,200)}...`)}}async executeActionExecutor(e,t){let a=e.data.config;if(!a?.actionType)throw Error("Action type not configured");let o={condition:t.monitorQuery||"Unknown condition",results:t.monitorResults||[],timestamp:new Date().toISOString(),workflow:this.execution?.workflowId},s=await u.u.execute({type:a.actionType,slackWebhook:a.slackWebhook,emailRecipients:a.emailRecipients,message:a.message,webhookUrl:a.webhookUrl},o);if(!s.success)throw Error(`Action failed: ${s.error||s.message}`);t.actionResult=s,this.log("info",e.id,`Action executed: ${s.message}`)}log(e,t,a,o){if(!this.execution)return;let s={nodeId:t,timestamp:new Date,level:e,message:a,data:o};this.execution.logs.push(s),console.log(`[${e.toUpperCase()}] ${t}: ${a}`,o||"")}constructor(){this.execution=null}}let p=new h;async function d(e){try{let t=await e.json(),{workflowId:a,nodes:o,edges:s}=t;if(!a||!o||!s)return i.Z.json({error:"Workflow ID, nodes, and edges are required"},{status:400});let r=o.filter(e=>!e.data.config||0===Object.keys(e.data.config).length);if(r.length>0)return i.Z.json({error:"Some nodes are not configured",unconfiguredNodes:r.map(e=>({id:e.id,label:e.data.label}))},{status:400});let n=await p.executeWorkflow(a,o,s);return i.Z.json({success:"completed"===n.status,execution:{id:n.id,status:n.status,startedAt:n.startedAt,completedAt:n.completedAt,error:n.error,logs:n.logs}})}catch(e){return console.error("Workflow execution failed:",e),i.Z.json({error:e.message||"Workflow execution failed"},{status:500})}}let m=new s.AppRouteRouteModule({definition:{kind:r.x.APP_ROUTE,page:"/api/workflow/execute/route",pathname:"/api/workflow/execute",filename:"route",bundlePath:"app/api/workflow/execute/route"},resolvedPagePath:"/Users/trinayhari/SailoGrowth/app/api/workflow/execute/route.ts",nextConfigOutput:"",userland:o}),{requestAsyncStorage:y,staticGenerationAsyncStorage:g,serverHooks:f,headerHooks:w,staticGenerationBailout:b}=m,x="/api/workflow/execute/route";function k(){return(0,n.patchFetch)({serverHooks:f,staticGenerationAsyncStorage:g})}},14197:(e,t,a)=>{a.d(t,{u:()=>s});class o{async execute(e,t){let a=new Date;try{switch(e.type){case"slack":return await this.sendSlackNotification(e,t,a);case"email":return await this.sendEmailAlert(e,t,a);case"webhook":return await this.triggerWebhook(e,t,a);default:return{success:!1,message:`Unsupported action type: ${e.type}`,timestamp:a}}}catch(e){return{success:!1,message:`Action execution failed: ${e.message}`,timestamp:a,error:e.message}}}async sendSlackNotification(e,t,a){if(!e.slackWebhook)throw Error("Slack webhook URL is required");try{let o=this.replaceTemplateVariables(e.message||"",t),s={text:o,blocks:[{type:"section",text:{type:"mrkdwn",text:o}},{type:"context",elements:[{type:"mrkdwn",text:`_Triggered at ${a.toLocaleString()}_`}]}]},r=await fetch(e.slackWebhook,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(s)});if(r.ok)return{success:!0,message:"Slack notification sent successfully",timestamp:a};{let e=await r.text();throw Error(`Slack API error: ${e}`)}}catch(e){throw Error(`Failed to send Slack notification: ${e.message}`)}}async sendEmailAlert(e,t,a){if(!e.emailRecipients)throw Error("Email recipients are required");let o=this.replaceTemplateVariables(e.message||"",t),s=e.emailRecipients.split(",").map(e=>e.trim());return console.log("Email would be sent to:",s),console.log("Email content:",o),{success:!0,message:`Email alert queued for ${s.length} recipient(s)`,timestamp:a}}async triggerWebhook(e,t,a){if(!e.webhookUrl)throw Error("Webhook URL is required");try{let o=e.webhookMethod||"POST",s={"Content-Type":"application/json",...e.webhookHeaders},r=e.webhookBody||t,n=await fetch(e.webhookUrl,{method:o,headers:s,body:"GET"!==o?JSON.stringify(r):void 0});if(n.ok)return{success:!0,message:`Webhook triggered successfully (${n.status})`,timestamp:a};throw Error(`Webhook returned ${n.status}: ${n.statusText}`)}catch(e){throw Error(`Failed to trigger webhook: ${e.message}`)}}replaceTemplateVariables(e,t){let a=e;return Object.keys(t).forEach(e=>{let o=RegExp(`{{${e}}}`,"g");a=a.replace(o,String(t[e]))}),t.timestamp||(a=a.replace(/{{timestamp}}/g,new Date().toLocaleString())),a}async testAction(e){let t={condition:"Test condition",value:100,threshold:50,timestamp:new Date().toISOString()};return await this.execute(e,t)}}let s=new o},2701:(e,t,a)=>{a.d(t,{h:()=>s});class o{async testConnection(e){let t=Date.now();try{switch(e.type){case"supabase":return await this.testSupabase(e);case"posthog":return await this.testPostHog(e);case"postgresql":case"mysql":return await this.testSQLDatabase(e);default:return{success:!1,message:`Unsupported connection type: ${e.type}`}}}catch(e){return{success:!1,message:`Connection failed: ${e.message}`,connectionTime:Date.now()-t}}}async testSupabase(e){let t=Date.now();try{let a=await fetch(`${e.endpoint}/rest/v1/`,{method:"GET",headers:{apikey:e.apiKey,Authorization:`Bearer ${e.apiKey}`}});if(a.ok)return{success:!0,message:"Successfully connected to Supabase",connectionTime:Date.now()-t};return{success:!1,message:`Supabase connection failed: ${a.statusText}`,connectionTime:Date.now()-t}}catch(e){throw Error(`Supabase connection error: ${e.message}`)}}async testPostHog(e){let t=Date.now();try{let a=await fetch(`${e.endpoint}/api/projects`,{method:"GET",headers:{Authorization:`Bearer ${e.apiKey}`}});if(a.ok)return{success:!0,message:"Successfully connected to PostHog",connectionTime:Date.now()-t};return{success:!1,message:`PostHog connection failed: ${a.statusText}`,connectionTime:Date.now()-t}}catch(e){throw Error(`PostHog connection error: ${e.message}`)}}async testSQLDatabase(e){return{success:!0,message:`SQL connection test not fully implemented yet for ${e.type}`,connectionTime:0}}async fetchSchema(e){switch(e.type){case"supabase":return await this.fetchSupabaseSchema(e);case"posthog":return await this.fetchPostHogSchema(e);case"postgresql":case"mysql":return await this.fetchSQLSchema(e);default:throw Error(`Unsupported connection type: ${e.type}`)}}async fetchSupabaseSchema(e){try{let t=await fetch(`${e.endpoint}/rest/v1/`,{method:"GET",headers:{apikey:e.apiKey,Authorization:`Bearer ${e.apiKey}`,Accept:"application/json"}});if(!t.ok)throw Error(`Failed to fetch schema: ${t.statusText}`);return{tables:[],relationships:[],entities:[]}}catch(e){throw Error(`Failed to fetch Supabase schema: ${e.message}`)}}async fetchPostHogSchema(e){try{let t=await fetch(`${e.endpoint}/api/projects/@current/event_definitions`,{method:"GET",headers:{Authorization:`Bearer ${e.apiKey}`}});if(!t.ok)throw Error(`Failed to fetch PostHog schema: ${t.statusText}`);return await t.json(),{tables:[{name:"events",columns:[{name:"event",type:"string",nullable:!1},{name:"timestamp",type:"timestamp",nullable:!1},{name:"distinct_id",type:"string",nullable:!1},{name:"properties",type:"jsonb",nullable:!0}]},{name:"persons",columns:[{name:"distinct_id",type:"string",nullable:!1,primaryKey:!0},{name:"properties",type:"jsonb",nullable:!0},{name:"created_at",type:"timestamp",nullable:!1}]}],relationships:[],entities:[{name:"User",table:"persons",description:"User entity tracked in PostHog",keyFields:["distinct_id"]},{name:"Event",table:"events",description:"User events and interactions",keyFields:["event","distinct_id"],eventFields:["event","timestamp"]}]}}catch(e){throw Error(`Failed to fetch PostHog schema: ${e.message}`)}}async fetchSQLSchema(e){return{tables:[],relationships:[],entities:[]}}async executeQuery(e,t){switch(e.type){case"supabase":return await this.executeSupabaseQuery(e,t);case"posthog":return await this.executePostHogQuery(e,t);default:throw Error(`Query execution not supported for ${e.type}`)}}async executeSupabaseQuery(e,t){try{let a=await fetch(`${e.endpoint}/rest/v1/rpc/execute_sql`,{method:"POST",headers:{apikey:e.apiKey,Authorization:`Bearer ${e.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({query:t})});if(!a.ok)throw Error(`Query failed: ${a.statusText}`);return await a.json()}catch(e){throw Error(`Supabase query execution failed: ${e.message}`)}}async executePostHogQuery(e,t){try{let a=await fetch(`${e.endpoint}/api/projects/@current/query`,{method:"POST",headers:{Authorization:`Bearer ${e.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({query:{kind:"HogQLQuery",query:t}})});if(!a.ok)throw Error(`Query failed: ${a.statusText}`);let o=await a.json();return o.results||[]}catch(e){throw Error(`PostHog query execution failed: ${e.message}`)}}}let s=new o},53569:(e,t,a)=>{a.d(t,{t:()=>s});class o{constructor(e){if(this.baseUrl="https://openrouter.ai/api/v1",this.apiKey=e||process.env.OPENROUTER_API_KEY||"",!this.apiKey)throw Error("OpenRouter API key is required")}async chat(e){try{let t=await fetch(`${this.baseUrl}/chat/completions`,{method:"POST",headers:{Authorization:`Bearer ${this.apiKey}`,"Content-Type":"application/json","HTTP-Referer":process.env.OPENROUTER_APP_URL||"http://localhost:3001","X-Title":process.env.OPENROUTER_APP_NAME||"SailoGrowth"},body:JSON.stringify(e)});if(!t.ok){let e=await t.json();throw Error(`OpenRouter API error: ${e.error?.message||t.statusText}`)}let a=await t.json();return a}catch(e){throw console.error("OpenRouter API call failed:",e),e}}async interpretSchema(e,t="anthropic/claude-3-sonnet",a=.7){let o=`You are a database schema analyst. Analyze the provided database schema and identify:
1. Key entities (e.g., users, events, sessions, products)
2. Important relationships between tables
3. Event tracking patterns
4. User behavior indicators
5. Business metrics that can be derived

Provide a clear, structured analysis that will help set up automated monitoring and alerts.`,s=`Analyze this database schema and identify key entities, relationships, and monitoring opportunities:

${e}`,r=await this.chat({model:t,messages:[{role:"system",content:o},{role:"user",content:s}],temperature:a,max_tokens:2e3});return r.choices[0].message.content}async generateMonitorQuery(e,t,a="anthropic/claude-3-sonnet"){let o=`You are an SQL expert. Generate SQL queries for monitoring specific conditions in a database.
Return your response as JSON with two fields: "query" (the SQL query) and "explanation" (brief description).`,s=`Generate a SQL query to monitor: ${t}

Context: ${e}

Return JSON with "query" and "explanation" fields.`,r=await this.chat({model:a,messages:[{role:"system",content:o},{role:"user",content:s}],temperature:.3,max_tokens:1e3});try{let e=JSON.parse(r.choices[0].message.content);return e}catch{return{query:r.choices[0].message.content,explanation:"Generated monitoring query"}}}async generateAlertMessage(e,t,a="anthropic/claude-3-sonnet"){let o=`You are a helpful assistant that generates alert messages based on templates and data.
Replace template variables like {{variable}} with actual values from the provided data.
Keep the message clear, concise, and actionable.`,s=`Template: ${e}

Data: ${JSON.stringify(t,null,2)}

Generate the final alert message with all variables replaced.`,r=await this.chat({model:a,messages:[{role:"system",content:o},{role:"user",content:s}],temperature:.5,max_tokens:500});return r.choices[0].message.content}}let s=new o}};var t=require("../../../../webpack-runtime.js");t.C(e);var a=e=>t(t.s=e),o=t.X(0,[271,107],()=>a(8348));module.exports=o})();